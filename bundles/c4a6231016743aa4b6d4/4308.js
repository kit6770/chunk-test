(self["webpackChunkhisease_im_web"] = self["webpackChunkhisease_im_web"] || []).push([[4308,7311,355,4586,6326,7434,7750,2172],{

/***/ 185675:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ showGroupAddRoomDialog),
/* harmony export */   k: () => (/* binding */ showGroupInviteDialog)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(667294);
/* harmony import */ var _Modal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(241648);
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(47185);
/* harmony import */ var _utils_MultiInviter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(216353);
/* harmony import */ var _languageHandler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(867614);
/* harmony import */ var _MatrixClientPeg__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(933393);
/* harmony import */ var _stores_GroupStore__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(152118);
/* harmony import */ var _components_views_elements_StyledCheckbox__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(239684);
/*
Copyright 2017 New Vector Ltd

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/









function showGroupInviteDialog(groupId) {
  return new Promise((resolve, reject) => {
    const description = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", null, (0,_languageHandler__WEBPACK_IMPORTED_MODULE_4__._t)("Who would you like to add to this community?")), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "warning"
    }, (0,_languageHandler__WEBPACK_IMPORTED_MODULE_4__._t)("Warning: any person you add to a community will be publicly " + "visible to anyone who knows the community ID")));
    const AddressPickerDialog = ___WEBPACK_IMPORTED_MODULE_2__.getComponent("dialogs.AddressPickerDialog");
    _Modal__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z.createTrackedDialog('Group Invite', '', AddressPickerDialog, {
      title: (0,_languageHandler__WEBPACK_IMPORTED_MODULE_4__._t)("Invite new community members"),
      description: description,
      placeholder: (0,_languageHandler__WEBPACK_IMPORTED_MODULE_4__._t)("Name or Matrix ID"),
      button: (0,_languageHandler__WEBPACK_IMPORTED_MODULE_4__._t)("Invite to Community"),
      validAddressTypes: ['mx-user-id'],
      onFinished: (success, addrs) => {
        if (!success) return;
        _onGroupInviteFinished(groupId, addrs).then(resolve, reject);
      }
    }, /*className=*/null, /*isPriority=*/false, /*isStatic=*/true);
  });
}
function showGroupAddRoomDialog(groupId) {
  return new Promise((resolve, reject) => {
    let addRoomsPublicly = false;
    const onCheckboxClicked = e => {
      addRoomsPublicly = e.target.checked;
    };
    const description = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", null, (0,_languageHandler__WEBPACK_IMPORTED_MODULE_4__._t)("Which rooms would you like to add to this community?")));
    const checkboxContainer = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components_views_elements_StyledCheckbox__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z, {
      className: "mx_GroupAddressPicker_checkboxContainer",
      onChange: onCheckboxClicked
    }, (0,_languageHandler__WEBPACK_IMPORTED_MODULE_4__._t)("Show these rooms to non-members on the community page and room list?"));
    const AddressPickerDialog = ___WEBPACK_IMPORTED_MODULE_2__.getComponent("dialogs.AddressPickerDialog");
    _Modal__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z.createTrackedDialog('Add Rooms to Group', '', AddressPickerDialog, {
      title: (0,_languageHandler__WEBPACK_IMPORTED_MODULE_4__._t)("Add rooms to the community"),
      description: description,
      extraNode: checkboxContainer,
      placeholder: (0,_languageHandler__WEBPACK_IMPORTED_MODULE_4__._t)("Room name or address"),
      button: (0,_languageHandler__WEBPACK_IMPORTED_MODULE_4__._t)("Add to community"),
      pickerType: 'room',
      validAddressTypes: ['mx-room-id'],
      onFinished: (success, addrs) => {
        if (!success) return;
        _onGroupAddRoomFinished(groupId, addrs, addRoomsPublicly).then(resolve, reject);
      }
    }, /*className=*/null, /*isPriority=*/false, /*isStatic=*/true);
  });
}
function _onGroupInviteFinished(groupId, addrs) {
  const multiInviter = new _utils_MultiInviter__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z(groupId);
  const addrTexts = addrs.map(addr => addr.address);
  return multiInviter.invite(addrTexts).then(completionStates => {
    // Show user any errors
    const errorList = [];
    for (const addr of Object.keys(completionStates)) {
      if (addrs[addr] === "error") {
        errorList.push(addr);
      }
    }
    if (errorList.length > 0) {
      const ErrorDialog = ___WEBPACK_IMPORTED_MODULE_2__.getComponent("dialogs.ErrorDialog");
      _Modal__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z.createTrackedDialog('Failed to invite the following users to the group', '', ErrorDialog, {
        title: (0,_languageHandler__WEBPACK_IMPORTED_MODULE_4__._t)("Failed to invite the following users to %(groupId)s:", {
          groupId: groupId
        }),
        description: errorList.join(", ")
      });
    }
  }).catch(err => {
    const ErrorDialog = ___WEBPACK_IMPORTED_MODULE_2__.getComponent("dialogs.ErrorDialog");
    _Modal__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z.createTrackedDialog('Failed to invite users to group', '', ErrorDialog, {
      title: (0,_languageHandler__WEBPACK_IMPORTED_MODULE_4__._t)("Failed to invite users to community"),
      description: (0,_languageHandler__WEBPACK_IMPORTED_MODULE_4__._t)("Failed to invite users to %(groupId)s", {
        groupId: groupId
      })
    });
  });
}
function _onGroupAddRoomFinished(groupId, addrs, addRoomsPublicly) {
  const matrixClient = _MatrixClientPeg__WEBPACK_IMPORTED_MODULE_5__/* .MatrixClientPeg */ .p.get();
  const errorList = [];
  return Promise.allSettled(addrs.map(addr => {
    return _stores_GroupStore__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .ZP.addRoomToGroup(groupId, addr.address, addRoomsPublicly).catch(() => {
      errorList.push(addr.address);
    }).then(() => {
      const roomId = addr.address;
      const room = matrixClient.getRoom(roomId);
      // Can the user change related groups?
      if (!room || !room.currentState.mayClientSendStateEvent("m.room.related_groups", matrixClient)) {
        return;
      }
      // Get the related groups
      const relatedGroupsEvent = room.currentState.getStateEvents('m.room.related_groups', '');
      const groups = relatedGroupsEvent ? relatedGroupsEvent.getContent().groups || [] : [];

      // Add this group as related
      if (!groups.includes(groupId)) {
        groups.push(groupId);
        return _MatrixClientPeg__WEBPACK_IMPORTED_MODULE_5__/* .MatrixClientPeg */ .p.get().sendStateEvent(roomId, 'm.room.related_groups', {
          groups
        }, '');
      }
    });
  })).then(() => {
    if (errorList.length === 0) {
      return;
    }
    const ErrorDialog = ___WEBPACK_IMPORTED_MODULE_2__.getComponent("dialogs.ErrorDialog");
    _Modal__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z.createTrackedDialog('Failed to add the following room to the group', '', ErrorDialog, {
      title: (0,_languageHandler__WEBPACK_IMPORTED_MODULE_4__._t)("Failed to add the following rooms to %(groupId)s:", {
        groupId
      }),
      description: errorList.join(", ")
    });
  });
}

/***/ }),

/***/ 231124:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (/* binding */ SendHistoryManager)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(225259);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(743913);

/*
Copyright 2017 Aviral Dasgupta

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/


class SendHistoryManager {
  // used for indexing the loaded validated history Array

  constructor(roomId, prefix) {
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this, "history", []);
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this, "prefix", void 0);
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this, "lastIndex", 0);
    // used for indexing the storage
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this, "currentIndex", 0);
    this.prefix = prefix + roomId;

    // TODO: Performance issues?
    let index = 0;
    let itemJSON;
    while (itemJSON = sessionStorage.getItem(`${this.prefix}[${index}]`)) {
      try {
        this.history.push(JSON.parse(itemJSON));
      } catch (e) {
        console.warn("Throwing away unserialisable history", e);
        break;
      }
      ++index;
    }
    this.lastIndex = this.history.length - 1;
    // reset currentIndex to account for any unserialisable history
    this.currentIndex = this.lastIndex + 1;
  }
  static createItem(model, replyEvent) {
    return {
      parts: model.serializeParts(),
      replyEventId: replyEvent ? replyEvent.getId() : undefined
    };
  }
  save(editorModel, replyEvent) {
    const item = SendHistoryManager.createItem(editorModel, replyEvent);
    this.history.push(item);
    this.currentIndex = this.history.length;
    this.lastIndex += 1;
    sessionStorage.setItem(`${this.prefix}[${this.lastIndex}]`, JSON.stringify(item));
  }
  getItem(offset) {
    this.currentIndex = (0,lodash_es__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(this.currentIndex + offset, 0, this.history.length - 1);
    return this.history[this.currentIndex];
  }
}

/***/ }),

/***/ 662316:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Mv: () => (/* binding */ CommandCategories),
  QQ: () => (/* binding */ CommandMap),
  Gh: () => (/* binding */ Commands),
  hW: () => (/* binding */ getCommand),
  dV: () => (/* binding */ parseCommandString)
});

// UNUSED EXPORTS: Command

// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/node_modules/@babel/runtime/helpers/esm/defineProperty.js
var defineProperty = __webpack_require__(225259);
// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(667294);
// EXTERNAL MODULE: ./node_modules/matrix-js-sdk/src/content-helpers.ts
var content_helpers = __webpack_require__(538573);
// EXTERNAL MODULE: ./node_modules/@hiseas/command-parse/index.js
var command_parse = __webpack_require__(472501);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/MatrixClientPeg.ts + 3 modules
var MatrixClientPeg = __webpack_require__(933393);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/dispatcher/dispatcher.ts
var dispatcher = __webpack_require__(245539);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/languageHandler.tsx
var languageHandler = __webpack_require__(867614);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/Modal.tsx + 1 modules
var Modal = __webpack_require__(241648);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/utils/MultiInviter.ts + 1 modules
var MultiInviter = __webpack_require__(216353);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/HtmlUtils.tsx
var HtmlUtils = __webpack_require__(714813);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/dialogs/QuestionDialog.js
var QuestionDialog = __webpack_require__(433773);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/utils/WidgetUtils.ts
var WidgetUtils = __webpack_require__(434596);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/utils/colour.ts
/*
Copyright 2019 Michael Telatynski <7t3chguy@gmail.com>

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

function textToHtmlRainbow(str) {
  const frequency = 2 * Math.PI / str.length;
  return Array.from(str).map((c, i) => {
    if (c === " ") {
      return c;
    }
    const [a, b] = generateAB(i * frequency, 1);
    const [red, green, blue] = labToRGB(75, a, b);
    return '<font color="#' + red.toString(16).padStart(2, "0") + green.toString(16).padStart(2, "0") + blue.toString(16).padStart(2, "0") + '">' + c + "</font>";
  }).join("");
}
function generateAB(hue, chroma) {
  const a = chroma * 127 * Math.cos(hue);
  const b = chroma * 127 * Math.sin(hue);
  return [a, b];
}
function labToRGB(l, a, b) {
  // https://en.wikipedia.org/wiki/CIELAB_color_space#Reverse_transformation
  // https://en.wikipedia.org/wiki/SRGB#The_forward_transformation_(CIE_XYZ_to_sRGB)

  // Convert CIELAB to CIEXYZ (D65)
  let y = (l + 16) / 116;
  const x = adjustXYZ(y + a / 500) * 0.9505;
  const z = adjustXYZ(y - b / 200) * 1.089;
  y = adjustXYZ(y);

  // Linear transformation from CIEXYZ to RGB
  const red = 3.24096994 * x - 1.53738318 * y - 0.49861076 * z;
  const green = -0.96924364 * x + 1.8759675 * y + 0.04155506 * z;
  const blue = 0.05563008 * x - 0.20397696 * y + 1.05697151 * z;
  return [adjustRGB(red), adjustRGB(green), adjustRGB(blue)];
}
function adjustXYZ(v) {
  if (v > 0.2069) {
    return Math.pow(v, 3);
  }
  return 0.1284 * v - 0.01771;
}
function gammaCorrection(v) {
  // Non-linear transformation to sRGB
  if (v <= 0.0031308) {
    return 12.92 * v;
  }
  return 1.055 * Math.pow(v, 1 / 2.4) - 0.055;
}
function adjustRGB(v) {
  const corrected = gammaCorrection(v);

  // Limits number between 0 and 1
  const limited = Math.min(Math.max(corrected, 0), 1);
  return Math.round(limited * 255);
}
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/UserAddress.ts
var UserAddress = __webpack_require__(996625);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/utils/UrlUtils.ts
var UrlUtils = __webpack_require__(58238);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/utils/IdentityServerUtils.ts
var IdentityServerUtils = __webpack_require__(450414);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/utils/permalinks/Permalinks.ts
var Permalinks = __webpack_require__(954105);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/widgets/WidgetType.ts
var WidgetType = __webpack_require__(152068);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/widgets/Jitsi.ts
var Jitsi = __webpack_require__(232691);
// EXTERNAL MODULE: ./node_modules/parse5/lib/index.js
var lib = __webpack_require__(542394);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/dialogs/BugReportDialog.tsx
var BugReportDialog = __webpack_require__(758795);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/createRoom.ts
var createRoom = __webpack_require__(147022);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/dispatcher/actions.ts
var actions = __webpack_require__(473627);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/utils/membership.ts
var membership = __webpack_require__(140974);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/SdkConfig.ts
var SdkConfig = __webpack_require__(374312);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/settings/SettingsStore.ts + 9 modules
var SettingsStore = __webpack_require__(571879);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/settings/UIFeature.ts
var UIFeature = __webpack_require__(187565);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/effects/index.ts
var effects = __webpack_require__(410603);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/CallHandler.tsx + 2 modules
var CallHandler = __webpack_require__(613431);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/Rooms.ts + 1 modules
var Rooms = __webpack_require__(286020);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/utils/RoomUpgrade.ts
var RoomUpgrade = __webpack_require__(336876);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/dialogs/UploadConfirmDialog.tsx
var UploadConfirmDialog = __webpack_require__(615043);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/dialogs/DevtoolsDialog.tsx
var DevtoolsDialog = __webpack_require__(970974);
// EXTERNAL MODULE: ./node_modules/matrix-js-sdk/src/@types/event.ts
var _types_event = __webpack_require__(907977);
// EXTERNAL MODULE: ./node_modules/matrix-js-sdk/src/@types/partials.ts
var partials = __webpack_require__(85047);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/elements/LabelledToggleSwitch.tsx
var LabelledToggleSwitch = __webpack_require__(258401);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/utils/replaceableComponent.ts
var replaceableComponent = __webpack_require__(90287);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/dialogs/BaseDialog.js
var BaseDialog = __webpack_require__(308043);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/elements/DialogButtons.js
var DialogButtons = __webpack_require__(804821);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/dialogs/RoomUpgradeWarningDialog.tsx

var _dec, _class;
/*
Copyright 2019 - 2021 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/













let RoomUpgradeWarningDialog = (_dec = (0,replaceableComponent/* replaceableComponent */.U)("views.dialogs.RoomUpgradeWarningDialog"), _dec(_class = class RoomUpgradeWarningDialog extends react.Component {
  constructor(props) {
    var _ref;
    super(props);
    (0,defineProperty/* default */.Z)(this, "isPrivate", void 0);
    (0,defineProperty/* default */.Z)(this, "currentVersion", void 0);
    (0,defineProperty/* default */.Z)(this, "onContinue", () => {
      this.props.onFinished({
        continue: true,
        invite: this.isPrivate && this.state.inviteUsersToNewRoom
      });
    });
    (0,defineProperty/* default */.Z)(this, "onCancel", () => {
      this.props.onFinished({
        continue: false,
        invite: false
      });
    });
    (0,defineProperty/* default */.Z)(this, "onInviteUsersToggle", inviteUsersToNewRoom => {
      this.setState({
        inviteUsersToNewRoom
      });
    });
    (0,defineProperty/* default */.Z)(this, "openBugReportDialog", e => {
      e.preventDefault();
      e.stopPropagation();
      Modal/* default */.Z.createTrackedDialog('Bug Report Dialog', '', BugReportDialog/* default */.Z, {});
    });
    const room = MatrixClientPeg/* MatrixClientPeg */.p.get().getRoom(this.props.roomId);
    const joinRules = room === null || room === void 0 ? void 0 : room.currentState.getStateEvents(_types_event/* EventType */.tw.RoomJoinRules, "");
    this.isPrivate = (_ref = (joinRules === null || joinRules === void 0 ? void 0 : joinRules.getContent()['join_rule']) !== partials/* JoinRule */.iE.Public) !== null && _ref !== void 0 ? _ref : true;
    this.currentVersion = (room === null || room === void 0 ? void 0 : room.getVersion()) || "1";
    this.state = {
      inviteUsersToNewRoom: true
    };
  }
  render() {
    const brand = SdkConfig/* default */.Z.get().brand;
    let inviteToggle = null;
    if (this.isPrivate) {
      inviteToggle = /*#__PURE__*/react.createElement(LabelledToggleSwitch/* default */.Z, {
        value: this.state.inviteUsersToNewRoom,
        onChange: this.onInviteUsersToggle,
        label: (0,languageHandler._t)("Automatically invite members from this room to the new one")
      });
    }
    const title = this.isPrivate ? (0,languageHandler._t)("Upgrade private room") : (0,languageHandler._t)("Upgrade public room");
    let bugReports = /*#__PURE__*/react.createElement("p", null, (0,languageHandler._t)("This usually only affects how the room is processed on the server. If you're " + "having problems with your %(brand)s, please report a bug.", {
      brand
    }));
    if (SdkConfig/* default */.Z.get().bug_report_endpoint_url) {
      bugReports = /*#__PURE__*/react.createElement("p", null, (0,languageHandler._t)("This usually only affects how the room is processed on the server. If you're " + "having problems with your %(brand)s, please <a>report a bug</a>.", {
        brand
      }, {
        "a": sub => {
          return /*#__PURE__*/react.createElement("a", {
            href: "#",
            onClick: this.openBugReportDialog
          }, sub);
        }
      }));
    }
    return /*#__PURE__*/react.createElement(BaseDialog/* default */.Z, {
      className: "mx_RoomUpgradeWarningDialog",
      hasCancel: true,
      fixedWidth: false,
      onFinished: this.props.onFinished,
      title: title
    }, /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement("p", null, this.props.description || (0,languageHandler._t)("Upgrading a room is an advanced action and is usually recommended when a room " + "is unstable due to bugs, missing features or security vulnerabilities.")), /*#__PURE__*/react.createElement("p", null, (0,languageHandler._t)("<b>Please note upgrading will make a new version of the room</b>. " + "All current messages will stay in this archived room.", {}, {
      b: sub => /*#__PURE__*/react.createElement("b", null, sub)
    })), bugReports, /*#__PURE__*/react.createElement("p", null, (0,languageHandler._t)("You'll upgrade this room from <oldVersion /> to <newVersion />.", {}, {
      oldVersion: () => /*#__PURE__*/react.createElement("code", null, this.currentVersion),
      newVersion: () => /*#__PURE__*/react.createElement("code", null, this.props.targetVersion)
    })), inviteToggle), /*#__PURE__*/react.createElement(DialogButtons/* default */.Z, {
      primaryButton: (0,languageHandler._t)("Upgrade"),
      onPrimaryButtonClick: this.onContinue,
      cancelButton: (0,languageHandler._t)("Cancel"),
      onCancel: this.onCancel
    }));
  }
}) || _class);

// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/dialogs/InfoDialog.tsx
var InfoDialog = __webpack_require__(786035);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/dialogs/SlashCommandHelpDialog.js
/*
Copyright 2019 Michael Telatynski <7t3chguy@gmail.com>

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/





/* harmony default export */ const SlashCommandHelpDialog = (({
  onFinished
}) => {
  const categories = {};
  Commands.forEach(cmd => {
    if (!cmd.isEnabled()) return;
    if (!categories[cmd.category]) {
      categories[cmd.category] = [];
    }
    categories[cmd.category].push(cmd);
  });
  const body = Object.values(CommandCategories).filter(c => categories[c]).map(category => {
    const rows = [/*#__PURE__*/react.createElement("tr", {
      key: "_category_" + category,
      className: "mx_SlashCommandHelpDialog_headerRow"
    }, /*#__PURE__*/react.createElement("td", {
      colSpan: 3
    }, /*#__PURE__*/react.createElement("h2", null, (0,languageHandler._t)(category))))];
    categories[category].forEach(cmd => {
      rows.push( /*#__PURE__*/react.createElement("tr", {
        key: cmd.command
      }, /*#__PURE__*/react.createElement("td", null, /*#__PURE__*/react.createElement("strong", null, cmd.getCommand())), /*#__PURE__*/react.createElement("td", null, cmd.args), /*#__PURE__*/react.createElement("td", null, cmd.description)));
    });
    return rows;
  });
  return /*#__PURE__*/react.createElement(InfoDialog/* default */.Z, {
    className: "mx_SlashCommandHelpDialog",
    title: (0,languageHandler._t)("Command Help"),
    description: /*#__PURE__*/react.createElement("table", null, /*#__PURE__*/react.createElement("tbody", null, body)),
    hasCloseButton: true,
    onFinished: onFinished
  });
});
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/SlashCommands.tsx

function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0,defineProperty/* default */.Z)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
/*
Copyright 2015, 2016 OpenMarket Ltd
Copyright 2018 New Vector Ltd
Copyright 2019 Michael Telatynski <7t3chguy@gmail.com>
Copyright 2020 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/






































// XXX: workaround for https://github.com/microsoft/TypeScript/issues/31816

const singleMxcUpload = async () => {
  return new Promise(resolve => {
    const fileSelector = document.createElement('input');
    fileSelector.setAttribute('type', 'file');
    fileSelector.onchange = ev => {
      const file = ev.target.files[0];
      Modal/* default */.Z.createTrackedDialog('Upload Files confirmation', '', UploadConfirmDialog/* default */.Z, {
        file,
        onFinished: shouldContinue => {
          resolve(shouldContinue ? MatrixClientPeg/* MatrixClientPeg */.p.get().uploadContent(file) : null);
        }
      });
    };
    fileSelector.click();
  });
};
const CommandCategories = {
  "messages": (0,languageHandler/* _td */.I8)("Messages"),
  "actions": (0,languageHandler/* _td */.I8)("Actions"),
  "admin": (0,languageHandler/* _td */.I8)("Admin"),
  "advanced": (0,languageHandler/* _td */.I8)("Advanced"),
  "effects": (0,languageHandler/* _td */.I8)("Effects"),
  "other": (0,languageHandler/* _td */.I8)("Other")
};
class Command {
  constructor(opts) {
    (0,defineProperty/* default */.Z)(this, "command", void 0);
    (0,defineProperty/* default */.Z)(this, "aliases", void 0);
    (0,defineProperty/* default */.Z)(this, "program", void 0);
    (0,defineProperty/* default */.Z)(this, "args", void 0);
    (0,defineProperty/* default */.Z)(this, "description", void 0);
    (0,defineProperty/* default */.Z)(this, "runFn", void 0);
    (0,defineProperty/* default */.Z)(this, "category", void 0);
    (0,defineProperty/* default */.Z)(this, "hideCompletionAfterSpace", void 0);
    (0,defineProperty/* default */.Z)(this, "_isEnabled", void 0);
    this.command = opts.command;
    this.aliases = opts.aliases || [];
    this.args = opts.args || "";
    this.description = opts.description;
    this.runFn = opts.runFn;
    this.program = opts.program;
    this.category = opts.category || CommandCategories.other;
    this.hideCompletionAfterSpace = opts.hideCompletionAfterSpace || false;
    this._isEnabled = opts.isEnabled;
  }
  getCommand() {
    return `/${this.command}`;
  }
  getCommandWithArgs() {
    return this.getCommand() + " " + this.args;
  }
  run(roomId, args, program) {
    // if it has no runFn then its an ignored/nop command (autocomplete only) e.g `/me`
    if (!this.runFn) return reject((0,languageHandler._t)("Command error"));
    return this.runFn.bind(this)(roomId, args, program);
  }
  getUsage() {
    return (0,languageHandler._t)('Usage') + ': ' + this.getCommandWithArgs();
  }
  isEnabled() {
    return this._isEnabled ? this._isEnabled() : true;
  }
}
function reject(error) {
  return {
    error
  };
}
function success(promise) {
  return {
    promise
  };
}
function successSync(value) {
  return success(Promise.resolve(value));
}

/* Disable the "unexpected this" error for these commands - all of the run
 * functions are called with `this` bound to the Command instance.
 */

const Commands = [new Command({
  command: 'transfer',
  args: '<Recipient> <NFT>',
  program: new command_parse.Command().command('transfer').argument('<Recipient>').argument('<NFT>'),
  description: (0,languageHandler/* _td */.I8)('Transfer the NFT to the recipient'),
  runFn: function (roomId, message) {
    const cli = MatrixClientPeg/* MatrixClientPeg */.p.get();
    const payerId = cli.getUserId();
    const [recipientId, tokenAddress] = message.split(" ");
    const promise = MatrixClientPeg/* MatrixClientPeg */.p.get().getWalletByUserId([payerId, recipientId]).then(({
      data
    }) => {
      // const [sender, recipient] = wallets;
      const [sender, recipient] = (data || [null, null]).map(item => {
        return item === null || item === void 0 ? void 0 : item.wallet_address;
      });
      // check has nft
      // hasNft(nftPubkey);
      const content = {
        msgtype: _types_event/* MsgType */.Zw.Transfer,
        component: "messages.TransferConfirmNFT",
        body: message,
        params: {
          sender,
          recipient,
          tokenAddress
        }
      };
      const promise = cli.sendMessage(roomId, content);
      promise.then(async res => {
        await cli.createTransferStatus(roomId, res["event_id"], {
          type: "transfer"
        });
      });
      return promise;
    });
    return {
      promise
    };
  },
  category: CommandCategories.actions
}), new Command({
  command: 'spoiler',
  args: '<message>',
  description: (0,languageHandler/* _td */.I8)('Sends the given message as a spoiler'),
  runFn: function (roomId, message) {
    return successSync(content_helpers.makeHtmlMessage(message, `<span data-mx-spoiler>${message}</span>`));
  },
  category: CommandCategories.messages
}), new Command({
  command: 'shrug',
  args: '<message>',
  description: (0,languageHandler/* _td */.I8)('Prepends ¯\\_(ツ)_/¯ to a plain-text message'),
  runFn: function (roomId, args) {
    let message = '¯\\_(ツ)_/¯';
    if (args) {
      message = message + ' ' + args;
    }
    return successSync(content_helpers.makeTextMessage(message));
  },
  category: CommandCategories.messages
}), new Command({
  command: 'tableflip',
  args: '<message>',
  description: (0,languageHandler/* _td */.I8)('Prepends (╯°□°）╯︵ ┻━┻ to a plain-text message'),
  runFn: function (roomId, args) {
    let message = '(╯°□°）╯︵ ┻━┻';
    if (args) {
      message = message + ' ' + args;
    }
    return successSync(content_helpers.makeTextMessage(message));
  },
  category: CommandCategories.messages
}), new Command({
  command: 'unflip',
  args: '<message>',
  description: (0,languageHandler/* _td */.I8)('Prepends ┬──┬ ノ( ゜-゜ノ) to a plain-text message'),
  runFn: function (roomId, args) {
    let message = '┬──┬ ノ( ゜-゜ノ)';
    if (args) {
      message = message + ' ' + args;
    }
    return successSync(content_helpers.makeTextMessage(message));
  },
  category: CommandCategories.messages
}), new Command({
  command: 'lenny',
  args: '<message>',
  description: (0,languageHandler/* _td */.I8)('Prepends ( ͡° ͜ʖ ͡°) to a plain-text message'),
  runFn: function (roomId, args) {
    let message = '( ͡° ͜ʖ ͡°)';
    if (args) {
      message = message + ' ' + args;
    }
    return successSync(content_helpers.makeTextMessage(message));
  },
  category: CommandCategories.messages
}), new Command({
  command: 'plain',
  args: '<message>',
  description: (0,languageHandler/* _td */.I8)('Sends a message as plain text, without interpreting it as markdown'),
  runFn: function (roomId, messages) {
    return successSync(content_helpers.makeTextMessage(messages));
  },
  category: CommandCategories.messages
}), new Command({
  command: 'html',
  args: '<message>',
  description: (0,languageHandler/* _td */.I8)('Sends a message as html, without interpreting it as markdown'),
  runFn: function (roomId, messages) {
    return successSync(content_helpers.makeHtmlMessage(messages, messages));
  },
  category: CommandCategories.messages
}), new Command({
  command: 'upgraderoom',
  args: '<new_version>',
  description: (0,languageHandler/* _td */.I8)('Upgrades a room to a new version'),
  runFn: function (roomId, args) {
    if (args) {
      const cli = MatrixClientPeg/* MatrixClientPeg */.p.get();
      const room = cli.getRoom(roomId);
      if (!room.currentState.mayClientSendStateEvent("m.room.tombstone", cli)) {
        return reject((0,languageHandler._t)("You do not have the required permissions to use this command."));
      }
      const {
        finished
      } = Modal/* default */.Z.createTrackedDialog('Slash Commands', 'upgrade room confirmation', RoomUpgradeWarningDialog, {
        roomId: roomId,
        targetVersion: args
      }, /*className=*/null, /*isPriority=*/false, /*isStatic=*/true);
      return success(finished.then(async ([resp]) => {
        if (!(resp !== null && resp !== void 0 && resp.continue)) return;
        await (0,RoomUpgrade/* upgradeRoom */.U)(room, args, resp.invite);
      }));
    }
    return reject(this.getUsage());
  },
  category: CommandCategories.admin
}), new Command({
  command: 'nick',
  args: '<display_name>',
  description: (0,languageHandler/* _td */.I8)('Changes your display nickname'),
  runFn: function (roomId, args) {
    if (args) {
      return success(MatrixClientPeg/* MatrixClientPeg */.p.get().setDisplayName(args));
    }
    return reject(this.getUsage());
  },
  category: CommandCategories.actions
}), new Command({
  command: 'myroomnick',
  aliases: ['roomnick'],
  args: '<display_name>',
  description: (0,languageHandler/* _td */.I8)('Changes your display nickname in the current room only'),
  runFn: function (roomId, args) {
    if (args) {
      const cli = MatrixClientPeg/* MatrixClientPeg */.p.get();
      const ev = cli.getRoom(roomId).currentState.getStateEvents('m.room.member', cli.getUserId());
      const content = _objectSpread(_objectSpread({}, ev ? ev.getContent() : {
        membership: 'join'
      }), {}, {
        displayname: args
      });
      return success(cli.sendStateEvent(roomId, 'm.room.member', content, cli.getUserId()));
    }
    return reject(this.getUsage());
  },
  category: CommandCategories.actions
}), new Command({
  command: 'roomavatar',
  args: '[<mxc_url>]',
  description: (0,languageHandler/* _td */.I8)('Changes the avatar of the current room'),
  runFn: function (roomId, args) {
    let promise = Promise.resolve(args);
    if (!args) {
      promise = singleMxcUpload();
    }
    return success(promise.then(url => {
      if (!url) return;
      return MatrixClientPeg/* MatrixClientPeg */.p.get().sendStateEvent(roomId, 'm.room.avatar', {
        url
      }, '');
    }));
  },
  category: CommandCategories.actions
}), new Command({
  command: 'myroomavatar',
  args: '[<mxc_url>]',
  description: (0,languageHandler/* _td */.I8)('Changes your avatar in this current room only'),
  runFn: function (roomId, args) {
    const cli = MatrixClientPeg/* MatrixClientPeg */.p.get();
    const room = cli.getRoom(roomId);
    const userId = cli.getUserId();
    let promise = Promise.resolve(args);
    if (!args) {
      promise = singleMxcUpload();
    }
    return success(promise.then(url => {
      if (!url) return;
      const ev = room.currentState.getStateEvents('m.room.member', userId);
      const content = _objectSpread(_objectSpread({}, ev ? ev.getContent() : {
        membership: 'join'
      }), {}, {
        avatar_url: url
      });
      return cli.sendStateEvent(roomId, 'm.room.member', content, userId);
    }));
  },
  category: CommandCategories.actions
}), new Command({
  command: 'myavatar',
  args: '[<mxc_url>]',
  description: (0,languageHandler/* _td */.I8)('Changes your avatar in all rooms'),
  runFn: function (roomId, args) {
    let promise = Promise.resolve(args);
    if (!args) {
      promise = singleMxcUpload();
    }
    return success(promise.then(url => {
      if (!url) return;
      return MatrixClientPeg/* MatrixClientPeg */.p.get().setAvatarUrl(url);
    }));
  },
  category: CommandCategories.actions
}), new Command({
  command: 'topic',
  args: '[<topic>]',
  description: (0,languageHandler/* _td */.I8)('Gets or sets the room topic'),
  runFn: function (roomId, args) {
    const cli = MatrixClientPeg/* MatrixClientPeg */.p.get();
    if (args) {
      return success(cli.setRoomTopic(roomId, args));
    }
    const room = cli.getRoom(roomId);
    if (!room) return reject((0,languageHandler._t)("Failed to set topic"));
    const topicEvents = room.currentState.getStateEvents('m.room.topic', '');
    const topic = topicEvents && topicEvents.getContent().topic;
    const topicHtml = topic ? (0,HtmlUtils/* linkifyAndSanitizeHtml */.xU)(topic) : (0,languageHandler._t)('This room has no topic.');
    Modal/* default */.Z.createTrackedDialog('Slash Commands', 'Topic', InfoDialog/* default */.Z, {
      title: room.name,
      description: /*#__PURE__*/react.createElement("div", {
        dangerouslySetInnerHTML: {
          __html: topicHtml
        }
      }),
      hasCloseButton: true
    });
    return success();
  },
  category: CommandCategories.admin
}), new Command({
  command: 'roomname',
  args: '<name>',
  description: (0,languageHandler/* _td */.I8)('Sets the room name'),
  runFn: function (roomId, args) {
    if (args) {
      return success(MatrixClientPeg/* MatrixClientPeg */.p.get().setRoomName(roomId, args));
    }
    return reject(this.getUsage());
  },
  category: CommandCategories.admin
}), new Command({
  command: 'invite',
  args: '<user-id> [<reason>]',
  description: (0,languageHandler/* _td */.I8)('Invites user with given id to current room'),
  runFn: function (roomId, args) {
    if (args) {
      const [address, reason] = args.split(/\s+(.+)/);
      if (address) {
        // We use a MultiInviter to re-use the invite logic, even though
        // we're only inviting one user.
        // If we need an identity server but don't have one, things
        // get a bit more complex here, but we try to show something
        // meaningful.
        let prom = Promise.resolve();
        if ((0,UserAddress/* getAddressType */.hZ)(address) === 'email' && !MatrixClientPeg/* MatrixClientPeg */.p.get().getIdentityServerUrl()) {
          const defaultIdentityServerUrl = (0,IdentityServerUtils/* getDefaultIdentityServerUrl */.P_)();
          if (defaultIdentityServerUrl) {
            const {
              finished
            } = Modal/* default */.Z.createTrackedDialog('Slash Commands', 'Identity server', QuestionDialog/* default */.Z, {
              title: (0,languageHandler._t)("Use an identity server"),
              description: /*#__PURE__*/react.createElement("p", null, (0,languageHandler._t)("Use an identity server to invite by email. " + "Click continue to use the default identity server " + "(%(defaultIdentityServerName)s) or manage in Settings.", {
                defaultIdentityServerName: (0,UrlUtils/* abbreviateUrl */.FB)(defaultIdentityServerUrl)
              })),
              button: (0,languageHandler._t)("Continue")
            });
            prom = finished.then(([useDefault]) => {
              if (useDefault) {
                (0,IdentityServerUtils/* useDefaultIdentityServer */.e8)();
                return;
              }
              throw new Error((0,languageHandler._t)("Use an identity server to invite by email. Manage in Settings."));
            });
          } else {
            return reject((0,languageHandler._t)("Use an identity server to invite by email. Manage in Settings."));
          }
        }
        const inviter = new MultiInviter/* default */.Z(roomId);
        return success(prom.then(() => {
          return inviter.invite([address], reason);
        }).then(() => {
          if (inviter.getCompletionState(address) !== "invited") {
            throw new Error(inviter.getErrorText(address));
          }
        }));
      }
    }
    return reject(this.getUsage());
  },
  category: CommandCategories.actions
}), new Command({
  command: 'join',
  aliases: ['j', 'goto'],
  args: '<room-address>',
  description: (0,languageHandler/* _td */.I8)('Joins room with given address'),
  runFn: function (roomId, args) {
    if (args) {
      // Note: we support 2 versions of this command. The first is
      // the public-facing one for most users and the other is a
      // power-user edition where someone may join via permalink or
      // room ID with optional servers. Practically, this results
      // in the following variations:
      //   /join #example:example.org
      //   /join !example:example.org
      //   /join !example:example.org altserver.com elsewhere.ca
      //   /join https://matrix.to/#/!example:example.org?via=altserver.com
      // The command also supports event permalinks transparently:
      //   /join https://matrix.to/#/!example:example.org/$something:example.org
      //   /join https://matrix.to/#/!example:example.org/$something:example.org?via=altserver.com
      const params = args.split(' ');
      if (params.length < 1) return reject(this.getUsage());
      let isPermalink = false;
      if (params[0].startsWith("http:") || params[0].startsWith("https:")) {
        // It's at least a URL - try and pull out a hostname to check against the
        // permalink handler
        const parsedUrl = new URL(params[0]);
        const hostname = parsedUrl.host || parsedUrl.hostname; // takes first non-falsey value

        // if we're using a Element permalink handler, this will catch it before we get much further.
        // see below where we make assumptions about parsing the URL.
        if ((0,Permalinks/* isPermalinkHost */.M5)(hostname)) {
          isPermalink = true;
        }
      }
      if (params[0][0] === '#') {
        let roomAlias = params[0];
        if (!roomAlias.includes(':')) {
          roomAlias += ':' + MatrixClientPeg/* MatrixClientPeg */.p.get().getDomain();
        }
        dispatcher/* default */.ZP.dispatch({
          action: 'view_room',
          room_alias: roomAlias,
          auto_join: true,
          _type: "slash_command" // instrumentation
        });

        return success();
      } else if (params[0][0] === '!') {
        const [roomId, ...viaServers] = params;
        dispatcher/* default */.ZP.dispatch({
          action: 'view_room',
          room_id: roomId,
          opts: {
            // These are passed down to the js-sdk's /join call
            viaServers: viaServers
          },
          via_servers: viaServers,
          // for the rejoin button
          auto_join: true,
          _type: "slash_command" // instrumentation
        });

        return success();
      } else if (isPermalink) {
        const permalinkParts = (0,Permalinks/* parsePermalink */.My)(params[0]);

        // This check technically isn't needed because we already did our
        // safety checks up above. However, for good measure, let's be sure.
        if (!permalinkParts) {
          return reject(this.getUsage());
        }

        // If for some reason someone wanted to join a group or user, we should
        // stop them now.
        if (!permalinkParts.roomIdOrAlias) {
          return reject(this.getUsage());
        }
        const entity = permalinkParts.roomIdOrAlias;
        const viaServers = permalinkParts.viaServers;
        const eventId = permalinkParts.eventId;
        const dispatch = {
          action: 'view_room',
          auto_join: true,
          _type: "slash_command" // instrumentation
        };

        if (entity[0] === '!') dispatch["room_id"] = entity;else dispatch["room_alias"] = entity;
        if (eventId) {
          dispatch["event_id"] = eventId;
          dispatch["highlighted"] = true;
        }
        if (viaServers) {
          // For the join
          dispatch["opts"] = {
            // These are passed down to the js-sdk's /join call
            viaServers: viaServers
          };

          // For if the join fails (rejoin button)
          dispatch['via_servers'] = viaServers;
        }
        dispatcher/* default */.ZP.dispatch(dispatch);
        return success();
      }
    }
    return reject(this.getUsage());
  },
  category: CommandCategories.actions
}), new Command({
  command: 'part',
  args: '[<room-address>]',
  description: (0,languageHandler/* _td */.I8)('Leave room'),
  runFn: function (roomId, args) {
    const cli = MatrixClientPeg/* MatrixClientPeg */.p.get();
    let targetRoomId;
    if (args) {
      const matches = args.match(/^(\S+)$/);
      if (matches) {
        let roomAlias = matches[1];
        if (roomAlias[0] !== '#') return reject(this.getUsage());
        if (!roomAlias.includes(':')) {
          roomAlias += ':' + cli.getDomain();
        }

        // Try to find a room with this alias
        const rooms = cli.getRooms();
        for (let i = 0; i < rooms.length; i++) {
          const aliasEvents = rooms[i].currentState.getStateEvents('m.room.aliases');
          for (let j = 0; j < aliasEvents.length; j++) {
            const aliases = aliasEvents[j].getContent().aliases || [];
            for (let k = 0; k < aliases.length; k++) {
              if (aliases[k] === roomAlias) {
                targetRoomId = rooms[i].roomId;
                break;
              }
            }
            if (targetRoomId) break;
          }
          if (targetRoomId) break;
        }
        if (!targetRoomId) return reject((0,languageHandler._t)('Unrecognised room address:') + ' ' + roomAlias);
      }
    }
    if (!targetRoomId) targetRoomId = roomId;
    return success((0,membership/* leaveRoomBehaviour */.cW)(targetRoomId));
  },
  category: CommandCategories.actions
}), new Command({
  command: 'kick',
  args: '<user-id> [reason]',
  description: (0,languageHandler/* _td */.I8)('Kicks user with given id'),
  runFn: function (roomId, args) {
    if (args) {
      const matches = args.match(/^(\S+?)( +(.*))?$/);
      if (matches) {
        return success(MatrixClientPeg/* MatrixClientPeg */.p.get().kick(roomId, matches[1], matches[3]));
      }
    }
    return reject(this.getUsage());
  },
  category: CommandCategories.admin
}), new Command({
  command: 'ban',
  args: '<user-id> [reason]',
  description: (0,languageHandler/* _td */.I8)('Bans user with given id'),
  runFn: function (roomId, args) {
    if (args) {
      const matches = args.match(/^(\S+?)( +(.*))?$/);
      if (matches) {
        return success(MatrixClientPeg/* MatrixClientPeg */.p.get().ban(roomId, matches[1], matches[3]));
      }
    }
    return reject(this.getUsage());
  },
  category: CommandCategories.admin
}), new Command({
  command: 'unban',
  args: '<user-id>',
  description: (0,languageHandler/* _td */.I8)('Unbans user with given ID'),
  runFn: function (roomId, args) {
    if (args) {
      const matches = args.match(/^(\S+)$/);
      if (matches) {
        // Reset the user membership to "leave" to unban him
        return success(MatrixClientPeg/* MatrixClientPeg */.p.get().unban(roomId, matches[1]));
      }
    }
    return reject(this.getUsage());
  },
  category: CommandCategories.admin
}), new Command({
  command: 'ignore',
  args: '<user-id>',
  description: (0,languageHandler/* _td */.I8)('Ignores a user, hiding their messages from you'),
  runFn: function (roomId, args) {
    if (args) {
      const cli = MatrixClientPeg/* MatrixClientPeg */.p.get();
      const matches = args.match(/^(@[^:]+:\S+)$/);
      if (matches) {
        const userId = matches[1];
        const ignoredUsers = cli.getIgnoredUsers();
        ignoredUsers.push(userId); // de-duped internally in the js-sdk
        return success(cli.setIgnoredUsers(ignoredUsers).then(() => {
          Modal/* default */.Z.createTrackedDialog('Slash Commands', 'User ignored', InfoDialog/* default */.Z, {
            title: (0,languageHandler._t)('Ignored user'),
            description: /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement("p", null, (0,languageHandler._t)('You are now ignoring %(userId)s', {
              userId
            })))
          });
        }));
      }
    }
    return reject(this.getUsage());
  },
  category: CommandCategories.actions
}), new Command({
  command: 'unignore',
  args: '<user-id>',
  description: (0,languageHandler/* _td */.I8)('Stops ignoring a user, showing their messages going forward'),
  runFn: function (roomId, args) {
    if (args) {
      const cli = MatrixClientPeg/* MatrixClientPeg */.p.get();
      const matches = args.match(/(^@[^:]+:\S+$)/);
      if (matches) {
        const userId = matches[1];
        const ignoredUsers = cli.getIgnoredUsers();
        const index = ignoredUsers.indexOf(userId);
        if (index !== -1) ignoredUsers.splice(index, 1);
        return success(cli.setIgnoredUsers(ignoredUsers).then(() => {
          Modal/* default */.Z.createTrackedDialog('Slash Commands', 'User unignored', InfoDialog/* default */.Z, {
            title: (0,languageHandler._t)('Unignored user'),
            description: /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement("p", null, (0,languageHandler._t)('You are no longer ignoring %(userId)s', {
              userId
            })))
          });
        }));
      }
    }
    return reject(this.getUsage());
  },
  category: CommandCategories.actions
}), new Command({
  command: 'op',
  args: '<user-id> [<power-level>]',
  description: (0,languageHandler/* _td */.I8)('Define the power level of a user'),
  runFn: function (roomId, args) {
    if (args) {
      const matches = args.match(/^(\S+?)( +(-?\d+))?$/);
      let powerLevel = 50; // default power level for op
      if (matches) {
        const userId = matches[1];
        if (matches.length === 4 && undefined !== matches[3]) {
          powerLevel = parseInt(matches[3], 10);
        }
        if (!isNaN(powerLevel)) {
          const cli = MatrixClientPeg/* MatrixClientPeg */.p.get();
          const room = cli.getRoom(roomId);
          if (!room) return reject((0,languageHandler._t)("Command failed"));
          const member = room.getMember(userId);
          if (!member || (0,membership/* getEffectiveMembership */.rK)(member.membership) === membership/* EffectiveMembership */.mK.Leave) {
            return reject((0,languageHandler._t)("Could not find user in room"));
          }
          const powerLevelEvent = room.currentState.getStateEvents('m.room.power_levels', '');
          return success(cli.setPowerLevel(roomId, userId, powerLevel, powerLevelEvent));
        }
      }
    }
    return reject(this.getUsage());
  },
  category: CommandCategories.admin
}), new Command({
  command: 'deop',
  args: '<user-id>',
  description: (0,languageHandler/* _td */.I8)('Deops user with given id'),
  runFn: function (roomId, args) {
    if (args) {
      const matches = args.match(/^(\S+)$/);
      if (matches) {
        const cli = MatrixClientPeg/* MatrixClientPeg */.p.get();
        const room = cli.getRoom(roomId);
        if (!room) return reject((0,languageHandler._t)("Command failed"));
        const powerLevelEvent = room.currentState.getStateEvents('m.room.power_levels', '');
        if (!powerLevelEvent.getContent().users[args]) return reject((0,languageHandler._t)("Could not find user in room"));
        return success(cli.setPowerLevel(roomId, args, undefined, powerLevelEvent));
      }
    }
    return reject(this.getUsage());
  },
  category: CommandCategories.admin
}), new Command({
  command: 'devtools',
  description: (0,languageHandler/* _td */.I8)('Opens the Developer Tools dialog'),
  runFn: function (roomId) {
    Modal/* default */.Z.createDialog(DevtoolsDialog/* default */.Z, {
      roomId
    });
    return success();
  },
  category: CommandCategories.advanced
}), new Command({
  command: 'addwidget',
  args: '<url | embed code | Jitsi url>',
  description: (0,languageHandler/* _td */.I8)('Adds a custom widget by URL to the room'),
  isEnabled: () => SettingsStore/* default */.C.getValue(UIFeature/* UIFeature */.H.Widgets),
  runFn: function (roomId, widgetUrl) {
    if (!widgetUrl) {
      return reject((0,languageHandler._t)("Please supply a widget URL or embed code"));
    }

    // Try and parse out a widget URL from iframes
    if (widgetUrl.toLowerCase().startsWith("<iframe ")) {
      // We use parse5, which doesn't render/create a DOM node. It instead runs
      // some superfast regex over the text so we don't have to.
      const embed = (0,lib.parseFragment)(widgetUrl);
      if (embed && embed.childNodes && embed.childNodes.length === 1) {
        const iframe = embed.childNodes[0];
        if (iframe.tagName.toLowerCase() === 'iframe' && iframe.attrs) {
          const srcAttr = iframe.attrs.find(a => a.name === 'src');
          console.log("Pulling URL out of iframe (embed code)");
          widgetUrl = srcAttr.value;
        }
      }
    }
    if (!widgetUrl.startsWith("https://") && !widgetUrl.startsWith("http://")) {
      return reject((0,languageHandler._t)("Please supply a https:// or http:// widget URL"));
    }
    if (WidgetUtils/* default */.Z.canUserModifyWidgets(roomId)) {
      const userId = MatrixClientPeg/* MatrixClientPeg */.p.get().getUserId();
      const nowMs = new Date().getTime();
      const widgetId = encodeURIComponent(`${roomId}_${userId}_${nowMs}`);
      let type = WidgetType/* WidgetType */.l.CUSTOM;
      let name = "Custom Widget";
      let data = {};

      // Make the widget a Jitsi widget if it looks like a Jitsi widget
      const jitsiData = Jitsi/* Jitsi */.b.getInstance().parsePreferredConferenceUrl(widgetUrl);
      if (jitsiData) {
        console.log("Making /addwidget widget a Jitsi conference");
        type = WidgetType/* WidgetType */.l.JITSI;
        name = "Jitsi Conference";
        data = jitsiData;
        widgetUrl = WidgetUtils/* default */.Z.getLocalJitsiWrapperUrl();
      }
      return success(WidgetUtils/* default */.Z.setRoomWidget(roomId, widgetId, type, widgetUrl, name, data));
    } else {
      return reject((0,languageHandler._t)("You cannot modify widgets in this room."));
    }
  },
  category: CommandCategories.admin
}), new Command({
  command: 'verify',
  args: '<user-id> <device-id> <device-signing-key>',
  description: (0,languageHandler/* _td */.I8)('Verifies a user, session, and pubkey tuple'),
  runFn: function (roomId, args) {
    if (args) {
      const matches = args.match(/^(\S+) +(\S+) +(\S+)$/);
      if (matches) {
        const cli = MatrixClientPeg/* MatrixClientPeg */.p.get();
        const userId = matches[1];
        const deviceId = matches[2];
        const fingerprint = matches[3];
        return success((async () => {
          const device = cli.getStoredDevice(userId, deviceId);
          if (!device) {
            throw new Error((0,languageHandler._t)('Unknown (user, session) pair:') + ` (${userId}, ${deviceId})`);
          }
          const deviceTrust = await cli.checkDeviceTrust(userId, deviceId);
          if (deviceTrust.isVerified()) {
            if (device.getFingerprint() === fingerprint) {
              throw new Error((0,languageHandler._t)('Session already verified!'));
            } else {
              throw new Error((0,languageHandler._t)('WARNING: Session already verified, but keys do NOT MATCH!'));
            }
          }
          if (device.getFingerprint() !== fingerprint) {
            const fprint = device.getFingerprint();
            throw new Error((0,languageHandler._t)('WARNING: KEY VERIFICATION FAILED! The signing key for %(userId)s and session' + ' %(deviceId)s is "%(fprint)s" which does not match the provided key ' + '"%(fingerprint)s". This could mean your communications are being intercepted!', {
              fprint,
              userId,
              deviceId,
              fingerprint
            }));
          }
          await cli.setDeviceVerified(userId, deviceId, true);

          // Tell the user we verified everything
          Modal/* default */.Z.createTrackedDialog('Slash Commands', 'Verified key', InfoDialog/* default */.Z, {
            title: (0,languageHandler._t)('Verified key'),
            description: /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement("p", null, (0,languageHandler._t)('The signing key you provided matches the signing key you received ' + 'from %(userId)s\'s session %(deviceId)s. Session marked as verified.', {
              userId,
              deviceId
            })))
          });
        })());
      }
    }
    return reject(this.getUsage());
  },
  category: CommandCategories.advanced
}), new Command({
  command: 'discardsession',
  description: (0,languageHandler/* _td */.I8)('Forces the current outbound group session in an encrypted room to be discarded'),
  runFn: function (roomId) {
    try {
      MatrixClientPeg/* MatrixClientPeg */.p.get().forceDiscardSession(roomId);
    } catch (e) {
      return reject(e.message);
    }
    return success();
  },
  category: CommandCategories.advanced
}), new Command({
  command: "rainbow",
  description: (0,languageHandler/* _td */.I8)("Sends the given message coloured as a rainbow"),
  args: '<message>',
  runFn: function (roomId, args) {
    if (!args) return reject(this.getUserId());
    return successSync(content_helpers.makeHtmlMessage(args, textToHtmlRainbow(args)));
  },
  category: CommandCategories.messages
}), new Command({
  command: "rainbowme",
  description: (0,languageHandler/* _td */.I8)("Sends the given emote coloured as a rainbow"),
  args: '<message>',
  runFn: function (roomId, args) {
    if (!args) return reject(this.getUserId());
    return successSync(content_helpers.makeHtmlEmote(args, textToHtmlRainbow(args)));
  },
  category: CommandCategories.messages
}), new Command({
  command: "help",
  description: (0,languageHandler/* _td */.I8)("Displays list of commands with usages and descriptions"),
  runFn: function () {
    Modal/* default */.Z.createTrackedDialog('Slash Commands', 'Help', SlashCommandHelpDialog);
    return success();
  },
  category: CommandCategories.advanced
}), new Command({
  command: "whois",
  description: (0,languageHandler/* _td */.I8)("Displays information about a user"),
  args: "<user-id>",
  runFn: function (roomId, userId) {
    if (!userId || !userId.startsWith("@") || !userId.includes(":")) {
      return reject(this.getUsage());
    }
    const member = MatrixClientPeg/* MatrixClientPeg */.p.get().getRoom(roomId).getMember(userId);
    dispatcher/* default */.ZP.dispatch({
      action: actions/* Action */.a.ViewUser,
      // XXX: We should be using a real member object and not assuming what the receiver wants.
      member: member || {
        userId
      }
    });
    return success();
  },
  category: CommandCategories.advanced
}), new Command({
  command: "rageshake",
  aliases: ["bugreport"],
  description: (0,languageHandler/* _td */.I8)("Send a bug report with logs"),
  isEnabled: () => !!SdkConfig/* default */.Z.get().bug_report_endpoint_url,
  args: "<description>",
  runFn: function (roomId, args) {
    return success(Modal/* default */.Z.createTrackedDialog('Slash Commands', 'Bug Report Dialog', BugReportDialog/* default */.Z, {
      initialText: args
    }).finished);
  },
  category: CommandCategories.advanced
}), new Command({
  command: "query",
  description: (0,languageHandler/* _td */.I8)("Opens chat with the given user"),
  args: "<user-id>",
  runFn: function (roomId, userId) {
    // easter-egg for now: look up phone numbers through the thirdparty API
    // (very dumb phone number detection...)
    const isPhoneNumber = userId && /^\+?[0123456789]+$/.test(userId);
    if (!userId || (!userId.startsWith("@") || !userId.includes(":")) && !isPhoneNumber) {
      return reject(this.getUsage());
    }
    return success((async () => {
      if (isPhoneNumber) {
        const results = await CallHandler/* default */.ZP.sharedInstance().pstnLookup(this.state.value);
        if (!results || results.length === 0 || !results[0].userid) {
          throw new Error("Unable to find Matrix ID for phone number");
        }
        userId = results[0].userid;
      }
      const roomId = await (0,createRoom/* ensureDMExists */.Aw)(MatrixClientPeg/* MatrixClientPeg */.p.get(), userId);
      dispatcher/* default */.ZP.dispatch({
        action: 'view_room',
        room_id: roomId
      });
    })());
  },
  category: CommandCategories.actions
}), new Command({
  command: "msg",
  description: (0,languageHandler/* _td */.I8)("Sends a message to the given user"),
  args: "<user-id> <message>",
  runFn: function (roomId, args) {
    if (args) {
      // matches the first whitespace delimited group and then the rest of the string
      const matches = args.match(/^(\S+?)(?: +(.*))?$/s);
      if (matches) {
        const [userId, msg] = matches.slice(1);
        if (msg && userId && userId.startsWith("@") && userId.includes(":")) {
          return success((async () => {
            const cli = MatrixClientPeg/* MatrixClientPeg */.p.get();
            const roomId = await (0,createRoom/* ensureDMExists */.Aw)(cli, userId);
            dispatcher/* default */.ZP.dispatch({
              action: 'view_room',
              room_id: roomId
            });
            cli.sendTextMessage(roomId, msg);
          })());
        }
      }
    }
    return reject(this.getUsage());
  },
  category: CommandCategories.actions
}), new Command({
  command: "holdcall",
  description: (0,languageHandler/* _td */.I8)("Places the call in the current room on hold"),
  category: CommandCategories.other,
  runFn: function (roomId, args) {
    const call = CallHandler/* default */.ZP.sharedInstance().getCallForRoom(roomId);
    if (!call) {
      return reject("No active call in this room");
    }
    call.setRemoteOnHold(true);
    return success();
  }
}), new Command({
  command: "unholdcall",
  description: (0,languageHandler/* _td */.I8)("Takes the call in the current room off hold"),
  category: CommandCategories.other,
  runFn: function (roomId, args) {
    const call = CallHandler/* default */.ZP.sharedInstance().getCallForRoom(roomId);
    if (!call) {
      return reject("No active call in this room");
    }
    call.setRemoteOnHold(false);
    return success();
  }
}), new Command({
  command: "converttodm",
  description: (0,languageHandler/* _td */.I8)("Converts the room to a DM"),
  category: CommandCategories.other,
  runFn: function (roomId, args) {
    const room = MatrixClientPeg/* MatrixClientPeg */.p.get().getRoom(roomId);
    return success((0,Rooms/* guessAndSetDMRoom */.aK)(room, true));
  }
}), new Command({
  command: "converttoroom",
  description: (0,languageHandler/* _td */.I8)("Converts the DM to a room"),
  category: CommandCategories.other,
  runFn: function (roomId, args) {
    const room = MatrixClientPeg/* MatrixClientPeg */.p.get().getRoom(roomId);
    return success((0,Rooms/* guessAndSetDMRoom */.aK)(room, false));
  }
}),
// Command definitions for autocompletion ONLY:
// /me is special because its not handled by SlashCommands.js and is instead done inside the Composer classes
new Command({
  command: "me",
  args: '<message>',
  description: (0,languageHandler/* _td */.I8)('Displays action'),
  category: CommandCategories.messages,
  hideCompletionAfterSpace: true
}), ...effects/* CHAT_EFFECTS */.b.map(effect => {
  return new Command({
    command: effect.command,
    description: effect.description(),
    args: '<message>',
    runFn: function (roomId, args) {
      return success((async () => {
        if (!args) {
          args = effect.fallbackMessage();
          MatrixClientPeg/* MatrixClientPeg */.p.get().sendEmoteMessage(roomId, args);
        } else {
          const content = {
            msgtype: effect.msgType,
            body: args
          };
          MatrixClientPeg/* MatrixClientPeg */.p.get().sendMessage(roomId, content);
        }
        dispatcher/* default */.ZP.dispatch({
          action: `effects.${effect.command}`
        });
      })());
    },
    category: CommandCategories.effects
  });
})];

// build a map from names and aliases to the Command objects.
const CommandMap = new Map();
Commands.forEach(cmd => {
  CommandMap.set(cmd.command, cmd);
  cmd.aliases.forEach(alias => {
    CommandMap.set(alias, cmd);
  });
});
function parseCommandString(input) {
  // trim any trailing whitespace, as it can confuse the parser for
  // IRC-style commands
  input = input.replace(/\s+$/, '');
  if (input[0] !== '/') return {}; // not a command

  const bits = input.match(/^(\S+?)(?:[ \n]+((.|\n)*))?$/);
  let cmd;
  let args;
  if (bits) {
    cmd = bits[1].substring(1).toLowerCase();
    args = bits[2];
  } else {
    cmd = input;
  }
  return {
    cmd,
    args
  };
}
/**
 * Process the given text for /commands and return a bound method to perform them.
 * @param {string} roomId The room in which the command was performed.
 * @param {string} input The raw text input by the user.
 * @return {null|function(): Object} Function returning an object with the property 'error' if there was an error
 * processing the command, or 'promise' if a request was sent out.
 * Returns null if the input didn't match a command.
 */
function getCommand(input) {
  const {
    cmd,
    args
  } = parseCommandString(input);
  if (CommandMap.has(cmd) && CommandMap.get(cmd).isEnabled()) {
    return {
      cmd: CommandMap.get(cmd),
      args
    };
  }
  return {};
}

/***/ }),

/***/ 158205:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ZP: () => (/* binding */ CallEventGrouper),
/* harmony export */   kE: () => (/* binding */ CustomCallState),
/* harmony export */   pN: () => (/* binding */ CallEventGrouperEvent)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(225259);
/* harmony import */ var matrix_js_sdk_src_types_event__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(907977);
/* harmony import */ var matrix_js_sdk_src_webrtc_call__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(160193);
/* harmony import */ var _CallHandler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(613431);
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(717187);
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _MatrixClientPeg__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(933393);
/* harmony import */ var _dispatcher_dispatcher__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(245539);

/*
Copyright 2021 Šimon Brandner <simon.bra.ag@gmail.com>

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/







let CallEventGrouperEvent = /*#__PURE__*/function (CallEventGrouperEvent) {
  CallEventGrouperEvent["StateChanged"] = "state_changed";
  CallEventGrouperEvent["SilencedChanged"] = "silenced_changed";
  CallEventGrouperEvent["LengthChanged"] = "length_changed";
  return CallEventGrouperEvent;
}({});
const CONNECTING_STATES = [matrix_js_sdk_src_webrtc_call__WEBPACK_IMPORTED_MODULE_1__/* .CallState */ .OX.Connecting, matrix_js_sdk_src_webrtc_call__WEBPACK_IMPORTED_MODULE_1__/* .CallState */ .OX.WaitLocalMedia, matrix_js_sdk_src_webrtc_call__WEBPACK_IMPORTED_MODULE_1__/* .CallState */ .OX.CreateOffer, matrix_js_sdk_src_webrtc_call__WEBPACK_IMPORTED_MODULE_1__/* .CallState */ .OX.CreateAnswer];
const SUPPORTED_STATES = [matrix_js_sdk_src_webrtc_call__WEBPACK_IMPORTED_MODULE_1__/* .CallState */ .OX.Connected, matrix_js_sdk_src_webrtc_call__WEBPACK_IMPORTED_MODULE_1__/* .CallState */ .OX.Ringing];
let CustomCallState = /*#__PURE__*/function (CustomCallState) {
  CustomCallState["Missed"] = "missed";
  return CustomCallState;
}({});
class CallEventGrouper extends events__WEBPACK_IMPORTED_MODULE_3__.EventEmitter {
  constructor() {
    super();
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(this, "events", new Set());
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(this, "call", void 0);
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(this, "state", void 0);
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(this, "onSilencedCallsChanged", () => {
      const newState = _CallHandler__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .ZP.sharedInstance().isCallSilenced(this.callId);
      this.emit(CallEventGrouperEvent.SilencedChanged, newState);
    });
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(this, "onLengthChanged", length => {
      this.emit(CallEventGrouperEvent.LengthChanged, length);
    });
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(this, "answerCall", () => {
      _dispatcher_dispatcher__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .ZP.dispatch({
        action: 'answer',
        room_id: this.roomId
      });
    });
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(this, "rejectCall", () => {
      _dispatcher_dispatcher__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .ZP.dispatch({
        action: 'reject',
        room_id: this.roomId
      });
    });
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(this, "callBack", () => {
      _dispatcher_dispatcher__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .ZP.dispatch({
        action: 'place_call',
        type: this.isVoice ? matrix_js_sdk_src_webrtc_call__WEBPACK_IMPORTED_MODULE_1__/* .CallType */ .rf.Voice : matrix_js_sdk_src_webrtc_call__WEBPACK_IMPORTED_MODULE_1__/* .CallType */ .rf.Video,
        room_id: this.roomId
      });
    });
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(this, "toggleSilenced", () => {
      const silenced = _CallHandler__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .ZP.sharedInstance().isCallSilenced(this.callId);
      silenced ? _CallHandler__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .ZP.sharedInstance().unSilenceCall(this.callId) : _CallHandler__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .ZP.sharedInstance().silenceCall(this.callId);
    });
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(this, "setState", () => {
      var _this$call, _this$call2;
      if (CONNECTING_STATES.includes((_this$call = this.call) === null || _this$call === void 0 ? void 0 : _this$call.state)) {
        this.state = matrix_js_sdk_src_webrtc_call__WEBPACK_IMPORTED_MODULE_1__/* .CallState */ .OX.Connecting;
      } else if (SUPPORTED_STATES.includes((_this$call2 = this.call) === null || _this$call2 === void 0 ? void 0 : _this$call2.state)) {
        this.state = this.call.state;
      } else {
        if (this.callWasMissed) this.state = CustomCallState.Missed;else if (this.reject) this.state = matrix_js_sdk_src_webrtc_call__WEBPACK_IMPORTED_MODULE_1__/* .CallState */ .OX.Ended;else if (this.hangup) this.state = matrix_js_sdk_src_webrtc_call__WEBPACK_IMPORTED_MODULE_1__/* .CallState */ .OX.Ended;else if (this.invite && this.call) this.state = matrix_js_sdk_src_webrtc_call__WEBPACK_IMPORTED_MODULE_1__/* .CallState */ .OX.Connecting;
      }
      this.emit(CallEventGrouperEvent.StateChanged, this.state);
    });
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(this, "setCall", () => {
      if (this.call) return;
      this.call = _CallHandler__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .ZP.sharedInstance().getCallById(this.callId);
      this.setCallListeners();
      this.setState();
    });
    _CallHandler__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .ZP.sharedInstance().addListener(_CallHandler__WEBPACK_IMPORTED_MODULE_2__/* .CallHandlerEvent */ .Tj.CallsChanged, this.setCall);
    _CallHandler__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .ZP.sharedInstance().addListener(_CallHandler__WEBPACK_IMPORTED_MODULE_2__/* .CallHandlerEvent */ .Tj.SilencedCallsChanged, this.onSilencedCallsChanged);
  }
  get invite() {
    return [...this.events].find(event => event.getType() === matrix_js_sdk_src_types_event__WEBPACK_IMPORTED_MODULE_0__/* .EventType */ .tw.CallInvite);
  }
  get hangup() {
    return [...this.events].find(event => event.getType() === matrix_js_sdk_src_types_event__WEBPACK_IMPORTED_MODULE_0__/* .EventType */ .tw.CallHangup);
  }
  get reject() {
    return [...this.events].find(event => event.getType() === matrix_js_sdk_src_types_event__WEBPACK_IMPORTED_MODULE_0__/* .EventType */ .tw.CallReject);
  }
  get selectAnswer() {
    return [...this.events].find(event => event.getType() === matrix_js_sdk_src_types_event__WEBPACK_IMPORTED_MODULE_0__/* .EventType */ .tw.CallSelectAnswer);
  }
  get isVoice() {
    var _invite$getContent, _invite$getContent$of, _invite$getContent$of2;
    const invite = this.invite;
    if (!invite) return;

    // FIXME: Find a better way to determine this from the event?
    if (((_invite$getContent = invite.getContent()) === null || _invite$getContent === void 0 ? void 0 : (_invite$getContent$of = _invite$getContent.offer) === null || _invite$getContent$of === void 0 ? void 0 : (_invite$getContent$of2 = _invite$getContent$of.sdp) === null || _invite$getContent$of2 === void 0 ? void 0 : _invite$getContent$of2.indexOf('m=video')) !== -1) return false;
    return true;
  }
  get hangupReason() {
    var _this$hangup, _this$hangup$getConte;
    return (_this$hangup = this.hangup) === null || _this$hangup === void 0 ? void 0 : (_this$hangup$getConte = _this$hangup.getContent()) === null || _this$hangup$getConte === void 0 ? void 0 : _this$hangup$getConte.reason;
  }
  get rejectParty() {
    var _this$reject;
    return (_this$reject = this.reject) === null || _this$reject === void 0 ? void 0 : _this$reject.getSender();
  }
  get gotRejected() {
    return Boolean(this.reject);
  }
  get duration() {
    if (!this.hangup || !this.selectAnswer) return;
    return new Date(this.hangup.getDate().getTime() - this.selectAnswer.getDate().getTime());
  }

  /**
   * Returns true if there are only events from the other side - we missed the call
   */
  get callWasMissed() {
    return ![...this.events].some(event => {
      var _event$sender;
      return ((_event$sender = event.sender) === null || _event$sender === void 0 ? void 0 : _event$sender.userId) === _MatrixClientPeg__WEBPACK_IMPORTED_MODULE_4__/* .MatrixClientPeg */ .p.get().getUserId();
    });
  }
  get callId() {
    var _, _$getContent;
    return (_ = [...this.events][0]) === null || _ === void 0 ? void 0 : (_$getContent = _.getContent()) === null || _$getContent === void 0 ? void 0 : _$getContent.call_id;
  }
  get roomId() {
    var _2;
    return (_2 = [...this.events][0]) === null || _2 === void 0 ? void 0 : _2.getRoomId();
  }
  setCallListeners() {
    if (!this.call) return;
    this.call.addListener(matrix_js_sdk_src_webrtc_call__WEBPACK_IMPORTED_MODULE_1__/* .CallEvent */ .nP.State, this.setState);
    this.call.addListener(matrix_js_sdk_src_webrtc_call__WEBPACK_IMPORTED_MODULE_1__/* .CallEvent */ .nP.LengthChanged, this.onLengthChanged);
  }
  add(event) {
    this.events.add(event);
    this.setCall();
  }
}

/***/ }),

/***/ 617691:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(225259);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(667294);
/* harmony import */ var matrix_js_sdk_src_filter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(965785);
/* harmony import */ var _MatrixClientPeg__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(933393);
/* harmony import */ var _indexing_EventIndexPeg__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(377145);
/* harmony import */ var _languageHandler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(867614);
/* harmony import */ var _views_right_panel_BaseCard__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(554219);
/* harmony import */ var _utils_replaceableComponent__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(90287);
/* harmony import */ var _TimelinePanel__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(672214);
/* harmony import */ var _views_elements_Spinner__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(641542);
/* harmony import */ var _views_rooms_EventTile__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(585340);
/* harmony import */ var _settings_Layout__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(244088);
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(294184);
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var sendingme_ui__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(602271);
/* harmony import */ var _res_img_empty_cover_empty_data_svg__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(211856);
/* harmony import */ var _res_img_empty_cover_empty_data_svg__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(_res_img_empty_cover_empty_data_svg__WEBPACK_IMPORTED_MODULE_13__);

var _dec, _class;
/*
Copyright 2016 OpenMarket Ltd
Copyright 2019 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/















/*
 * Component which shows the filtered file using a TimelinePanel
 */
let FilePanel = (_dec = (0,_utils_replaceableComponent__WEBPACK_IMPORTED_MODULE_6__/* .replaceableComponent */ .U)("structures.FilePanel"), _dec(_class = class FilePanel extends react__WEBPACK_IMPORTED_MODULE_0__.Component {
  constructor(...args) {
    super(...args);
    // This is used to track if a decrypted event was a live event and should be
    // added to the timeline.
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z)(this, "decryptingEvents", new Set());
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z)(this, "mounted", false);
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z)(this, "noRoom", void 0);
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z)(this, "state", {
      timelineSet: null
    });
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z)(this, "onRoomTimeline", (ev, room, toStartOfTimeline, removed, data) => {
      var _this$props;
      if ((room === null || room === void 0 ? void 0 : room.roomId) !== ((_this$props = this.props) === null || _this$props === void 0 ? void 0 : _this$props.roomId)) return;
      if (toStartOfTimeline || !data || !data.liveEvent || ev.isRedacted()) return;
      const client = _MatrixClientPeg__WEBPACK_IMPORTED_MODULE_2__/* .MatrixClientPeg */ .p.get();
      client.decryptEventIfNeeded(ev);
      if (ev.isBeingDecrypted()) {
        this.decryptingEvents.add(ev.getId());
      } else {
        this.addEncryptedLiveEvent(ev);
      }
    });
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z)(this, "onEventDecrypted", (ev, err) => {
      if (ev.getRoomId() !== this.props.roomId) return;
      const eventId = ev.getId();
      if (!this.decryptingEvents.delete(eventId)) return;
      if (err) return;
      this.addEncryptedLiveEvent(ev);
    });
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z)(this, "onPaginationRequest", (timelineWindow, direction, limit) => {
      const client = _MatrixClientPeg__WEBPACK_IMPORTED_MODULE_2__/* .MatrixClientPeg */ .p.get();
      const eventIndex = _indexing_EventIndexPeg__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z.get();
      const roomId = this.props.roomId;
      const room = client.getRoom(roomId);

      // We override the pagination request for encrypted rooms so that we ask
      // the event index to fulfill the pagination request. Asking the server
      // to paginate won't ever work since the server can't correctly filter
      // out events containing URLs
      if (client.isRoomEncrypted(roomId) && eventIndex !== null) {
        return eventIndex.paginateTimelineWindow(room, timelineWindow, direction, limit);
      } else {
        return timelineWindow.paginate(direction, limit);
      }
    });
  }
  addEncryptedLiveEvent(ev) {
    if (!this.state.timelineSet) return;
    const timeline = this.state.timelineSet.getLiveTimeline();
    if (ev.getType() !== "m.room.message") return;
    if (["m.file", "m.image", "m.video", "m.audio"].indexOf(ev.getContent().msgtype) == -1) {
      return;
    }
    if (!this.state.timelineSet.eventIdToTimeline(ev.getId())) {
      this.state.timelineSet.addEventToTimeline(ev, timeline, false);
    }
  }
  async componentDidMount() {
    this.mounted = true;
    this.init();
  }
  async init() {
    const client = _MatrixClientPeg__WEBPACK_IMPORTED_MODULE_2__/* .MatrixClientPeg */ .p.get();
    await this.updateTimelineSet(this.props.roomId);
    if (!_MatrixClientPeg__WEBPACK_IMPORTED_MODULE_2__/* .MatrixClientPeg */ .p.get().isRoomEncrypted(this.props.roomId)) return;

    // The timelineSets filter makes sure that encrypted events that contain
    // URLs never get added to the timeline, even if they are live events.
    // These methods are here to manually listen for such events and add
    // them despite the filter's best efforts.
    //
    // We do this only for encrypted rooms and if an event index exists,
    // this could be made more general in the future or the filter logic
    // could be fixed.
    if (_indexing_EventIndexPeg__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z.get() !== null) {
      client.on('Room.timeline', this.onRoomTimeline);
      client.on('Event.decrypted', this.onEventDecrypted);
    }
  }
  componentWillUnmount() {
    this.mounted = false;
    const client = _MatrixClientPeg__WEBPACK_IMPORTED_MODULE_2__/* .MatrixClientPeg */ .p.get();
    if (client === null) return;
    if (!_MatrixClientPeg__WEBPACK_IMPORTED_MODULE_2__/* .MatrixClientPeg */ .p.get().isRoomEncrypted(this.props.roomId)) return;
    if (_indexing_EventIndexPeg__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z.get() !== null) {
      client.removeListener('Room.timeline', this.onRoomTimeline);
      client.removeListener('Event.decrypted', this.onEventDecrypted);
    }
  }
  componentDidUpdate(prevProps) {
    if (prevProps.roomId !== this.props.roomId) {
      this.setState({
        timelineSet: null
      });
      this.init();
    }
  }
  async fetchFileEventsServer(room) {
    const client = _MatrixClientPeg__WEBPACK_IMPORTED_MODULE_2__/* .MatrixClientPeg */ .p.get();
    const filter = new matrix_js_sdk_src_filter__WEBPACK_IMPORTED_MODULE_1__/* .Filter */ .w(client.credentials.userId);
    filter.setDefinition({
      room: {
        timeline: {
          contains_url: true,
          types: ["m.room.message"]
        }
      }
    });
    const prevFix = this.props.tileShape === _views_rooms_EventTile__WEBPACK_IMPORTED_MODULE_9__/* .TileShape */ .GO.ImageGrid ? "FILTER_IMAGES_" : this.props.tileShape === _views_rooms_EventTile__WEBPACK_IMPORTED_MODULE_9__/* .TileShape */ .GO.FileGrid ? "FILTER_FILES_" : "FILTER_FILES_";
    const filterId = await client.getOrCreateFilter(prevFix + client.credentials.userId, filter);
    filter.filterId = filterId;
    let timelineSet = room.getOrCreateFilteredTimelineSet(filter);
    // timelineSet.sortLiveTimeLine("DOWN");
    return timelineSet;
  }
  async updateTimelineSet(roomId) {
    const client = _MatrixClientPeg__WEBPACK_IMPORTED_MODULE_2__/* .MatrixClientPeg */ .p.get();
    const room = client.getRoom(roomId);
    const eventIndex = _indexing_EventIndexPeg__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z.get();
    this.noRoom = !room;
    if (room) {
      let timelineSet;
      try {
        timelineSet = await this.fetchFileEventsServer(room);

        // If this room is encrypted the file panel won't be populated
        // correctly since the defined filter doesn't support encrypted
        // events and the server can't check if encrypted events contain
        // URLs.
        //
        // This is where our event index comes into place, we ask the
        // event index to populate the timelineSet for us. This call
        // will add 10 events to the live timeline of the set. More can
        // be requested using pagination.
        if (client.isRoomEncrypted(roomId) && eventIndex !== null) {
          const timeline = timelineSet.getLiveTimeline();
          await eventIndex.populateFileTimeline(timelineSet, timeline, room, 10);
        }
        this.mounted && this.setState({
          timelineSet: timelineSet
        });
      } catch (error) {
        console.error("Failed to get or create file panel filter", error);
      }
    } else {
      console.error("Failed to add filtered timelineSet for FilePanel as no room!");
    }
  }
  render() {
    if (_MatrixClientPeg__WEBPACK_IMPORTED_MODULE_2__/* .MatrixClientPeg */ .p.get().isGuest()) {
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_views_right_panel_BaseCard__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .C, {
        className: "mx_FilePanel mx_RoomView_messageListWrapper",
        onClose: this.props.onClose,
        onBack: this.props.onBack
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
        className: "mx_RoomView_empty"
      }, (0,_languageHandler__WEBPACK_IMPORTED_MODULE_4__._t)("You must <a>register</a> to use this functionality", {}, {
        'a': sub => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("a", {
          href: "#/register",
          key: "sub"
        }, sub)
      })));
    } else if (this.noRoom) {
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_views_right_panel_BaseCard__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .C, {
        className: "mx_FilePanel mx_RoomView_messageListWrapper",
        onClose: this.props.onClose,
        onBack: this.props.onBack
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
        className: "mx_RoomView_empty"
      }, (0,_languageHandler__WEBPACK_IMPORTED_MODULE_4__._t)("You must join the room to see its files")));
    }

    // wrap a TimelinePanel with the jump-to-event bits turned off.

    // const emptyState = (<div className="mx_RightPanel_empty mx_FilePanel_empty">
    //     <h2>{_t('No files visible in this room')}</h2>
    //     <p>{_t('Attach files to the messages or just drag and drop them anywhere in the room.')}</p>
    // </div>);

    const emptyState = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(sendingme_ui__WEBPACK_IMPORTED_MODULE_12__.SdEmpty, {
      image: /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("img", {
        src: (_res_img_empty_cover_empty_data_svg__WEBPACK_IMPORTED_MODULE_13___default()),
        alt: ""
      }),
      description: (0,_languageHandler__WEBPACK_IMPORTED_MODULE_4__._t)("No data available.")
    });
    const isRoomEncrypted = this.noRoom ? false : _MatrixClientPeg__WEBPACK_IMPORTED_MODULE_2__/* .MatrixClientPeg */ .p.get().isRoomEncrypted(this.props.roomId);
    if (this.state.timelineSet) {
      // console.log("rendering TimelinePanel for timelineSet " + this.state.timelineSet.room.roomId + " " +
      //             "(" + this.state.timelineSet._timelines.join(", ") + ")" + " with key " + this.props.roomId);
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_views_right_panel_BaseCard__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .C, {
        className: classnames__WEBPACK_IMPORTED_MODULE_11___default()({
          mx_FilePanel: true,
          mx_ImagePanel: this.props.tileShape === _views_rooms_EventTile__WEBPACK_IMPORTED_MODULE_9__/* .TileShape */ .GO.ImageGrid
        }),
        onClose: this.props.onClose,
        onBack: this.props.onBack,
        withoutScrollContainer: true
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_TimelinePanel__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z, {
        manageReadReceipts: false,
        manageReadMarkers: false,
        timelineSet: this.state.timelineSet,
        showUrlPreview: false,
        onPaginationRequest: this.onPaginationRequest,
        tileShape: this.props.tileShape ? this.props.tileShape : _views_rooms_EventTile__WEBPACK_IMPORTED_MODULE_9__/* .TileShape */ .GO.FileGrid,
        resizeNotifier: this.props.resizeNotifier,
        empty: emptyState,
        layout: _settings_Layout__WEBPACK_IMPORTED_MODULE_10__/* .Layout */ .A.Group,
        sortEventType: "DOWN"
      }));
    } else {
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_views_right_panel_BaseCard__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .C, {
        className: "mx_FilePanel",
        onClose: this.props.onClose,
        onBack: this.props.onBack
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_views_elements_Spinner__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z, null));
    }
  }
}) || _class);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FilePanel);

/***/ }),

/***/ 409957:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (/* binding */ MainSplit)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(225259);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(667294);
/* harmony import */ var re_resizable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(715170);
/* harmony import */ var _utils_replaceableComponent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(90287);
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(294184);
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _dispatcher_actions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(473627);
/* harmony import */ var _dispatcher_dispatcher__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(245539);
/* harmony import */ var _settings_Layout__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(244088);

var _dec, _class;
/*
Copyright 2018 New Vector Ltd
Copyright 2019 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/








let MainSplit = (_dec = (0,_utils_replaceableComponent__WEBPACK_IMPORTED_MODULE_2__/* .replaceableComponent */ .U)("structures.MainSplit"), _dec(_class = class MainSplit extends react__WEBPACK_IMPORTED_MODULE_0__.Component {
  constructor(props, context) {
    super(props, context);
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(this, "dispatcherRef", void 0);
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(this, "onResizeStart", () => {
      this.props.resizeNotifier.startResizing();
    });
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(this, "onResize", () => {
      this.props.resizeNotifier.notifyRightHandleResized();
    });
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(this, "onAction", payload => {
      switch (payload.action) {
        case _dispatcher_actions__WEBPACK_IMPORTED_MODULE_4__/* .Action */ .a.ShowRightPanel:
          this.setState({
            showRightPanel: true
          });
          break;
        case _dispatcher_actions__WEBPACK_IMPORTED_MODULE_4__/* .Action */ .a.HideRightPanel:
          this.setState({
            showRightPanel: false
          });
          break;
      }
    });
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(this, "onResizeStop", (event, direction, elementRef, delta) => {
      this.props.resizeNotifier.stopResizing();
      window.localStorage.setItem("mx_rhs_size", (this.loadSidePanelSize().width + delta.width).toString());
    });
    this.state = {
      showRightPanel: false
    };
  }
  loadSidePanelSize() {
    let rhsSize = parseInt(window.localStorage.getItem("mx_rhs_size"), 10);
    if (isNaN(rhsSize)) {
      rhsSize = 390;
    }
    return {
      height: "100%",
      width: rhsSize
    };
  }
  componentDidMount() {
    this.dispatcherRef = _dispatcher_dispatcher__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .ZP.register(this.onAction);
  }
  componentWillUnmount() {
    _dispatcher_dispatcher__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .ZP.unregister(this.dispatcherRef);
  }
  render() {
    const bodyView = react__WEBPACK_IMPORTED_MODULE_0__.Children.only(this.props.children);
    const panelView = this.props.panel;
    const classes = ["mx_RightPanel_ResizeWrapper", {
      "mx_RightPanel_ResizeWrapper--mobile": this.state.showRightPanel && panelView,
      "mx_GroupLayout": this.props.layout === _settings_Layout__WEBPACK_IMPORTED_MODULE_6__/* .Layout */ .A.Group
    }];
    const hasResizer = !this.props.collapsedRhs && panelView;
    let children;
    if (hasResizer) {
      children = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(re_resizable__WEBPACK_IMPORTED_MODULE_1__/* .Resizable */ .e, {
        defaultSize: this.loadSidePanelSize(),
        minWidth: 280
        // maxWidth="50%"
        ,
        enable: {
          top: false,
          right: false,
          bottom: false,
          left: false,
          topRight: false,
          bottomRight: false,
          bottomLeft: false,
          topLeft: false
        },
        onResizeStart: this.onResizeStart,
        onResize: this.onResize,
        onResizeStop: this.onResizeStop,
        className: classnames__WEBPACK_IMPORTED_MODULE_3___default()(classes),
        handleClasses: {
          left: "mx_RightPanel_ResizeHandle"
        }
      }, panelView);
    }
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "mx_MainSplit"
    }, bodyView, children);
  }
}) || _class);


/***/ }),

/***/ 832227:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  VA: () => (/* binding */ PinnedContainer),
  US: () => (/* binding */ getContentOfCard),
  oG: () => (/* binding */ getContentOfMsg),
  kD: () => (/* binding */ getDisplayNameFromEvent)
});

// UNUSED EXPORTS: PinnedMsgBar, default

// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/node_modules/@babel/runtime/helpers/esm/defineProperty.js
var defineProperty = __webpack_require__(225259);
// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(667294);
// EXTERNAL MODULE: ./node_modules/@hiseas/react/dist/index.js
var dist = __webpack_require__(989638);
// EXTERNAL MODULE: ./node_modules/matrix-js-sdk/src/browser-index.js
var browser_index = __webpack_require__(407637);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/right_panel/PinnedMessagesCard.tsx
var PinnedMessagesCard = __webpack_require__(802257);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/contexts/MatrixClientContext.ts
var MatrixClientContext = __webpack_require__(311878);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/utils/strings.ts
var strings = __webpack_require__(653848);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/utils/FormattingUtils.ts
var FormattingUtils = __webpack_require__(960882);
// EXTERNAL MODULE: ./node_modules/matrix-js-sdk/src/@types/event.ts
var _types_event = __webpack_require__(907977);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/languageHandler.tsx
var languageHandler = __webpack_require__(867614);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/elements/ReplyThread.tsx
var ReplyThread = __webpack_require__(980531);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/HtmlUtils.tsx
var HtmlUtils = __webpack_require__(714813);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/dispatcher/dispatcher.ts
var dispatcher = __webpack_require__(245539);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/dispatcher/actions.ts
var actions = __webpack_require__(473627);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/RightPanelStorePhases.ts
var RightPanelStorePhases = __webpack_require__(274057);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/PermissionStore.ts
var PermissionStore = __webpack_require__(825291);
// EXTERNAL MODULE: ./node_modules/sendingme-ui/dist/index.js
var sendingme_ui_dist = __webpack_require__(602271);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/messages/pinned_message/MImagePinnedBody.tsx
var MImagePinnedBody = __webpack_require__(527750);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/utils/EventUtils.ts
var EventUtils = __webpack_require__(26031);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/messages/pinned_message/MFilePinedBody.tsx
var MFilePinedBody = __webpack_require__(822172);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/messages/pinned_message/MVoicePinnedBody.tsx
var MVoicePinnedBody = __webpack_require__(356326);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/messages/pinned_message/MTextPinnedBody.tsx
var MTextPinnedBody = __webpack_require__(144957);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/rooms/EventTileType.tsx
var EventTileType = __webpack_require__(442025);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/structures/PinnedMsgList.tsx









// import { ReactSVGComponent as PinBox } from "../../../res/img/element-icons/message/pinBox.svg";

const Bar = props => {
  // const style = {
  //     height: `${100 / props.count}%`,
  //     top: `${(props.index / props.count) * 100}%`,
  // };
  return /*#__PURE__*/react.createElement("div", {
    className: "mx_pinned_message_bar"
  }, [...new Array(props.count).keys()].map((item, index) => {
    return /*#__PURE__*/react.createElement("div", {
      className: `mx_pinned_message_bar_item ${index === props.index ? "active" : ""}`
    });
  }));
};
const PinnedMsgList = props => {
  const [index, setIndex] = (0,react.useState)(0);
  const mxEvent = props.msgList[index];
  (0,react.useEffect)(() => {
    props.msgList.length > 0 && setIndex(0);
  }, [props.msgList]);
  return mxEvent ? /*#__PURE__*/react.createElement("div", {
    className: "mx_pinned_message_container"
  }, /*#__PURE__*/react.createElement(Bar, {
    count: props.msgList.length,
    index: index
  }), /*#__PURE__*/react.createElement("div", {
    className: "mx_pinned_message",
    onClick: () => {
      setIndex(v => {
        const res = v + 1 >= props.msgList.length ? 0 : v + 1;
        props.onClick(res);
        return res;
      });
    }
  }, /*#__PURE__*/react.createElement(PinnedMsgItem, {
    mxEvent: mxEvent,
    pindedIndex: index,
    key: mxEvent.getId()
  })), props.onClose ? /*#__PURE__*/react.createElement(sendingme_ui_dist.SdIcon, {
    className: "mx_pinned_message_close",
    icon: "CloseOutlines",
    onClick: () => props.onClose(index)
  }) : null, /*#__PURE__*/react.createElement("div", {
    className: "mx_pinned_message_pinbox",
    onClick: () => props.onShowList()
  })) : null;
};
class PinnedMsgItem extends react.PureComponent {
  render() {
    const {
      mxEvent,
      pindedIndex
    } = this.props;
    const msgtypeOverrides = {
      [_types_event/* MsgType */.Zw.Image]: MImagePinnedBody["default"],
      [_types_event/* MsgType */.Zw.Sticker]: MImagePinnedBody["default"],
      // Override audio and video body with file body. We also hide the download/decrypt button using CSS
      [_types_event/* MsgType */.Zw.Audio]: (0,EventUtils/* isVoiceMessage */.CZ)(mxEvent) ? MVoicePinnedBody["default"] : MFilePinedBody["default"],
      [_types_event/* MsgType */.Zw.Video]: MImagePinnedBody["default"],
      [_types_event/* MsgType */.Zw.File]: MFilePinedBody["default"],
      [_types_event/* MsgType */.Zw.Text]: MTextPinnedBody["default"]
    };
    const evOverrides = {
      // Use MImageReplyBody so that the sticker isn't taking up a lot of space
      [_types_event/* EventType */.tw.Sticker]: MImagePinnedBody["default"],
      [_types_event/* EventType */.tw.RoomAnnouncement]: MTextPinnedBody["default"]
    };
    const {
      tileHandler,
      isInfoMessage
    } = (0,EventUtils/* getEventDisplayInfo */.UL)(mxEvent);
    // This shouldn't happen: the caller should check we support this type
    // before trying to instantiate us
    if (!tileHandler) {
      console.warn(`Event type not supported: type:${mxEvent.getType()} isState:${mxEvent.isState()}`);
      return /*#__PURE__*/react.createElement("div", {
        className: "mx_ReplyTile mx_ReplyTile_info mx_MNoticeBody"
      }, (0,languageHandler._t)("This event could not be displayed"));
    }

    // const EventTileType = sdk.getComponent(tileHandler);
    return /*#__PURE__*/react.createElement(EventTileType/* default */.Z, {
      messageType: tileHandler,
      mxEvent: mxEvent,
      showUrlPreview: false,
      overrideBodyTypes: msgtypeOverrides,
      overrideEventTypes: evOverrides,
      replacingEventId: mxEvent.replacingEventId(),
      maxImageHeight: 96,
      pindedIndex: pindedIndex,
      onHeightChanged: () => {}
    });
  }
}
/* harmony default export */ const structures_PinnedMsgList = ({});
// EXTERNAL MODULE: ./node_modules/ahooks/lib/index.js
var lib = __webpack_require__(924737);
// EXTERNAL MODULE: ./node_modules/classnames/index.js
var classnames = __webpack_require__(294184);
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);
// EXTERNAL MODULE: ./node_modules/lodash-es/last.js
var last = __webpack_require__(200935);
// EXTERNAL MODULE: ./node_modules/antd/lib/index.js
var antd_lib = __webpack_require__(769215);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/MatrixClientPeg.ts + 3 modules
var MatrixClientPeg = __webpack_require__(933393);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/utils/permalinks/Permalinks.ts
var Permalinks = __webpack_require__(954105);
// EXTERNAL MODULE: ./node_modules/html2canvas/dist/html2canvas.js
var html2canvas = __webpack_require__(461120);
var html2canvas_default = /*#__PURE__*/__webpack_require__.n(html2canvas);
// EXTERNAL MODULE: ./node_modules/lodash-es/toArray.js + 1 modules
var toArray = __webpack_require__(994076);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/share/ShareCard.tsx

function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0,defineProperty/* default */.Z)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }





const ShareCard = props => {
  const {
    wrapClassName,
    backgroundStyle,
    width,
    height,
    updateSummarCardUrl,
    children
  } = props;
  const ref = (0,react.useRef)(null);
  const client = (0,react.useContext)(MatrixClientContext/* default */.Z);
  const [startDraw, setStartDraw] = (0,react.useState)(false);
  const wrapStyle = _objectSpread(_objectSpread({}, backgroundStyle), {}, {
    width: `${width}px`,
    height: `${height}px`
  });
  (0,react.useEffect)(() => {
    const imgs = ref.current.querySelectorAll("img");
    const len = imgs.length;
    let successCount = 0;
    if (len === 0) {
      setStartDraw(true);
    } else {
      (0,toArray/* default */.Z)(imgs).forEach(img => {
        img.onload = () => {
          successCount++;
          if (successCount === len) {
            setStartDraw(true);
          }
        };
      });
    }
  }, []);
  (0,react.useEffect)(() => {
    if (startDraw) {
      html2canvas_default()(ref.current).then(canvas => {
        canvas.toBlob(async blob => {
          const url = await client.uploadContent(blob, {
            downloadType: 0
          });
          updateSummarCardUrl === null || updateSummarCardUrl === void 0 ? void 0 : updateSummarCardUrl(url);
        }, "image/webp");
      });
    }
  }, [startDraw]);
  return /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(["mx_ShareCard", wrapClassName]),
    style: wrapStyle,
    ref: ref
  }, children);
};
/* harmony default export */ const share_ShareCard = (/*#__PURE__*/(0,react.memo)(ShareCard));
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/utils/avatar.ts
var avatar = __webpack_require__(9266);
// EXTERNAL MODULE: ./node_modules/lodash-es/isNumber.js
var isNumber = __webpack_require__(400290);
// EXTERNAL MODULE: ./node_modules/dayjs/dayjs.min.js
var dayjs_min = __webpack_require__(727484);
var dayjs_min_default = /*#__PURE__*/__webpack_require__.n(dayjs_min);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/structures/StereoButton.tsx
var StereoButton = __webpack_require__(274184);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/elements/Spinner.tsx
var Spinner = __webpack_require__(641542);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/activity/EventShare2X.tsx

function EventShare2X_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function EventShare2X_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? EventShare2X_ownKeys(Object(t), !0).forEach(function (r) { (0,defineProperty/* default */.Z)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : EventShare2X_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }














/* harmony default export */ const EventShare2X = (/*#__PURE__*/(0,react.memo)(function EventShare2X(props) {
  const {
    room,
    previewData,
    open,
    onFinish
  } = props;
  const title = previewData["og:title"];
  const host = previewData["og:host:name"];
  const hostAvatar = previewData["og:host:avatar"];
  const date = previewData["og:date"];
  const weekday = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
  const [sending, setSending] = (0,react.useState)(false);
  const [loading, setLoading] = (0,react.useState)(true);
  const [summaryCardUrl, setSummaryCardUrl] = (0,react.useState)();
  const client = (0,react.useContext)(MatrixClientContext/* default */.Z);
  const summaryCardBgUrl = __webpack_require__(705947);
  const avatarBg = __webpack_require__(112092);
  const shareUrl = new URL((0,Permalinks/* shareRoomPermalink */.U7)(room.roomId));
  const imgProxyUrl = location.origin === "https://chat.sending.me" ? "https://chat.sending.me" : "https://chat-alpha.sending.me";
  const shareHost = shareUrl.origin === "https://chat.sending.me" ? "https://dapp.sending.me" : "https://dapp-alpha.sending.me";
  const twitterContent = [`I'm attending an online event with @${host} on the topic of #${title}`, `Live on SendingMe - the most interesting Web3 AMA club.\n`].join("\n");
  const link = `${shareHost}/share${shareUrl.search}&domain=${shareUrl.host}`;
  const onSend = (0,react.useCallback)(async () => {
    if (sending) {
      return;
    }
    try {
      setSending(true);
      await client.updateSdnRoomToSdm(EventShare2X_objectSpread(EventShare2X_objectSpread({}, room.getSdnRoomSummary({
        getDefaultAvatar: avatar/* getDefaultAvatar */.W
      })), {}, {
        summary_card_url: summaryCardUrl
      }));
      setSending(false);
      onFinish();
      setTimeout(() => {
        window.open(`https://twitter.com/intent/tweet?url=${encodeURIComponent(link)}&text=${encodeURIComponent(twitterContent)}`, "_blank");
      }, 300);
    } catch {
      sendingme_ui_dist.SdMessage.error("send twitter error!");
      setSending(false);
    }
  }, [summaryCardUrl, sending]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(share_ShareCard, {
    backgroundStyle: {
      background: `url(${summaryCardBgUrl}) no-repeat center/100%`
    },
    width: 625,
    height: 329,
    wrapClassName: "mx_ShareCard_event",
    updateSummarCardUrl: setSummaryCardUrl
  }, /*#__PURE__*/react.createElement("h2", {
    className: "event-title"
  }, title), /*#__PURE__*/react.createElement("div", {
    className: "event-host"
  }, /*#__PURE__*/react.createElement("div", {
    className: "event-host-avatar-wrapper",
    style: {
      background: `url(${avatarBg}) no-repeat center/100%`
    }
  }, /*#__PURE__*/react.createElement("img", {
    src: `${imgProxyUrl}/imageUrl/?url=${hostAvatar}`,
    className: "event-host-avatar"
  })), /*#__PURE__*/react.createElement("span", {
    className: "event-host-name"
  }, host), /*#__PURE__*/react.createElement("span", {
    className: "event-host-tag"
  }, "Host")), /*#__PURE__*/react.createElement("div", {
    className: "event-date"
  }, (0,isNumber/* default */.Z)(date) ? dayjs_min_default()(date).format(`MMM D, E, hh:mm A UTC Z`).replace("E", weekday[+dayjs_min_default()(date).get("d")]) : date)), /*#__PURE__*/react.createElement(antd_lib.Modal, {
    open: open,
    footer: null,
    onCancel: onFinish
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_PostX"
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_PostX_title"
  }, (0,languageHandler._t)("Post to X")), /*#__PURE__*/react.createElement("div", {
    className: "mx_PostX_tw"
  }, /*#__PURE__*/react.createElement("p", null, "I'm attending an online event with @davis on the topic of #", title), /*#__PURE__*/react.createElement("p", null, "Live on SendingMe - the most interesting Web3 AMA club."), /*#__PURE__*/react.createElement("div", {
    style: {
      position: "relative",
      minHeight: "150px"
    }
  }, loading && /*#__PURE__*/react.createElement(Spinner/* default */.Z, {
    message: "Creating the share summary card..."
  }), /*#__PURE__*/react.createElement("img", {
    src: summaryCardUrl,
    onLoad: () => setLoading(false),
    className: "mx_PostX_summaryaCard"
  }))), /*#__PURE__*/react.createElement(StereoButton/* default */.Z, {
    className: classnames_default()(["mx_PostX_btn", {
      mx_PostX_disabled: sending
    }]),
    onClick: onSend
  }, /*#__PURE__*/react.createElement("div", {
    style: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center"
    }
  }, sending && /*#__PURE__*/react.createElement(Spinner/* default */.Z, {
    w: 26,
    h: 26
  }), (0,languageHandler._t)("Post to X(twitter）"))))));
}));
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/activity/EventTwitter.tsx










const EventTwitter = /*#__PURE__*/(0,react.memo)(props => {
  const {
    room,
    previewData
  } = props;
  const title = previewData["og:title"];
  const host = previewData["og:host:name"];
  const url = previewData["og:url"];
  const count = previewData["og:participant:count"];
  const spaceId = (0,last/* default */.Z)(new URL(url).pathname.split("/"));
  const [playingId, setPlayingId] = (0,react.useState)();
  const [isPlaying, setIsPlaying] = (0,react.useState)(false);
  const [open, setOpen] = (0,react.useState)(false);
  const onPlay = (0,react.useCallback)(async () => {
    const client = MatrixClientPeg/* MatrixClientPeg */.p.get();
    if (spaceId !== playingId) {
      client.getTwitterSpace(spaceId).then(res => {
        if (res !== null && res !== void 0 && res.source) {
          dispatcher/* default */.ZP.dispatch({
            action: "twitter_space_play",
            playerParams: {
              title,
              host,
              count,
              url,
              streamParams: res,
              room
            }
          });
        }
      }).catch(err => {});
    } else {
      if (isPlaying) {
        dispatcher/* default */.ZP.dispatch({
          action: "twitter_space_audio_pause",
          spaceId
        });
      } else if (!isPlaying) {
        dispatcher/* default */.ZP.dispatch({
          action: "twitter_space_audio_play",
          spaceId
        });
      }
    }
    const preview = await client.getUrlPreview(url, Date.now());
    dispatcher/* default */.ZP.dispatch({
      action: actions/* Action */.a.SetRightPanelPhase,
      phase: RightPanelStorePhases/* RightPanelPhases */.q4.XSpace,
      refireParams: {
        params: {
          preview,
          xSpaceUrl: url,
          roomId: room.roomId,
          xSpaceId: spaceId
        }
      }
    });
  }, [playingId, isPlaying]);
  (0,react.useEffect)(() => {
    const onAction = payload => {
      if (payload.action === "twitter_space_play") {
        if (spaceId !== (payload === null || payload === void 0 ? void 0 : payload.spaceId)) {
          setIsPlaying(false);
        }
      } else if (payload.action === "twitter_space_audio_play") {
        if (spaceId === (payload === null || payload === void 0 ? void 0 : payload.spaceId)) {
          setIsPlaying(true);
        }
      } else if (payload.action === "twitter_space_audio_pause") {
        if (spaceId === (payload === null || payload === void 0 ? void 0 : payload.spaceId)) {
          setIsPlaying(false);
        }
      }
      setPlayingId(payload === null || payload === void 0 ? void 0 : payload.spaceId);
    };
    const id = dispatcher/* default */.ZP.register(onAction);
    return () => {
      dispatcher/* default */.ZP.unregister(id);
      setIsPlaying(false);
      setPlayingId("");
    };
  }, []);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("div", {
    className: "mx_EventPin_Twitter"
  }, /*#__PURE__*/react.createElement("div", {
    onClick: onPlay,
    className: classnames_default()({
      "icon-play": !isPlaying,
      "icon-pause": isPlaying
    })
  }), /*#__PURE__*/react.createElement("div", {
    className: "mx_EventPin_content"
  }, /*#__PURE__*/react.createElement("div", {
    className: "event-title"
  }, /*#__PURE__*/react.createElement("span", {
    className: "title"
  }, title)), /*#__PURE__*/react.createElement("div", {
    className: "event-desc"
  }, host && /*#__PURE__*/react.createElement("div", null, host, /*#__PURE__*/react.createElement(antd_lib.Tag, {
    color: "rgba(255,255,255,0.2)",
    style: {
      marginLeft: "10px",
      lineHeight: "18px"
    }
  }, "Host")), count && /*#__PURE__*/react.createElement(react.Fragment, null, "|", /*#__PURE__*/react.createElement("div", null, count, " listened")))), /*#__PURE__*/react.createElement("span", {
    className: "icon-share",
    onClick: () => setOpen(true)
  })), /*#__PURE__*/react.createElement(EventShare2X, {
    room: room,
    previewData: previewData,
    open: open,
    onFinish: () => setOpen(false)
  }));
});
/* harmony default export */ const activity_EventTwitter = (EventTwitter);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/activity/zoom_view/util.ts
var util = __webpack_require__(781373);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/activity/EventZoom.tsx




const EventZoom = /*#__PURE__*/(0,react.memo)(props => {
  const {
    previewData
  } = props;
  const title = previewData["og:title"];
  const host = previewData["og:host:name"];
  const url = previewData["og:url"];
  const count = previewData["og:participant:count"];
  const _onJoinMeeting = () => {
    (0,util/* onJoinMeeting */.hW)(url);
  };
  return /*#__PURE__*/react.createElement("div", {
    className: "mx_EventPin_Zoom"
  }, /*#__PURE__*/react.createElement("div", {
    className: "icon-zoom"
  }), /*#__PURE__*/react.createElement("div", {
    className: "mx_EventPin_content"
  }, /*#__PURE__*/react.createElement("div", {
    className: "event-title"
  }, /*#__PURE__*/react.createElement("span", {
    className: "icon-live"
  }), /*#__PURE__*/react.createElement("span", {
    className: "title"
  }, title), /*#__PURE__*/react.createElement("span", {
    role: "button",
    className: "btn-join",
    onClick: _onJoinMeeting
  }, "Join")), /*#__PURE__*/react.createElement("div", {
    className: "event-desc"
  }, host && /*#__PURE__*/react.createElement("div", null, host, /*#__PURE__*/react.createElement(antd_lib.Tag, {
    color: "rgba(255,255,255,0.2)",
    style: {
      marginLeft: "10px",
      lineHeight: "18px"
    }
  }, "Host")), count && /*#__PURE__*/react.createElement(react.Fragment, null, "|", /*#__PURE__*/react.createElement("div", null, count, " listened")))));
});
/* harmony default export */ const activity_EventZoom = (EventZoom);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/activity/EventLive.tsx




/* harmony default export */ const EventLive = (/*#__PURE__*/(0,react.memo)(function EventLive(props) {
  const {
    room,
    previewData
  } = props;
  const title = previewData["og:title"];
  const host = previewData["og:host:name"];
  const hostAvatar = previewData["og:host:avatar"];
  const roomUrl = previewData["og:url"];
  const count = previewData["og:participant:count"];
  const joinHandler = e => {
    e.stopPropagation();
    const url = new URL(roomUrl);
    const roomId = url.hash.replace(/^#\/room\//, "");
    if (roomId === room.roomId) {
      dispatcher/* default */.ZP.dispatch({
        action: "show_live_view",
        roomId: room.roomId
      });
    } else {
      dispatcher/* default */.ZP.dispatch({
        action: "view_room",
        room_id: roomId
      });
    }
  };
  return /*#__PURE__*/react.createElement("div", {
    className: "mx_EventPin_Live",
    onClick: joinHandler
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_EventPin_Live_hostAvatar"
  }, /*#__PURE__*/react.createElement("img", {
    src: hostAvatar
  }), /*#__PURE__*/react.createElement("span", {
    className: "circle-1"
  }), /*#__PURE__*/react.createElement("span", {
    className: "circle-2"
  }), /*#__PURE__*/react.createElement("span", {
    className: "circle-3"
  })), /*#__PURE__*/react.createElement("div", {
    className: "mx_EventPin_content"
  }, /*#__PURE__*/react.createElement("div", {
    className: "event-title"
  }, /*#__PURE__*/react.createElement("span", {
    className: "title"
  }, title)), /*#__PURE__*/react.createElement("div", {
    className: "event-desc"
  }, host && /*#__PURE__*/react.createElement("div", null, host, /*#__PURE__*/react.createElement(antd_lib.Tag, {
    color: "rgba(255,255,255,0.2)",
    style: {
      marginLeft: "10px",
      lineHeight: "18px"
    }
  }, "Host")), count && /*#__PURE__*/react.createElement(react.Fragment, null, "|", /*#__PURE__*/react.createElement("div", null, count, " in this Space")))), /*#__PURE__*/react.createElement(sendingme_ui_dist.SdIcon, {
    icon: "AdduserOutlines",
    role: "button",
    className: "mx_EventPin_Live_join"
  }));
}));
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/activity/zoom_view/meetingConf.ts
var meetingConf = __webpack_require__(855905);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/activity/EventTool.tsx









/* harmony default export */ const EventTool = (/*#__PURE__*/(0,react.memo)(function EventTool(props) {
  const {
    room
  } = props;
  const unPin = async e => {
    e.stopPropagation();
    const sure = await (0,dist.confirm)({
      content: (0,languageHandler._t)("Unpin this Event from top"),
      cancelText: (0,languageHandler._t)("Cancel"),
      okText: (0,languageHandler._t)("Unpin"),
      container: document.getElementsByClassName("mx_RoomView_body")[0]
    });
    if (sure) {
      var _pinnedEvents$getCont;
      const pinnedEvents = room.currentState.getStateEvents(_types_event/* EventType */.tw.RoomPinnedActivity, "");
      if (pinnedEvents !== null && pinnedEvents !== void 0 && (_pinnedEvents$getCont = pinnedEvents.getContent()) !== null && _pinnedEvents$getCont !== void 0 && _pinnedEvents$getCont.pinned) {
        await room.client.sendStateEvent(room.roomId, _types_event/* EventType */.tw.RoomPinnedActivity, {}, "");
      }
      localStorage.removeItem(`${meetingConf/* PINNED_EVENT_SHOW */.CJ}_${room.roomId}`);
    }
  };
  const onHidePinnedEvent = e => {
    e.stopPropagation();
    localStorage.setItem(`${meetingConf/* PINNED_EVENT_SHOW */.CJ}_${room.roomId}`, "0");
    dispatcher/* default */.ZP.dispatch({
      action: meetingConf/* PINNED_EVENT_SHOW */.CJ,
      shouldHide: true
    });
  };
  const [canManage] = PermissionStore/* default */.ZP.hasPermission(room.roomId, PermissionStore/* PermissionMap */.$W.RoomManageMessage);
  return /*#__PURE__*/react.createElement("div", {
    className: "mx_EventPin_btns"
  }, canManage ? /*#__PURE__*/react.createElement(sendingme_ui_dist.SdTooltip, {
    placement: "bottom",
    title: /*#__PURE__*/react.createElement("div", {
      className: "mx_EventPin-tooltip-btns"
    }, /*#__PURE__*/react.createElement("span", {
      role: "button",
      onClick: unPin
    }, (0,languageHandler._t)("Unpin")), /*#__PURE__*/react.createElement("span", {
      role: "button",
      onClick: onHidePinnedEvent
    }, (0,languageHandler._t)("Hide")))
  }, /*#__PURE__*/react.createElement("span", {
    className: "icon-close"
  })) : /*#__PURE__*/react.createElement("span", {
    className: "icon-close",
    role: "button",
    onClick: onHidePinnedEvent
  }));
}));
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/activity/WithEvent.tsx










/* harmony default export */ const WithEvent = (/*#__PURE__*/(0,react.memo)(function WithEvent(props) {
  const {
    room,
    previewUrl
  } = props;
  const [shouldHide, setShouldHide] = (0,react.useState)(localStorage.getItem(`${meetingConf/* PINNED_EVENT_SHOW */.CJ}_${room.roomId}`) === "0");
  (0,react.useEffect)(() => {
    const onAction = payload => {
      if (payload.action === meetingConf/* PINNED_EVENT_SHOW */.CJ) {
        if (!payload.shouldHide) {
          localStorage.removeItem(`${meetingConf/* PINNED_EVENT_SHOW */.CJ}_${room.roomId}`);
        }
        setShouldHide(payload.shouldHide);
      }
    };
    const id = dispatcher/* default */.ZP.register(onAction);
    return () => {
      dispatcher/* default */.ZP.unregister(id);
    };
  }, []);
  const {
    loading,
    data
  } = (0,lib.useRequest)(() => room.client.getUrlPreview(previewUrl, Date.now()), {
    refreshDeps: [previewUrl]
  });
  const eventType = (0,util/* getActivityEventType */.g1)(previewUrl);
  if (shouldHide || !(data !== null && data !== void 0 && data["og:url"])) {
    return null;
  }
  if (loading) {
    return /*#__PURE__*/react.createElement(sendingme_ui_dist.SdSkeleton.SimpleList, {
      active: true,
      rows: 1
    });
  }
  let eventElem = null;
  let containerStyle = {};
  if (eventType === "AMA" || eventType === "twitterSpace") {
    eventElem = /*#__PURE__*/react.createElement(activity_EventTwitter, {
      previewData: data,
      room: room
    });
  } else if (eventType === "ZOOM") {
    eventElem = /*#__PURE__*/react.createElement(activity_EventZoom, {
      previewData: data
    });
  } else if (eventType === "LIVE") {
    eventElem = /*#__PURE__*/react.createElement(EventLive, {
      previewData: data,
      room: room
    });
    // containerStyle = {
    //     background: "linear-gradient(90deg, #C847E8 0%, #C847E8 100%)",
    //     boxShadow: "0px 10px 15px 0px rgba(141, 21, 171, 0.4)",
    // };
  }

  return /*#__PURE__*/react.createElement("div", {
    className: "mx_EventPin_Container",
    style: containerStyle
  }, eventElem, /*#__PURE__*/react.createElement(EventTool, {
    room: room
  }));
}));
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/structures/PinnedMsgBar.tsx

function PinnedMsgBar_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function PinnedMsgBar_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? PinnedMsgBar_ownKeys(Object(t), !0).forEach(function (r) { (0,defineProperty/* default */.Z)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : PinnedMsgBar_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }




















const PinnedMsgBar = props => {
  const cli = (0,react.useContext)(MatrixClientContext/* default */.Z);
  const pinnedEvents = (0,PinnedMessagesCard/* usePinnedEvents */.Rq)(props.room, cli);
  const [canUnpin] = PermissionStore/* default */.ZP.hasPermission(props.room.roomId, [PermissionStore/* PermissionMap */.$W.RoomManageMessage]);
  const onUnpinClicked = async event => {
    sendingme_ui_dist.SdModal.createDialog({
      title: (0,languageHandler._t)("Confirm Unpin"),
      cancelText: (0,languageHandler._t)("Cancel"),
      okText: (0,languageHandler._t)("Unpin"),
      children: /*#__PURE__*/react.createElement("span", null, (0,languageHandler._t)("Unpin this message from top")),
      closable: false,
      onOk: async close => {
        try {
          var _pinnedEvents$getCont;
          const pinnedEvents = props.room.currentState.getStateEvents(_types_event/* EventType */.tw.RoomPinnedEvents, "");
          if (pinnedEvents !== null && pinnedEvents !== void 0 && (_pinnedEvents$getCont = pinnedEvents.getContent()) !== null && _pinnedEvents$getCont !== void 0 && _pinnedEvents$getCont.pinned) {
            const pinned = pinnedEvents.getContent().pinned;
            const index = pinned.indexOf(event === null || event === void 0 ? void 0 : event.getId());
            if (index !== -1) {
              pinned.splice(index, 1);
              await cli.sendStateEvent(props.room.roomId, _types_event/* EventType */.tw.RoomPinnedEvents, {
                pinned
              }, "");
            }
          }
          close === null || close === void 0 ? void 0 : close();
        } catch (err) {
          console.log(err);
          close === null || close === void 0 ? void 0 : close();
        }
      }
    });
  };
  const showList = () => {
    dispatcher/* default */.ZP.dispatch({
      action: actions/* Action */.a.SetRightPanelPhase,
      phase: RightPanelStorePhases/* RightPanelPhases */.q4.PinnedMessages,
      allowClose: false
    });
  };
  const msgs = (0,react.useMemo)(() => {
    var _pinnedEvents$filter;
    return pinnedEvents === null || pinnedEvents === void 0 ? void 0 : (_pinnedEvents$filter = pinnedEvents.filter(event => event)) === null || _pinnedEvents$filter === void 0 ? void 0 : _pinnedEvents$filter.sort((a, b) => (b === null || b === void 0 ? void 0 : b.getTs()) - (a === null || a === void 0 ? void 0 : a.getTs())).map(event => {
      const sender = getDisplayNameFromEvent(event, cli) + " ";
      return PinnedMsgBar_objectSpread(PinnedMsgBar_objectSpread({}, getContentOfMsg(event)), {}, {
        sender
      });
    });
  }, [cli, pinnedEvents]);
  const focusMsg = index => {
    var _pinnedEvents$filter2;
    const event = pinnedEvents === null || pinnedEvents === void 0 ? void 0 : (_pinnedEvents$filter2 = pinnedEvents.filter(event => event)) === null || _pinnedEvents$filter2 === void 0 ? void 0 : _pinnedEvents$filter2.sort((a, b) => (b === null || b === void 0 ? void 0 : b.getTs()) - (a === null || a === void 0 ? void 0 : a.getTs()))[index];
    if (event) {
      dispatcher/* default */.ZP.dispatch({
        action: "view_room",
        event_id: event.getId(),
        highlighted: true,
        room_id: event.getRoomId()
      });
    }
  };
  if (!pinnedEvents || pinnedEvents.length === 0) {
    return null;
  }
  return (
    /*#__PURE__*/
    // <MessageList
    //     msgList={msgs}
    //     onClick={focusMsg}
    //     onClose={
    //         canUnpin
    //             ? (index) => onUnpinClicked(pinnedEvents[index])
    //             : void 0
    //     }
    //     onShowList={showList}
    //     _t={_t}
    // />
    react.createElement(PinnedMsgList, {
      msgList: pinnedEvents,
      onClick: focusMsg,
      onClose: canUnpin ? index => onUnpinClicked(pinnedEvents[index]) : void 0,
      onShowList: showList
    })
  );
};
const initActivityState = {
  pinned: "",
  title: "",
  date: "",
  host: "",
  hostAvatar: "",
  activityType: "",
  previewLink: "",
  url: "",
  count: 0
};
const PinnedContainer = props => {
  var _props$room$currentSt;
  const cli = (0,react.useContext)(MatrixClientContext/* default */.Z);
  const [activityState, setActivityState] = (0,react.useState)(((_props$room$currentSt = props.room.currentState.getStateEvents(_types_event/* EventType */.tw.RoomPinnedActivity, "")) === null || _props$room$currentSt === void 0 ? void 0 : _props$room$currentSt.getContent()) || initActivityState);
  const pinnedEvents = (0,PinnedMessagesCard/* usePinnedEvents */.Rq)(props.room, cli);
  (0,react.useEffect)(() => {
    const onEventsAction = event => {
      if (event.getType() === _types_event/* EventType */.tw.RoomPinnedActivity && event.getRoomId() === props.room.roomId) {
        setActivityState(event.getContent() || initActivityState);
      }
    };
    props.room.client.on("RoomState.events", onEventsAction);
    return () => {
      props.room.client.off("RoomState.events", onEventsAction);
    };
  }, []);
  if ((!pinnedEvents || pinnedEvents.length === 0) && !activityState.pinned) {
    return null;
  }
  return /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(props.className, {
      mx_PinnedContainer: true
    })
  }, /*#__PURE__*/react.createElement(PinnedMsgBar, {
    room: props.room
  }), activityState.pinned && /*#__PURE__*/react.createElement(WithEvent, {
    room: props.room,
    previewUrl: activityState.previewLink || activityState.url
  }));
};
const getContentOfMsg = event => {
  var _event$getContent, _event$getContent$inf;
  const {
    msgtype,
    body,
    format,
    formatted_body: formattedBody
  } = event.getContent();
  let content = body;
  let tag = "";
  let icon = "";
  const mRelatesTo = event.getWireContent()["m.relates_to"];
  if (mRelatesTo && mRelatesTo["m.in_reply_to"]) {
    tag = (0,languageHandler._t)("Reply");
    const hasHtml = format === "org.matrix.custom.html" && formattedBody;
    if (hasHtml) {
      content = (0,HtmlUtils/* getHtmlText */.JS)((ReplyThread/* default */.Z.stripHTMLReply(formattedBody) || "").trim());
    } else {
      content = (ReplyThread/* default */.Z.stripPlainReply(content) || "").trim();
    }
    if (!content) {
      content = "";
    }
  }
  if (event.getWireContent()["m.forward"]) {
    tag = (0,languageHandler._t)("Forward message");
    content = "";
  }
  if (event.getType() === _types_event/* EventType */.tw.PollStart || event.getType() === _types_event/* EventType */.tw.PollEnd) {
    var _event$getContent$eve;
    tag = (0,languageHandler._t)("Poll");
    content = ((_event$getContent$eve = event.getContent()[event.getType()]) === null || _event$getContent$eve === void 0 ? void 0 : _event$getContent$eve.question["m.text"]) || "";
    icon = "📊";
  }
  if (event.getType() === _types_event/* EventType */.tw.RoomAnnouncement) {
    var _event$getContent$ann;
    tag = (0,languageHandler._t)("Room Notice");
    content = (0,FormattingUtils/* parseHtmlString */.PS)((_event$getContent$ann = event.getContent()["announcement"]) === null || _event$getContent$ann === void 0 ? void 0 : _event$getContent$ann.content) || "";
    icon = "📢";
  }
  switch (msgtype) {
    case _types_event/* MsgType */.Zw.Card:
      {
        try {
          const tagMap = {
            [dist.MsgHandler.token]: (0,languageHandler._t)("Crypto"),
            [dist.MsgHandler.nft]: (0,languageHandler._t)("NFT")
          };
          const {
            handler,
            props
          } = JSON.parse(body);
          tag = tagMap[handler];
          content = handler === dist.MsgHandler.token ? props.symbol : "";
        } catch (error) {
          content = "";
        }
      }
      break;
    case _types_event/* MsgType */.Zw.Audio:
      tag = (0,languageHandler._t)("Voice");
      content = content ? (0,FormattingUtils/* formatFileName */.y4)(content) : "";
      icon = "🎤";
      break;
    case _types_event/* MsgType */.Zw.File:
      tag = (0,languageHandler._t)("File");
      content = (0,FormattingUtils/* formatFileName */.y4)(content || (0,languageHandler._t)("Attachment"));
      icon = "📂";
      break;
    case _types_event/* MsgType */.Zw.Video:
      tag = (0,languageHandler._t)("Video");
      content = content ? (0,FormattingUtils/* formatFileName */.y4)(content) : "";
      icon = "🎞️";
      break;
    case _types_event/* MsgType */.Zw.Image:
      tag = (0,languageHandler._t)("Image");
      content = content ? (0,FormattingUtils/* formatFileName */.y4)(content) : "";
      icon = "🖼️";
      break;
    case _types_event/* MsgType */.Zw.Sticker:
      tag = "";
      content = "Sticker";
      icon = (_event$getContent = event.getContent()) === null || _event$getContent === void 0 ? void 0 : (_event$getContent$inf = _event$getContent.info) === null || _event$getContent$inf === void 0 ? void 0 : _event$getContent$inf.emoji;
      break;
    default:
      break;
  }
  return {
    content,
    tag,
    icon
  };
};
const getContentOfCard = event => {
  const {
    msgtype,
    body
  } = event.getContent();
  if (msgtype === _types_event/* MsgType */.Zw.Card) {
    try {
      const {
        props,
        handler
      } = JSON.parse(body);
      if (handler === dist.MsgHandler.token) {
        return props.slug || "";
      }
    } catch (error) {
      return "";
    }
  }
  return "";
};
const getDisplayNameFromEvent = (event, cli, ignoreRemarkName) => {
  var _RemarkStore$get$getR;
  const userId = event === null || event === void 0 ? void 0 : event.getSender();
  let nickName = "";
  let rawDisplayName = "";
  if (event.sender) {
    nickName = event.sender.nickName;
    rawDisplayName = event.sender.rawDisplayName;
  } else {
    var _cli$getUser;
    rawDisplayName = (_cli$getUser = cli.getUser(userId)) === null || _cli$getUser === void 0 ? void 0 : _cli$getUser.displayName;
  }
  const remarkName = ignoreRemarkName ? "" : (_RemarkStore$get$getR = browser_index/* RemarkStore */.Tq.get().getRemarkMap()[userId]) === null || _RemarkStore$get$getR === void 0 ? void 0 : _RemarkStore$get$getR.name;
  const sender = remarkName || nickName || rawDisplayName || (0,strings/* getDisplayUserId */.RL)(userId);
  return sender;
};
/* harmony default export */ const structures_PinnedMsgBar = ((/* unused pure expression or super */ null && (PinnedMsgBar)));

/***/ }),

/***/ 285243:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Z: () => (/* binding */ RightPanel)
});

// UNUSED EXPORTS: isLocalWalletAddress

// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/node_modules/@babel/runtime/helpers/esm/extends.js
var esm_extends = __webpack_require__(166644);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/node_modules/@babel/runtime/helpers/esm/defineProperty.js
var defineProperty = __webpack_require__(225259);
// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(667294);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/dispatcher/dispatcher.ts
var dispatcher = __webpack_require__(245539);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/GroupStore.js
var GroupStore = __webpack_require__(152118);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/RightPanelStorePhases.ts
var RightPanelStorePhases = __webpack_require__(274057);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/RightPanelStore.ts
var RightPanelStore = __webpack_require__(652458);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/contexts/MatrixClientContext.ts
var MatrixClientContext = __webpack_require__(311878);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/dispatcher/actions.ts
var actions = __webpack_require__(473627);
// EXTERNAL MODULE: ./node_modules/classnames/index.js
var classnames = __webpack_require__(294184);
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/hooks/useIsEncrypted.ts
var useIsEncrypted = __webpack_require__(48653);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/right_panel/BaseCard.tsx
var BaseCard = __webpack_require__(554219);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/languageHandler.tsx
var languageHandler = __webpack_require__(867614);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/avatars/RoomAvatar.tsx
var RoomAvatar = __webpack_require__(139319);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/elements/AccessibleButton.tsx
var elements_AccessibleButton = __webpack_require__(805035);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/elements/RoomName.tsx
var RoomName = __webpack_require__(75865);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/structures/FilePanel.tsx
var FilePanel = __webpack_require__(617691);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/SdkConfig.ts
var SdkConfig = __webpack_require__(374312);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/RoomInvite.tsx + 1 modules
var RoomInvite = __webpack_require__(106579);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/MatrixClientPeg.ts + 3 modules
var MatrixClientPeg = __webpack_require__(933393);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/utils/replaceableComponent.ts
var replaceableComponent = __webpack_require__(90287);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/settings/SettingsStore.ts + 9 modules
var SettingsStore = __webpack_require__(571879);
// EXTERNAL MODULE: ./node_modules/matrix-js-sdk/src/models/room-member.ts
var room_member = __webpack_require__(69694);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/elements/TruncatedList.tsx
var TruncatedList = __webpack_require__(953416);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/elements/Spinner.tsx
var Spinner = __webpack_require__(641542);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/structures/SearchBox.tsx
var SearchBox = __webpack_require__(229773);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/rooms/EntityTile.tsx
var EntityTile = __webpack_require__(327629);
// EXTERNAL MODULE: ./node_modules/matrix-js-sdk/src/@types/event.ts
var _types_event = __webpack_require__(907977);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/avatars/MemberAvatar.tsx
var MemberAvatar = __webpack_require__(6156);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/right_panel/UserInfo.tsx + 4 modules
var UserInfo = __webpack_require__(931363);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/utils/strings.ts
var strings = __webpack_require__(653848);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/ContactStore.ts + 1 modules
var stores_ContactStore = __webpack_require__(476979);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/structures/ContextMenu.tsx + 6 modules
var ContextMenu = __webpack_require__(760172);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/context_menus/IconizedContextMenu.tsx
var IconizedContextMenu = __webpack_require__(882385);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/firebase_analytics.ts + 3 modules
var firebase_analytics = __webpack_require__(937139);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/dialogs/ForwardDialog.tsx
var ForwardDialog = __webpack_require__(606510);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/utils/permalinks/Permalinks.ts
var Permalinks = __webpack_require__(954105);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/PermissionStore.ts
var PermissionStore = __webpack_require__(825291);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/utils/commonPointParams.ts
var commonPointParams = __webpack_require__(970698);
// EXTERNAL MODULE: ./node_modules/antd/lib/index.js
var lib = __webpack_require__(769215);
// EXTERNAL MODULE: ./node_modules/ahooks/lib/index.js
var ahooks_lib = __webpack_require__(924737);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/elements/RoleLabel.tsx
var RoleLabel = __webpack_require__(215248);
// EXTERNAL MODULE: ./node_modules/lodash-es/get.js
var get = __webpack_require__(216423);
// EXTERNAL MODULE: ./node_modules/sendingme-ui/dist/index.js
var dist = __webpack_require__(602271);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/right_panel/components/PowerLevelEditorForNewRoom.tsx


function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0,defineProperty/* default */.Z)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }












// import Spinner from "../../elements/Spinner";

const maxAdminCount = 3;
const OWNER_KEY_WORDS = "Owner";
const ADMIN_KEY_WORDS = "SA";
const POWER_LEVEL_EVENT_KEY = "m.room.power_levels";
/**
 * TODO: split this component
 *
 * only on high level room
 *
 * check is it squad/rooms
 * @param param0
 * @returns
 */
const PowerLevelEditorForNewRoom = ({
  member,
  room,
  onClick
}) => {
  var _CurrentRoom$currentS;
  const cli = (0,react.useContext)(MatrixClientContext/* default */.Z);
  const currentUserId = cli.getUserId();
  const [requestLoading, setRequestLoadingState] = (0,react.useState)(false);
  const [position, setPosition] = (0,react.useState)(null);
  const [clickTarget, setClickTargetState] = (0,react.useState)(-1);
  const isGroup = room.isGroup();
  const isDMRoom = room.isDmRoom();
  const isSpaceOrChannel = !isGroup && !isDMRoom;
  const CurrentRoom = isGroup ? room : room.getParentRoom() || room;
  const [_hasMangeRoles] = PermissionStore/* default */.ZP.hasPermission(room.roomId, PermissionStore/* PermissionMap */.$W.SquadManageRole);
  const isHighLevelRole = PermissionStore/* default */.ZP.instance.comparePermissionLevel(CurrentRoom.roomId, member.userId, currentUserId);
  const groupRoles = CurrentRoom.getRoleMembers();
  const admin = (0,get/* default */.Z)(groupRoles, ADMIN_KEY_WORDS, []);
  const isTargetUserAdmin = admin.some(id => id === member.userId);
  const isFullOrAlreadyAdmin = admin.length === maxAdminCount || isTargetUserAdmin;
  const groupOptionList = [{
    label: `${(0,languageHandler._t)("Admin")} (${admin.length}/${maxAdminCount})`,
    level: "100",
    className: classnames_default()({
      mx_UserInfo_RolesButton_context_menu_item: true,
      role_100: true,
      disable: isFullOrAlreadyAdmin || requestLoading
    }),
    disable: isFullOrAlreadyAdmin || requestLoading
  }, {
    label: (0,languageHandler._t)("Member"),
    level: "0",
    className: classnames_default()({
      mx_UserInfo_RolesButton_context_menu_item: true,
      disable: !isTargetUserAdmin || requestLoading
    }),
    disable: !isTargetUserAdmin || requestLoading
  }];
  const {
    role_bindings = {}
  } = ((_CurrentRoom$currentS = CurrentRoom.currentState.getStateEvents(POWER_LEVEL_EVENT_KEY, "")) === null || _CurrentRoom$currentS === void 0 ? void 0 : _CurrentRoom$currentS.getContent()) || {};
  const isUserOwner = (0,get/* default */.Z)(role_bindings, OWNER_KEY_WORDS, []).find(userId => userId === currentUserId);
  const fullRoleLists = CurrentRoom.getRoles().filter(role => (role === null || role === void 0 ? void 0 : role.id) !== "Member");
  const currentUserPermissionKeys = Object.keys(role_bindings).filter(key => role_bindings[key].some(id => id === currentUserId));
  const [highLevelPowerKey] = fullRoleLists.filter(role => currentUserPermissionKeys.some(key => key === (role === null || role === void 0 ? void 0 : role.id))) || [];
  const getLevelIndexOfRoleList = fullRoleLists.findIndex(item => item.id === (highLevelPowerKey === null || highLevelPowerKey === void 0 ? void 0 : highLevelPowerKey.id));
  const channelRoles = isUserOwner ? fullRoleLists : fullRoleLists.slice(getLevelIndexOfRoleList + 1);
  const [channelRolesMember, setChannelRolesMemberState] = (0,react.useState)(cli.getRoom(CurrentRoom.roomId).getRoleMembers());
  const shouldDisplayRolesOption = (0,react.useMemo)(() => {
    var _room$getParentRoom;
    const roomOwner = room.hasSpaceParent() ? (_room$getParentRoom = room.getParentRoom()) === null || _room$getParentRoom === void 0 ? void 0 : _room$getParentRoom.getOwner() : room.getOwner();
    const isTargetSquadOwner = member.userId === roomOwner;
    const isMeSquadOwner = room.myUserId === roomOwner;
    if (isGroup && isMeSquadOwner) {
      return true;
    }
    if (isSpaceOrChannel && _hasMangeRoles && isHighLevelRole && !isTargetSquadOwner && Boolean(channelRoles.length)) {
      return true;
    }
    return false;
  }, [room, member, isGroup, isSpaceOrChannel, _hasMangeRoles, isHighLevelRole, channelRoles]);
  const onGroupPowerChange = async powerLevelStr => {
    try {
      setRequestLoadingState(true);
      const groupRoles = room.getRoleMembers();
      const admin = (0,get/* default */.Z)(groupRoles, ADMIN_KEY_WORDS, []);
      const roleBindings = room.getRoleMembers();
      const powerLevelEvent = room.currentState.getStateEvents(POWER_LEVEL_EVENT_KEY, "");
      const admins = powerLevelStr === "100" ? [...admin, member.userId] : admin.filter(id => id !== member.userId);
      roleBindings[ADMIN_KEY_WORDS] = admins;
      await cli.setRoomRoleToUsers(room.roomId, roleBindings, powerLevelEvent);
      dist.SdMessage.success("Successful");
    } catch (error) {
      dist.SdMessage.error("Filed");
    } finally {
      setRequestLoadingState(false);
      setPosition(null);
      setClickTargetState(-1);
      onClick === null || onClick === void 0 ? void 0 : onClick();
    }
  };
  const openContextMenu = e => {
    const {
      left,
      top
    } = e.currentTarget.getBoundingClientRect();
    setPosition({
      left: left - 120,
      top
    });
  };
  const handleGroupPowerLevelOptionSelected = (level, index) => async () => {
    try {
      setClickTargetState(index);
      if (isGroup) {
        if (level == 100) {
          if (isFullOrAlreadyAdmin) {
            return;
          }
          await onGroupPowerChange("100");
        } else {
          if (!isTargetUserAdmin) {
            return;
          }
          await onGroupPowerChange("0");
        }
      }
    } catch {
      // pass
    }
  };
  const sendUpdateChannelRequest = (0,ahooks_lib.useDebounceFn)(async (role, index) => {
    try {
      setClickTargetState(index);
      setRequestLoadingState(true);
      if (isSpaceOrChannel) {
        const roleMembers = _objectSpread({}, cli.getRoom(CurrentRoom.roomId).getRoleMembers()) || {};
        const powerLevelEvent = CurrentRoom.currentState.getStateEvents("m.room.power_levels", "");
        const currentRolesList = roleMembers[role.id] || [];
        const hasUser = currentRolesList.some(item => item === member.userId);
        const finallyList = hasUser ? currentRolesList.filter(item => item !== member.userId) : [...currentRolesList, member.userId];
        if (finallyList.length === 0) {
          delete roleMembers[role.id];
        } else {
          roleMembers[role.id] = finallyList;
        }
        await cli.setRoomRoleToUsers(CurrentRoom.roomId, roleMembers, powerLevelEvent);
        roleMembers[role.id] = finallyList;
        setChannelRolesMemberState(roleMembers);
        dist.SdMessage.success("Successful");
      }
    } catch {
      // pass
      dist.SdMessage.error("Failed");
    } finally {
      setRequestLoadingState(false);
      setClickTargetState(-1);
      // setPosition(null);
      // onClick?.();
    }
  }, {
    wait: 200
  });
  const handleSelectRoleInChannel = (role, index) => () => sendUpdateChannelRequest.run(role, index);

  // only work on normal group / squad channel
  if (!shouldDisplayRolesOption) {
    return null;
  }
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(IconizedContextMenu/* IconizedContextMenuOption */.$k, null, /*#__PURE__*/react.createElement(elements_AccessibleButton/* default */.Z, {
    className: "mx_UserInfo_field mx_UserInfo_RolesButton",
    onClick: openContextMenu
  }, (0,languageHandler._t)("Roles"), /*#__PURE__*/react.createElement(RoleLabel/* default */.Z, {
    room: room,
    member: member
  }))), position && isGroup && Boolean(groupOptionList.length) && /*#__PURE__*/react.createElement(IconizedContextMenu/* default */.ZP, (0,esm_extends/* default */.Z)({
    className: "mx_UserInfo_RolesButton_context_menu_wrapper",
    onFinished: () => setPosition(null)
  }, position), /*#__PURE__*/react.createElement("div", {
    className: "mx_UserInfo_RolesButton_context_menu"
  }, groupOptionList.map((option, index) => /*#__PURE__*/react.createElement("div", {
    key: option.label,
    className: option.className,
    onClick: handleGroupPowerLevelOptionSelected(option.level, index)
  }, option.label)))), position && isSpaceOrChannel && /*#__PURE__*/react.createElement(IconizedContextMenu/* default */.ZP, (0,esm_extends/* default */.Z)({
    className: "mx_UserInfo_RolesButton_context_menu_wrapper",
    onFinished: () => setPosition(null)
  }, position), /*#__PURE__*/react.createElement("div", {
    className: "mx_UserInfo_RolesButton_context_menu"
  }, channelRoles.map((item, index) => {
    var _channelRolesMember, _channelRolesMember$s;
    return /*#__PURE__*/react.createElement("div", {
      key: item.id,
      className: classnames_default()({
        mx_UserInfo_RolesButton_context_menu_item: true,
        disable: requestLoading
      }),
      style: {
        color: item.color
      },
      onClick: handleSelectRoleInChannel(item, index)
    }, item.name, /*#__PURE__*/react.createElement("div", {
      style: {
        flex: "1"
      }
    }), /*#__PURE__*/react.createElement(lib.Checkbox, {
      checked: (_channelRolesMember = channelRolesMember[item.id]) === null || _channelRolesMember === void 0 ? void 0 : (_channelRolesMember$s = _channelRolesMember.some) === null || _channelRolesMember$s === void 0 ? void 0 : _channelRolesMember$s.call(_channelRolesMember, id => id === member.userId)
    }));
  }))));
};
/* harmony default export */ const components_PowerLevelEditorForNewRoom = (PowerLevelEditorForNewRoom);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/right_panel/components/PowerLevelEditor.tsx
var PowerLevelEditor = __webpack_require__(937901);
// EXTERNAL MODULE: ./node_modules/matrix-js-sdk/src/@types/user.ts
var user = __webpack_require__(650540);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/right_panel/RoomMemberOperations.tsx


function RoomMemberOperations_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function RoomMemberOperations_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? RoomMemberOperations_ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : RoomMemberOperations_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }





















const MessageButton = ({
  member,
  onContextMenu,
  onClick,
  isColleage
}) => {
  const cli = (0,react.useContext)(MatrixClientContext/* default */.Z);
  const [busy, setBusy] = (0,react.useState)(false);
  const room = cli.getRoom(member.roomId);
  return /*#__PURE__*/react.createElement(IconizedContextMenu/* IconizedContextMenuOption */.$k, null, /*#__PURE__*/react.createElement(elements_AccessibleButton/* default */.Z, {
    onContextMenu: onContextMenu,
    onClick: async ev => {
      if (busy) return;
      setBusy(true);
      if (isColleage) {
        var _room$getParentRoom;
        await (0,UserInfo/* openDMForUser */.Oz)({
          userId: member.userId,
          squadId: room !== null && room !== void 0 && room.isSpaceRoom() ? room.roomId : room !== null && room !== void 0 && room.getParentRoom() ? (_room$getParentRoom = room.getParentRoom()) === null || _room$getParentRoom === void 0 ? void 0 : _room$getParentRoom.roomId : "",
          isJump: true,
          showRoomTile: false,
          directMessage: true
        });
      } else {
        await (0,UserInfo/* openDMForUser */.Oz)({
          userId: member.userId
        });
      }
      setBusy(false);
      onClick(ev);
    },
    className: "mx_UserInfo_field",
    disabled: busy
  }, (0,languageHandler._t)("Message")));
};
const UserProfileButton = ({
  member,
  onContextMenu,
  onClick
}) => {
  const [busy, setBusy] = (0,react.useState)(false);
  return /*#__PURE__*/react.createElement(IconizedContextMenu/* IconizedContextMenuOption */.$k, null, /*#__PURE__*/react.createElement(elements_AccessibleButton/* default */.Z, {
    onContextMenu: onContextMenu,
    onClick: async ev => {
      if (busy) return;
      setBusy(true);
      dispatcher/* default */.ZP.dispatch({
        action: actions/* Action */.a.SetRightPanelPhase,
        phase: RightPanelStorePhases/* RightPanelPhases */.q4.UserProfile,
        refireParams: {
          member
        }
      });
      setBusy(false);
      onClick(ev);
    },
    className: "mx_UserInfo_field",
    disabled: busy
  }, (0,languageHandler._t)("Profile")));
};
const NickNameEditButton = props => {
  const handleClick = (0,react.useCallback)(() => {
    props.onClick();
    // if (props.room.isSpaceRoom()) {
    //     showSpaceSettings(props.room);
    //     return;
    // }
    // dis.dispatch({
    //     action: "open_room_settings",
    //     room_id: props.room.roomId,
    // });
    dispatcher/* default */.ZP.dispatch({
      action: actions/* Action */.a.SetRightPanelPhase,
      phase: RightPanelStorePhases/* RightPanelPhases */.q4.EditNickname,
      refireParams: {
        params: {
          userId: props.member.userId,
          room: props.room
        }
      }
    });
  }, [props]);
  if (props.room.isDmRoom()) {
    return null;
  }
  return /*#__PURE__*/react.createElement(IconizedContextMenu/* IconizedContextMenuOption */.$k, null, /*#__PURE__*/react.createElement(elements_AccessibleButton/* default */.Z, {
    className: "mx_UserInfo_field",
    onClick: handleClick
  }, (0,languageHandler._t)("Edit member's Alias")));
};
const ContactButton = ({
  member,
  onContextMenu,
  onClick
}) => {
  const [busy, setBusy] = useState(false);
  const [isContact, setIsContact] = useState(false);
  useEffect(() => {
    const changeContact = async () => {
      const flag = await ContactStore.instance.isFavorite(member.userId);
      setIsContact(flag);
    };
    changeContact();
    ContactStore.instance.on(CONTACT_UPDATE_EVENT, changeContact);
    return () => {
      ContactStore.instance.off(CONTACT_UPDATE_EVENT, changeContact);
    };
  }, [member.userId]);
  return /*#__PURE__*/React.createElement(IconizedContextMenuOption, null, /*#__PURE__*/React.createElement(AccessibleButton, {
    onContextMenu: onContextMenu,
    onClick: async ev => {
      if (busy) return;
      setBusy(true);
      if (!isContact) {
        //done firebase : contact_add
        logEvent(analytics, "contact_add", RoomMemberOperations_objectSpread(RoomMemberOperations_objectSpread({}, getCommonPointParams()), {}, {
          contact_add_user_Id: member.userId,
          contact_add_room_Id: member.roomId.split(":")[0],
          is_room: false
        }));
        try {
          await ContactStore.instance.addFavourite(member.userId, true);
          await openDMForUser({
            userId: member.userId,
            isJump: false
          });
          // done firebase : contact_add_success
          logEvent(analytics, "contact_add_success", RoomMemberOperations_objectSpread(RoomMemberOperations_objectSpread({}, getCommonPointParams()), {}, {
            contact_add_user_Id: member.userId,
            contact_add_room_Id: member.roomId.split(":")[0],
            is_room: false
          }));
        } catch (err) {
          // done firebase : contact_add_failed
          logEvent(analytics, "contact_add_failed", RoomMemberOperations_objectSpread(RoomMemberOperations_objectSpread({}, getCommonPointParams()), {}, {
            contact_add_user_Id: member.userId,
            contact_add_room_Id: member.roomId.split(":")[0],
            is_room: false,
            error_code: err.httpStatus || err.errcode || 0,
            error_reason: err.name || err.message || err.stack
          }));
        }
      } else {
        // done firebase : contact_cancel
        logEvent(analytics, "contact_cancel", RoomMemberOperations_objectSpread(RoomMemberOperations_objectSpread({}, getCommonPointParams()), {}, {
          contact_cancel_user_Id: member.userId,
          contact_cancel_room_Id: member.roomId.split(":")[0],
          is_room: false
        }));
        try {
          await ContactStore.instance.removeFavourite(member.userId, true);
          // done firebase : contact_cancel_success
          logEvent(analytics, "contact_cancel_success", RoomMemberOperations_objectSpread(RoomMemberOperations_objectSpread({}, getCommonPointParams()), {}, {
            contact_cancel_user_Id: member.userId,
            contact_cancel_room_Id: member.roomId.split(":")[0],
            is_room: false
          }));
        } catch (err) {
          // done firebase : contact_cancel_failed
          logEvent(analytics, "contact_cancel_failed", RoomMemberOperations_objectSpread(RoomMemberOperations_objectSpread({}, getCommonPointParams()), {}, {
            contact_cancel_user_Id: member.userId,
            contact_cancel_room_Id: member.roomId.split(":")[0],
            is_room: false,
            error_code: err.httpStatus || err.errcode || 0,
            error_reason: err.name || err.message || err.stack
          }));
        }
      }
      setBusy(false);
      onClick(ev);
    },
    className: "mx_UserInfo_field",
    disabled: busy
  }, _t(isContact ? "Remove Contact" : "Add Contact")));
};
const MentionButton = ({
  member,
  onContextMenu,
  onClick
}) => {
  const onInsertPillButton = function (ev) {
    dispatcher/* default */.ZP.dispatch({
      action: actions/* Action */.a.ComposerInsert,
      userId: member.userId
    });
    onClick(ev);
  };
  return /*#__PURE__*/react.createElement(IconizedContextMenu/* IconizedContextMenuOption */.$k, null, /*#__PURE__*/react.createElement(elements_AccessibleButton/* default */.Z, {
    onContextMenu: onContextMenu,
    onClick: onInsertPillButton,
    className: "mx_UserInfo_field"
  }, (0,languageHandler._t)("Mention")));
};
const ShareUserButton = ({
  member,
  onContextMenu,
  onClick
}) => {
  const onShareUserClick = ev => {
    var _creds;
    (0,ForwardDialog/* showForwardDialogWithContent */.H2)({
      msgtype: member.userId === MatrixClientPeg/* MatrixClientPeg */.p.get().getUserId() ? "me" : "user",
      body: (0,Permalinks/* shareUserPermalink */.G3)(member.userId)
    }, "share");
    onClick(ev);
    let creds;
    try {
      creds = JSON.parse(localStorage.getItem("mx_Homeserver_Creds"));
    } catch {}
    const avatar = member.getMxcAvatarUrl();
    MatrixClientPeg/* MatrixClientPeg */.p.get().updateSdnUserToSdm({
      user_id: member.userId,
      display_name: member.rawDisplayName,
      wallet_address: member.walletAddress,
      avatar: avatar ? `${member.getMxcAvatarUrl()}?access_token=${(_creds = creds) === null || _creds === void 0 ? void 0 : _creds.accessToken}` : "",
      ens: !!member.ens,
      source: "web"
    });
  };
  return /*#__PURE__*/react.createElement(IconizedContextMenu/* IconizedContextMenuOption */.$k, null, /*#__PURE__*/react.createElement(elements_AccessibleButton/* default */.Z, {
    onContextMenu: onContextMenu,
    onClick: onShareUserClick,
    className: "mx_UserInfo_field"
  }, (0,languageHandler._t)("Share contact to")));
};
const IgnoreButton = ({
  member,
  onClick
}) => {
  // Check whether the user is ignored
  const cli = (0,react.useContext)(MatrixClientContext/* default */.Z);
  const [isIgnored, setIsIgnored] = (0,react.useState)(cli.isUserIgnored(member.userId));
  // Recheck if the user or client changes
  (0,react.useEffect)(() => {
    setIsIgnored(cli.isUserIgnored(member.userId));
  }, [cli, member.userId]);
  const onIgnoreToggle = ev => {
    const ignoredUsers = cli.getIgnoredUsers();
    if (isIgnored) {
      const index = ignoredUsers.indexOf(member.userId);
      if (index !== -1) ignoredUsers.splice(index, 1);
    } else {
      ignoredUsers.push(member.userId);
    }
    cli.setIgnoredUsers(ignoredUsers);
    onClick(ev);
  };
  return /*#__PURE__*/react.createElement(IconizedContextMenu/* IconizedContextMenuOption */.$k, null, /*#__PURE__*/react.createElement(elements_AccessibleButton/* default */.Z, {
    className: classnames_default()("mx_UserInfo_field", {
      mx_IconizedContextMenu_red: !isIgnored
    }),
    onClick: onIgnoreToggle
  }, isIgnored ? (0,languageHandler._t)("Unblock") : (0,languageHandler._t)("Block")));
};
const RoomMemberOperations = props => {
  const {
    member,
    generalMenuPosition,
    roomId
  } = props;
  const cli = (0,react.useContext)(MatrixClientContext/* default */.Z);
  const room = cli.getRoom(roomId);
  const powerLevels = (0,UserInfo/* useRoomPowerLevels */.nE)(cli, room);
  const isMe = member.userId === cli.getUserId();
  const [pendingUpdateCount, setPendingUpdateCount] = (0,react.useState)(0);
  // use for low version room
  const roomPermissions = (0,UserInfo/* useRoomPermissions */.B9)(cli, room, member);
  const startUpdating = (0,react.useCallback)(() => {
    setPendingUpdateCount(pendingUpdateCount + 1);
  }, [pendingUpdateCount]);
  const stopUpdating = (0,react.useCallback)(() => {
    setPendingUpdateCount(pendingUpdateCount - 1);
  }, [pendingUpdateCount]);
  const contextMenuBelow = elementRect => {
    // align the context menu's icons with the icon which opened the context menu
    const left = elementRect.left + window.pageXOffset - 200;
    const top = elementRect.bottom + window.pageYOffset;
    const chevronFace = ContextMenu/* ChevronFace */.N7.None;
    return {
      left,
      top,
      chevronFace
    };
  };
  const roomVersion = room.getVersion();
  const canEdit = () => {
    const [canManage] = PermissionStore/* default */.ZP.hasPermission(roomId, PermissionStore/* PermissionMap */.$W.UserManageNickname);
    const [canChange] = PermissionStore/* default */.ZP.hasPermission(roomId, PermissionStore/* PermissionMap */.$W.UserChangeNickname);
    if (room.getOwner() === cli.getUserId()) {
      return true;
    }
    if (room.isGroup()) {
      return canManage || isMe && canChange;
    }
    if (room.isSpaceRoom() || room.hasSpaceParent()) {
      if (isMe) {
        return canChange;
      }
      return PermissionStore/* default */.ZP.instance.comparePermissionLevel(roomId, member.userId) && canManage;
    }
  };
  const userShip = stores_ContactStore["default"].instance.getUserShip(props.member.userId);
  return /*#__PURE__*/react.createElement(IconizedContextMenu/* default */.ZP, (0,esm_extends/* default */.Z)({}, contextMenuBelow(generalMenuPosition), {
    className: "mx_MemberTile_contextMenu",
    onFinished: props.onFinished,
    compact: true
  }), /*#__PURE__*/react.createElement(IconizedContextMenu/* IconizedContextMenuOptionList */.I2, null, !isMe && (userShip.includes(user/* UserShip */.J.Friend) || userShip.includes(user/* UserShip */.J.Colleague)) && /*#__PURE__*/react.createElement(MessageButton, {
    member: member,
    onClick: props.onFinished,
    isColleage: userShip.includes(user/* UserShip */.J.Colleague)
  }), /*#__PURE__*/react.createElement(UserProfileButton, {
    member: member,
    onClick: props.onFinished
  }), !room.isSpaceRoom() && /*#__PURE__*/react.createElement(MentionButton, {
    member: member,
    onClick: props.onFinished
  }), canEdit() && /*#__PURE__*/react.createElement(NickNameEditButton, {
    room: room,
    member: member,
    onClick: props.onFinished
  }), userShip.includes(user/* UserShip */.J.Friend) || userShip.includes(user/* UserShip */.J.Colleague) ? /*#__PURE__*/react.createElement(ShareUserButton, {
    member: member,
    onClick: props.onFinished
  }) : null, +roomVersion < 100 ? /*#__PURE__*/react.createElement(PowerLevelEditor/* default */.Z, {
    user: member,
    room: room,
    roomPermissions: roomPermissions,
    asContextMenu: true
  }) : /*#__PURE__*/react.createElement(components_PowerLevelEditorForNewRoom, {
    member: member,
    room: room,
    roomPermissions: roomPermissions,
    onClick: props.onFinished
  })), /*#__PURE__*/react.createElement(IconizedContextMenu/* IconizedContextMenuOptionList */.I2, {
    red: true
  }, !isMe && /*#__PURE__*/react.createElement(IgnoreButton, {
    member: member,
    onClick: props.onFinished
  })), /*#__PURE__*/react.createElement(IconizedContextMenu/* IconizedContextMenuOptionList */.I2, {
    red: true
  }, /*#__PURE__*/react.createElement(UserInfo/* RoomAdminToolsContainer */.Rk, {
    onlyButtons: true,
    room: room,
    member: member
    // hasKick={hasKick}
    // hasBan={hasBan}
    // hasMute={hasMute}
    ,
    powerLevels: powerLevels,
    startUpdating: startUpdating,
    stopUpdating: stopUpdating,
    onFinished: props.onFinished
  })));
};
/* harmony default export */ const right_panel_RoomMemberOperations = (RoomMemberOperations);
// EXTERNAL MODULE: ./node_modules/@hiseas/react/dist/index.js
var react_dist = __webpack_require__(989638);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/OpenseaStore.ts
var OpenseaStore = __webpack_require__(683043);
// EXTERNAL MODULE: ./node_modules/matrix-js-sdk/src/browser-index.js
var browser_index = __webpack_require__(407637);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/ProfileCardStore.ts
var ProfileCardStore = __webpack_require__(33523);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/lib/util.ts
var util = __webpack_require__(25654);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/settings/ProfileCardSettings.tsx
var ProfileCardSettings = __webpack_require__(158737);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/rooms/MemberTile.tsx


var _dec, _class, _class2;
function MemberTile_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function MemberTile_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? MemberTile_ownKeys(Object(t), !0).forEach(function (r) { (0,defineProperty/* default */.Z)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : MemberTile_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
/*
Copyright 2015, 2016 OpenMarket Ltd
Copyright 2019, 2020 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/


























let MemberTile = (_dec = (0,replaceableComponent/* replaceableComponent */.U)("views.rooms.MemberTile"), _dec(_class = (_class2 = class MemberTile extends react.Component {
  constructor(props) {
    super(props);
    (0,defineProperty/* default */.Z)(this, "userLastModifiedTime", void 0);
    (0,defineProperty/* default */.Z)(this, "memberLastModifiedTime", void 0);
    (0,defineProperty/* default */.Z)(this, "onRoomStateEvents", ev => {
      if (ev.getType() !== _types_event/* EventType */.tw.RoomEncryption) return;
      const {
        roomId
      } = this.props.member;
      if (ev.getRoomId() !== roomId) return;

      // The room is encrypted now.
      const cli = MatrixClientPeg/* MatrixClientPeg */.p.get();
      cli.removeListener("RoomState.events", this.onRoomStateEvents);
      this.setState({
        isRoomEncrypted: true
      });
      this.updateE2EStatus();
    });
    (0,defineProperty/* default */.Z)(this, "onUpdateMemberNickname", ev => {
      if (ev.getType() === _types_event/* EventType */.tw.RoomNicknameList) {
        var _ev$getContent, _nicknameMap$this$pro;
        // MatrixClientPeg.get().getRoomUserNickName(this.props.roomId);
        const nicknameMap = (_ev$getContent = ev.getContent()) === null || _ev$getContent === void 0 ? void 0 : _ev$getContent.nickname_list;
        const nickname = nicknameMap === null || nicknameMap === void 0 ? void 0 : (_nicknameMap$this$pro = nicknameMap[this.props.member.userId]) === null || _nicknameMap$this$pro === void 0 ? void 0 : _nicknameMap$this$pro.nickname;
        if (nickname) {
          this.forceUpdate();
        }
      }
    });
    (0,defineProperty/* default */.Z)(this, "onUserTrustStatusChanged", (userId, trustStatus) => {
      if (userId !== this.props.member.userId) return;
      this.updateE2EStatus();
    });
    (0,defineProperty/* default */.Z)(this, "onDeviceVerificationChanged", (userId, deviceId, deviceInfo) => {
      if (userId !== this.props.member.userId) return;
      this.updateE2EStatus();
    });
    (0,defineProperty/* default */.Z)(this, "onStatusMessageCommitted", () => {
      // The `User` object has observed a status message change.
      this.setState({
        statusMessage: this.getStatusMessage()
      });
    });
    (0,defineProperty/* default */.Z)(this, "onContextMenu", ev => {
      // If we don't have a context menu to show, ignore the action.
      if (!this.showContextMenu) return;
      ev.preventDefault();
      ev.stopPropagation();
      this.setState({
        generalMenuPosition: {
          left: ev.clientX,
          bottom: ev.clientY
        }
      });
    });
    (0,defineProperty/* default */.Z)(this, "onHideMenus", () => {
      this.setState({
        generalMenuPosition: null
      });
    });
    (0,defineProperty/* default */.Z)(this, "showUserProfileMenu", ev => {
      const element = ev.target;
      const {
        left,
        top
      } = element.getBoundingClientRect();
      this.setState({
        userProfileMenuPosition: {
          left: left - 320,
          top: top
        }
      });
    });
    (0,defineProperty/* default */.Z)(this, "hideUserProfileMenu", () => {
      this.setState({
        userProfileMenuPosition: null
      });
    });
    (0,defineProperty/* default */.Z)(this, "onClick", e => {
      if (e.target.matches(".mx_EntityTile")) {
        this.onContextMenu(e);
      } else if (e.target.matches(".mx_EntityTile_avatar .mx_BaseAvatar_image")) {
        this.state.userProfileMenuPosition ? this.hideUserProfileMenu() : this.showUserProfileMenu(e);
      } else {
        // dis.dispatch({
        //     action: Action.ViewUser,
        //     member: this.props.member,
        // });
        dispatcher/* default */.ZP.dispatch({
          action: actions/* Action */.a.SetRightPanelPhase,
          phase: RightPanelStorePhases/* RightPanelPhases */.q4.UserProfile,
          refireParams: {
            member: this.props.member
          }
        });
      }
    });
    (0,defineProperty/* default */.Z)(this, "onMessage", () => {
      (0,UserInfo/* openDMForUser */.Oz)({
        userId: this.props.member.userId
      });
    });
    this.state = {
      statusMessage: this.getStatusMessage(),
      isRoomEncrypted: false,
      e2eStatus: null,
      generalMenuPosition: null,
      userProfileMenuPosition: null
    };
  }
  componentDidMount() {
    const cli = MatrixClientPeg/* MatrixClientPeg */.p.get();
    this.fetchProfileInfo();
    if (SettingsStore/* default */.C.getValue("feature_custom_status")) {
      const {
        user
      } = this.props.member;
      if (user) {
        user.on("User._unstable_statusMessage", this.onStatusMessageCommitted);
      }
    }
    const {
      roomId
    } = this.props.member;
    if (roomId) {
      const isRoomEncrypted = cli.isRoomEncrypted(roomId);
      this.setState({
        isRoomEncrypted
      });
      if (isRoomEncrypted) {
        cli.on("userTrustStatusChanged", this.onUserTrustStatusChanged);
        cli.on("deviceVerificationChanged", this.onDeviceVerificationChanged);
        this.updateE2EStatus();
      } else {
        // Listen for room to become encrypted
        cli.on("RoomState.events", this.onRoomStateEvents);
      }
    }
    cli.on("RoomState.events", this.onUpdateMemberNickname);
  }
  componentWillUnmount() {
    const cli = MatrixClientPeg/* MatrixClientPeg */.p.get();
    const {
      user
    } = this.props.member;
    if (user) {
      user.removeListener("User._unstable_statusMessage", this.onStatusMessageCommitted);
    }
    if (cli) {
      cli.removeListener("RoomState.events", this.onRoomStateEvents);
      cli.removeListener("userTrustStatusChanged", this.onUserTrustStatusChanged);
      cli.removeListener("deviceVerificationChanged", this.onDeviceVerificationChanged);
    }
    cli.removeListener("RoomState.events", this.onUpdateMemberNickname);
  }
  getDisplayNickname() {
    var _MatrixClientPeg$get$, _RemarkStore$get$getR2;
    const nickname = (_MatrixClientPeg$get$ = MatrixClientPeg/* MatrixClientPeg */.p.get().getRoom(this.props.roomId)) === null || _MatrixClientPeg$get$ === void 0 ? void 0 : _MatrixClientPeg$get$.getRoomUserNickName(this.props.member.userId);
    const remarkName = (_RemarkStore$get$getR2 = browser_index/* RemarkStore */.Tq.get().getRemarkMap()[this.props.member.userId]) === null || _RemarkStore$get$getR2 === void 0 ? void 0 : _RemarkStore$get$getR2.name;
    return remarkName || nickname || this.getDisplayName();
  }
  async updateE2EStatus() {
    const cli = MatrixClientPeg/* MatrixClientPeg */.p.get();
    const {
      userId
    } = this.props.member;
    const isMe = userId === cli.getUserId();
    const userTrust = cli.checkUserTrust(userId);
    if (!userTrust.isCrossSigningVerified()) {
      this.setState({
        e2eStatus: userTrust.wasCrossSigningVerified() ? "warning" : "normal"
      });
      return;
    }
    const devices = cli.getStoredDevicesForUser(userId);
    const anyDeviceUnverified = devices.some(device => {
      const {
        deviceId
      } = device;
      // For your own devices, we use the stricter check of cross-signing
      // verification to encourage everyone to trust their own devices via
      // cross-signing so that other users can then safely trust you.
      // For other people's devices, the more general verified check that
      // includes locally verified devices can be used.
      const deviceTrust = cli.checkDeviceTrust(userId, deviceId);
      return isMe ? !deviceTrust.isCrossSigningVerified() : !deviceTrust.isVerified();
    });
    this.setState({
      e2eStatus: anyDeviceUnverified ? "warning" : "verified"
    });
  }
  getStatusMessage() {
    const {
      user
    } = this.props.member;
    if (!user) {
      return "";
    }
    return user.unstable_statusMessage;
  }
  shouldComponentUpdate(nextProps, nextState) {
    if (this.memberLastModifiedTime === undefined || this.memberLastModifiedTime < nextProps.member.getLastModifiedTime()) {
      return true;
    }
    if (nextProps.member.user && (this.userLastModifiedTime === undefined || this.userLastModifiedTime < nextProps.member.user.getLastModifiedTime())) {
      return true;
    }
    if (nextState.isRoomEncrypted !== this.state.isRoomEncrypted || nextState.e2eStatus !== this.state.e2eStatus || nextState.generalMenuPosition !== this.state.generalMenuPosition || nextState.userProfileMenuPosition !== this.state.userProfileMenuPosition || nextState.walletAddress !== this.state.walletAddress) {
      return true;
    }
    return false;
  }
  get showContextMenu() {
    return true;
  }
  getDisplayName() {
    return this.props.member.name;
  }
  getPowerLabel() {
    return (0,languageHandler._t)("%(userName)s (power %(powerLevelNumber)s)", {
      userName: this.props.member.userId,
      powerLevelNumber: this.props.member.powerLevel
    });
  }
  fetchProfileInfo() {
    var _this$props$member, _this$props$member$us;
    if (!((_this$props$member = this.props.member) !== null && _this$props$member !== void 0 && (_this$props$member$us = _this$props$member.user) !== null && _this$props$member$us !== void 0 && _this$props$member$us.getWalletAddress())) {
      var _this$props$member2, _this$props$member3, _this$props$member3$u;
      MatrixClientPeg/* MatrixClientPeg */.p.get().getProfileInfo(((_this$props$member2 = this.props.member) === null || _this$props$member2 === void 0 ? void 0 : _this$props$member2.userId) || ((_this$props$member3 = this.props.member) === null || _this$props$member3 === void 0 ? void 0 : (_this$props$member3$u = _this$props$member3.user) === null || _this$props$member3$u === void 0 ? void 0 : _this$props$member3$u.userId)).then(res => {
        if (res.wallet_address) {
          var _this$props$member4, _this$props$member4$u;
          (_this$props$member4 = this.props.member) === null || _this$props$member4 === void 0 ? void 0 : (_this$props$member4$u = _this$props$member4.user) === null || _this$props$member4$u === void 0 ? void 0 : _this$props$member4$u.setWalletAddress(res.wallet_address);
          this.setState({
            walletAddress: res.wallet_address
          });
        }
      });
    } else {
      var _this$props$member5, _this$props$member5$u;
      this.setState({
        walletAddress: (_this$props$member5 = this.props.member) === null || _this$props$member5 === void 0 ? void 0 : (_this$props$member5$u = _this$props$member5.user) === null || _this$props$member5$u === void 0 ? void 0 : _this$props$member5$u.getWalletAddress()
      });
    }
  }
  render() {
    var _member$events$member, _member$events$member2, _member$events$member3, _member$user, _this$state$userProfi, _this$state$userProfi2;
    const member = this.props.member;
    const name = this.getDisplayNickname();
    const presenceState = member.user ? member.user.presence : null;
    // when dm type room could show roles label
    const isDM = MatrixClientPeg/* MatrixClientPeg */.p.get().getRoom(this.props.roomId).isDmRoom();
    const av = /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(MemberAvatar/* default */.Z, {
      member: member,
      size: 44,
      "aria-hidden": "true"
    }));
    if (member.user) {
      this.userLastModifiedTime = member.user.getLastModifiedTime();
    }
    this.memberLastModifiedTime = member.getLastModifiedTime();
    const powerStatusMap = new Map([[100, PowerStatus.Admin], [50, PowerStatus.Moderator]]);

    // Find the nearest power level with a badge
    let powerLevel = this.props.member.powerLevel;
    for (const [pl] of powerStatusMap) {
      if (this.props.member.powerLevel >= pl) {
        powerLevel = pl;
        break;
      }
    }
    const powerStatus = powerStatusMap.get(powerLevel);
    let e2eStatus;
    if (this.state.isRoomEncrypted) {
      e2eStatus = this.state.e2eStatus;
    }
    return /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement(EntityTile/* default */.ZP, (0,esm_extends/* default */.Z)({}, this.props, {
      presenceState: presenceState,
      presenceLastActiveAgo: member.user ? member.user.lastActiveAgo : 0,
      presenceLastTs: member.user ? member.user.lastPresenceTs : 0,
      presenceCurrentlyActive: member.user ? member.user.currentlyActive : false,
      avatarJsx: av,
      title: this.getPowerLabel(),
      name: name,
      ens: member.rawDisplayName === name ? member.ens : member.nickName === name ? (_member$events$member = member.events.member) === null || _member$events$member === void 0 ? void 0 : (_member$events$member2 = _member$events$member.getContent()) === null || _member$events$member2 === void 0 ? void 0 : (_member$events$member3 = _member$events$member2.extended_fields) === null || _member$events$member3 === void 0 ? void 0 : _member$events$member3.ens : 0,
      rawDisplayName: member.rawDisplayName,
      powerStatus: powerStatus,
      showPresence: this.props.showPresence,
      subtextLabel: (0,strings/* getDisplayUserId */.RL)(this.props.member.userId),
      walletAddress: this.state.walletAddress,
      extendedFields: member.extendedFields,
      e2eStatus: e2eStatus,
      onClick: this.onClick,
      showPowerByLabel: !isDM,
      idName: (member === null || member === void 0 ? void 0 : (_member$user = member.user) === null || _member$user === void 0 ? void 0 : _member$user.userId) || (member === null || member === void 0 ? void 0 : member.userId),
      roomId: this.props.roomId,
      member: this.props.member
    })), this.state.generalMenuPosition && /*#__PURE__*/react.createElement(right_panel_RoomMemberOperations, {
      generalMenuPosition: this.state.generalMenuPosition,
      member: this.props.member,
      roomId: this.props.roomId,
      onFinished: this.onHideMenus
    }), this.state.userProfileMenuPosition && /*#__PURE__*/react.createElement(UserProfileMenu, {
      onFinished: this.hideUserProfileMenu,
      left: (_this$state$userProfi = this.state.userProfileMenuPosition) === null || _this$state$userProfi === void 0 ? void 0 : _this$state$userProfi.left,
      top: (_this$state$userProfi2 = this.state.userProfileMenuPosition) === null || _this$state$userProfi2 === void 0 ? void 0 : _this$state$userProfi2.top,
      member: this.props.member,
      powerStatus: powerStatus,
      presenceState: presenceState,
      onProfileClick: this.onClick,
      onMessageClick: this.onMessage
    }));
  }
}, (0,defineProperty/* default */.Z)(_class2, "defaultProps", {
  showPresence: true
}), _class2)) || _class);

const Badge = props => {
  return /*#__PURE__*/React.createElement("div", {
    className: classNames("mx_Badge", props.className, props.presenceState)
  });
};
let PowerStatus = /*#__PURE__*/function (PowerStatus) {
  PowerStatus["Admin"] = "admin";
  PowerStatus["Moderator"] = "moderator";
  return PowerStatus;
}({});
const PowerLabel = {
  [PowerStatus.Admin]: (0,languageHandler/* _td */.I8)("Admin"),
  [PowerStatus.Moderator]: (0,languageHandler/* _td */.I8)("Mod")
};
const UserProfileMenu = props => {
  var _props$member$events, _props$member$events$4;
  const getUserInfo = (0,react.useCallback)(() => {
    var _props$member, _props$member2, _props$member3, _RemarkStore$get$getR, _props$member$events$;
    let nickName = props.member.nickName;
    if (nickName === ((_props$member = props.member) === null || _props$member === void 0 ? void 0 : _props$member.rawDisplayName) || nickName === ((_props$member2 = props.member) === null || _props$member2 === void 0 ? void 0 : _props$member2.userId)) {
      nickName = "";
    }
    let displayName = (_props$member3 = props.member) === null || _props$member3 === void 0 ? void 0 : _props$member3.rawDisplayName;
    if (displayName === props.member.userId) {
      displayName = "";
    }
    return {
      userId: (0,strings/* getDisplayUserId */.RL)(props.member.userId),
      displayName,
      remarkName: (_RemarkStore$get$getR = browser_index/* RemarkStore */.Tq.get().getRemarkMap()[props.member.userId]) === null || _RemarkStore$get$getR === void 0 ? void 0 : _RemarkStore$get$getR.name,
      nickName,
      avatar: (0,ProfileCardSettings/* avatarUrl */.Qx)((_props$member$events$ = props.member.events.member) === null || _props$member$events$ === void 0 ? void 0 : _props$member$events$.getContent().profile_card_id, 60, props.member.getMxcAvatarUrl()),
      role: PowerLabel[props.powerStatus],
      status: props.presenceState
    };
  }, [props.member, props.powerStatus, props.presenceState]);
  const [userInfo, setUserInfo] = (0,react.useState)(getUserInfo);
  const [userShip, setUserShip] = (0,react.useState)([]);
  (0,react.useEffect)(() => {
    setUserInfo(getUserInfo);
  }, [getUserInfo]);
  (0,react.useEffect)(() => {
    async function getAssets() {
      if (props.member.user) {
        var _props$member$events$2, _props$member$events$3;
        let walletAddress = props.member.user.getWalletAddress();
        let signature = props.member.user.signature;
        if (!walletAddress || !signature) {
          const res = await MatrixClientPeg/* MatrixClientPeg */.p.get().getProfileInfo(props.member.userId);
          walletAddress = res.wallet_address || "";
          signature = res.signature || "";
          props.member.user.setWalletAddress(walletAddress);
          props.member.user.setSignature(signature);
        }
        const profileCardId = (_props$member$events$2 = props.member.events.member) === null || _props$member$events$2 === void 0 ? void 0 : _props$member$events$2.getContent().profile_card_id;
        if (profileCardId) {
          const res = await ProfileCardStore/* ProfileCardStore */.Wv.instance.getCardById(profileCardId);
          signature = (res === null || res === void 0 ? void 0 : res.signature) || signature;
        }
        if (signature) {
          setUserInfo(userInfo => MemberTile_objectSpread(MemberTile_objectSpread({}, userInfo), {}, {
            aboutMe: signature
          }));
        }
        const profileWallet = (_props$member$events$3 = props.member.events.member) === null || _props$member$events$3 === void 0 ? void 0 : _props$member$events$3.getContent().wallet_address;
        if (profileWallet && profileWallet !== walletAddress) {
          setUserInfo(userInfo => MemberTile_objectSpread(MemberTile_objectSpread({}, userInfo), {}, {
            profileWallet: (0,util/* shortStr */.lS)(profileWallet)
          }));
        }
        if (walletAddress) {
          try {
            var _result$value, _result$value$assets, _nfts$value;
            const [result, nfts] = await Promise.allSettled([OpenseaStore/* default */.Z.instance.getAssetsByOwner(walletAddress), OpenseaStore/* default */.Z.instance.getNftsByOwner(walletAddress)]);
            if (result.status === "fulfilled" && (_result$value = result.value) !== null && _result$value !== void 0 && (_result$value$assets = _result$value.assets) !== null && _result$value$assets !== void 0 && _result$value$assets[0]) {
              const {
                assets: [assets]
              } = result.value;
              setUserInfo(userInfo => {
                const asset = MemberTile_objectSpread(MemberTile_objectSpread({}, userInfo.asset), {}, {
                  netWorth: assets.net_worth,
                  tokensWorth: assets.tokens_worth,
                  nftWorth: assets.metrics.est_holding_value_usd
                });
                return MemberTile_objectSpread(MemberTile_objectSpread({}, userInfo), {}, {
                  asset
                });
              });
            }
            if (nfts.status === "fulfilled" && (_nfts$value = nfts.value) !== null && _nfts$value !== void 0 && _nfts$value.nfts) {
              setUserInfo(userInfo => {
                const asset = MemberTile_objectSpread(MemberTile_objectSpread({}, userInfo.asset), {}, {
                  // eslint-disable-next-line camelcase, @typescript-eslint/naming-convention
                  nfts: nfts.value.nfts.map(({
                    image_thumbnail_url
                  }) => image_thumbnail_url)
                });
                return MemberTile_objectSpread(MemberTile_objectSpread({}, userInfo), {}, {
                  asset
                });
              });
            }
          } catch (error) {
            console.error(error);
          }
          setUserInfo(userInfo => MemberTile_objectSpread(MemberTile_objectSpread({}, userInfo), {}, {
            assetLoading: false
          }));
        }
      }
    }
    getAssets();
    setUserInfo(userInfo => MemberTile_objectSpread(MemberTile_objectSpread({}, userInfo), {}, {
      assetLoading: true
    }));
    const userShip = stores_ContactStore["default"].instance.getUserShip(props.member.userId);
    setUserShip(userShip);
  }, [props.member]);
  return /*#__PURE__*/react.createElement(ContextMenu/* ContextMenu */.xV, {
    onFinished: props.onFinished,
    left: isNaN(props.left) ? 0 : props.left,
    top: isNaN(props.top) ? 0 : props.top,
    wrapperClassName: "mx_userProfileMenu",
    key: JSON.stringify(userInfo)
  }, /*#__PURE__*/react.createElement(react_dist.UserProfileContextMenu, {
    user: userInfo,
    nameTag: props.member.ens || (_props$member$events = props.member.events) !== null && _props$member$events !== void 0 && (_props$member$events$4 = _props$member$events.member) !== null && _props$member$events$4 !== void 0 && _props$member$events$4.getContent().ens ? __webpack_require__(107467) : "",
    footer: /*#__PURE__*/react.createElement("div", {
      className: "mx_userProfileMenu_footer"
    }, userShip.includes(user/* UserShip */.J.Friend) || userShip.includes(user/* UserShip */.J.Colleague) ? /*#__PURE__*/react.createElement(elements_AccessibleButton/* default */.Z, {
      kind: "primary",
      onClick: props.onMessageClick
    }, (0,languageHandler._t)("Message")) : null, /*#__PURE__*/react.createElement(elements_AccessibleButton/* default */.Z, {
      kind: "primary_outline",
      onClick: props.onProfileClick
    }, (0,languageHandler._t)("Profile")))
  }));
};
UserProfileMenu.displayName = "UserProfileMenu";
// EXTERNAL MODULE: ./node_modules/lodash-es/throttle.js
var throttle = __webpack_require__(300111);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/SpaceStore.tsx + 2 modules
var SpaceStore = __webpack_require__(387579);
// EXTERNAL MODULE: ./node_modules/matrix-js-sdk/src/@types/partials.ts
var partials = __webpack_require__(85047);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/utils/room/getRoomScene.ts
var getRoomScene = __webpack_require__(827337);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/rooms/MemberList.tsx

var MemberList_dec, MemberList_class;
/*
Copyright 2015, 2016 OpenMarket Ltd
Copyright 2017 Vector Creations Ltd
Copyright 2017, 2018 New Vector Ltd
Copyright 2021 Šimon Brandner <simon.bra.ag@gmail.com>

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

























const getSearchQueryLSKey = roomId => `mx_MemberList_searchQuarry_${roomId}`;
const INITIAL_LOAD_NUM_MEMBERS = 30;
const INITIAL_LOAD_NUM_INVITED = 5;
const SHOW_MORE_INCREMENT = 100;

// Regex applied to filter our punctuation in member names before applying sort, to fuzzy it a little
// matches all ASCII punctuation: !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~
const SORT_REGEX = /[\x21-\x2F\x3A-\x40\x5B-\x60\x7B-\x7E]+/g;
let MemberList = (MemberList_dec = (0,replaceableComponent/* replaceableComponent */.U)("views.rooms.MemberList"), MemberList_dec(MemberList_class = class MemberList extends react.Component {
  // RoomMember -> sortName

  constructor(props) {
    var _enablePresenceByHsUr;
    super(props);
    (0,defineProperty/* default */.Z)(this, "showPresence", true);
    (0,defineProperty/* default */.Z)(this, "mounted", false);
    (0,defineProperty/* default */.Z)(this, "collator", void 0);
    (0,defineProperty/* default */.Z)(this, "sortNames", new Map());
    (0,defineProperty/* default */.Z)(this, "onUserPresenceChange", (event, user) => {
      // Attach a SINGLE listener for global presence changes then locate the
      // member tile and re-render it. This is more efficient than every tile
      // ever attaching their own listener.
      const tile = this.refs[user.userId];
      // console.log(`Got presence update for ${user.userId}. hasTile=${!!tile}`);
      if (tile) {
        this.updateList(); // reorder the membership list
      }
    });
    (0,defineProperty/* default */.Z)(this, "onRoom", room => {
      if (room.roomId !== this.props.roomId) {
        return;
      }
      // We listen for room events because when we accept an invite
      // we need to wait till the room is fully populated with state
      // before refreshing the member list else we get a stale list.
      this.showMembersAccordingToMembershipWithLL();
    });
    (0,defineProperty/* default */.Z)(this, "onMyMembership", (room, membership, oldMembership) => {
      if (room.roomId === this.props.roomId && membership === "join") {
        this.showMembersAccordingToMembershipWithLL();
      }
    });
    (0,defineProperty/* default */.Z)(this, "onRoomStateMember", (ev, state, member) => {
      if (member.roomId !== this.props.roomId) {
        return;
      }
      this.updateList();
    });
    (0,defineProperty/* default */.Z)(this, "onRoomMemberName", (ev, member) => {
      if (member.roomId !== this.props.roomId) {
        return;
      }
      this.updateList();
    });
    (0,defineProperty/* default */.Z)(this, "onRoomStateEvent", (event, state) => {
      if (event.getRoomId() === this.props.roomId && event.getType() === "m.room.third_party_invite") {
        this.updateList();
      }
      if (this.canInvite !== this.state.canInvite) {
        this.setState({
          canInvite: this.canInvite
        });
      }
    });
    (0,defineProperty/* default */.Z)(this, "updateList", (0,throttle/* default */.Z)(() => {
      this.updateListNow();
    }, 500, {
      leading: true,
      trailing: true
    }));
    (0,defineProperty/* default */.Z)(this, "createOverflowTileJoined", (overflowCount, totalCount, ref) => {
      return this.createOverflowTile(overflowCount, totalCount, this.showMoreJoinedMemberList, ref);
    });
    (0,defineProperty/* default */.Z)(this, "createOverflowTileInvited", (overflowCount, totalCount, ref) => {
      return this.createOverflowTile(overflowCount, totalCount, this.showMoreInvitedMemberList, ref);
    });
    (0,defineProperty/* default */.Z)(this, "createOverflowTile", (overflowCount, totalCount, onClick, ref) => {
      // For now we'll pretend this is any entity. It should probably be a separate tile.
      const text = (0,languageHandler._t)("and %(count)s others...", {
        count: overflowCount
      });
      return /*#__PURE__*/react.createElement("div", {
        ref: ref
      }, /*#__PURE__*/react.createElement(EntityTile/* default */.ZP, {
        className: "mx_EntityTile_ellipsis",
        avatarJsx: /*#__PURE__*/react.createElement(dist.SdAvatar, {
          src: __webpack_require__(699521),
          name: "...",
          size: 36
        }),
        name: text,
        presenceState: "online",
        suppressOnHover: true,
        onClick: onClick
      }));
    });
    (0,defineProperty/* default */.Z)(this, "showMoreJoinedMemberList", () => {
      this.setState({
        truncateAtJoined: this.state.truncateAtJoined + SHOW_MORE_INCREMENT
      });
    });
    (0,defineProperty/* default */.Z)(this, "showMoreInvitedMemberList", () => {
      this.setState({
        truncateAtInvited: this.state.truncateAtInvited + SHOW_MORE_INCREMENT
      });
    });
    (0,defineProperty/* default */.Z)(this, "getMemberRole", member => {
      var _room$getVersion;
      const room = MatrixClientPeg/* MatrixClientPeg */.p.get().getRoom(this.props.roomId);
      const squad = room.hasSpaceParent() ? room.getParentRoom() : room;
      const roomVersion = room === null || room === void 0 ? void 0 : (_room$getVersion = room.getVersion) === null || _room$getVersion === void 0 ? void 0 : _room$getVersion.call(room);
      if (!squad) {
        return null;
      }
      let powerLevel;
      if (+roomVersion < 100) {
        powerLevel = room.currentState.getStateEvents(_types_event/* EventType */.tw.RoomPowerLevels, "");
      } else {
        powerLevel = squad.currentState.getStateEvents(_types_event/* EventType */.tw.RoomPowerLevels, "");
      }
      if (powerLevel) {
        return (0,RoleLabel/* getRole */.c)(powerLevel, member, room);
      }
      return null;
    });
    // returns negative if a comes before b,
    // returns 0 if a and b are equivalent in ordering
    // returns positive if a comes after b.
    (0,defineProperty/* default */.Z)(this, "memberSort", members => {
      var _room$getVersion2, _powerLevelEvent;
      const myUserId = MatrixClientPeg/* MatrixClientPeg */.p.get().getUserId();
      const room = MatrixClientPeg/* MatrixClientPeg */.p.get().getRoom(this.props.roomId);
      const squad = room.hasSpaceParent() ? room.getParentRoom() : room;
      const roomVersion = room === null || room === void 0 ? void 0 : (_room$getVersion2 = room.getVersion) === null || _room$getVersion2 === void 0 ? void 0 : _room$getVersion2.call(room);
      let powerLevelEvent;
      if (+roomVersion < 100) {
        powerLevelEvent = room.currentState.getStateEvents(_types_event/* EventType */.tw.RoomPowerLevels, "");
      } else if (squad) {
        powerLevelEvent = squad.currentState.getStateEvents(_types_event/* EventType */.tw.RoomPowerLevels, "");
      }
      const {
        roles = []
      } = ((_powerLevelEvent = powerLevelEvent) === null || _powerLevelEvent === void 0 ? void 0 : _powerLevelEvent.getContent()) || {};
      let map = {};
      var c = "A".charCodeAt(0);
      for (; c <= "Z".charCodeAt(0); c++) {
        map[String.fromCharCode(c)] = [];
      }
      for (let i = 0; i < members.length; i++) {
        const member = members[i];
        const role = member.getRoomMemberRole(room);
        let powerLevel = 0;
        if (role) {
          if (role.id == "owner") {
            powerLevel = 10000;
          } else if (role.id == "SA") {
            powerLevel = 9999;
          } else if (roles) {
            const roleWeight = roles.findIndex(r => r.id === role.id) + 1 || 0;
            powerLevel = 9999 - roleWeight;
          }
        }
        const displayName = this.getDisplayNickname(member);
        const firstCharUpper = (0,util/* getFirstUpperChar */.jG)(displayName);
        let firstCharCode;
        if (map.hasOwnProperty(firstCharUpper)) {
          firstCharCode = firstCharUpper.charCodeAt(0);
        } else {
          firstCharCode = firstCharUpper.charCodeAt(0) + "Z".charCodeAt(0);
        }
        let keyWeight = (powerLevel + 1) * 1000 - firstCharCode;
        if (member.userId === myUserId) {
          keyWeight = Number.MAX_VALUE;
        }
        member.keyWeight = keyWeight;
      }
      members = members.sort((a, b) => b.keyWeight - a.keyWeight);
      return members;
      // order by presence, with "active now" first.
      // ...and then by power level
      // ...and then by last active
      // ...and then alphabetically.
      // We could tiebreak instead by "last recently spoken in this room" if we wanted to.

      // console.log(`Comparing userA=${this.memberString(memberA)} userB=${this.memberString(memberB)}`);

      // const userA = memberA.user;
      // const userB = memberB.user;

      // if (!userA) console.log("!! MISSING USER FOR A-SIDE: " + memberA.name + " !!");
      // if (!userB) console.log("!! MISSING USER FOR B-SIDE: " + memberB.name + " !!");

      // if (!userA && !userB) return 0;
      // if (userA && !userB) return -1;
      // if (!userA && userB) return 1;

      // First by presence
      // if (this.showPresence) {
      //     const convertPresence = (p) => (p === "unavailable" ? "online" : p);
      //     const presenceIndex = (p) => {
      //         const order = ["active", "online", "offline"];
      //         const idx = order.indexOf(convertPresence(p));
      //         return idx === -1 ? order.length : idx; // unknown states at the end
      //     };

      //     const idxA = presenceIndex(
      //         userA.currentlyActive ? "active" : userA.presence
      //     );
      //     const idxB = presenceIndex(
      //         userB.currentlyActive ? "active" : userB.presence
      //     );
      //     // console.log(`userA_presenceGroup=${idxA} userB_presenceGroup=${idxB}`);
      //     if (idxA !== idxB) {
      //         // console.log("Comparing on presence group - returning");
      //         return idxA - idxB;
      //     }
      // }

      // Second by power level
      // if (memberA.powerLevel !== memberB.powerLevel) {
      //     // console.log("Comparing on power level - returning");
      //     return memberB.powerLevel - memberA.powerLevel;
      // }

      // Third by last active
      // if (
      //     this.showPresence &&
      //     userA.getLastActiveTs() !== userB.getLastActiveTs()
      // ) {
      //     // console.log("Comparing on last active timestamp - returning");
      //     return userB.getLastActiveTs() - userA.getLastActiveTs();
      // }

      // Fourth by name (alphabetical)
      // return this.collator.compare(
      //     this.sortNames.get(memberA),
      //     this.sortNames.get(memberB)
      // );
    });
    (0,defineProperty/* default */.Z)(this, "onSearchQueryChanged", searchQuery => {
      try {
        window.localStorage.setItem(getSearchQueryLSKey(this.props.roomId), searchQuery);
      } catch (error) {
        console.warn("Failed to set the last MemberList search query", error);
      }
      this.setState({
        searchQuery,
        filteredJoinedMembers: this.filterMembers(this.state.members, "join", searchQuery),
        filteredInvitedMembers: this.filterMembers(this.state.members, "invite", searchQuery)
      });
    });
    (0,defineProperty/* default */.Z)(this, "onPending3pidInviteClick", inviteEvent => {
      dispatcher/* default */.ZP.dispatch({
        action: "view_3pid_invite",
        event: inviteEvent
      });
    });
    (0,defineProperty/* default */.Z)(this, "getChildrenJoined", (start, end) => {
      return this.makeMemberTiles(this.state.filteredJoinedMembers.slice(start, end));
    });
    (0,defineProperty/* default */.Z)(this, "getChildCountJoined", () => this.state.filteredJoinedMembers.length);
    (0,defineProperty/* default */.Z)(this, "getChildrenInvited", (start, end) => {
      let targets = this.state.filteredInvitedMembers;
      if (end > this.state.filteredInvitedMembers.length) {
        targets = targets.concat(this.getPending3PidInvites());
      }
      return this.makeMemberTiles(targets.slice(start, end));
    });
    (0,defineProperty/* default */.Z)(this, "getChildCountInvited", () => {
      return this.state.filteredInvitedMembers.length + (this.getPending3PidInvites() || []).length;
    });
    (0,defineProperty/* default */.Z)(this, "onInviteButtonClick", () => {
      if (MatrixClientPeg/* MatrixClientPeg */.p.get().isGuest()) {
        dispatcher/* default */.ZP.dispatch({
          action: "require_registration"
        });
        return;
      }

      // call AddressPickerDialog
      dispatcher/* default */.ZP.dispatch({
        action: "view_invite",
        roomId: this.props.roomId
      });
    });
    const cli = MatrixClientPeg/* MatrixClientPeg */.p.get();
    if (cli.hasLazyLoadMembersEnabled()) {
      // show an empty list
      this.state = this.getMembersState([]);
    } else {
      this.state = this.getMembersState(this.roomMembers());
    }
    cli.on("Room", this.onRoom); // invites & joining after peek
    const enablePresenceByHsUrl = SdkConfig/* default */.Z.get()["enable_presence_by_hs_url"];
    const hsUrl = MatrixClientPeg/* MatrixClientPeg */.p.get().baseUrl;
    this.showPresence = (_enablePresenceByHsUr = enablePresenceByHsUrl === null || enablePresenceByHsUrl === void 0 ? void 0 : enablePresenceByHsUrl[hsUrl]) !== null && _enablePresenceByHsUr !== void 0 ? _enablePresenceByHsUr : true;
  }

  // eslint-disable-next-line
  UNSAFE_componentWillMount() {
    const cli = MatrixClientPeg/* MatrixClientPeg */.p.get();
    this.mounted = true;
    if (cli.hasLazyLoadMembersEnabled()) {
      this.showMembersAccordingToMembershipWithLL();
      cli.on("Room.myMembership", this.onMyMembership);
    } else {
      this.listenForMembersChanges();
    }
  }
  listenForMembersChanges() {
    const cli = MatrixClientPeg/* MatrixClientPeg */.p.get();
    cli.on("RoomState.members", this.onRoomStateMember);
    cli.on("RoomMember.name", this.onRoomMemberName);
    cli.on("RoomState.events", this.onRoomStateEvent);
    // We listen for changes to the lastPresenceTs which is essentially
    // listening for all presence events (we display most of not all of
    // the information contained in presence events).
    cli.on("User.lastPresenceTs", this.onUserPresenceChange);
    cli.on("User.presence", this.onUserPresenceChange);
    cli.on("User.currentlyActive", this.onUserPresenceChange);
    // cli.on("Room.timeline", this.onRoomTimeline);
  }

  componentWillUnmount() {
    this.mounted = false;
    const cli = MatrixClientPeg/* MatrixClientPeg */.p.get();
    if (cli) {
      cli.removeListener("RoomState.members", this.onRoomStateMember);
      cli.removeListener("RoomMember.name", this.onRoomMemberName);
      cli.removeListener("Room.myMembership", this.onMyMembership);
      cli.removeListener("RoomState.events", this.onRoomStateEvent);
      cli.removeListener("Room", this.onRoom);
      cli.removeListener("User.lastPresenceTs", this.onUserPresenceChange);
      cli.removeListener("User.presence", this.onUserPresenceChange);
      cli.removeListener("User.currentlyActive", this.onUserPresenceChange);
    }

    // cancel any pending calls to the rate_limited_funcs
    this.updateList.cancel();
  }

  /**
   * If lazy loading is enabled, either:
   * show a spinner and load the members if the user is joined,
   * or show the members available so far if the user is invited
   */
  async showMembersAccordingToMembershipWithLL() {
    const cli = MatrixClientPeg/* MatrixClientPeg */.p.get();
    if (cli.hasLazyLoadMembersEnabled()) {
      const cli = MatrixClientPeg/* MatrixClientPeg */.p.get();
      const room = cli.getRoom(this.props.roomId);
      const membership = room && room.getMyMembership();
      if (membership === "join") {
        this.setState({
          loading: true
        });
        try {
          await room.loopMembersIfNeeded();
        } catch (ex) {
          /* already logged in RoomView */
        }
        if (this.mounted) {
          this.setState(this.getMembersState(this.roomMembers()));
          this.listenForMembersChanges();
        }
      } else {
        // show the members we already have loaded
        this.setState(this.getMembersState(this.roomMembers()));
      }
    }
  }
  get canInvite() {
    var _room$currentState$ge, _room$currentState, _room$currentState$ge2;
    const cli = MatrixClientPeg/* MatrixClientPeg */.p.get();
    const room = cli.getRoom(this.props.roomId);
    const {
      preset
    } = (_room$currentState$ge = room === null || room === void 0 ? void 0 : (_room$currentState = room.currentState) === null || _room$currentState === void 0 ? void 0 : (_room$currentState$ge2 = _room$currentState.getStateEvents("m.room.create", "")) === null || _room$currentState$ge2 === void 0 ? void 0 : _room$currentState$ge2.getContent()) !== null && _room$currentState$ge !== void 0 ? _room$currentState$ge : {};
    return room && room.canInvite(cli.getUserId()) && preset && preset !== partials/* Preset */.Sk.TrustedPrivateChat;
  }
  getMembersState(members) {
    var _searchQuery;
    let searchQuery;
    try {
      searchQuery = window.localStorage.getItem(getSearchQueryLSKey(this.props.roomId));
    } catch (error) {
      console.warn("Failed to get last the MemberList search query", error);
    }

    // set the state after determining showPresence to make sure it's
    // taken into account while rendering
    return {
      loading: false,
      members: members,
      filteredJoinedMembers: this.filterMembers(members, "join", searchQuery),
      filteredInvitedMembers: this.filterMembers(members, "invite", searchQuery),
      canInvite: this.canInvite,
      // ideally we'd size this to the page height, but
      // in practice I find that a little constraining
      truncateAtJoined: INITIAL_LOAD_NUM_MEMBERS,
      truncateAtInvited: INITIAL_LOAD_NUM_INVITED,
      searchQuery: (_searchQuery = searchQuery) !== null && _searchQuery !== void 0 ? _searchQuery : ""
    };
  }
  updateListNow() {
    const members = this.roomMembers();
    this.setState({
      loading: false,
      members: members,
      filteredJoinedMembers: this.filterMembers(members, "join", this.state.searchQuery),
      filteredInvitedMembers: this.filterMembers(members, "invite", this.state.searchQuery)
    });
  }
  getMembersWithUser() {
    if (!this.props.roomId) return [];
    const cli = MatrixClientPeg/* MatrixClientPeg */.p.get();
    const room = cli.getRoom(this.props.roomId);
    if (!room) return [];
    const allMembers = Object.values(room.currentState.members);
    allMembers.forEach(member => {
      // work around a race where you might have a room member object
      // before the user object exists. This may or may not cause
      // https://github.com/vector-im/vector-web/issues/186
      if (!member.user) {
        member.user = cli.getUser(member.userId);
      }
      this.sortNames.set(member, (member.name[0] === "@" ? member.name.substr(1) : member.name).replace(SORT_REGEX, ""));

      // XXX: this user may have no lastPresenceTs value!
      // the right solution here is to fix the race rather than leave it as 0
    });

    return allMembers;
  }
  roomMembers() {
    const allMembers = this.getMembersWithUser();
    let filteredAndSortedMembers = allMembers.filter(m => {
      return m.membership === "join" || m.membership === "invite";
    });
    const language = SettingsStore/* default */.C.getValue("language");
    this.collator = new Intl.Collator(language, {
      sensitivity: "base",
      ignorePunctuation: false
    });
    // filteredAndSortedMembers.sort(this.memberSort);
    filteredAndSortedMembers = this.memberSort(filteredAndSortedMembers);
    return filteredAndSortedMembers;
  }
  /**
   * SHOULD ONLY BE USED BY TESTS
   */
  memberString(member) {
    if (!member) {
      return "(null)";
    } else {
      const u = member.user;
      return "(" + member.name + ", " + member.powerLevel + ", " + (u ? u.lastActiveAgo : "<null>") + ", " + (u ? u.getLastActiveTs() : "<null>") + ", " + (u ? u.currentlyActive : "<null>") + ", " + (u ? u.presence : "<null>") + ")";
    }
  }
  getDisplayNickname(member) {
    var _MatrixClientPeg$get$, _RemarkStore$get$getR;
    const nickname = (_MatrixClientPeg$get$ = MatrixClientPeg/* MatrixClientPeg */.p.get().getRoom(this.props.roomId)) === null || _MatrixClientPeg$get$ === void 0 ? void 0 : _MatrixClientPeg$get$.getRoomUserNickName(member.userId);
    const remarkName = (_RemarkStore$get$getR = browser_index/* RemarkStore */.Tq.get().getRemarkMap()[member.userId]) === null || _RemarkStore$get$getR === void 0 ? void 0 : _RemarkStore$get$getR.name;
    return remarkName || nickname || member.name;
  }
  filterMembers(members, membership, query) {
    const remarkIds = browser_index/* RemarkStore */.Tq.get().getUserIdByRemarkName(query);
    return members.filter(m => {
      if (query) {
        query = query.toLowerCase();
        let address;
        if (query.startsWith("0x")) {
          address = query.substring(2);
        }
        const matchesName = m.name.toLowerCase().includes(query) || m.rawDisplayName.toLowerCase().includes(query);
        const matchesId = m.userId.toLowerCase().includes(query);
        const hasAddress = m.userId.toLowerCase().includes(address);
        if (!matchesName && !matchesId && !hasAddress && !remarkIds.includes(m.userId)) {
          return false;
        }
      }
      return m.membership === membership;
    });
  }
  getPending3PidInvites() {
    // include 3pid invites (m.room.third_party_invite) state events.
    // The HS may have already converted these into m.room.member invites so
    // we shouldn't add them if the 3pid invite state key (token) is in the
    // member invite (content.third_party_invite.signed.token)
    const room = MatrixClientPeg/* MatrixClientPeg */.p.get().getRoom(this.props.roomId);
    if (room) {
      return room.currentState.getStateEvents("m.room.third_party_invite").filter(function (e) {
        if (!(0,RoomInvite/* isValid3pidInvite */.ih)(e)) return false;

        // discard all invites which have a m.room.member event since we've
        // already added them.
        const memberEvent = room.currentState.getInviteForThreePidToken(e.getStateKey());
        if (memberEvent) return false;
        return true;
      });
    }
  }
  makeMemberTiles(members) {
    return members.map(m => {
      if (m instanceof room_member/* RoomMember */.T) {
        // Is a Matrix invite
        return /*#__PURE__*/react.createElement(MemberTile, {
          key: m.userId + m.name,
          member: m,
          roomId: this.props.roomId,
          ref: m.userId,
          showPresence: false
        });
      } else {
        // Is a 3pid invite
        return /*#__PURE__*/react.createElement(EntityTile/* default */.ZP, {
          key: m.getStateKey(),
          name: m.getContent().display_name,
          suppressOnHover: true,
          onClick: () => this.onPending3pidInviteClick(m),
          idName: m.getSender()
        });
      }
    });
  }
  render() {
    var _room$currentState$ge3;
    if (this.state.loading) {
      return /*#__PURE__*/react.createElement(BaseCard/* default */.C, {
        className: "mx_MemberList",
        onClose: this.props.onClose,
        onBack: this.props.onBack
      }, /*#__PURE__*/react.createElement(Spinner/* default */.Z, null));
    }
    const cli = MatrixClientPeg/* MatrixClientPeg */.p.get();
    const room = cli.getRoom(this.props.roomId);
    const eventContent = ((_room$currentState$ge3 = room.currentState.getStateEvents(_types_event/* EventType */.tw.RoomJoinRules, "")) === null || _room$currentState$ge3 === void 0 ? void 0 : _room$currentState$ge3.getContent()) || {};
    const {
      join_rule: joinRule
    } = eventContent;
    const isTacitJoined = joinRule === partials/* JoinRule */.iE.Invite || joinRule === partials/* JoinRule */.iE.Public;
    const showInviteHeader = !isTacitJoined || room.getRoomType() === "squad" ? true : (0,getRoomScene/* isCommunityRoom */.eg)(room);
    let invitedHeader;
    let invitedSection;
    if (this.getChildCountInvited() > 0) {
      invitedHeader = /*#__PURE__*/react.createElement("h2", null, (0,languageHandler._t)("Invited"));
      invitedSection = /*#__PURE__*/react.createElement(TruncatedList/* default */.Z, {
        className: "mx_MemberList_section mx_MemberList_invited",
        truncateAt: this.state.truncateAtInvited,
        createOverflowElement: this.createOverflowTileInvited,
        getChildren: this.getChildrenInvited,
        getChildCount: this.getChildCountInvited,
        infinity: true,
        loadMore: this.showMoreInvitedMemberList
      });
    }
    const footer = /*#__PURE__*/react.createElement(SearchBox/* default */.Z, {
      className: "mx_MemberList_query",
      placeholder: (0,languageHandler._t)("Filter room members"),
      onSearch: this.onSearchQueryChanged,
      initialValue: this.state.searchQuery
    });

    // We have no previousPhase for when viewing a MemberList from a Squad
    let scopeHeader;
    if (SpaceStore/* default */.ZP.spacesEnabled && room !== null && room !== void 0 && room.isSpaceRoom()) {
      scopeHeader = /*#__PURE__*/react.createElement("div", {
        className: "mx_RightPanel_scopeHeader"
      }, room.name);
    }
    return /*#__PURE__*/react.createElement(BaseCard/* default */.C, {
      className: "mx_MemberList",
      header: scopeHeader,
      onClose: this.props.onClose,
      onBack: this.props.onBack,
      withoutScrollContainer: true
    }, footer, /*#__PURE__*/react.createElement("div", {
      className: "mx_MemberList_wrapper"
    }, /*#__PURE__*/react.createElement(TruncatedList/* default */.Z, {
      className: "mx_MemberList_section mx_MemberList_joined",
      truncateAt: this.state.truncateAtJoined,
      createOverflowElement: this.createOverflowTileJoined,
      getChildren: this.getChildrenJoined,
      getChildCount: this.getChildCountJoined,
      infinity: true,
      loadMore: this.showMoreJoinedMemberList
    }), showInviteHeader ? invitedHeader : null, invitedSection));
  }
}) || MemberList_class);

// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/local-echo/EchoChamber.ts + 5 modules
var EchoChamber = __webpack_require__(932955);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/RoomNotifs.js
var RoomNotifs = __webpack_require__(349340);
// EXTERNAL MODULE: ./node_modules/@ant-design/icons/lib/index.js
var icons_lib = __webpack_require__(639389);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/rooms/EventTile.tsx + 7 modules
var EventTile = __webpack_require__(585340);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/right_panel/RoomSummaryCard.tsx
/*
Copyright 2020 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/













// import AutoHideScrollbar from "../../structures/AutoHideScrollbar";

// import GroupMemberList from "../../views/groups/GroupMemberList";












const Button = ({
  children,
  className,
  onClick
}) => {
  return /*#__PURE__*/React.createElement(AccessibleButton, {
    className: classNames("mx_BaseCard_Button mx_RoomSummaryCard_Button", className),
    onClick: onClick
  }, children);
};
const ActionButtons = props => {
  const [isMute, setVolume] = (0,react.useState)(false);
  const roomProps = (0,react.useMemo)(() => {
    return EchoChamber/* EchoChamber */.P.forRoom(props.room);
  }, [props.room]);
  (0,react.useEffect)(() => {
    const isMute = roomProps.notificationVolume === RoomNotifs/* MUTE */.Q2;
    setVolume(isMute);
  }, [roomProps]);
  return /*#__PURE__*/react.createElement("div", {
    className: "mx_RoomSummaryCard_actionGroup"
  }, /*#__PURE__*/react.createElement(dist.SdButton, {
    type: "associate",
    icon: "AdduserOutlines",
    size: "large",
    className: "mx_RoomSummaryCard_actionButton",
    onClick: () => onRoomInviteClick(props.room)
  }, (0,languageHandler._t)("Invite")), /*#__PURE__*/react.createElement(dist.SdButton, {
    type: "associate",
    icon: isMute ? "MuteOutlines" : "NoticeOutlines",
    size: "large",
    className: "mx_RoomSummaryCard_actionButton",
    onClick: () => {
      onMuteClick(roomProps, isMute ? RoomNotifs/* ALL_MESSAGES_LOUD */.ei : RoomNotifs/* MUTE */.Q2);
      setVolume(!isMute);
    }
  }, (0,languageHandler._t)(isMute ? "Off" : "On")), !props.room.isDmRoom() && /*#__PURE__*/react.createElement(dist.SdButton, {
    type: "associate",
    icon: "SettingOutlines",
    size: "large",
    className: "mx_RoomSummaryCard_actionButton",
    onClick: () => onRoomSettingsClick()
  }, (0,languageHandler._t)("Settings")));
};
const onRoomInviteClick = room => {
  // TODO: move user limit in `showRoomInviteDialog` into here
  dispatcher/* default */.ZP.dispatch({
    action: "view_invite",
    roomId: room.roomId
  });
};
const onRoomMembersClick = () => {
  defaultDispatcher.dispatch({
    action: Action.SetRightPanelPhase,
    phase: RightPanelPhases.RoomMemberList
  });
};
const onRoomFilesClick = () => {
  defaultDispatcher.dispatch({
    action: Action.SetRightPanelPhase,
    phase: RightPanelPhases.FilePanel
  });
};
const onRoomTopicClick = () => {
  defaultDispatcher.dispatch({
    action: Action.SetRightPanelPhase,
    phase: RightPanelPhases.TopicSummaryPanel
  });
};

// const onShareRoomClick = (room: Room) => {
//     Modal.createTrackedDialog("share room dialog", "", ShareDialog, {
//         target: room,
//     });
// };

const onRoomSettingsClick = () => {
  dispatcher/* default */.ZP.dispatch({
    action: "open_room_settings"
  });
};
const onMuteClick = (roomProps, type) => {
  if (MatrixClientPeg/* MatrixClientPeg */.p.get().isGuest()) return;
  roomProps.notificationVolume = type;
};
const RoomSummaryCard = props => {
  const [showBack, setShowBack] = (0,react.useState)(false);
  const cli = (0,react.useContext)(MatrixClientContext/* default */.Z);
  const headerRef = (0,react.useRef)();
  const contentRef = (0,react.useRef)();
  const {
    room,
    onClose,
    phase,
    resizeNotifier,
    groupId
  } = props;
  const isRoomEncrypted = (0,useIsEncrypted/* useIsEncrypted */.H)(cli, room);
  const {
    joinLinkSquad,
    hasJoinSquad,
    hasLinkSquad,
    squad
  } = useSquadLink({
    room,
    client: cli
  });
  const alias = room.getCanonicalAlias() || room.getAltAliases()[0] || "";
  let encryptedAlias = null;
  const title = (0,react.useMemo)(() => {
    if (room) {
      if (room.isSaveMessageRoom()) {
        return null;
      }
      if (room.isDmRoom()) {
        return /*#__PURE__*/react.createElement("span", {
          className: "mx_Profile_title"
        }, (0,languageHandler._t)("DM Info"));
      }
      if (room.isGroup()) {
        return /*#__PURE__*/react.createElement("span", {
          className: "mx_Profile_title"
        }, (0,languageHandler._t)("Group Info"));
      }
      if (room.hasSpaceParent()) {
        return /*#__PURE__*/react.createElement("span", {
          className: "mx_Profile_title"
        }, (0,languageHandler._t)("Channel Info"));
      }
    }
  }, [room]);
  const target = (0,react.useMemo)(() => {
    switch (props.phase) {
      case RightPanelStorePhases/* RightPanelPhases */.q4.FilePanel:
        return "files";
      case RightPanelStorePhases/* RightPanelPhases */.q4.RoomMemberList:
        return "members";
      // case RightPanelPhases.TopicSummaryPanel:
      //     return "topic";
      case RightPanelStorePhases/* RightPanelPhases */.q4.RoomSummary:
      default:
        return "";
    }
  }, [props.phase]);
  if (isRoomEncrypted) {
    const msg = (0,languageHandler._t)("Messages in this room are end-to-end encrypted.");
    encryptedAlias = /*#__PURE__*/react.createElement("div", {
      className: "mx_RoomSummaryCard_alias mx_RoomSummaryCard_encryptedInfo"
    }, /*#__PURE__*/react.createElement("span", {
      className: "mx_RoomSummaryCard_icon mx_RoomSummaryCard_icon_verified"
    }), msg.split(" ")[0]);
  }
  const UNABLE_FUN_PERMISSION = SdkConfig/* default */.Z.get("UNABLE_FUN_PERMISSION");
  const handleBack = (0,react.useCallback)(() => {
    setShowBack(false);
  }, []);
  const profileTabs = [{
    key: "members",
    label: "Members",
    children: /*#__PURE__*/react.createElement(MemberList, {
      roomId: props.room.roomId,
      key: props.room.roomId,
      onClose: props.onClose,
      onBack: showBack ? handleBack : void 0
    })
  }, {
    key: "media",
    label: "Media",
    children: /*#__PURE__*/react.createElement(FilePanel/* default */.Z, {
      roomId: props.room.roomId,
      resizeNotifier: props.resizeNotifier,
      tileShape: EventTile/* TileShape */.GO.ImageGrid,
      onClose: props.onClose,
      onBack: showBack ? handleBack : void 0
    })
  }, {
    key: "files",
    label: "File",
    children: /*#__PURE__*/react.createElement(FilePanel/* default */.Z, {
      roomId: props.room.roomId,
      resizeNotifier: props.resizeNotifier,
      onClose: props.onClose,
      onBack: showBack ? handleBack : void 0
    })
  }
  // {
  //     key: "topic",
  //     label: "Topic",
  //     children: (
  //         <TopicSummaryPanel
  //             roomId={props.room.roomId}
  //             key={props.room.roomId}
  //             onClose={props.onClose}
  //             onBack={showBack ? handleBack : void 0}
  //         />
  //     )
  // }
  ];

  const handleTabChange = value => {
    // if (value === "members") {
    //     onRoomMembersClick();
    // } else if (value === "files") {
    //     onRoomFilesClick();
    // } else if (value === "topic") {
    //     onRoomTopicClick();
    // }
    const headerHeight = headerRef.current.offsetHeight;
    contentRef.current.style.minHeight = headerRef.current.parentElement.offsetHeight + "px";
    headerRef.current.parentElement.scrollTo({
      behavior: "smooth",
      top: headerHeight + 15
    });
  };
  const handleNameCopy = async (e, name) => {
    e.preventDefault();
    const successful = await (0,strings/* copyPlaintext */.RO)(name);
    successful ? dist.SdMessage.success((0,languageHandler._t)("Copied to clipboard")) : dist.SdMessage.success((0,languageHandler._t)("Failed to copy"));
  };
  return /*#__PURE__*/react.createElement(BaseCard/* default */.C, {
    onClose: onClose,
    header: title,
    className: "mx_RoomSummaryCard"
    // onScroll={handleScroll}
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_RoomProfile_header",
    ref: headerRef
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_RoomSummaryCard_avatar_container",
    role: "presentation"
  }, /*#__PURE__*/react.createElement(RoomAvatar/* default */.Z, {
    room: room,
    viewAvatarOnClick: true,
    size: 120,
    isThumbnail: false,
    className: "mx_RoomProfile_avatar"
  }), /*#__PURE__*/react.createElement("div", {
    className: "mx_RoomProfile_avatar_info"
  }, /*#__PURE__*/react.createElement(RoomName/* default */.Z, {
    room: room,
    showMiningBar: false
  }, (name, remark) => {
    return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("div", {
      className: "mx_RoomProfile_note_name"
    }, remark ? remark : name), remark ? /*#__PURE__*/react.createElement("div", {
      className: "mx_RoomProfile_info_expand"
    }, /*#__PURE__*/react.createElement("div", {
      className: "mx_RoomProfile_info_expand_item"
    }, /*#__PURE__*/react.createElement("span", null, name), /*#__PURE__*/react.createElement(dist.SdTooltip, {
      placement: "top",
      title: "Copy"
    }, /*#__PURE__*/react.createElement(dist.SdIcon, {
      icon: "CopyOutlines",
      onClick: e => handleNameCopy(e, name)
    })))) : null);
  }), hasJoinSquad && hasLinkSquad && UNABLE_FUN_PERMISSION && /*#__PURE__*/react.createElement("div", {
    className: "mx_Link_Squad_external"
  }, (0,languageHandler._t)("Linked")), room.isAnnouncementRoom() ? /*#__PURE__*/react.createElement(AnnouncementRoomMembers, {
    roomId: room.roomId
  }) : null, alias ? /*#__PURE__*/react.createElement("div", {
    className: "mx_RoomSummaryCard_alias",
    title: alias
  }, alias) : null, encryptedAlias)), !room.isSaveMessageRoom() ? /*#__PURE__*/react.createElement(ActionButtons, {
    room: room,
    userId: cli.getUserId()
  }) : null, joinLinkSquad), /*#__PURE__*/react.createElement("div", {
    className: "mx_RoomProfile_content",
    ref: contentRef
  }, /*#__PURE__*/react.createElement(dist.SdTabs, {
    defaultActiveKey: "members",
    items: profileTabs,
    activeKey: target || profileTabs[0].key,
    onChange: handleTabChange
  })));
};
const AnnouncementRoomMembers = ({
  roomId
}) => {
  const [nums, setNums] = (0,react.useState)(0);
  (0,react.useEffect)(() => {
    const cli = MatrixClientPeg/* MatrixClientPeg */.p.get();
    cli.getAnnouncementsCount(roomId).then(count => {
      setNums(count.total);
    });
  }, [roomId]);
  return /*#__PURE__*/react.createElement("div", {
    className: "mx_RoomSummaryCard_Announcement_Members_Count"
  }, (0,languageHandler._t)("%(count)s Rooms Following", {
    count: nums
  }));
};
/* harmony default export */ const right_panel_RoomSummaryCard = (RoomSummaryCard);
const useSquadLink = props => {
  var _props$room;
  const squadInfo = (_props$room = props.room) === null || _props$room === void 0 ? void 0 : _props$room.getLinkSquad();
  const isLink = !!(squadInfo !== null && squadInfo !== void 0 && squadInfo.display_space_id);
  const squad = props.client.getRoom(squadInfo === null || squadInfo === void 0 ? void 0 : squadInfo.display_space_id);
  const hasJoinSquad = squad && squad.hasMembershipState(props.client.getUserId(), "join");
  const squadAvatar = props.client.mxcUrlToHttp((squad === null || squad === void 0 ? void 0 : squad.getMxcAvatarUrl()) || (squadInfo === null || squadInfo === void 0 ? void 0 : squadInfo.space_avatar));
  const squadName = (squad === null || squad === void 0 ? void 0 : squad.name) || (squadInfo === null || squadInfo === void 0 ? void 0 : squadInfo.space_name);
  const joinLinkSquad = (0,react.useMemo)(() => {
    if (!isLink) {
      // not link
      return null;
    }
    if (hasJoinSquad && isLink) {
      // has link and join squad
      return null;
    }
    const onClick = () => {
      dispatcher/* default */.ZP.dispatch({
        action: "view_room",
        room_id: squadInfo === null || squadInfo === void 0 ? void 0 : squadInfo.display_space_id
      });
    };
    return /*#__PURE__*/react.createElement("div", {
      className: "mx_Join_Link_Squad_button",
      onClick: onClick
    }, /*#__PURE__*/react.createElement("div", {
      className: "mx_Join_Link_Squad_button_left"
    }, /*#__PURE__*/react.createElement(lib.Avatar, {
      shape: "square",
      size: 40,
      src: squadAvatar
    }), /*#__PURE__*/react.createElement("div", {
      className: "mx_Join_Link_Squad_button_info"
    }, /*#__PURE__*/react.createElement("div", {
      className: "mx_Join_Link_Squad_button_title"
    }, (0,languageHandler._t)("Link Squad")), /*#__PURE__*/react.createElement("div", {
      className: "mx_Join_Link_Squad_name"
    }, squadName))), /*#__PURE__*/react.createElement(icons_lib.RightOutlined, null));
  }, [isLink, hasJoinSquad, squadAvatar, squadName, squadInfo]);
  return {
    joinLinkSquad,
    hasJoinSquad,
    hasLinkSquad: isLink,
    squad
  };
};
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/utils/WidgetUtils.ts
var WidgetUtils = __webpack_require__(434596);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/elements/AppTile.js + 16 modules
var AppTile = __webpack_require__(659210);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/hooks/useEventEmitter.ts
var useEventEmitter = __webpack_require__(457771);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/WidgetStore.ts
var WidgetStore = __webpack_require__(548226);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/context_menus/WidgetContextMenu.tsx + 1 modules
var WidgetContextMenu = __webpack_require__(482538);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/widgets/WidgetLayoutStore.ts
var WidgetLayoutStore = __webpack_require__(90625);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/UIStore.ts
var UIStore = __webpack_require__(563869);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/right_panel/WidgetCard.tsx
/*
Copyright 2020 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
















const useWidgets = room => {
  const [apps, setApps] = (0,react.useState)(WidgetStore/* default */.Z.instance.getApps(room.roomId));
  const updateApps = (0,react.useCallback)(() => {
    // Copy the array so that we always trigger a re-render, as some updates mutate the array of apps/settings
    setApps([...WidgetStore/* default */.Z.instance.getApps(room.roomId)]);
  }, [room]);
  (0,react.useEffect)(updateApps, [room, updateApps]);
  (0,useEventEmitter/* useEventEmitter */.x)(WidgetStore/* default */.Z.instance, room.roomId, updateApps);
  (0,useEventEmitter/* useEventEmitter */.x)(WidgetLayoutStore/* WidgetLayoutStore */.z3.instance, WidgetLayoutStore/* WidgetLayoutStore */.z3.emissionForRoom(room), updateApps);
  return apps;
};
const WidgetCard = ({
  room,
  widgetId,
  onClose
}) => {
  const cli = (0,react.useContext)(MatrixClientContext/* default */.Z);
  const apps = useWidgets(room);
  const app = apps.find(a => a.id === widgetId);
  const isPinned = app && WidgetLayoutStore/* WidgetLayoutStore */.z3.instance.isInContainer(room, app, WidgetLayoutStore/* Container */.W2.Top);
  const [menuDisplayed, handle, openMenu, closeMenu] = (0,ContextMenu/* useContextMenu */.av)();
  (0,react.useEffect)(() => {
    if (!app || isPinned) {
      // stop showing this card
      dispatcher/* default */.ZP.dispatch({
        action: actions/* Action */.a.SetRightPanelPhase,
        phase: RightPanelStorePhases/* RightPanelPhases */.q4.RoomSummary
      });
    }
  }, [app, isPinned]);

  // Don't render anything as we are about to transition
  if (!app || isPinned) return null;
  let contextMenu;
  if (menuDisplayed) {
    const rect = handle.current.getBoundingClientRect();
    contextMenu = /*#__PURE__*/react.createElement(WidgetContextMenu/* default */.Z, {
      chevronFace: ContextMenu/* ChevronFace */.N7.None,
      right: UIStore/* default */.Z.instance.windowWidth - rect.right - 12,
      top: rect.bottom + 12,
      onFinished: closeMenu,
      app: app
    });
  }
  const header = /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement("h2", null, WidgetUtils/* default */.Z.getWidgetName(app)), /*#__PURE__*/react.createElement(ContextMenu/* ContextMenuButton */.lX, {
    kind: "secondary",
    className: "mx_WidgetCard_optionsButton",
    inputRef: handle,
    onClick: openMenu,
    isExpanded: menuDisplayed,
    label: (0,languageHandler._t)("Options")
  }), contextMenu);
  return /*#__PURE__*/react.createElement(BaseCard/* default */.C, {
    header: header,
    className: "mx_WidgetCard",
    onClose: onClose,
    previousPhase: RightPanelStorePhases/* RightPanelPhases */.q4.RoomSummary,
    withoutScrollContainer: true
  }, /*#__PURE__*/react.createElement(AppTile/* default */.Z, {
    app: app,
    fullWidth: true,
    show: true,
    showMenubar: false,
    room: room,
    userId: cli.getUserId(),
    creatorUserId: app.creatorUserId,
    widgetPageTitle: WidgetUtils/* default */.Z.getWidgetDataTitle(app),
    waitForIframeLoad: app.waitForIframeLoad
  }));
};
/* harmony default export */ const right_panel_WidgetCard = (WidgetCard);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/index.js + 1 modules
var src = __webpack_require__(47185);
// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(45697);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/GroupAddressPicker.js
var GroupAddressPicker = __webpack_require__(185675);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/structures/AutoHideScrollbar.tsx
var AutoHideScrollbar = __webpack_require__(651070);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/groups.js
var groups = __webpack_require__(617575);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/customisations/Media.ts + 1 modules
var Media = __webpack_require__(834208);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/groups/GroupMemberTile.js

/*
Copyright 2017 Vector Creations Ltd
Copyright 2017 New Vector Ltd
Copyright 2019 Michael Telatynski <7t3chguy@gmail.com>

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/









class GroupMemberTile extends react.Component {
  constructor(...args) {
    super(...args);
    (0,defineProperty/* default */.Z)(this, "onClick", e => {
      dispatcher/* default */.ZP.dispatch({
        action: 'view_group_user',
        member: this.props.member,
        groupId: this.props.groupId
      });
    });
  }
  render() {
    const BaseAvatar = src.getComponent('avatars.BaseAvatar');
    const name = this.props.member.displayname || this.props.member.userId;
    const avatarUrl = this.props.member.avatarUrl ? (0,Media/* mediaFromMxc */.TS)(this.props.member.avatarUrl).getSquareThumbnailHttp(36) : null;
    const av = /*#__PURE__*/react.createElement(BaseAvatar, {
      "aria-hidden": "true",
      name: this.props.member.displayname || this.props.member.userId,
      idName: this.props.member.userId,
      width: 36,
      height: 36,
      url: avatarUrl
    });
    return /*#__PURE__*/react.createElement(EntityTile/* default */.ZP, {
      name: name,
      avatarJsx: av,
      onClick: this.onClick,
      suppressOnHover: true,
      presenceState: "online",
      powerStatus: this.props.member.isPrivileged ? EntityTile/* default */.ZP.POWER_STATUS_ADMIN : null
    });
  }
}
(0,defineProperty/* default */.Z)(GroupMemberTile, "propTypes", {
  groupId: (prop_types_default()).string.isRequired,
  member: groups/* GroupMemberType */.or.isRequired
});
(0,defineProperty/* default */.Z)(GroupMemberTile, "contextType", MatrixClientContext/* default */.Z);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/groups/GroupMemberList.js

/*
Copyright 2017 Vector Creations Ltd.
Copyright 2017 New Vector Ltd.
Copyright 2019 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/














const GroupMemberList_INITIAL_LOAD_NUM_MEMBERS = 30;
class GroupMemberList extends react.Component {
  constructor(...args) {
    super(...args);
    (0,defineProperty/* default */.Z)(this, "state", {
      members: null,
      membersError: null,
      invitedMembers: null,
      invitedMembersError: null,
      truncateAt: GroupMemberList_INITIAL_LOAD_NUM_MEMBERS
    });
    (0,defineProperty/* default */.Z)(this, "_createOverflowTile", (overflowCount, totalCount) => {
      // For now we'll pretend this is any entity. It should probably be a separate tile.
      const BaseAvatar = src.getComponent("avatars.BaseAvatar");
      const text = (0,languageHandler._t)("and %(count)s others...", {
        count: overflowCount
      });
      return /*#__PURE__*/react.createElement(EntityTile/* default */.ZP, {
        className: "mx_EntityTile_ellipsis",
        avatarJsx: /*#__PURE__*/react.createElement(BaseAvatar, {
          url: __webpack_require__(699521),
          name: "...",
          width: 36,
          height: 36
        }),
        name: text,
        presenceState: "online",
        suppressOnHover: true,
        onClick: this._showFullMemberList
      });
    });
    (0,defineProperty/* default */.Z)(this, "_showFullMemberList", () => {
      this.setState({
        truncateAt: -1
      });
    });
    (0,defineProperty/* default */.Z)(this, "onSearchQueryChanged", ev => {
      this.setState({
        searchQuery: ev.target.value
      });
    });
    (0,defineProperty/* default */.Z)(this, "onInviteToGroupButtonClick", () => {
      (0,GroupAddressPicker/* showGroupInviteDialog */.k)(this.props.groupId).then(() => {
        dispatcher/* default */.ZP.dispatch({
          action: actions/* Action */.a.SetRightPanelPhase,
          phase: RightPanelStorePhases/* RightPanelPhases */.q4.GroupMemberList,
          refireParams: {
            groupId: this.props.groupId
          }
        });
      });
    });
  }
  componentDidMount() {
    this._unmounted = false;
    this._initGroupStore(this.props.groupId);
  }
  componentWillUnmount() {
    this._unmounted = true;
  }
  _initGroupStore(groupId) {
    GroupStore/* default */.ZP.registerListener(groupId, () => {
      this._fetchMembers();
    });
    GroupStore/* default */.ZP.on('error', (err, errorGroupId, stateKey) => {
      if (this._unmounted || groupId !== errorGroupId) return;
      if (stateKey === GroupStore/* default */.ZP.STATE_KEY.GroupMembers) {
        this.setState({
          membersError: err
        });
      }
      if (stateKey === GroupStore/* default */.ZP.STATE_KEY.GroupInvitedMembers) {
        this.setState({
          invitedMembersError: err
        });
      }
    });
  }
  _fetchMembers() {
    if (this._unmounted) return;
    this.setState({
      members: GroupStore/* default */.ZP.getGroupMembers(this.props.groupId),
      invitedMembers: GroupStore/* default */.ZP.getGroupInvitedMembers(this.props.groupId)
    });
  }
  makeGroupMemberTiles(query, memberList, memberListError) {
    if (memberListError) {
      return /*#__PURE__*/react.createElement("div", {
        className: "warning"
      }, (0,languageHandler._t)("Failed to load group members"));
    }
    query = (query || "").toLowerCase();
    if (query) {
      memberList = memberList.filter(m => {
        const matchesName = (m.displayname || "").toLowerCase().includes(query);
        const matchesId = m.userId.toLowerCase().includes(query);
        if (!matchesName && !matchesId) {
          return false;
        }
        return true;
      });
    }
    const uniqueMembers = {};
    memberList.forEach(m => {
      if (!uniqueMembers[m.userId]) uniqueMembers[m.userId] = m;
    });
    memberList = Object.keys(uniqueMembers).map(userId => uniqueMembers[userId]);
    // Descending sort on isPrivileged = true = 1 to isPrivileged = false = 0
    memberList.sort((a, b) => {
      if (a.isPrivileged === b.isPrivileged) {
        const aName = a.displayname || a.userId;
        const bName = b.displayname || b.userId;
        if (aName < bName) {
          return -1;
        } else if (aName > bName) {
          return 1;
        } else {
          return 0;
        }
      } else {
        return a.isPrivileged ? -1 : 1;
      }
    });
    const memberTiles = memberList.map(m => {
      return /*#__PURE__*/react.createElement(GroupMemberTile, {
        key: m.userId,
        groupId: this.props.groupId,
        member: m
      });
    });
    return /*#__PURE__*/react.createElement(TruncatedList/* default */.Z, {
      className: "mx_MemberList_wrapper",
      truncateAt: this.state.truncateAt,
      createOverflowElement: this._createOverflowTile
    }, memberTiles);
  }
  render() {
    if (this.state.fetching || this.state.fetchingInvitedMembers) {
      const Spinner = src.getComponent("elements.Spinner");
      return /*#__PURE__*/react.createElement("div", {
        className: "mx_MemberList"
      }, /*#__PURE__*/react.createElement(Spinner, null));
    }
    const inputBox = /*#__PURE__*/react.createElement("input", {
      className: "mx_GroupMemberList_query mx_textinput",
      id: "mx_GroupMemberList_query",
      type: "text",
      onChange: this.onSearchQueryChanged,
      value: this.state.searchQuery,
      placeholder: (0,languageHandler._t)('Filter community members'),
      autoComplete: "off"
    });
    const joined = this.state.members ? /*#__PURE__*/react.createElement("div", {
      className: "mx_MemberList_joined"
    }, this.makeGroupMemberTiles(this.state.searchQuery, this.state.members, this.state.membersError)) : /*#__PURE__*/react.createElement("div", null);
    const invited = this.state.invitedMembers && this.state.invitedMembers.length > 0 ? /*#__PURE__*/react.createElement("div", {
      className: "mx_MemberList_invited"
    }, /*#__PURE__*/react.createElement("h2", null, (0,languageHandler._t)("Invited")), this.makeGroupMemberTiles(this.state.searchQuery, this.state.invitedMembers, this.state.invitedMembersError)) : /*#__PURE__*/react.createElement("div", null);
    let inviteButton;
    if (GroupStore/* default */.ZP.isUserPrivileged(this.props.groupId)) {
      inviteButton = /*#__PURE__*/react.createElement(elements_AccessibleButton/* default */.Z, {
        className: "mx_MemberList_invite mx_MemberList_inviteCommunity",
        onClick: this.onInviteToGroupButtonClick
      }, /*#__PURE__*/react.createElement("span", null, (0,languageHandler._t)('Invite to this community')));
    }
    return /*#__PURE__*/react.createElement("div", {
      className: "mx_MemberList",
      role: "tabpanel"
    }, inviteButton, /*#__PURE__*/react.createElement(AutoHideScrollbar/* default */.Z, null, joined, invited), inputBox);
  }
}
(0,defineProperty/* default */.Z)(GroupMemberList, "propTypes", {
  groupId: (prop_types_default()).string.isRequired
});
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/groups/GroupRoomTile.js

/*
Copyright 2017 New Vector Ltd

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/








class GroupRoomTile extends react.Component {
  constructor(...args) {
    super(...args);
    (0,defineProperty/* default */.Z)(this, "onClick", e => {
      dispatcher/* default */.ZP.dispatch({
        action: 'view_group_room',
        groupId: this.props.groupId,
        groupRoomId: this.props.groupRoom.roomId
      });
    });
  }
  render() {
    const BaseAvatar = src.getComponent('avatars.BaseAvatar');
    const AccessibleButton = src.getComponent('elements.AccessibleButton');
    const avatarUrl = this.props.groupRoom.avatarUrl ? (0,Media/* mediaFromMxc */.TS)(this.props.groupRoom.avatarUrl).getSquareThumbnailHttp(36) : null;
    const av = /*#__PURE__*/react.createElement(BaseAvatar, {
      name: this.props.groupRoom.displayname,
      width: 36,
      height: 36,
      url: avatarUrl
    });
    return /*#__PURE__*/react.createElement(AccessibleButton, {
      className: "mx_GroupRoomTile",
      onClick: this.onClick
    }, /*#__PURE__*/react.createElement("div", {
      className: "mx_GroupRoomTile_avatar"
    }, av), /*#__PURE__*/react.createElement("div", {
      className: "mx_GroupRoomTile_name"
    }, this.props.groupRoom.displayname));
  }
}
(0,defineProperty/* default */.Z)(GroupRoomTile, "propTypes", {
  groupId: (prop_types_default()).string.isRequired,
  groupRoom: groups/* GroupRoomType */.d4.isRequired
});
(0,defineProperty/* default */.Z)(GroupRoomTile, "contextType", MatrixClientContext/* default */.Z);
/* harmony default export */ const groups_GroupRoomTile = (GroupRoomTile);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/groups/GroupRoomList.js

var GroupRoomList_dec, GroupRoomList_class, GroupRoomList_class2;
/*
Copyright 2017 New Vector Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/












const INITIAL_LOAD_NUM_ROOMS = 30;
let GroupRoomList = (GroupRoomList_dec = (0,replaceableComponent/* replaceableComponent */.U)("views.groups.GroupRoomList"), GroupRoomList_dec(GroupRoomList_class = (GroupRoomList_class2 = class GroupRoomList extends react.Component {
  constructor(...args) {
    super(...args);
    (0,defineProperty/* default */.Z)(this, "state", {
      rooms: null,
      truncateAt: INITIAL_LOAD_NUM_ROOMS,
      searchQuery: ""
    });
    (0,defineProperty/* default */.Z)(this, "onGroupStoreUpdated", () => {
      if (this._unmounted) return;
      this.setState({
        rooms: GroupStore/* default */.ZP.getGroupRooms(this.props.groupId)
      });
    });
    (0,defineProperty/* default */.Z)(this, "_createOverflowTile", (overflowCount, totalCount) => {
      // For now we'll pretend this is any entity. It should probably be a separate tile.
      const BaseAvatar = src.getComponent("avatars.BaseAvatar");
      const text = (0,languageHandler._t)("and %(count)s others...", {
        count: overflowCount
      });
      return /*#__PURE__*/react.createElement(EntityTile/* default */.ZP, {
        className: "mx_EntityTile_ellipsis",
        avatarJsx: /*#__PURE__*/react.createElement(BaseAvatar, {
          url: __webpack_require__(699521),
          name: "...",
          width: 36,
          height: 36
        }),
        name: text,
        presenceState: "online",
        suppressOnHover: true,
        onClick: this._showFullRoomList
      });
    });
    (0,defineProperty/* default */.Z)(this, "_showFullRoomList", () => {
      this.setState({
        truncateAt: -1
      });
    });
    (0,defineProperty/* default */.Z)(this, "onSearchQueryChanged", ev => {
      this.setState({
        searchQuery: ev.target.value
      });
    });
    (0,defineProperty/* default */.Z)(this, "onAddRoomToGroupButtonClick", () => {
      (0,GroupAddressPicker/* showGroupAddRoomDialog */.A)(this.props.groupId).then(() => {
        this.forceUpdate();
      });
    });
  }
  componentDidMount() {
    this._unmounted = false;
    this._initGroupStore(this.props.groupId);
  }
  componentWillUnmount() {
    this._unmounted = true;
    this._unregisterGroupStore();
  }
  _unregisterGroupStore() {
    GroupStore/* default */.ZP.unregisterListener(this.onGroupStoreUpdated);
  }
  _initGroupStore(groupId) {
    GroupStore/* default */.ZP.registerListener(groupId, this.onGroupStoreUpdated);
    // XXX: This should be more fluxy - let's get the error from GroupStore .getError or something
    // XXX: This is also leaked - we should remove it when unmounting
    GroupStore/* default */.ZP.on('error', (err, errorGroupId) => {
      if (errorGroupId !== groupId) return;
      this.setState({
        rooms: null
      });
    });
  }
  makeGroupRoomTiles(query) {
    query = (query || "").toLowerCase();
    let roomList = this.state.rooms;
    if (query) {
      roomList = roomList.filter(room => {
        const matchesName = (room.name || "").toLowerCase().includes(query);
        const matchesAlias = (room.canonicalAlias || "").toLowerCase().includes(query);
        return matchesName || matchesAlias;
      });
    }
    roomList = roomList.map((groupRoom, index) => {
      return /*#__PURE__*/react.createElement(groups_GroupRoomTile, {
        key: index,
        groupId: this.props.groupId,
        groupRoom: groupRoom
      });
    });
    return roomList;
  }
  render() {
    if (this.state.rooms === null) {
      return null;
    }
    let inviteButton;
    if (GroupStore/* default */.ZP.isUserPrivileged(this.props.groupId)) {
      inviteButton = /*#__PURE__*/react.createElement(elements_AccessibleButton/* default */.Z, {
        className: "mx_MemberList_invite mx_MemberList_addRoomToCommunity",
        onClick: this.onAddRoomToGroupButtonClick
      }, /*#__PURE__*/react.createElement("span", null, (0,languageHandler._t)('Add rooms to this community')));
    }
    const inputBox = /*#__PURE__*/react.createElement("input", {
      className: "mx_GroupRoomList_query mx_textinput",
      id: "mx_GroupRoomList_query",
      type: "text",
      onChange: this.onSearchQueryChanged,
      value: this.state.searchQuery,
      placeholder: (0,languageHandler._t)('Filter community rooms'),
      autoComplete: "off"
    });
    return /*#__PURE__*/react.createElement("div", {
      className: "mx_GroupRoomList",
      role: "tabpanel"
    }, inviteButton, /*#__PURE__*/react.createElement(AutoHideScrollbar/* default */.Z, {
      className: "mx_GroupRoomList_joined mx_GroupRoomList_outerWrapper"
    }, /*#__PURE__*/react.createElement(TruncatedList/* default */.Z, {
      className: "mx_GroupRoomList_wrapper",
      truncateAt: this.state.truncateAt,
      createOverflowElement: this._createOverflowTile
    }, this.makeGroupRoomTiles(this.state.searchQuery))), inputBox);
  }
}, (0,defineProperty/* default */.Z)(GroupRoomList_class2, "propTypes", {
  groupId: (prop_types_default()).string.isRequired
}), GroupRoomList_class2)) || GroupRoomList_class);

// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/Modal.tsx + 1 modules
var Modal = __webpack_require__(241648);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/elements/InlineSpinner.tsx
var InlineSpinner = __webpack_require__(650193);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/groups/GroupRoomInfo.js

var GroupRoomInfo_dec, GroupRoomInfo_class, GroupRoomInfo_class2;
/*
Copyright 2017 New Vector Ltd
Copyright 2019 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/













let GroupRoomInfo = (GroupRoomInfo_dec = (0,replaceableComponent/* replaceableComponent */.U)("views.groups.GroupRoomInfo"), GroupRoomInfo_dec(GroupRoomInfo_class = (GroupRoomInfo_class2 = class GroupRoomInfo extends react.Component {
  constructor(...args) {
    super(...args);
    (0,defineProperty/* default */.Z)(this, "state", {
      isUserPrivilegedInGroup: null,
      groupRoom: null,
      groupRoomPublicityLoading: false,
      groupRoomRemoveLoading: false
    });
    (0,defineProperty/* default */.Z)(this, "onGroupStoreUpdated", () => {
      this.setState({
        isUserPrivilegedInGroup: GroupStore/* default */.ZP.isUserPrivileged(this.props.groupId)
      });
      this._updateGroupRoom();
    });
    (0,defineProperty/* default */.Z)(this, "_onRemove", e => {
      const groupId = this.props.groupId;
      const roomName = this.state.groupRoom.displayname;
      e.preventDefault();
      e.stopPropagation();
      const QuestionDialog = src.getComponent("dialogs.QuestionDialog");
      Modal/* default */.Z.createTrackedDialog('Confirm removal of group from room', '', QuestionDialog, {
        title: (0,languageHandler._t)("Are you sure you want to remove '%(roomName)s' from %(groupId)s?", {
          roomName,
          groupId
        }),
        description: (0,languageHandler._t)("Removing a room from the community will also remove it from the community page."),
        button: (0,languageHandler._t)("Remove"),
        onFinished: proceed => {
          if (!proceed) return;
          this.setState({
            groupRoomRemoveLoading: true
          });
          const groupId = this.props.groupId;
          const roomId = this.props.groupRoomId;
          GroupStore/* default */.ZP.removeRoomFromGroup(this.props.groupId, roomId).then(() => {
            dispatcher/* default */.ZP.dispatch({
              action: "view_group_room_list"
            });
          }).catch(err => {
            console.error(`Error whilst removing ${roomId} from ${groupId}`, err);
            const ErrorDialog = src.getComponent("dialogs.ErrorDialog");
            Modal/* default */.Z.createTrackedDialog('Failed to remove room from group', '', ErrorDialog, {
              title: (0,languageHandler._t)("Failed to remove room from community"),
              description: (0,languageHandler._t)("Failed to remove '%(roomName)s' from %(groupId)s", {
                groupId,
                roomName
              })
            });
          }).finally(() => {
            this.setState({
              groupRoomRemoveLoading: false
            });
          });
        }
      });
    });
    (0,defineProperty/* default */.Z)(this, "_onCancel", e => {
      dispatcher/* default */.ZP.dispatch({
        action: "view_group_room_list"
      });
    });
    (0,defineProperty/* default */.Z)(this, "_changeGroupRoomPublicity", e => {
      const isPublic = e.target.value === "public";
      this.setState({
        groupRoomPublicityLoading: true
      });
      const groupId = this.props.groupId;
      const roomId = this.props.groupRoomId;
      const roomName = this.state.groupRoom.displayname;
      GroupStore/* default */.ZP.updateGroupRoomVisibility(this.props.groupId, roomId, isPublic).catch(err => {
        console.error(`Error whilst changing visibility of ${roomId} in ${groupId} to ${isPublic}`, err);
        const ErrorDialog = src.getComponent("dialogs.ErrorDialog");
        Modal/* default */.Z.createTrackedDialog('Failed to remove room from group', '', ErrorDialog, {
          title: (0,languageHandler._t)("Something went wrong!"),
          description: (0,languageHandler._t)("The visibility of '%(roomName)s' in %(groupId)s could not be updated.", {
            roomName,
            groupId
          })
        });
      }).finally(() => {
        this.setState({
          groupRoomPublicityLoading: false
        });
      });
    });
  }
  componentDidMount() {
    this._initGroupStore(this.props.groupId);
  }

  // TODO: [REACT-WARNING] Replace with appropriate lifecycle event
  // eslint-disable-next-line camelcase
  UNSAFE_componentWillReceiveProps(newProps) {
    if (newProps.groupId !== this.props.groupId) {
      this._unregisterGroupStore(this.props.groupId);
      this._initGroupStore(newProps.groupId);
    }
  }
  componentWillUnmount() {
    this._unregisterGroupStore(this.props.groupId);
  }
  _initGroupStore(groupId) {
    GroupStore/* default */.ZP.registerListener(groupId, this.onGroupStoreUpdated);
  }
  _unregisterGroupStore(groupId) {
    GroupStore/* default */.ZP.unregisterListener(this.onGroupStoreUpdated);
  }
  _updateGroupRoom() {
    this.setState({
      groupRoom: GroupStore/* default */.ZP.getGroupRooms(this.props.groupId).find(r => r.roomId === this.props.groupRoomId)
    });
  }
  render() {
    const AccessibleButton = src.getComponent('elements.AccessibleButton');
    if (this.state.groupRoomRemoveLoading || !this.state.groupRoom) {
      const Spinner = src.getComponent("elements.Spinner");
      return /*#__PURE__*/react.createElement("div", {
        className: "mx_MemberInfo"
      }, /*#__PURE__*/react.createElement(Spinner, null));
    }
    let adminTools;
    if (this.state.isUserPrivilegedInGroup) {
      adminTools = /*#__PURE__*/react.createElement("div", {
        className: "mx_MemberInfo_adminTools"
      }, /*#__PURE__*/react.createElement("h3", null, (0,languageHandler._t)("Admin Tools")), /*#__PURE__*/react.createElement("div", {
        className: "mx_MemberInfo_buttons"
      }, /*#__PURE__*/react.createElement(AccessibleButton, {
        className: "mx_MemberInfo_field",
        onClick: this._onRemove
      }, (0,languageHandler._t)('Remove from community'))), /*#__PURE__*/react.createElement("h3", null, (0,languageHandler._t)('Visibility in Room List'), this.state.groupRoomPublicityLoading ? /*#__PURE__*/react.createElement(InlineSpinner/* default */.Z, null) : /*#__PURE__*/react.createElement("div", null)), /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement("label", null, /*#__PURE__*/react.createElement("input", {
        type: "radio",
        value: "public",
        checked: this.state.groupRoom.isPublic,
        onChange: this._changeGroupRoomPublicity
      }), /*#__PURE__*/react.createElement("div", {
        className: "mx_MemberInfo_label_text"
      }, (0,languageHandler._t)('Visible to everyone')))), /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement("label", null, /*#__PURE__*/react.createElement("input", {
        type: "radio",
        value: "private",
        checked: !this.state.groupRoom.isPublic,
        onChange: this._changeGroupRoomPublicity
      }), /*#__PURE__*/react.createElement("div", {
        className: "mx_MemberInfo_label_text"
      }, (0,languageHandler._t)('Only visible to community members')))));
    }
    const avatarUrl = this.state.groupRoom.avatarUrl;
    let avatarElement;
    if (avatarUrl) {
      const httpUrl = (0,Media/* mediaFromMxc */.TS)(avatarUrl).getSquareThumbnailHttp(800);
      avatarElement = /*#__PURE__*/react.createElement("div", {
        className: "mx_MemberInfo_avatar"
      }, /*#__PURE__*/react.createElement("img", {
        src: httpUrl
      }));
    }
    const groupRoomName = this.state.groupRoom.displayname;
    return /*#__PURE__*/react.createElement("div", {
      className: "mx_MemberInfo",
      role: "tabpanel"
    }, /*#__PURE__*/react.createElement(AutoHideScrollbar/* default */.Z, null, /*#__PURE__*/react.createElement(AccessibleButton, {
      className: "mx_MemberInfo_cancel",
      onClick: this._onCancel
    }, /*#__PURE__*/react.createElement("img", {
      src: __webpack_require__(531497),
      width: "18",
      height: "18",
      className: "mx_filterFlipColor"
    })), avatarElement, /*#__PURE__*/react.createElement("h2", null, groupRoomName), /*#__PURE__*/react.createElement("div", {
      className: "mx_MemberInfo_profile"
    }, /*#__PURE__*/react.createElement("div", {
      className: "mx_MemberInfo_profileField"
    }, this.state.groupRoom.canonicalAlias)), adminTools));
  }
}, (0,defineProperty/* default */.Z)(GroupRoomInfo_class2, "contextType", MatrixClientContext/* default */.Z), (0,defineProperty/* default */.Z)(GroupRoomInfo_class2, "propTypes", {
  groupId: (prop_types_default()).string,
  groupRoomId: (prop_types_default()).string
}), GroupRoomInfo_class2)) || GroupRoomInfo_class);

// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/dialogs/ErrorDialog.tsx
var ErrorDialog = __webpack_require__(705636);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/rooms/ThirdPartyMemberInfo.tsx

var ThirdPartyMemberInfo_dec, ThirdPartyMemberInfo_class;
/*
Copyright 2019-2021 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/













let ThirdPartyMemberInfo = (ThirdPartyMemberInfo_dec = (0,replaceableComponent/* replaceableComponent */.U)("views.rooms.ThirdPartyMemberInfo"), ThirdPartyMemberInfo_dec(ThirdPartyMemberInfo_class = class ThirdPartyMemberInfo extends react.Component {
  constructor(props) {
    super(props);
    (0,defineProperty/* default */.Z)(this, "room", void 0);
    (0,defineProperty/* default */.Z)(this, "onRoomStateEvents", ev => {
      if (ev.getType() === "m.room.third_party_invite" && ev.getStateKey() === this.state.stateKey) {
        const newDisplayName = ev.getContent().display_name;
        const isInvited = (0,RoomInvite/* isValid3pidInvite */.ih)(ev);
        const newState = {
          invited: isInvited
        };
        if (newDisplayName) newState['displayName'] = newDisplayName;
        this.setState(newState);
      }
    });
    (0,defineProperty/* default */.Z)(this, "onCancel", () => {
      dispatcher/* default */.ZP.dispatch({
        action: "view_3pid_invite",
        event: null
      });
    });
    (0,defineProperty/* default */.Z)(this, "onKickClick", () => {
      MatrixClientPeg/* MatrixClientPeg */.p.get().sendStateEvent(this.state.roomId, "m.room.third_party_invite", {}, this.state.stateKey).catch(err => {
        console.error(err);

        // Revert echo because of error
        this.setState({
          invited: true
        });
        Modal/* default */.Z.createTrackedDialog('Revoke 3pid invite failed', '', ErrorDialog/* default */.Z, {
          title: (0,languageHandler._t)("Failed to revoke invite"),
          description: (0,languageHandler._t)("Could not revoke the invite. The server may be experiencing a temporary problem or " + "you do not have sufficient permissions to revoke the invite.")
        });
      });

      // Local echo
      this.setState({
        invited: false
      });
    });
    this.room = MatrixClientPeg/* MatrixClientPeg */.p.get().getRoom(this.props.event.getRoomId());
    const me = this.room.getMember(MatrixClientPeg/* MatrixClientPeg */.p.get().getUserId());
    const powerLevels = this.room.currentState.getStateEvents("m.room.power_levels", "");
    let kickLevel = powerLevels ? powerLevels.getContent().kick : 50;
    if (typeof kickLevel !== 'number') kickLevel = 50;
    const sender = this.room.getMember(this.props.event.getSender());
    this.state = {
      stateKey: this.props.event.getStateKey(),
      roomId: this.props.event.getRoomId(),
      displayName: this.props.event.getContent().display_name,
      invited: true,
      canKick: me ? me.powerLevel > kickLevel : false,
      senderName: sender ? sender.name : this.props.event.getSender()
    };
  }
  componentDidMount() {
    MatrixClientPeg/* MatrixClientPeg */.p.get().on("RoomState.events", this.onRoomStateEvents);
  }
  componentWillUnmount() {
    const client = MatrixClientPeg/* MatrixClientPeg */.p.get();
    if (client) {
      client.removeListener("RoomState.events", this.onRoomStateEvents);
    }
  }
  render() {
    let adminTools = null;
    if (this.state.canKick && this.state.invited) {
      adminTools = /*#__PURE__*/react.createElement("div", {
        className: "mx_MemberInfo_container"
      }, /*#__PURE__*/react.createElement("h3", null, (0,languageHandler._t)("Admin Tools")), /*#__PURE__*/react.createElement("div", {
        className: "mx_MemberInfo_buttons"
      }, /*#__PURE__*/react.createElement(elements_AccessibleButton/* default */.Z, {
        className: "mx_MemberInfo_field",
        onClick: this.onKickClick
      }, (0,languageHandler._t)("Revoke invite"))));
    }
    let scopeHeader;
    if (SpaceStore/* default */.ZP.spacesEnabled && this.room.isSpaceRoom()) {
      scopeHeader = /*#__PURE__*/react.createElement("div", {
        className: "mx_RightPanel_scopeHeader"
      }, /*#__PURE__*/react.createElement(RoomAvatar/* default */.Z, {
        room: this.room,
        size: 32
      }), /*#__PURE__*/react.createElement(RoomName/* default */.Z, {
        room: this.room
      }));
    }

    // We shamelessly rip off the MemberInfo styles here.
    return /*#__PURE__*/react.createElement("div", {
      className: "mx_MemberInfo",
      role: "tabpanel"
    }, scopeHeader, /*#__PURE__*/react.createElement("div", {
      className: "mx_MemberInfo_name"
    }, /*#__PURE__*/react.createElement(elements_AccessibleButton/* default */.Z, {
      className: "mx_MemberInfo_cancel",
      onClick: this.onCancel,
      title: (0,languageHandler._t)('Close')
    }), /*#__PURE__*/react.createElement("h2", null, this.state.displayName)), /*#__PURE__*/react.createElement("div", {
      className: "mx_MemberInfo_container"
    }, /*#__PURE__*/react.createElement("div", {
      className: "mx_MemberInfo_profile"
    }, /*#__PURE__*/react.createElement("div", {
      className: "mx_MemberInfo_profileField"
    }, (0,languageHandler._t)("Invited by %(sender)s", {
      sender: this.state.senderName
    })))), adminTools);
  }
}) || ThirdPartyMemberInfo_class);

// EXTERNAL MODULE: ./node_modules/matrix-js-sdk/src/models/thread.ts
var models_thread = __webpack_require__(493283);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/rooms/MessageComposer.tsx + 18 modules
var MessageComposer = __webpack_require__(539315);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/settings/Layout.ts
var Layout = __webpack_require__(244088);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/structures/TimelinePanel.tsx + 30 modules
var TimelinePanel = __webpack_require__(672214);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/structures/ThreadView.tsx

var ThreadView_dec, ThreadView_class;
/*
Copyright 2021 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/













let ThreadView = (ThreadView_dec = (0,replaceableComponent/* replaceableComponent */.U)('structures.ThreadView'), ThreadView_dec(ThreadView_class = class ThreadView extends react.Component {
  constructor(props) {
    super(props);
    (0,defineProperty/* default */.Z)(this, "dispatcherRef", void 0);
    (0,defineProperty/* default */.Z)(this, "timelinePanelRef", /*#__PURE__*/react.createRef());
    (0,defineProperty/* default */.Z)(this, "onAction", payload => {
      if (payload.phase == RightPanelStorePhases/* RightPanelPhases */.q4.ThreadView && payload.event) {
        if (payload.event !== this.props.mxEvent) {
          this.teardownThread();
          this.setupThread(payload.event);
        }
      }
    });
    (0,defineProperty/* default */.Z)(this, "setupThread", mxEv => {
      let thread = mxEv.getThread();
      if (!thread) {
        const client = MatrixClientPeg/* MatrixClientPeg */.p.get();
        thread = new models_thread/* Thread */.j([mxEv], this.props.room, client);
        mxEv.setThread(thread);
      }
      thread.on(models_thread/* ThreadEvent */.A.Update, this.updateThread);
      thread.once(models_thread/* ThreadEvent */.A.Ready, this.updateThread);
      this.updateThread(thread);
    });
    (0,defineProperty/* default */.Z)(this, "teardownThread", () => {
      if (this.state.thread) {
        this.state.thread.removeListener(models_thread/* ThreadEvent */.A.Update, this.updateThread);
        this.state.thread.removeListener(models_thread/* ThreadEvent */.A.Ready, this.updateThread);
      }
    });
    (0,defineProperty/* default */.Z)(this, "updateThread", thread => {
      var _this$timelinePanelRe;
      if (thread) {
        this.setState({
          thread,
          replyToEvent: thread.replyToEvent
        });
      }
      (_this$timelinePanelRe = this.timelinePanelRef.current) === null || _this$timelinePanelRe === void 0 ? void 0 : _this$timelinePanelRe.refreshTimeline();
    });
    this.state = {};
  }
  componentDidMount() {
    this.setupThread(this.props.mxEvent);
    this.dispatcherRef = dispatcher/* default */.ZP.register(this.onAction);
  }
  componentWillUnmount() {
    this.teardownThread();
    dispatcher/* default */.ZP.unregister(this.dispatcherRef);
  }
  componentDidUpdate(prevProps) {
    if (prevProps.mxEvent !== this.props.mxEvent) {
      this.teardownThread();
      this.setupThread(this.props.mxEvent);
    }
    if (prevProps.room !== this.props.room) {
      dispatcher/* default */.ZP.dispatch({
        action: actions/* Action */.a.SetRightPanelPhase,
        phase: RightPanelStorePhases/* RightPanelPhases */.q4.RoomSummary
      });
    }
  }
  render() {
    var _this$state, _this$state$thread, _this$state2, _this$state2$thread;
    return /*#__PURE__*/react.createElement(BaseCard/* default */.C, {
      className: "mx_ThreadView",
      onClose: this.props.onClose,
      previousPhase: RightPanelStorePhases/* RightPanelPhases */.q4.RoomSummary,
      withoutScrollContainer: true
    }, this.state.thread && /*#__PURE__*/react.createElement(TimelinePanel/* default */.Z, {
      ref: this.timelinePanelRef,
      manageReadReceipts: false,
      manageReadMarkers: false,
      timelineSet: (_this$state = this.state) === null || _this$state === void 0 ? void 0 : (_this$state$thread = _this$state.thread) === null || _this$state$thread === void 0 ? void 0 : _this$state$thread.timelineSet,
      showUrlPreview: false,
      tileShape: EventTile/* TileShape */.GO.Notif,
      empty: /*#__PURE__*/react.createElement("div", null, "empty"),
      alwaysShowTimestamps: true,
      layout: Layout/* Layout */.A.Group,
      hideThreadedMessages: false
    }), /*#__PURE__*/react.createElement(MessageComposer/* default */.ZP, {
      room: this.props.room,
      resizeNotifier: this.props.resizeNotifier,
      replyInThread: true,
      replyToEvent: (_this$state2 = this.state) === null || _this$state2 === void 0 ? void 0 : (_this$state2$thread = _this$state2.thread) === null || _this$state2$thread === void 0 ? void 0 : _this$state2$thread.replyToEvent,
      showReplyPreview: false,
      permalinkCreator: this.props.permalinkCreator,
      e2eStatus: this.props.e2eStatus,
      compact: true
    }));
  }
}) || ThreadView_class);

;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/structures/ThreadPanel.tsx

var ThreadPanel_dec, ThreadPanel_class;
/*
Copyright 2021 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/








let ThreadPanel = (ThreadPanel_dec = (0,replaceableComponent/* replaceableComponent */.U)("structures.ThreadView"), ThreadPanel_dec(ThreadPanel_class = class ThreadPanel extends react.Component {
  constructor(props) {
    super(props);
    (0,defineProperty/* default */.Z)(this, "room", void 0);
    (0,defineProperty/* default */.Z)(this, "onThreadEventReceived", () => this.updateThreads());
    (0,defineProperty/* default */.Z)(this, "updateThreads", callback => {
      this.setState({
        threads: this.room.getThreads()
      }, callback);
    });
    this.room = MatrixClientPeg/* MatrixClientPeg */.p.get().getRoom(this.props.roomId);
  }
  componentDidMount() {
    this.room.on(models_thread/* ThreadEvent */.A.Update, this.onThreadEventReceived);
    this.room.on(models_thread/* ThreadEvent */.A.Ready, this.onThreadEventReceived);
  }
  componentWillUnmount() {
    this.room.removeListener(models_thread/* ThreadEvent */.A.Update, this.onThreadEventReceived);
    this.room.removeListener(models_thread/* ThreadEvent */.A.Ready, this.onThreadEventReceived);
  }
  renderEventTile(event) {
    return /*#__PURE__*/react.createElement(EventTile/* default */.ZP, {
      key: event.getId(),
      mxEvent: event,
      enableFlair: false,
      showReadReceipts: false,
      as: "div"
    });
  }
  render() {
    var _this$state;
    return /*#__PURE__*/react.createElement(BaseCard/* default */.C, {
      className: "mx_ThreadPanel",
      onClose: this.props.onClose,
      previousPhase: RightPanelStorePhases/* RightPanelPhases */.q4.RoomSummary
    }, (_this$state = this.state) === null || _this$state === void 0 ? void 0 : _this$state.threads.map(thread => {
      if (thread.ready) {
        return this.renderEventTile(thread.rootEvent);
      }
    }));
  }
}) || ThreadPanel_class);

// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/right_panel/PinnedMessagesCard.tsx
var PinnedMessagesCard = __webpack_require__(802257);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js + 1 modules
var objectWithoutProperties = __webpack_require__(992619);
// EXTERNAL MODULE: ./node_modules/lightweight-charts/index.js
var lightweight_charts = __webpack_require__(530301);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/lib/coinmarketcapUtil.ts
var coinmarketcapUtil = __webpack_require__(470701);
// EXTERNAL MODULE: ./node_modules/lodash-es/isArray.js
var isArray = __webpack_require__(427771);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/structures/TokenPanel.tsx

const _excluded = ["onClose"];








const TokenPanel = _ref => {
  var _state$quote2, _state$quote2$USD;
  let {
      onClose
    } = _ref,
    props = (0,objectWithoutProperties/* default */.Z)(_ref, _excluded);
  const classes = ["mx_TokenPanel"];
  const ref = (0,react.useRef)();
  const [loading, setLoading] = (0,react.useState)(false);
  const [state, setState] = (0,react.useState)();
  (0,react.useEffect)(() => {
    setLoading(true);
    const fetchToken = async () => {
      const quotes = await coinmarketcapUtil/* CoinmarketcapUtil */.V.getQuotes(props.token.slug);
      const dataSource = quotes && quotes.data[props.token.id];
      if (dataSource) {
        setState(dataSource);
      } else {
        throw Error(`The corresponding token is not searched：${props.token}`);
      }
    };
    fetchToken().then(() => {
      setLoading(false);
    }).catch(error => {
      setLoading(false);
      console.error(error);
    });
  }, [props.token, props.token.slug]);
  (0,react.useEffect)(() => {
    let chart;
    let lineSeries;
    if (ref.current && state !== null && state !== void 0 && state.symbol && !loading) {
      chart = (0,lightweight_charts.createChart)(ref.current, {
        width: 280,
        height: 150
      });
      lineSeries = chart.addLineSeries();
      // setChartLoading(true);
      coinmarketcapUtil/* CoinmarketcapUtil */.V.getChat(props.token.id).then(res => {
        var _res$data;
        if (res !== null && res !== void 0 && (_res$data = res.data) !== null && _res$data !== void 0 && _res$data.points) {
          var _res$data2;
          return Object.keys(res === null || res === void 0 ? void 0 : (_res$data2 = res.data) === null || _res$data2 === void 0 ? void 0 : _res$data2.points).map(key => {
            var _res$data3;
            const [price] = res === null || res === void 0 ? void 0 : (_res$data3 = res.data) === null || _res$data3 === void 0 ? void 0 : _res$data3.points[key].v;
            const data = {
              time: +key,
              value: price
            };
            return data;
          });
        }
      }).then(data => {
        if ((0,isArray/* default */.Z)(data) && lineSeries) {
          lineSeries.setData(data);
        }
      }).then(() => {
        // setChartLoading(false);
      });
    }
    return () => {
      if (chart && lineSeries) {
        chart.removeSeries(lineSeries);
        chart.remove();
      }
    };
  }, [state === null || state === void 0 ? void 0 : state.symbol, props.token.id, props.token.symbol, loading]);
  const linkContent = (0,react.useMemo)(() => {
    const url = `https://coinmarketcap.com/currencies/${props.token.slug}`;
    return /*#__PURE__*/react.createElement("div", {
      className: "mx_Token_link"
    }, "Data source:", " ", /*#__PURE__*/react.createElement("a", {
      href: url,
      target: "_blank"
    }, "CoinMarketCap"));
  }, [props.token.slug]);
  const tagColor = (0,react.useMemo)(() => {
    var _state$quote, _state$quote$USD;
    if (state !== null && state !== void 0 && (_state$quote = state.quote) !== null && _state$quote !== void 0 && (_state$quote$USD = _state$quote.USD) !== null && _state$quote$USD !== void 0 && _state$quote$USD.percent_change_24h) {
      if (state.quote.USD.percent_change_24h > 0) {
        return "#16c784";
      } else if (state.quote.USD.percent_change_24h < 0) {
        return "#F34949";
      }
    }
    return "";
  }, [state === null || state === void 0 ? void 0 : (_state$quote2 = state.quote) === null || _state$quote2 === void 0 ? void 0 : (_state$quote2$USD = _state$quote2.USD) === null || _state$quote2$USD === void 0 ? void 0 : _state$quote2$USD.percent_change_24h]);
  let tokenHeader;
  if (state !== null && state !== void 0 && state.quote) {
    tokenHeader = /*#__PURE__*/react.createElement("div", {
      className: "mx_TokenPanel_header"
    }, /*#__PURE__*/react.createElement("div", {
      className: "mx_TokenPanel_avatar"
    }, /*#__PURE__*/react.createElement(lib.Avatar, {
      size: 66,
      src: props.token.icon
    })), /*#__PURE__*/react.createElement("div", {
      className: "mx_TokenPanel_info"
    }, /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement(lib.Space, {
      align: "baseline"
    }, /*#__PURE__*/react.createElement("span", {
      className: "mx_Token_name"
    }, props.token.name), /*#__PURE__*/react.createElement("span", {
      className: "mx_Token_symbol"
    }, props.token.symbol))), /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement(lib.Space, {
      align: "start"
    }, /*#__PURE__*/react.createElement("span", {
      className: "mx_Token_price"
    }, "$", state.quote.USD.price.toFixed(2)), /*#__PURE__*/react.createElement(lib.Tag, {
      color: tagColor
    }, state.quote.USD.percent_change_24h.toFixed(2), "%")))));
  }
  let tags;
  if (state !== null && state !== void 0 && state.tags) {
    tags = /*#__PURE__*/react.createElement("div", null, state.tags.filter((tag, index) => index < 3).map(tag => {
      return /*#__PURE__*/react.createElement(lib.Tag, {
        key: tag
      }, tag);
    }));
  }
  return /*#__PURE__*/react.createElement(BaseCard/* default */.C, {
    onClose: onClose
  }, loading && /*#__PURE__*/react.createElement(Spinner/* default */.Z, null), /*#__PURE__*/react.createElement("div", {
    className: classes.join(" ")
  }, (state === null || state === void 0 ? void 0 : state.quote) && /*#__PURE__*/react.createElement(react.Fragment, null, tokenHeader, linkContent, tags, /*#__PURE__*/react.createElement("div", {
    className: "mx_Token_price_chart"
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_Token_price_chart_title"
  }, "Price Chart"), /*#__PURE__*/react.createElement("div", {
    ref: ref,
    className: "mx_Token_price_chart_content"
  })), renderMarketCap("Market Cap", `$${state.quote.USD.market_cap.toLocaleString()}`, state.quote.USD.market_cap_dominance), renderMarketCap("Full Diluted Market Cap", `$${state.quote.USD.fully_diluted_market_cap.toLocaleString()}`, state.quote.USD.percent_change_24h), renderMarketCap( /*#__PURE__*/react.createElement("div", null, "Volume ", /*#__PURE__*/react.createElement(lib.Tag, null, "24h")), `$${state.quote.USD.volume_24h.toLocaleString()}`, state.quote.USD.volume_change_24h), renderMarketCap("Volume/Market Cap", (state.quote.USD.volume_24h / state.quote.USD.market_cap).toFixed(2)))));
};
const renderRate = rate => {
  let rateClass;
  let rateIcon;
  if (rate > 0) {
    rateClass = "mx_MarketCap_rate_up";
    rateIcon = /*#__PURE__*/react.createElement(icons_lib.CaretUpOutlined, null);
  } else if (rate < 0) {
    rateClass = "mx_MarketCap_rate_down";
    rateIcon = /*#__PURE__*/react.createElement(icons_lib.CaretDownOutlined, null);
  }
  return /*#__PURE__*/react.createElement("div", {
    className: `mx_MarketCap_rate ${rateClass}`
  }, /*#__PURE__*/react.createElement(lib.Space, null, rateIcon, /*#__PURE__*/react.createElement("span", null, rate.toFixed(2), "%")));
};
const renderMarketCap = (title, value, rate) => {
  return /*#__PURE__*/react.createElement("div", {
    className: "mx_MarketCap"
  }, title && /*#__PURE__*/react.createElement("div", {
    className: "mx_MarketCap_title"
  }, title), value && /*#__PURE__*/react.createElement("div", {
    className: "mx_MarketCap_value"
  }, value), rate && renderRate(rate));
};
/* harmony default export */ const structures_TokenPanel = (TokenPanel);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/structures/IframeWidget.tsx + 7 modules
var IframeWidget = __webpack_require__(731400);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/right_panel/SeaUserProfile/SeaUserProfile.tsx + 3 modules
var SeaUserProfile = __webpack_require__(128370);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/Avatar.ts
var Avatar = __webpack_require__(161992);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/avatars/BaseAvatar.tsx
var BaseAvatar = __webpack_require__(56607);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/structures/PinnedMsgBar.tsx + 8 modules
var PinnedMsgBar = __webpack_require__(832227);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/messages/MessageEvent.tsx
var MessageEvent = __webpack_require__(175358);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/DateUtils.ts
var DateUtils = __webpack_require__(466556);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/accessibility/RovingTabIndex.tsx + 3 modules
var RovingTabIndex = __webpack_require__(34625);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/dialogs/ConfirmRedactDialog.tsx
var ConfirmRedactDialog = __webpack_require__(523677);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/rooms/SendMessageComposer.tsx
var SendMessageComposer = __webpack_require__(467315);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/editor/parts.ts + 1 modules
var parts = __webpack_require__(887403);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/structures/TopicDetailPanel.tsx

function TopicDetailPanel_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function TopicDetailPanel_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? TopicDetailPanel_ownKeys(Object(t), !0).forEach(function (r) { (0,defineProperty/* default */.Z)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : TopicDetailPanel_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }


























const FETCH_LIMIT = 50;
const TopicDetailPanel = props => {
  const [hasMore, setHasMore] = (0,react.useState)(false);
  const [offset, setOffset] = (0,react.useState)(0);
  const [data, setData] = (0,react.useState)([]);
  const [loading, setLoading] = (0,react.useState)(false);
  const [location, setLocation] = (0,react.useState)({
    left: 0,
    top: 0
  });
  const currentEv = (0,react.useRef)(null);
  (0,react.useEffect)(() => {
    setData([]);
    setOffset(0);
  }, [props.topic, props.roomId]);
  (0,react.useEffect)(() => {
    const cli = MatrixClientPeg/* MatrixClientPeg */.p.get();
    setLoading(true);
    const loadMore = refresh => {
      cli.getTopicMsgOfRoom(props.roomId, props.topic, FETCH_LIMIT, (refresh ? 0 : offset) * FETCH_LIMIT).then(res => {
        setHasMore(res.data.length >= FETCH_LIMIT);
        const evs = res.data.map(v => {
          var _cli$getRoom;
          const ev = getNewEvent(v);
          ev.sender = (_cli$getRoom = cli.getRoom(props.roomId)) === null || _cli$getRoom === void 0 ? void 0 : _cli$getRoom.getMember(ev.getSender());
          return ev;
        });
        setData(v => refresh ? evs : v.concat(evs));
        if (refresh) {
          setOffset(0);
        }
        setLoading(false);
      });
    };
    loadMore(false);
    const handleTimeline = (ev, room) => {
      if (room.roomId !== props.roomId) {
        return;
      }
      const topics = ev.getContent()["m.topic"];
      if (topics !== null && topics !== void 0 && topics.length && topics.includes(props.topic) || ev.isRelation("m.replace") || ev.getType() === "m.room.redaction") {
        loadMore(true);
      }
    };
    cli.on("Room.timeline", handleTimeline);
    return () => {
      cli.off("Room.timeline", handleTimeline);
    };
  }, [offset, props.roomId, props.topic]);
  const room = useRoom(props.roomId);
  const permalinkCreator = usePermalinkCreator(room);
  const canSend = useCanSend(room);
  const sendMessageComposer = (0,react.useRef)();
  const refreshPlaceHolder = (0,react.useCallback)(() => {
    if (sendMessageComposer.current) {
      var _model$parts$;
      const model = sendMessageComposer.current.getModel();
      if (!(model.parts[0] instanceof parts/* TopicPillPart */.DU) || model.parts[0].text !== props.topic || !((_model$parts$ = model.parts[1]) !== null && _model$parts$ !== void 0 && _model$parts$.text.startsWith(" "))) {
        model.transform(() => {
          model.reset([{
            type: parts/* Type */.Dy.TopicPill,
            text: props.topic
          }, {
            type: parts/* Type */.Dy.Plain,
            text: " "
          }]);
          return model.getPositionAtEnd();
        });
      }
    }
  }, [props.topic]);
  (0,react.useEffect)(() => {
    refreshPlaceHolder();
  }, [refreshPlaceHolder]);
  return /*#__PURE__*/react.createElement(BaseCard/* default */.C, {
    header: /*#__PURE__*/react.createElement("div", {
      className: "mx_BaseCard_topic"
    }, (0,languageHandler._t)("Topic")),
    onClose: props.onClose,
    withoutScrollContainer: true,
    previousPhase: RightPanelStorePhases/* RightPanelPhases */.q4.TopicSummaryPanel
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_TopicDetail"
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_TopicDetail_title"
  }, props.topic), /*#__PURE__*/react.createElement("div", {
    className: "mx_TopicList"
  }, /*#__PURE__*/react.createElement(AutoHideScrollbar/* default */.Z, null, /*#__PURE__*/react.createElement(TruncatedList/* default */.Z, {
    truncateAt: data.length,
    createOverflowElement: (_, totalCount, ref) => {
      return /*#__PURE__*/react.createElement("div", {
        ref: ref,
        className: "loading"
      }, (0,languageHandler._t)("Loading …"));
    },
    getChildren: () => data.map(mxEvent => {
      const {
        url,
        name,
        userId
      } = getUrlAndNameOfUser(mxEvent);
      return /*#__PURE__*/react.createElement("div", {
        key: mxEvent.getId(),
        className: "mx_TopicList_item mx_PinnedEventTile",
        onClick: e => {
          if (e.target.classList.contains("mx_AccessibleButton")) {
            return;
          }
          if (e.target.classList.contains("mx_Pill")) {
            return;
          }
          dispatcher/* default */.ZP.dispatch({
            action: actions/* Action */.a.SetRightPanelPhase,
            phase: RightPanelStorePhases/* RightPanelPhases */.q4.TopicReply,
            refireParams: {
              params: {
                topic: props.topic,
                roomId: room.roomId,
                event: mxEvent
              }
            }
          });
        }
      }, /*#__PURE__*/react.createElement(BaseAvatar/* default */.Z, {
        name: name,
        idName: userId,
        url: url,
        width: 34,
        height: 34,
        className: "avatar"
      }), /*#__PURE__*/react.createElement("div", {
        className: "mx_TopicList_item_content"
      }, /*#__PURE__*/react.createElement("div", {
        className: "header"
      }, /*#__PURE__*/react.createElement("div", {
        className: "name"
      }, name), /*#__PURE__*/react.createElement("span", {
        className: "timestamp"
      }, (0,DateUtils/* formatDate */.p6)(new Date(mxEvent.getTs()))), /*#__PURE__*/react.createElement(RovingTabIndex/* RovingAccessibleTooltipButton */.yy, {
        onClick: () => {
          dispatcher/* default */.ZP.dispatch({
            action: "view_room",
            event_id: mxEvent.getId(),
            highlighted: true,
            room_id: mxEvent.getRoomId()
          });
        },
        className: "mx_PinnedEventTile_focusButton",
        title: (0,languageHandler._t)("View message")
      }), /*#__PURE__*/react.createElement(RovingTabIndex/* RovingAccessibleTooltipButton */.yy, {
        onClick: e => {
          const {
            left,
            top
          } = e.target.getBoundingClientRect();
          setLocation({
            left,
            top
          });
          currentEv.current = mxEvent;
        },
        className: "mx_TopicList_more",
        title: (0,languageHandler._t)("More options")
      })), /*#__PURE__*/react.createElement("div", {
        className: "mx_PinnedEventTile_message"
      }, /*#__PURE__*/react.createElement(MessageEvent["default"], {
        mxEvent: mxEvent,
        maxImageHeight: 150,
        onHeightChanged: () => {},
        tileShape: EventTile/* TileShape */.GO.Pinned
      })), /*#__PURE__*/react.createElement("div", {
        className: "mx_TopicList_item_footer"
      }, /*#__PURE__*/react.createElement("div", {
        className: "mx_TopicList_item_footer_reply_count"
      }, mxEvent.event.reply_num))));
    }),
    getChildCount: () => hasMore ? data.length + FETCH_LIMIT : data.length,
    infinity: true,
    loadMore: () => !loading && hasMore && setOffset(v => v + 1)
  }))), /*#__PURE__*/react.createElement(TopicMenu, {
    location: location,
    roomId: props.roomId,
    topic: props.topic,
    onFinished: () => setLocation({
      left: 0,
      top: 0
    }),
    event: currentEv.current
  }), /*#__PURE__*/react.createElement("div", {
    className: "mx_TopicDetail_footer"
  }, canSend ? /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(SendMessageComposer/* default */.ZP, {
    ref: sendMessageComposer,
    room: room,
    permalinkCreator: permalinkCreator,
    placeholder: `${props.topic}`,
    onChange: () => {
      refreshPlaceHolder();
    },
    privateKey: "topic"
  }), /*#__PURE__*/react.createElement(MessageComposer/* EmojiButton */.Km, {
    addEmoji: emoji => {
      dispatcher/* default */.ZP.dispatch({
        action: actions/* Action */.a.ComposerInsert,
        text: emoji,
        privateKey: "topic"
      });
      return true;
    },
    menuPosition: {
      right: 20,
      bottom: 500
    }
  })) : null)));
};
const useCanSend = room => {
  const [canSend, setCanSend] = (0,react.useState)(true);
  (0,react.useEffect)(() => {
    const cli = MatrixClientPeg/* MatrixClientPeg */.p.get();
    const resetCanSend = () => {
      setCanSend(room.maySendMessage() && !room.currentState.getStateEvents("m.room.tombstone", "") && room.getMyMembership() === "join");
    };
    const handleRoomStateEvents = ev => {
      if (ev.getRoomId() !== room.roomId) return;
      if (ev.getType() === "m.room.power_levels" || ev.getType() === "m.room.tombstone") {
        resetCanSend();
      }
    };
    const handleMyMembership = _room => {
      if (room.roomId !== _room.roomId) {
        return;
      }
      resetCanSend();
    };
    resetCanSend();
    cli.on("RoomState.events", handleRoomStateEvents);
    cli.on("Room.myMembership", handleMyMembership);
    return () => {
      cli.off("RoomState.events", handleRoomStateEvents);
      cli.off("Room.myMembership", handleMyMembership);
    };
  }, [room]);
  return canSend;
};
/* harmony default export */ const structures_TopicDetailPanel = (TopicDetailPanel);
const TopicMenu = props => {
  const {
    location,
    onFinished,
    event,
    topic,
    roomId,
    showReply = true
  } = props;
  return location.left && location.top ? /*#__PURE__*/react.createElement(IconizedContextMenu/* default */.ZP, {
    left: location.left - 100,
    top: location.top + 10,
    onFinished: onFinished,
    wrapperClassName: "mx_TopicList_item_menu"
  }, /*#__PURE__*/react.createElement(IconizedContextMenu/* IconizedContextMenuOptionList */.I2, null, /*#__PURE__*/react.createElement(IconizedContextMenu/* IconizedContextMenuOption */.$k, null, /*#__PURE__*/react.createElement(IconizedContextMenu/* IconizedContextMenuItem */.XH, {
    iconClassName: "mx_TopicList_item_menu_iconForward",
    label: (0,languageHandler._t)("Forward"),
    onClick: () => (0,ForwardDialog/* showForwardDialogWithContent */.H2)(event.getContent())
  })), showReply ? /*#__PURE__*/react.createElement(IconizedContextMenu/* IconizedContextMenuOption */.$k, null, /*#__PURE__*/react.createElement(IconizedContextMenu/* IconizedContextMenuItem */.XH, {
    iconClassName: "mx_TopicList_item_menu_iconRely",
    label: (0,languageHandler._t)("Reply"),
    onClick: () => {
      dispatcher/* default */.ZP.dispatch({
        action: actions/* Action */.a.SetRightPanelPhase,
        phase: RightPanelStorePhases/* RightPanelPhases */.q4.TopicReply,
        refireParams: {
          params: {
            topic,
            roomId,
            event
          }
        }
      });
    }
  })) : null), /*#__PURE__*/react.createElement(IconizedContextMenu/* IconizedContextMenuOptionList */.I2, {
    red: true
  }, /*#__PURE__*/react.createElement(IconizedContextMenu/* IconizedContextMenuOption */.$k, null, /*#__PURE__*/react.createElement(IconizedContextMenu/* IconizedContextMenuItem */.XH, {
    iconClassName: "mx_TopicList_item_menu_iconRemove",
    label: (0,languageHandler._t)("Remove"),
    onClick: () => {
      onFinished();
      Modal/* default */.Z.createTrackedDialog("Confirm Redact Dialog", "", ConfirmRedactDialog/* default */.Z, {
        onFinished: async (proceed, reason) => {
          if (!proceed) return;
          const cli = MatrixClientPeg/* MatrixClientPeg */.p.get();
          try {
            var _props$onRemove;
            await cli.redactEvent(event.getRoomId(), event.getId(), undefined, reason ? {
              reason
            } : {});
            (_props$onRemove = props.onRemove) === null || _props$onRemove === void 0 ? void 0 : _props$onRemove.call(props);
          } catch (e) {
            const code = e.errcode || e.statusCode;
            if (typeof code !== "undefined") {
              Modal/* default */.Z.createTrackedDialog("You cannot delete this message", "", ErrorDialog/* default */.Z, {
                title: (0,languageHandler._t)("Error"),
                description: (0,languageHandler._t)("You cannot delete this message. (%(code)s)", {
                  code
                })
              });
            }
          }
        }
      }, "mx_Dialog_confirmredact");
    }
  })))) : null;
};
const useRoom = roomId => {
  const room = (0,react.useMemo)(() => {
    const cli = MatrixClientPeg/* MatrixClientPeg */.p.get();
    return cli.getRoom(roomId);
  }, [roomId]);
  return room;
};
const getUrlAndNameOfUser = mxEvent => {
  const cli = MatrixClientPeg/* MatrixClientPeg */.p.get();
  const userId = mxEvent.getSender();
  const user = cli.getUser(userId);
  const url = (0,Avatar/* avatarUrlForUser */.cL)(user, 24, 24, "crop");
  const name = (0,PinnedMsgBar/* getDisplayNameFromEvent */.kD)(mxEvent, cli);
  return {
    url,
    name,
    userId
  };
};
const usePermalinkCreator = room => {
  const permalinkCreator = (0,react.useMemo)(() => {
    const permalinkCreator = new Permalinks/* RoomPermalinkCreator */.w6(room);
    permalinkCreator.load();
    return permalinkCreator;
  }, [room]);
  return permalinkCreator;
};
const getNewEvent = mxEvent => {
  const content = mxEvent.content;
  if (content["m.new_content"]) {
    return new browser_index/* MatrixEvent */.dC(TopicDetailPanel_objectSpread(TopicDetailPanel_objectSpread({}, mxEvent), {}, {
      content: content["m.new_content"]
    }));
  }
  return new browser_index/* MatrixEvent */.dC(mxEvent);
};
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/elements/ReplyThread.tsx
var ReplyThread = __webpack_require__(980531);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/structures/TopicReplyPanel.tsx


















const TopicReplyPanel_FETCH_LIMIT = 50;
const TopicReplyPanel = props => {
  const [curEvent, setCurEvent] = (0,react.useState)(props.event);
  const [offset, setOffset] = (0,react.useState)(0);
  const [data, setData] = (0,react.useState)([]);
  const [loading, setLoading] = (0,react.useState)(false);
  const [hasMore, setHasMore] = (0,react.useState)(false);
  const [location, setLocation] = (0,react.useState)({
    left: 0,
    top: 0
  });
  const exit = (0,react.useCallback)(() => {
    dispatcher/* default */.ZP.dispatch({
      action: actions/* Action */.a.SetRightPanelPhase,
      phase: RightPanelStorePhases/* RightPanelPhases */.q4.TopicDetail,
      refireParams: {
        params: {
          roomId: props.roomId,
          topic: props.topic
        }
      }
    });
  }, [props.roomId, props.topic]);
  (0,react.useEffect)(() => {
    const cli = MatrixClientPeg/* MatrixClientPeg */.p.get();
    setLoading(true);
    const loadMore = refresh => {
      cli.getTopicReply(curEvent.getId(), TopicReplyPanel_FETCH_LIMIT, (refresh ? 0 : offset) * TopicReplyPanel_FETCH_LIMIT).then(res => {
        setHasMore(res.data.length >= TopicReplyPanel_FETCH_LIMIT);
        const evs = res.data.map(v => {
          var _cli$getRoom;
          const ev = getNewEvent(v);
          ev.sender = (_cli$getRoom = cli.getRoom(props.roomId)) === null || _cli$getRoom === void 0 ? void 0 : _cli$getRoom.getMember(ev.getSender());
          return ev;
        });
        setData(v => refresh ? evs : v.concat(evs));
        if (refresh) {
          setOffset(0);
        }
        setLoading(false);
      });
    };
    loadMore(false);
    const handleTimeline = (ev, room) => {
      if (room.roomId !== props.roomId) {
        return;
      }
      if (ReplyThread/* default */.Z.getParentEventId(ev) === curEvent.getId()) {
        loadMore(true);
      }
      if (ev.isRelation("m.replace")) {
        if (curEvent.isRelation("m.replace") && ev.getRelation().event_id === curEvent.getRelation().event_id || ev.getRelation().event_id === curEvent.getId()) {
          var _ev$getContent$mNew_;
          if (((_ev$getContent$mNew_ = ev.getContent()['m.new_content']['m.topic']) === null || _ev$getContent$mNew_ === void 0 ? void 0 : _ev$getContent$mNew_.length) > 0) {
            setCurEvent(ev);
          } else {
            exit();
          }
        } else {
          loadMore(true);
        }
      }
      if (ev.getType() === "m.room.redaction") {
        if (ev.getAssociatedId() === curEvent.getId()) {
          exit();
        } else {
          setData(v => {
            return v.filter(v => v.getId() !== ev.getAssociatedId());
          });
        }
      }
    };
    cli.on('Room.timeline', handleTimeline);
    return () => {
      cli.off('Room.timeline', handleTimeline);
    };
  }, [offset, curEvent, props.roomId, exit]);
  (0,react.useEffect)(() => {
    setCurEvent(props.event);
  }, [props.event]);
  const {
    url,
    name,
    userId
  } = getUrlAndNameOfUser(curEvent);
  const room = useRoom(props.roomId);
  const canSend = useCanSend(room);
  const permalinkCreator = usePermalinkCreator(room);
  const getOriginEvent = ev => {
    if (ev.isRelation("m.replace")) {
      return room.findEventById(ev.getRelation().event_id);
    }
    return ev;
  };
  return /*#__PURE__*/react.createElement(BaseCard/* default */.C, {
    onClose: props.onClose,
    previousPhase: RightPanelStorePhases/* RightPanelPhases */.q4.TopicDetail,
    refireParams: {
      params: {
        roomId: props.roomId,
        topic: props.topic
      }
    },
    header: /*#__PURE__*/react.createElement("div", {
      style: {
        fontSize: 14,
        color: '#E7E8EC',
        marginLeft: 30,
        marginTop: -12,
        textOverflow: 'ellipsis',
        overflow: 'hidden',
        whiteSpace: 'nowrap',
        maxWidth: 300
      }
    }, props.topic),
    withoutScrollContainer: true
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_TopicReply"
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_PinnedEventTile mx_TopicReply_event"
  }, /*#__PURE__*/react.createElement(BaseAvatar/* default */.Z, {
    name: name,
    idName: userId,
    url: url,
    width: 34,
    height: 34,
    className: "avatar"
  }), /*#__PURE__*/react.createElement("div", {
    className: "mx_TopicReply_header"
  }, /*#__PURE__*/react.createElement("div", {
    className: "name"
  }, name), /*#__PURE__*/react.createElement("span", {
    className: "timestamp"
  }, (0,DateUtils/* formatDate */.p6)(new Date(curEvent.getTs())))), /*#__PURE__*/react.createElement("div", {
    className: "mx_PinnedEventTile_message mx_TopicReply_content"
  }, /*#__PURE__*/react.createElement(MessageEvent["default"], {
    mxEvent: curEvent,
    maxImageHeight: 150,
    onHeightChanged: () => {},
    tileShape: EventTile/* TileShape */.GO.Pinned
  })), /*#__PURE__*/react.createElement("div", {
    className: "mx_TopicReply_more"
  }, /*#__PURE__*/react.createElement(RovingTabIndex/* RovingAccessibleTooltipButton */.yy, {
    onClick: () => {
      dispatcher/* default */.ZP.dispatch({
        action: 'view_room',
        event_id: curEvent.getId(),
        highlighted: true,
        room_id: curEvent.getRoomId()
      });
    },
    className: "mx_PinnedEventTile_focusButton",
    title: (0,languageHandler._t)("View message")
  }), /*#__PURE__*/react.createElement(RovingTabIndex/* RovingAccessibleTooltipButton */.yy, {
    onClick: e => {
      const {
        left,
        top
      } = e.target.getBoundingClientRect();
      setLocation({
        left,
        top
      });
    },
    className: "mx_TopicReply_more_opts",
    title: (0,languageHandler._t)("More options")
  })), /*#__PURE__*/react.createElement("div", {
    className: "mx_TopicReply_footer"
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_TopicReply_footer_reply_count"
  }, data.length, " ", (0,languageHandler._t)('replies')))), /*#__PURE__*/react.createElement("div", {
    className: "mx_TopicReply_list"
  }, /*#__PURE__*/react.createElement(AutoHideScrollbar/* default */.Z, null, /*#__PURE__*/react.createElement(TruncatedList/* default */.Z, {
    truncateAt: data.length,
    createOverflowElement: (_, totalCount, ref) => {
      return /*#__PURE__*/react.createElement("div", {
        ref: ref,
        className: "loading"
      }, (0,languageHandler._t)("Loading …"));
    },
    getChildren: () => data.map(mxEvent => {
      const {
        url,
        name,
        userId
      } = getUrlAndNameOfUser(mxEvent);
      return /*#__PURE__*/react.createElement("div", {
        key: mxEvent.getId(),
        className: "mx_TopicReply_list_item mx_PinnedEventTile"
      }, /*#__PURE__*/react.createElement(BaseAvatar/* default */.Z, {
        name: name,
        idName: userId,
        url: url,
        width: 34,
        height: 34,
        className: "avatar"
      }), /*#__PURE__*/react.createElement("div", {
        className: "mx_TopicReply_list_item_content"
      }, /*#__PURE__*/react.createElement("div", {
        className: "header"
      }, /*#__PURE__*/react.createElement("div", {
        className: "name"
      }, name), /*#__PURE__*/react.createElement("span", {
        className: "timestamp"
      }, (0,DateUtils/* formatDate */.p6)(new Date(mxEvent.getTs())))), /*#__PURE__*/react.createElement("div", {
        className: "mx_PinnedEventTile_message"
      }, /*#__PURE__*/react.createElement(MessageEvent["default"], {
        mxEvent: mxEvent,
        maxImageHeight: 150,
        onHeightChanged: () => {},
        tileShape: EventTile/* TileShape */.GO.Pinned
      }))));
    }),
    getChildCount: () => hasMore ? data.length + TopicReplyPanel_FETCH_LIMIT : data.length,
    infinity: true,
    loadMore: () => !loading && hasMore && setOffset(v => v + 1)
  }), !hasMore ? /*#__PURE__*/react.createElement("div", {
    className: "no_more"
  }, (0,languageHandler._t)('No more reply')) : null)), /*#__PURE__*/react.createElement("div", {
    className: "mx_TopicReply_footer"
  }, canSend ? /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(SendMessageComposer/* default */.ZP, {
    room: room,
    placeholder: "reply",
    privateKey: "topic_reply",
    permalinkCreator: permalinkCreator,
    replyInThread: false,
    replyToEvent: getOriginEvent(curEvent),
    disableCache: true
  }), /*#__PURE__*/react.createElement(MessageComposer/* EmojiButton */.Km, {
    addEmoji: emoji => {
      dispatcher/* default */.ZP.dispatch({
        action: actions/* Action */.a.ComposerInsert,
        text: emoji,
        privateKey: 'topic_reply'
      });
      return true;
    },
    menuPosition: {
      right: 20,
      bottom: 500
    }
  })) : null)), /*#__PURE__*/react.createElement(TopicMenu, {
    event: curEvent,
    location: location,
    roomId: props.roomId,
    topic: props.topic,
    onFinished: () => setLocation({
      left: 0,
      top: 0
    }),
    showReply: false,
    onRemove: exit
  }));
};
/* harmony default export */ const structures_TopicReplyPanel = (TopicReplyPanel);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/rooms/PinnedEventTile.tsx
var PinnedEventTile = __webpack_require__(433314);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/right_panel/ChatHistoryCard.tsx








const ChatHistoryCard = props => {
  const [content, setContent] = (0,react.useState)( /*#__PURE__*/react.createElement(Spinner/* default */.Z, null));
  const [roomId, setRoomId] = (0,react.useState)();
  const cli = (0,react.useContext)(MatrixClientContext/* default */.Z);
  (0,react.useEffect)(() => {
    var _props$content$forwar;
    setContent( /*#__PURE__*/react.createElement(Spinner/* default */.Z, null));
    const room = cli.getRoom(props.roomId);
    setContent( /*#__PURE__*/react.createElement(react.Fragment, null, (_props$content$forwar = props.content.forward_list) === null || _props$content$forwar === void 0 ? void 0 : _props$content$forwar.map((ev, i) => {
      const event = new browser_index/* MatrixEvent */.dC(ev);
      if (ev.content['m.forward']) {
        ev.content['m.forward'].level = props.level + 1;
      }
      return /*#__PURE__*/react.createElement(PinnedEventTile/* default */.Z, {
        key: `${event.getId()}_${i}`,
        room: room,
        event: event,
        hideViewMessage: true
      });
    })));
  }, [cli, props.roomId, props.eventId, props.level]);
  return /*#__PURE__*/react.createElement(BaseCard/* default */.C, {
    header: /*#__PURE__*/react.createElement("h2", {
      style: {
        textAlign: 'left',
        fontSize: '16px',
        fontWeight: 600
      }
    }, (0,languageHandler._t)("Forward message")),
    className: "mx_ChatHistoryCard",
    onClose: props.onClose
  }, /*#__PURE__*/react.createElement(RoomHeader, {
    roomId: props.roomId,
    roomName: props.roomName
  }), content);
};
const RoomHeader = props => {
  const cli = (0,react.useContext)(MatrixClientContext/* default */.Z);
  const room = cli.getRoom(props.roomId);
  return /*#__PURE__*/react.createElement("div", {
    className: "mx_ChatHistoryCard_Room_Header"
  }, /*#__PURE__*/react.createElement(RoomAvatar/* default */.Z, {
    size: 38,
    room: room,
    chatHistory: true
  }), /*#__PURE__*/react.createElement("div", {
    className: "mx_ChatHistoryCard_Room_Header_title"
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_ChatHistoryCard_Room_Header_title_name"
  }, props.roomName), room !== null && room !== void 0 && room.getJoinedMemberCount() ? /*#__PURE__*/react.createElement("div", {
    className: "mx_ChatHistoryCard_Room_Header_title_members"
  }, (0,languageHandler._t)('Members'), " ", room === null || room === void 0 ? void 0 : room.getJoinedMemberCount()) : null));
};
/* harmony default export */ const right_panel_ChatHistoryCard = ((/* unused pure expression or super */ null && (ChatHistoryCard)));
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/spaces/ActivityCard.tsx
var ActivityCard = __webpack_require__(161732);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/elements/Dropdown.tsx
var Dropdown = __webpack_require__(893683);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/ActivityStore.ts
var ActivityStore = __webpack_require__(182445);
// EXTERNAL MODULE: ./node_modules/lodash-es/debounce.js
var debounce = __webpack_require__(453434);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/spaces/ActivityManage.tsx


const ActivityManage_excluded = ["onClose"];










const ActivityManage = _ref => {
  let {
      onClose
    } = _ref,
    props = (0,objectWithoutProperties/* default */.Z)(_ref, ActivityManage_excluded);
  const [scrollFLag, setScrollFLag] = (0,react.useState)(1);
  const [refreshFlag, setRefreshFlag] = (0,react.useState)(0);
  const [tab, setTab] = (0,react.useState)("all");
  const [query, setQuery] = (0,react.useState)("");
  const [valueInput, setValueInput] = (0,react.useState)("");
  const [loading, setLoading] = (0,react.useState)(false);
  const [filter, setFilter] = (0,react.useState)("squad");
  const [activities, setActivities] = (0,react.useState)({
    more: 0,
    data: []
  });
  (0,react.useEffect)(() => {
    setLoading(true);
    setActivities({
      more: 0,
      data: []
    });
    ActivityStore/* default */.Z.instance.fetchList(props.roomId, {
      clear: true,
      query,
      filter,
      tab
    }).then(res => {
      if (res && res.data) {
        setActivities(res);
      }
    }).finally(() => setLoading(false));
  }, [query, filter, tab, props.roomId]);
  (0,react.useEffect)(() => {
    const refresh = () => {
      if (tab !== "all") {
        setActivities({
          more: activities.more,
          data: ActivityStore/* default */.Z.instance.resetInterestList()
        });
      } else {
        setRefreshFlag(refreshFlag + 1);
      }
    };
    ActivityStore/* default */.Z.instance.on("ActivityInterested", refresh);
    return () => {
      ActivityStore/* default */.Z.instance.off("ActivityInterested", refresh);
    };
  }, [activities.more, refreshFlag, tab]);
  const onScroll = ev => {
    const target = ev.target;
    if (target.scrollHeight - target.clientHeight - target.scrollTop < 40) {
      if (ActivityStore/* default */.Z.instance.getLoading()) {
        return;
      }
      if (scrollFLag > 0) {
        setScrollFLag(scrollFLag + 1);
      }
      setLoading(true);
      ActivityStore/* default */.Z.instance.fetchList(props.roomId, {
        clear: false,
        filter
      }).then(res => {
        if (res) {
          if (res.data) {
            setActivities(res);
          } else {
            setScrollFLag(-1);
          }
        }
      }).finally(() => setLoading(false));
    }
  };
  const onChangeFilterType = value => {
    if (value !== "all") {
      setQuery("");
      setValueInput("");
    }
    setFilter(value);
    // setContentTokenDetail(value);
  };

  const renderFilter = () => {
    return [{
      title: "All",
      value: "all"
    }, {
      title: "My Squads",
      value: "squads"
    }, {
      title: "In this squad",
      value: "squad"
    }, {
      title: "Friend participation",
      value: "contacts_participate"
    }].map(item => /*#__PURE__*/react.createElement("div", {
      key: item.value,
      className: "mx_ActivityManage_Dropdown_item"
    }, (0,languageHandler._t)(item.title)));
  };
  const renderContent = () => {
    const array = ActivityStore/* default */.Z.instance.getInterests();
    return /*#__PURE__*/react.createElement(react.Fragment, null, tab === "all" && /*#__PURE__*/react.createElement("div", {
      className: classnames_default()("mx_ActivityManage_input_wrap", {
        mx_ActivityManage_input_query: true
      })
    }, /*#__PURE__*/react.createElement("input", {
      className: "mx_ActivityManage_input",
      value: valueInput,
      onChange: ev => {
        setValueInput(ev.target.value);
        (0,debounce/* default */.Z)(ev => {
          setQuery(ev.target.value);
        }, 1000)(ev);
      },
      placeholder: (0,languageHandler._t)("Search")
    }), /*#__PURE__*/react.createElement(Dropdown/* default */.Z, {
      id: "mx_ActivityManage_filter",
      className: "mx_ActivityManage_filter",
      onOptionChange: onChangeFilterType,
      value: filter,
      label: ""
    }, renderFilter())), activities.data.map(item => /*#__PURE__*/react.createElement(ActivityCard/* default */.Z, (0,esm_extends/* default */.Z)({
      key: item.id
    }, item, {
      filter: filter,
      interested: array.includes(item.id)
    }))), loading && /*#__PURE__*/react.createElement(Spinner/* default */.Z, null), !loading && (activities.data.length === 0 || scrollFLag < 0 || activities.more < 0) && /*#__PURE__*/react.createElement("div", {
      className: "mx_ActivityManage_Nomore"
    }, (0,languageHandler._t)("No more results")));
  };
  return /*#__PURE__*/react.createElement(BaseCard/* default */.C, {
    key: tab,
    className: "mx_ActivityManage",
    onClose: onClose,
    onScroll: onScroll,
    header: (0,languageHandler._t)("Events")
  }, /*#__PURE__*/react.createElement(react_dist.Tabs, {
    classNames: "mx_ActivityManage_tabs",
    tabs: [{
      title: (0,languageHandler._t)("Interested"),
      value: "interested",
      action: () => setTab("interested"),
      children: renderContent()
    }, {
      title: (0,languageHandler._t)("All Events"),
      value: "all",
      action: () => setTab("all"),
      children: renderContent()
    }],
    value: tab,
    barWidth: 48
  }));
};
/* harmony default export */ const spaces_ActivityManage = (ActivityManage);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/spaces/ActivityCreate.tsx

const ActivityCreate_excluded = ["onClose"];











const ActivityCreate = _ref => {
  let {
      onClose
    } = _ref,
    props = (0,objectWithoutProperties/* default */.Z)(_ref, ActivityCreate_excluded);
  const [loading, setLoading] = (0,react.useState)(false);
  const [result, setResult] = (0,react.useState)({});
  const [showShare, setShowShare] = (0,react.useState)(false);
  const [orgUrl, setOrgUrl] = (0,react.useState)('');
  const handleShare = () => {
    (0,ForwardDialog/* showForwardDialogWithContent */.H2)({
      msgtype: _types_event/* MsgType */.Zw.Text,
      body: result.url
    }, 'share');
  };
  const startImport = () => {
    setLoading(true);
    ActivityStore/* default */.Z.importActivity(orgUrl).then(res => {
      if (res !== null && res !== void 0 && res.success) {
        setResult(res.data);
      } else {
        Modal/* default */.Z.createDialog(ErrorDialog/* default */.Z, {
          title: (0,languageHandler._t)("Error"),
          description: (0,languageHandler._t)("Event source not supported yet")
        });
      }
    }).finally(() => {
      setLoading(false);
    });
  };
  const startCreate = async () => {
    if (!result.org) {
      return;
    }
    setLoading(true);
    const data = await ActivityStore/* default */.Z.createActivity(props.roomId, result.org);
    if (data.success) {
      setShowShare(true);
    } else {
      Modal/* default */.Z.createDialog(ErrorDialog/* default */.Z, {
        title: (0,languageHandler._t)("Error"),
        description: (0,languageHandler._t)("Event source not supported yet") //data?.error ||
      });
    }

    setLoading(false);
  };
  const renderCreateInfo = () => {
    return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("div", {
      className: "mx_ActivityCreate_tag"
    }, (0,languageHandler._t)("Event link")), /*#__PURE__*/react.createElement("div", {
      className: "mx_ActivityCreate_desc",
      dangerouslySetInnerHTML: {
        __html: (0,languageHandler._t)("We supporting from <span>Flamingle</span> and <span>Soshow</span>")
      }
    }), /*#__PURE__*/react.createElement("div", {
      className: "mx_ActivityCreate_input_wrap"
    }, /*#__PURE__*/react.createElement("input", {
      className: "mx_ActivityCreate_input",
      onChange: ev => setOrgUrl(ev.target.value)
    }), /*#__PURE__*/react.createElement(elements_AccessibleButton/* default */.Z, {
      className: "mx_ActivityCreate_import",
      kind: "primary",
      disabled: loading || !orgUrl,
      onClick: startImport
    }, (0,languageHandler._t)("Import"))), /*#__PURE__*/react.createElement("div", {
      className: "mx_ActivityCreate_tag"
    }, (0,languageHandler._t)("Information")), /*#__PURE__*/react.createElement("div", {
      className: "mx_ActivityCreate_detail"
    }, /*#__PURE__*/react.createElement("div", {
      className: "mx_ActivityCreate_detail_tag"
    }, (0,languageHandler._t)("Name")), /*#__PURE__*/react.createElement("div", null, result.title || '-')), /*#__PURE__*/react.createElement("div", {
      className: "mx_ActivityCreate_detail"
    }, /*#__PURE__*/react.createElement("div", {
      className: "mx_ActivityCreate_detail_tag"
    }, (0,languageHandler._t)("Host")), /*#__PURE__*/react.createElement("div", null, result.host || '-')), /*#__PURE__*/react.createElement("div", {
      className: "mx_ActivityCreate_detail"
    }, /*#__PURE__*/react.createElement("div", {
      className: "mx_ActivityCreate_detail_tag"
    }, (0,languageHandler._t)("Time")), /*#__PURE__*/react.createElement("div", null, (0,ActivityCard/* dateFormat */.v)(result.startTime, result.endTime) || '-')), /*#__PURE__*/react.createElement("div", {
      className: "mx_ActivityCreate_detail"
    }, /*#__PURE__*/react.createElement("div", {
      className: "mx_ActivityCreate_detail_tag"
    }, (0,languageHandler._t)("Location")), /*#__PURE__*/react.createElement("div", null, result.location || '-')), /*#__PURE__*/react.createElement("div", {
      className: "mx_ActivityCreate_tag"
    }, (0,languageHandler._t)("Preview")), /*#__PURE__*/react.createElement("div", {
      className: classnames_default()('mx_ActivityCreate_preview', {
        'mx_ActivityCreate_preview_default': !result.title
      })
    }, result.title ? /*#__PURE__*/react.createElement(ActivityCard/* default */.Z, result) : /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("img", {
      className: "mx_ActivityCreate_preview_img",
      src: __webpack_require__(466451)
    }), (0,languageHandler._t)('Event Card'))), result.title && /*#__PURE__*/react.createElement("div", {
      className: "mx_ActivityCreate_create"
    }, /*#__PURE__*/react.createElement(elements_AccessibleButton/* default */.Z, {
      kind: "primary",
      disabled: loading,
      onClick: startCreate
    }, (0,languageHandler._t)("Create"))));
  };
  const renderShare = () => {
    return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("img", {
      className: "mx_ActivityCreate_share_img",
      src: __webpack_require__(311317)
    }), /*#__PURE__*/react.createElement("div", {
      className: "mx_ActivityCreate_share_title"
    }, (0,languageHandler._t)("All set. Now share your event!")), /*#__PURE__*/react.createElement("div", {
      className: "mx_ActivityCreate_share_desc",
      dangerouslySetInnerHTML: {
        __html: (0,languageHandler._t)("Copy the event link below to invite people<br />to your event. This also acts as a<br />server invite link.")
      }
    }), /*#__PURE__*/react.createElement("div", {
      className: "mx_ActivityCreate_share_url"
    }, "https://SendingMe/ZbxN9rhN?event=10647883..."), /*#__PURE__*/react.createElement(elements_AccessibleButton/* default */.Z, {
      className: "mx_ActivityCreate_share_btn",
      kind: "primary",
      disabled: loading,
      onClick: handleShare
    }, (0,languageHandler._t)("Share")));
  };
  const renderHeader = () => {
    return showShare ? null : (0,languageHandler._t)("Create Event");
  };
  return /*#__PURE__*/react.createElement(BaseCard/* default */.C, {
    className: "mx_ActivityCreate",
    onClose: onClose,
    header: renderHeader()
  }, showShare ? renderShare() : renderCreateInfo());
};
/* harmony default export */ const spaces_ActivityCreate = (ActivityCreate);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/settings/ApproveListPanel.tsx
var ApproveListPanel = __webpack_require__(163485);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/panelcontent/Squad.tsx
var Squad = __webpack_require__(241358);
// EXTERNAL MODULE: ./node_modules/lodash-es/set.js
var set = __webpack_require__(448707);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/OwnProfileStore.ts
var OwnProfileStore = __webpack_require__(580089);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/rooms/GroupNotePanel.tsx

function GroupNotePanel_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function GroupNotePanel_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? GroupNotePanel_ownKeys(Object(t), !0).forEach(function (r) { (0,defineProperty/* default */.Z)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : GroupNotePanel_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }












const createMsg = (content, userId) => {
  const {
    title,
    description,
    layout,
    note_id
  } = content.base_info;
  const notes = content.joined_content_list;
  const result = {
    msgtype: "m.text",
    "m.group_note": content,
    body: `${title}\n${description}\n${layout}\n\n${notes.map(item => item.content).join("\n")}`
  };
  if (notes.length > 3) {
    result.format = "org.matrix.custom.html";
    let array = notes.map((item, index) => {
      if (item.creator !== userId) {
        return "";
      }
      return `${index + 1}. ${item.content}`;
    });
    array = array.filter(item => !!item);
    if (!array.length) {
      const index = notes.length - 1;
      array = [`${index + 1}. ${notes[index]}`];
    }
    result.formatted_body = `${title}\n${description}\n${layout}\n\n<a href='group_note:\/\/${note_id}'>···Expand···<\/a>\n${array.join("\n")}`;
  }
  return result;
};
const initCurrent = detail => {
  const result = {
    count: 1,
    baseInfo: detail.base_info,
    name: "",
    avatar: "",
    notes: [...(detail.joined_content_list || [])].map(item => GroupNotePanel_objectSpread({}, item))
  };
  result.count = new Set(result.notes.map(item => item.creator)).size;
  const user = MatrixClientPeg/* MatrixClientPeg */.p.get().getUser(result.baseInfo.creator);
  if (user) {
    result.name = user.displayName;
    result.avatar = user.avatarUrl;
  }
  return result;
};
const getDetailCreated = (id, userId, name, roomId) => {
  if (id) {
    return {
      baseInfo: {},
      notes: []
    };
  }
  return {
    loading: false,
    baseInfo: {
      creator: userId,
      description: "",
      layout: "",
      note_id: null,
      room_id: roomId,
      title: "#Group_Note"
    },
    name,
    avatar: OwnProfileStore.OwnProfileStore.instance.getHttpAvatarUrl(24),
    count: 0,
    notes: [{
      key: Date.now(),
      creator: userId,
      content: `${name} `
    }]
  };
};
const GroupNotePanel = ({
  onClose,
  room,
  id
}) => {
  const client = MatrixClientPeg/* MatrixClientPeg */.p.get();
  const userId = client.getUserId();
  const name = OwnProfileStore.OwnProfileStore.instance.displayName || (0,strings/* getDisplayUserId */.RL)(userId);
  const [current, setCurrent] = (0,react.useState)(getDetailCreated(id, userId, name, room.roomId));
  const [detail, setDetail] = (0,react.useState)(id ? {
    loading: true,
    baseInfo: {},
    notes: []
  } : null);
  const [focusIndex, setFocusIndex] = (0,react.useState)(-1);
  const [sending, setSending] = (0,react.useState)(false);
  const edit = !!id;
  const notes = current.notes;
  const disableAdd = notes.length ? !notes[notes.length - 1].content : false;
  (0,react.useEffect)(() => {
    if (!+id) {
      return;
    }
    client.getGroupNoteDetail(+id).then(res => {
      setDetail(res);
      setCurrent(initCurrent(res));
    });
  }, [id]);
  const getSendNotes = (data, orgNotes) => {
    const result = [];
    const array = [];
    for (let i = 0; i < data.length; i++) {
      var _orgNotes$i;
      const item = data[i];
      if (item.creator !== userId) {
        if (array.includes(item.content)) {
          return null;
        }
        array.push(item.content);
        continue;
      }
      const content = item.content.trim();
      if (!content) {
        if (item.id === undefined) {
          continue;
        }
        result.push({
          id: item.id,
          content: ""
        });
        continue;
      }
      if (array.includes(content)) {
        return null;
      }
      array.push(content);
      if (content !== ((_orgNotes$i = orgNotes[i]) === null || _orgNotes$i === void 0 ? void 0 : _orgNotes$i.content)) {
        result.push({
          id: item.id,
          content
        });
      }
    }
    return result;
  };
  const getSendNoteCreate = data => {
    const array = [];
    for (let i = 0; i < data.length; i++) {
      const item = data[i];
      const content = item.content.trim();
      if (array.includes(content)) {
        return null;
      }
      if (content) {
        array.push(content);
      }
    }
    return array.map(item => ({
      content: item
    }));
  };
  const checkSend = data => {
    const array = edit ? getSendNotes(data, detail.joined_content_list) : getSendNoteCreate(data);
    return !array ? -1 : array.length;
  };
  const cannotSendFlag = checkSend(notes); // -1 changed 0 nochanged 1 cansend

  const refresh = () => {
    setCurrent(GroupNotePanel_objectSpread({}, current));
  };
  const addNote = () => {
    current.notes.push({
      key: Date.now(),
      content: `${name} `,
      creator: userId
    });
    refresh();
  };
  const changeValue = (event, prop) => {
    (0,set/* default */.Z)(current, prop, event.target.value);
    refresh();
  };
  const changeNote = (event, index) => {
    current.notes[index].content = event.target.value;
    refresh();
  };
  const focusNote = index => {
    setFocusIndex(index);
  };
  const blurNote = index => {
    const notes = current.notes;
    if (index === notes.length - 1) {
      return;
    }
    if (!notes[index].content && notes[index].id === undefined) {
      notes.splice(index, 1);
      refresh();
    }
    if (index === focusIndex) {
      setFocusIndex(-1);
    }
  };
  const trySend = () => {
    const array = edit ? getSendNotes(notes, detail.joined_content_list) : getSendNoteCreate(notes);
    const result = {
      room_id: room.roomId,
      joined_content_list: array,
      title: (current.baseInfo.title || "").trim(),
      description: (current.baseInfo.description || "").trim(),
      layout: (current.baseInfo.layout || "").trim()
    };
    setSending(true);
    return client.createGroupNote(result, current.baseInfo.note_id).then(res => {
      const msg = createMsg(res, userId);
      client.sendMessage(room.roomId, msg).then(dd => {
        setSending(false);
        onClose();
      }).catch(ee => {
        setSending(false);
      });
    }).catch(res => {
      setSending(false);
    });
  };
  const DeleteModal = props => {
    const contentClick = e => {
      e.stopPropagation();
      e.preventDefault();
    };
    const onOk = () => {
      onClose();
      props.onFinished(false);
    };
    return /*#__PURE__*/react.createElement("div", {
      className: "mx_GroupNotePanel_Leave_content",
      onClick: contentClick
    }, /*#__PURE__*/react.createElement("div", {
      className: "mx_GroupNotePanel_Leave_title"
    }, (0,languageHandler._t)("Are you sure to leave?")), /*#__PURE__*/react.createElement("div", {
      className: "mx_GroupNotePanel_Leave_desc"
    }, (0,languageHandler._t)("Your edits to the group note will be lost.")), /*#__PURE__*/react.createElement("div", {
      className: "mx_GroupNotePanel_Leave_btns"
    }, /*#__PURE__*/react.createElement(elements_AccessibleButton/* default */.Z, {
      kind: "secondary",
      onClick: () => {
        props.onFinished(false);
      }
    }, (0,languageHandler._t)("Cancel")), /*#__PURE__*/react.createElement(elements_AccessibleButton/* default */.Z, {
      kind: "danger",
      onClick: onOk
    }, (0,languageHandler._t)("Leave"))));
  };
  const closePanel = () => {
    if (!cannotSendFlag) {
      onClose();
      return;
    }
    Modal/* default */.Z.createDialog(DeleteModal, {}, "mx_GroupNotePanel_Leave_dialog", null, false);
  };
  const renderTag = () => {
    const baseInfo = current.baseInfo;
    return /*#__PURE__*/react.createElement("div", {
      className: "mx_GroupNotePanel_tag"
    }, !(detail !== null && detail !== void 0 && detail.loading) && /*#__PURE__*/react.createElement(BaseAvatar/* default */.Z, {
      className: "mx_GroupNotePanel_avatar",
      url: current.avatar,
      name: current.name,
      idName: baseInfo.creator,
      width: 24,
      height: 24
    }), /*#__PURE__*/react.createElement("div", {
      className: "mx_GroupNotePanel_creator"
    }, (0,languageHandler._t)("Group Note created by <b>%(name)s</b>.", {
      name: current.name
    }, {
      b: name => /*#__PURE__*/react.createElement("b", null, name)
    })), /*#__PURE__*/react.createElement("div", {
      className: "mx_GroupNotePanel_joined"
    }, (0,languageHandler._t)("<b>%(count)s</b> group %(unit)s participating.", {
      count: current.count,
      unit: (0,languageHandler._t)(current.count > 1 ? "members" : "member")
    }, {
      b: count => /*#__PURE__*/react.createElement("b", null, count)
    })));
  };
  const renderNotes = () => {
    let prefix = 0;
    const length = notes.length;
    return notes.map((item, index) => {
      if (!item.content && length - 1 !== index && index !== focusIndex) {
        return null;
      }
      prefix++;
      return /*#__PURE__*/react.createElement("div", {
        key: item.id || item.key,
        className: "mx_GroupNotePanel_input_item"
      }, /*#__PURE__*/react.createElement("div", {
        className: "mx_GroupNotePanel_input_item_prefix"
      }, prefix), /*#__PURE__*/react.createElement("input", {
        disabled: userId !== item.creator,
        value: item.content,
        onChange: event => changeNote(event, index),
        onBlur: () => blurNote(index),
        onFocus: () => focusNote(index)
      }));
    });
  };
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(BaseCard/* default */.C, {
    className: "mx_GroupNotePanel",
    onClose: closePanel,
    header: (0,languageHandler._t)("Group Note")
  }, renderTag(), !edit ? /*#__PURE__*/react.createElement("input", {
    value: current.baseInfo.title,
    className: "mx_GroupNotePanel_title",
    onChange: event => changeValue(event, "baseInfo.title")
  }) : /*#__PURE__*/react.createElement("div", {
    className: "mx_GroupNotePanel_title_show"
  }, current.baseInfo.title), !edit ? /*#__PURE__*/react.createElement("textarea", {
    value: current.baseInfo.description,
    placeholder: (0,languageHandler._t)("Description"),
    onChange: event => changeValue(event, "baseInfo.description")
  }) : /*#__PURE__*/react.createElement("div", {
    className: "mx_GroupNotePanel_description_show"
  }, current.baseInfo.description), current.baseInfo.layout || !edit ? /*#__PURE__*/react.createElement("div", {
    className: "mx_GroupNotePanel_input_item"
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_GroupNotePanel_input_item_prefix"
  }, "Ex."), /*#__PURE__*/react.createElement("input", {
    disabled: edit,
    value: current.baseInfo.layout,
    placeholder: (0,languageHandler._t)("Enter the format for entries"),
    onChange: event => changeValue(event, "baseInfo.layout")
  })) : null, renderNotes(), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()("mx_GroupNotePanel_add", {
      disabled: disableAdd
    }),
    onClick: disableAdd ? null : addNote
  }, (0,languageHandler._t)("Add")), /*#__PURE__*/react.createElement("div", {
    className: "mx_GroupNotePanel_mark"
  }), /*#__PURE__*/react.createElement("div", {
    className: "mx_GroupNotePanel_btns"
  }, /*#__PURE__*/react.createElement(elements_AccessibleButton/* default */.Z, {
    kind: "secondary",
    onClick: closePanel
  }, (0,languageHandler._t)("Cancel")), /*#__PURE__*/react.createElement(elements_AccessibleButton/* default */.Z, {
    kind: "primary",
    disabled: cannotSendFlag < 1,
    onClick: trySend
  }, (0,languageHandler._t)("Send"))), sending || id && detail !== null && detail !== void 0 && detail.loading ? /*#__PURE__*/react.createElement(Spinner/* default */.Z, null) : null));
};
/* harmony default export */ const rooms_GroupNotePanel = (GroupNotePanel);
// EXTERNAL MODULE: ./node_modules/lodash-es/isEmpty.js
var isEmpty = __webpack_require__(479697);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/right_panel/EditUserRemark.tsx

function EditUserRemark_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function EditUserRemark_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? EditUserRemark_ownKeys(Object(t), !0).forEach(function (r) { (0,defineProperty/* default */.Z)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : EditUserRemark_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }












const EditUserRemark = props => {
  const [fileList, setFileList] = (0,react.useState)([]);
  const [loading, setLoading] = (0,react.useState)(false);
  const client = MatrixClientPeg/* MatrixClientPeg */.p.get();
  const user = client.getUser(props.userId);
  const [remark, setRemark] = (0,react.useState)();
  const host = SdkConfig/* default */.Z.get("sdn_homeserver");
  const uploadUrl = `${host}/_file-service/uploadSmallFile`;
  const downloadUrl = `${host}/_file-service/download`;
  const str = localStorage.getItem("mx_Homeserver_Creds");
  const homeserverCreds = JSON.parse(str) || {};
  const {
    accessToken
  } = homeserverCreds;
  (0,react.useEffect)(() => {
    const onChangeRemark = (userid, userRemark) => {
      if (props.userId === userid) {
        setRemark(userRemark);
      }
    };
    browser_index/* RemarkStore */.Tq.get().addListener("User.remark_change", onChangeRemark);
    const _remark = browser_index/* RemarkStore */.Tq.get().getRemarkMap()[props.userId];
    if (!(0,isEmpty/* default */.Z)(_remark === null || _remark === void 0 ? void 0 : _remark.images)) {
      const _fileList = _remark.images.filter(Boolean).map((url, index) => {
        const _url = (0,util/* urlBindAccessToken */.U)(url);
        return {
          uid: Date.now() + "_" + index,
          name: url,
          status: "done",
          url: _url
        };
      });
      setFileList(_fileList);
    }
    setRemark(_remark);
    return () => {
      browser_index/* RemarkStore */.Tq.get().removeListener("User.remark_change", onChangeRemark);
    };
  }, [props.userId]);
  const onChange = ({
    fileList: newFileList
  }) => {
    setFileList(newFileList);
    const images = newFileList.filter(file => file.response).map(file => {
      return `${downloadUrl}?id=${file.response.id}`;
    });
    setRemark(EditUserRemark_objectSpread(EditUserRemark_objectSpread({}, remark), {}, {
      images
    }));
  };
  const onPreview = async file => {
    let src = file.url;
    if (!src) {
      src = await new Promise(resolve => {
        const reader = new FileReader();
        reader.readAsDataURL(file.originFileObj);
        reader.onload = () => resolve(reader.result);
      });
    }
    const image = new Image();
    image.src = src;
    const imgWindow = window.open(src);
    imgWindow === null || imgWindow === void 0 ? void 0 : imgWindow.document.write(image.outerHTML);
  };
  const onChangeName = e => {
    const {
      value
    } = e.target;
    setRemark(EditUserRemark_objectSpread(EditUserRemark_objectSpread({}, remark), {}, {
      name: value
    }));
  };
  const onChangeRemark = e => {
    const {
      value
    } = e.target;
    setRemark(EditUserRemark_objectSpread(EditUserRemark_objectSpread({}, remark), {}, {
      note: value
    }));
  };
  const onSave = async () => {
    setLoading(true);
    const images = fileList.map(file => {
      if (file.response && file.status === "done") {
        return `${downloadUrl}?id=${file.response.id}`;
      } else if (file.url) {
        return file.name;
      }
    });
    await browser_index/* RemarkStore */.Tq.get().setUserRemarkMap(props.userId, EditUserRemark_objectSpread(EditUserRemark_objectSpread({}, remark), {}, {
      images
    }));
    setLoading(false);
    onBack();
  };
  const onBack = () => {
    dispatcher/* default */.ZP.dispatch({
      action: actions/* Action */.a.SetRightPanelPhase,
      phase: RightPanelStorePhases/* RightPanelPhases */.q4.UserProfile,
      refireParams: {
        member: props.member
      }
    });
  };
  return /*#__PURE__*/react.createElement(BaseCard/* default */.C, {
    className: "mx_EditUserRemark",
    onClose: props.onClose
    // header={header}
    ,
    previousPhase: RightPanelStorePhases/* RightPanelPhases */.q4.UserProfile,
    refireParams: {
      member: props.member
    }
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_EditUserRemark_title"
  }, "Edit Contact"), /*#__PURE__*/react.createElement("div", {
    className: "mx_EditUserRemark_content"
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_EditUserRemark_nick_name mx_Field mx_Field_input"
  }, /*#__PURE__*/react.createElement("label", {
    htmlFor: "nick_name"
  }, "Nick Name"), /*#__PURE__*/react.createElement(dist.SdInput, {
    value: remark === null || remark === void 0 ? void 0 : remark.name,
    onChange: onChangeName
  })), /*#__PURE__*/react.createElement("div", {
    className: "mx_EditUserRemark_remark mx_Field mx_Field_textarea"
  }, /*#__PURE__*/react.createElement("label", {
    htmlFor: "remark"
  }, "Note"), /*#__PURE__*/react.createElement(dist.SdTextArea, {
    value: remark === null || remark === void 0 ? void 0 : remark.note,
    onChange: onChangeRemark
  })), /*#__PURE__*/react.createElement(lib.Upload, {
    className: "mx_EditUserRemark_images",
    action: uploadUrl,
    accept: "image/png, image/jpeg",
    listType: "picture-card",
    showUploadList: {
      showPreviewIcon: false
    },
    headers: {
      Authorization: "Bearer " + accessToken
    },
    fileList: fileList,
    onChange: onChange,
    onPreview: onPreview
  }, fileList.length < 3 && "Add Image")), /*#__PURE__*/react.createElement("div", {
    className: "mx_EditUserRemark_buttons"
  }, /*#__PURE__*/react.createElement(dist.SdButton, {
    disabled: loading,
    size: "large",
    type: "associate",
    onClick: onBack
  }, "Cancel"), /*#__PURE__*/react.createElement(dist.SdButton, {
    loading: loading,
    size: "large",
    type: "primary",
    onClick: onSave
  }, "Done")));
};
/* harmony default export */ const right_panel_EditUserRemark = (EditUserRemark);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/points_task/types.ts
let PointView = /*#__PURE__*/function (PointView) {
  PointView[PointView["Mian"] = 0] = "Mian";
  PointView[PointView["Record"] = 1] = "Record";
  PointView[PointView["Rank"] = 2] = "Rank";
  PointView[PointView["Detail"] = 3] = "Detail";
  return PointView;
}({});
// EXTERNAL MODULE: ./node_modules/matrix-js-sdk/src/@types/task.ts
var task = __webpack_require__(357921);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/points_task/RecordList.tsx










const DetailItem = props => {
  const {
    trans_name,
    trans_time_ms,
    trans_point,
    balance
  } = props;
  const isCost = trans_point < 0;
  const isGet = trans_point > 0;
  return /*#__PURE__*/react.createElement("div", {
    className: "trans-list-item"
  }, /*#__PURE__*/react.createElement("div", {
    className: "trans-list-item-inner"
  }, /*#__PURE__*/react.createElement("span", {
    className: classnames_default()([{
      "cost-point": isCost,
      "get-point": isGet
    }])
  }), /*#__PURE__*/react.createElement("div", {
    className: "trans-box"
  }, /*#__PURE__*/react.createElement("span", {
    className: "trans-name"
  }, trans_name), /*#__PURE__*/react.createElement("span", {
    className: "trans-time"
  }, (0,DateUtils/* formatFullDate */.Tu)(new Date(trans_time_ms)))), /*#__PURE__*/react.createElement("div", {
    className: "points-detail"
  }, /*#__PURE__*/react.createElement("span", {
    className: classnames_default()([{
      "cost-detail": isCost,
      "get-detail": isGet
    }])
  }, isGet ? "+" : "", trans_point), /*#__PURE__*/react.createElement("span", {
    className: "balance"
  }, balance)), "\u02DC"));
};
const LIMIT = 10;
const RecordList = props => {
  const [transType, setTrnsType] = (0,react.useState)(task/* TransactionType */.iU.All);
  const [loading, setLoading] = (0,react.useState)(false);
  const [myLoading, setMyLoading] = (0,react.useState)(false);
  const [myPoints, setMyPoints] = (0,react.useState)(0);
  const [list, setList] = (0,react.useState)([]);
  const [offset, setOffset] = (0,react.useState)(0);
  const client = (0,react.useContext)(MatrixClientContext/* default */.Z);
  const ref = (0,react.useRef)(null);
  const ifFinish = (0,react.useRef)(false);
  const onFilter = (filterType, offset = 0) => {
    setLoading(true);
    setTrnsType(filterType);
    client.getPointsTransaction({
      trans_type: filterType,
      offset
    }).then(res => {
      if (res !== null && res !== void 0 && res.data) {
        ifFinish.current = res.data.length < LIMIT;
        if (offset === 0) {
          setList(res.data);
        } else {
          setList(l => [...l, ...res.data]);
        }
      }
      setLoading(false);
    }).catch(() => {
      setLoading(false);
    });
  };
  const onDateChange = date => {
    const start = date.startOf("month");
    const end = date.endOf("month");
  };
  const observer = new IntersectionObserver(entries => {
    entries.forEach(entry => {
      if (entry.isIntersecting && !ifFinish.current) {
        setOffset(offset => offset + LIMIT);
      }
    });
  });
  (0,react.useEffect)(() => {
    if (!ifFinish.current) {
      onFilter(task/* TransactionType */.iU.All, offset);
    }
  }, [offset]);
  (0,react.useEffect)(() => {
    let didCancel = false;
    setMyLoading(true);
    client.getPointsBalance().then(res => {
      if (!didCancel) {
        if ((res === null || res === void 0 ? void 0 : res.balance) >= 0) {
          setMyPoints(res.balance);
          setMyLoading(false);
        }
      }
    }).catch(() => setMyLoading(false));
    return () => {
      didCancel = true;
    };
  }, []);
  (0,react.useEffect)(() => {
    if (ref.current) {
      observer.observe(ref.current);
    }
    return () => {
      observer.disconnect();
    };
  }, [ref.current]);
  let listContent = null;
  if (loading) {
    // listContent = <Spinner />;
    listContent = Array.from({
      length: 8
    }, () => {
      return /*#__PURE__*/react.createElement(PointsListSkeleton, null);
    });
  } else {
    listContent = /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("div", {
      className: "trans-list"
    }, list.map(item => /*#__PURE__*/react.createElement(DetailItem, (0,esm_extends/* default */.Z)({
      key: item.trans_event_id
    }, item)))), list.length >= LIMIT && !ifFinish.current && /*#__PURE__*/react.createElement("div", {
      ref: ref,
      style: {
        textAlign: "center",
        height: 30
      }
    }, loading ? /*#__PURE__*/react.createElement(Spinner/* default */.Z, {
      w: 18,
      h: 18
    }) : "load more"));
  }
  return /*#__PURE__*/react.createElement("div", {
    className: "mx_PointsRecord"
  }, /*#__PURE__*/react.createElement("div", {
    className: "summary"
  }, /*#__PURE__*/react.createElement("h3", null, myLoading ? /*#__PURE__*/react.createElement(dist.SdSkeleton.Button, {
    active: true
  }) : myPoints), /*#__PURE__*/react.createElement("span", null, (0,languageHandler._t)("Points"))), /*#__PURE__*/react.createElement("div", {
    className: "trans-btn-group"
  }, Object.entries(task/* TransactionType */.iU).map(([k, v]) => /*#__PURE__*/react.createElement("span", {
    key: k,
    className: classnames_default()(["trans-btn", {
      "trans-btn-active": v === transType
    }]),
    role: "button",
    onClick: () => onFilter(v)
  }, (0,languageHandler._t)(k)))), listContent);
};
/* harmony default export */ const points_task_RecordList = (RecordList);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/utils/token.ts
var token = __webpack_require__(732094);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/utils/avatar.ts
var utils_avatar = __webpack_require__(9266);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/points_task/PointsRank.tsx












const MyRank = ({
  rankType
}) => {
  const [rank, setRank] = (0,react.useState)();
  const [balance, setBalance] = (0,react.useState)(0);
  const [loading, setLoading] = (0,react.useState)(false);
  const client = (0,react.useContext)(MatrixClientContext/* default */.Z);
  const userId = client.getUserId();
  const avatarSize = 46;
  const displayName = OwnProfileStore.OwnProfileStore.instance.displayName || (0,strings/* getDisplayUserId */.RL)(userId);
  const avatarUrl = OwnProfileStore.OwnProfileStore.instance.getHttpAvatarUrl(avatarSize);
  const walletAddress = OwnProfileStore.OwnProfileStore.instance.walletAddress;
  const isEns = OwnProfileStore.OwnProfileStore.instance.isEns;
  const _displayname = displayName !== null && displayName !== void 0 ? displayName : walletAddress;
  (0,react.useEffect)(() => {
    let didCancel = false;
    setLoading(true);
    client.getMyPointsRank({
      rank_type: rankType
    }).then(({
      rank,
      balance
    }) => {
      if (!didCancel) {
        setRank(rank);
        setBalance(balance);
        setLoading(false);
      }
    }).catch(() => {
      setLoading(false);
    });
    return () => {
      didCancel = true;
    };
  }, [rankType]);
  if (loading) {
    // return <Spinner />;
    return /*#__PURE__*/react.createElement(PointsListSkeleton, null);
  }
  return /*#__PURE__*/react.createElement("div", {
    className: "rank-list-item rank-me"
  }, /*#__PURE__*/react.createElement("div", {
    className: "user-box"
  }, /*#__PURE__*/react.createElement("span", {
    className: classnames_default()(["user-rank", {
      "top-three": +rank <= 3
    }])
  }, rank), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(["user-avatar-box", {
      "is-champion": rank == "1"
    }])
  }, /*#__PURE__*/react.createElement("img", {
    className: "user-avatar",
    src: avatarUrl || (0,utils_avatar/* getDefaultAvatar */.W)({
      id: userId,
      size: 46
    }),
    alt: _displayname
  })), /*#__PURE__*/react.createElement("div", {
    className: "user-info"
  }, /*#__PURE__*/react.createElement("span", {
    className: classnames_default()(["user-name", {
      "user-ens-name": isEns
    }])
  }, _displayname.length > 12 ? `${_displayname.slice(0, 12)}...` : _displayname), /*#__PURE__*/react.createElement("span", {
    className: "user-wallet"
  }, (0,token/* formatWallet */.Tl)(walletAddress)))), /*#__PURE__*/react.createElement("div", {
    className: "user-balance"
  }, /*#__PURE__*/react.createElement("span", {
    className: "user-balance-icon"
  }), balance));
};
const RankListItem = props => {
  const {
    balance,
    displayname,
    avatar_url,
    ens,
    index,
    wallet_address,
    user_id
  } = props;
  const _displayname = displayname !== null && displayname !== void 0 ? displayname : wallet_address;
  return /*#__PURE__*/react.createElement("div", {
    className: "rank-list-item"
  }, /*#__PURE__*/react.createElement("div", {
    className: "rank-list-item-inner"
  }, /*#__PURE__*/react.createElement("div", {
    className: "user-box"
  }, /*#__PURE__*/react.createElement("span", {
    className: classnames_default()(["user-rank", {
      "top-three": index <= 3
    }])
  }, index), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(["user-avatar-box", {
      "is-champion": index === 1
    }])
  }, /*#__PURE__*/react.createElement("img", {
    className: "user-avatar",
    src: avatar_url || (0,utils_avatar/* getDefaultAvatar */.W)({
      id: user_id,
      size: 46
    }),
    alt: _displayname
  })), /*#__PURE__*/react.createElement("div", {
    className: "user-info"
  }, /*#__PURE__*/react.createElement("span", {
    className: classnames_default()(["user-name", {
      "user-ens-name": ens
    }])
  }, _displayname.length > 12 ? `${_displayname.slice(0, 12)}...` : _displayname), /*#__PURE__*/react.createElement("span", {
    className: "user-wallet"
  }, (0,token/* formatWallet */.Tl)(wallet_address)))), /*#__PURE__*/react.createElement("div", {
    className: "user-balance"
  }, balance)));
};
const RankTypeTab = props => {
  const {
    rankType,
    onRankTypeChange
  } = props;
  return /*#__PURE__*/react.createElement("div", {
    className: "rank-tabs"
  }, /*#__PURE__*/react.createElement("span", {
    className: classnames_default()({
      "rank-tab-active": task/* RankType */.cP.Daily === rankType
    }),
    onClick: () => onRankTypeChange(task/* RankType */.cP.Daily)
  }, "24H"), /*#__PURE__*/react.createElement("span", {
    className: classnames_default()({
      "rank-tab-active": task/* RankType */.cP.Total === rankType
    }),
    onClick: () => onRankTypeChange(task/* RankType */.cP.Total)
  }, (0,languageHandler._t)("Total")));
};
const PointsRank_LIMIT = 10;
const PointsRank = props => {
  const [rankType, setRankType] = (0,react.useState)(task/* RankType */.cP.Daily);
  const [ranks, setRanks] = (0,react.useState)([]);
  const [loading, setLoading] = (0,react.useState)(false);
  const [offset, setOffset] = (0,react.useState)(0);
  const client = (0,react.useContext)(MatrixClientContext/* default */.Z);
  const ref = (0,react.useRef)(null);
  const ifFinish = (0,react.useRef)(false);
  const observer = new IntersectionObserver(entries => {
    entries.forEach(entry => {
      console.log(entry);
      if (entry.isIntersecting) {
        setOffset(offset => offset + 10);
      }
    });
  });
  (0,react.useEffect)(() => {
    let didCancel = false;
    setLoading(true);
    client.getPointsRank({
      rank_type: rankType,
      offset
    }).then(res => {
      if (!didCancel) {
        ifFinish.current = res.data.length < PointsRank_LIMIT;
        if (offset === 0) {
          setRanks(res.data);
        } else {
          setRanks(r => [...r, ...res.data]);
        }
        setLoading(false);
      }
    }).catch(() => {
      setLoading(false);
    });
    return () => {
      didCancel = true;
    };
  }, [rankType, offset]);
  (0,react.useEffect)(() => {
    if (ref.current) {
      observer.observe(ref.current);
    }
    return () => {
      observer.disconnect();
    };
  }, [ref.current]);
  return /*#__PURE__*/react.createElement("div", {
    className: "mx_PointsRank"
  }, /*#__PURE__*/react.createElement(MyRank, {
    rankType: rankType
  }), /*#__PURE__*/react.createElement(RankTypeTab, {
    rankType: rankType,
    onRankTypeChange: type => {
      ifFinish.current = false;
      setRanks([]);
      setRankType(type);
      setOffset(0);
    }
  }), loading && ranks.length === 0 && Array.from({
    length: 8
  }, () => {
    return /*#__PURE__*/react.createElement(PointsListSkeleton, null);
  }), /*#__PURE__*/react.createElement("div", {
    className: "rank-list"
  }, ranks.map((item, index) => /*#__PURE__*/react.createElement(RankListItem, (0,esm_extends/* default */.Z)({
    key: item.user_id,
    index: index + 1
  }, item)))), ranks.length >= PointsRank_LIMIT && !ifFinish.current && /*#__PURE__*/react.createElement("div", {
    ref: ref,
    style: {
      textAlign: "center",
      height: 30
    }
  }, loading ? /*#__PURE__*/react.createElement(Spinner/* default */.Z, {
    w: 18,
    h: 18
  }) : "load more"));
};
/* harmony default export */ const points_task_PointsRank = (PointsRank);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/points_task/PointsViewContext.ts

const PointsViewContext = /*#__PURE__*/(0,react.createContext)(null);
/* harmony default export */ const points_task_PointsViewContext = (PointsViewContext);
// EXTERNAL MODULE: ./node_modules/lodash-es/groupBy.js
var groupBy = __webpack_require__(515643);
// EXTERNAL MODULE: ./node_modules/lodash-es/toPairs.js
var toPairs = __webpack_require__(440471);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/LeftPanelStore.ts
var LeftPanelStore = __webpack_require__(290884);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/lib/authorize/twitter.ts
var twitter = __webpack_require__(182574);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/points_task/FollowX.tsx










/* harmony default export */ const FollowX = (/*#__PURE__*/(0,react.memo)(function FollowX(props) {
  const {
    task_name,
    extra_json,
    task_status,
    reward_count,
    task_id,
    task_logo,
    onCollected
  } = props;
  const [taskStatus, setTaskStatus] = (0,react.useState)(task_status);
  const [loading, setLoading] = (0,react.useState)(false);
  const [showToast, setShowToast] = (0,react.useState)(false);
  const client = (0,react.useMemo)(() => MatrixClientPeg/* MatrixClientPeg */.p.get(), []);
  const {
    data
  } = (0,ahooks_lib.useRequest)(() => client === null || client === void 0 ? void 0 : client.getTwitterBaseInfo(), {
    refreshDeps: [client]
  });
  const onClaimed = (0,react.useCallback)(async e => {
    e.preventDefault();
    e.stopPropagation();
    if (taskStatus === task/* TaskStatus */.hY.FinishedAndNotReceived) {
      setShowToast(true);
      setLoading(true);
      client.postPointsBalance({
        task_id,
        trans_type: task/* TransactionType */.iU.Claimed
      }).then(res => {
        if (res !== null && res !== void 0 && res.balance) {
          onCollected(res.balance);
          setTaskStatus(task/* TaskStatus */.hY.Received);
          setTimeout(() => {
            setShowToast(false);
          }, 2000);
        }
      }).catch(() => {
        dist.SdMessage.error("you claimed this fail, please try later!");
      }).finally(() => setLoading(false));
    }
  }, [taskStatus, client]);
  const handleStorage = async ev => {
    if (ev.key === "task_x_bind") {
      try {
        const authCode = JSON.parse(localStorage.getItem("task_x_bind"));
        if (authCode !== null && authCode !== void 0 && authCode.code) {
          repostTweet(extra_json.tweet_id);
          client.authTwitterCode(authCode.code);
        }
      } catch {
        lib.Modal.error({
          title: "Connect X failed",
          content: "We can't connect your twitter account. Please try again."
        });
      }
    }
  };
  const onFollow = () => {
    window.removeEventListener("storage", handleStorage);
    if (data) {
      repostTweet(extra_json.tweet_id);
    } else {
      (0,twitter/* openXAuthWindow */.U)("task_x_bind");
      window.addEventListener("storage", handleStorage, false);
    }
  };
  const onVerify = async () => {
    try {
      const {
        task_status
      } = await client.verfiyRepostTweet(extra_json.tweet_id);
      if (task_status === 2) {
        lib.Modal.error({
          title: "Verify Failed",
          content: "The twitter account connected with current SendingMe account has already claimed point. Please choose a new twitter account to connect."
        });
      } else if (task_status === 1) {
        setTaskStatus(task/* TaskStatus */.hY.FinishedAndNotReceived);
      } else {
        lib.Modal.error({
          title: "Verify Failed",
          content: "Please check if you have repost the specified tweet"
        });
      }
    } catch (err) {
      lib.Modal.error({
        title: "Verify Failed",
        content: "You have not authorized your X account. Please connect your X account." //err?.data?.error || JSON.stringify(err),
      });
    }
  };

  (0,react.useEffect)(() => {
    return () => {
      window.removeEventListener("storage", handleStorage);
    };
  }, []);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("div", {
    className: "task-item"
  }, /*#__PURE__*/react.createElement("div", {
    className: "task-item-inner"
  }, /*#__PURE__*/react.createElement("div", {
    className: "task-info"
  }, /*#__PURE__*/react.createElement("img", {
    src: task_logo,
    className: "task-logo",
    alt: task_name
  }), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()({
      "flex flex-col flex-1 justify-between": true,
      "self-stretch": (extra_json === null || extra_json === void 0 ? void 0 : extra_json.required_count) > 0
    })
  }, /*#__PURE__*/react.createElement("span", {
    className: "task-name"
  }, task_name), taskStatus === task/* TaskStatus */.hY.NotFinished && /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement(lib.Button, {
    type: "link",
    onClick: onFollow,
    style: {
      paddingLeft: 0
    }
  }, "Repost"), /*#__PURE__*/react.createElement(lib.Button, {
    type: "link",
    onClick: onVerify
  }, "Verify")))), /*#__PURE__*/react.createElement("span", {
    role: "button",
    className: classnames_default()(["task-point-num-btn", {
      "task-point-num-notfinished": taskStatus === task/* TaskStatus */.hY.NotFinished,
      "task-point-num-active": taskStatus === task/* TaskStatus */.hY.FinishedAndNotReceived,
      "task-point-num-received": taskStatus === task/* TaskStatus */.hY.Received
    }]),
    onClick: onClaimed
  }, taskStatus === task/* TaskStatus */.hY.Received ? "Claimed" : /*#__PURE__*/react.createElement(react.Fragment, null, "+", reward_count)))), showToast && /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement("div", {
    className: "task-toast"
  }), /*#__PURE__*/react.createElement("div", {
    className: "task-toast-content"
  }, loading ? /*#__PURE__*/react.createElement(Spinner/* default */.Z, null) : /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("span", null, (0,languageHandler._t)("You have obtained")), /*#__PURE__*/react.createElement("span", {
    className: "points"
  }, "+", reward_count), /*#__PURE__*/react.createElement("span", null, "Points")))));
}));
function followSendingLabs() {
  window.open("https://twitter.com/intent/follow?screen_name=SendingLabs", "SendingLabs", "popup");
}
function repostTweet(tweetId) {
  window.open(`https://twitter.com/intent/retweet?tweet_id=${tweetId}`, "SendingLabs", "popup");
}
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/lib/authorize/popupWinConf.ts
var popupWinConf = __webpack_require__(426652);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/lib/authorize/discord.ts


const openDiscordAuthWindow = (state = "discord") => {
  var _SdkConfig$get;
  const clientId = ((_SdkConfig$get = SdkConfig/* default */.Z.get("thirdKeys")) === null || _SdkConfig$get === void 0 ? void 0 : _SdkConfig$get.discordClientId) || "1217302706297901146";
  const searchParams = new URLSearchParams({
    response_type: "code",
    client_id: clientId,
    scope: ["identify", "guilds", "email",
    // "dm_channels.read",
    // "role_connections.write",
    "guilds.members.read"
    // "relationships.read",
    ].join(" "),
    state: state
  });
  const queryString = [`redirect_uri=${popupWinConf/* redirectUri */.Bx}`, searchParams.toString()].join("&");
  window.open(`https://discord.com/oauth2/authorize?${queryString}`, "SendingMeAuthWin", popupWinConf/* windowFeatures */.Y_);
};
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/points_task/JoinDiscord.tsx










/* harmony default export */ const JoinDiscord = (/*#__PURE__*/(0,react.memo)(function JoinDiscord(props) {
  const {
    task_name,
    extra_json,
    task_status,
    reward_count,
    task_id,
    task_logo,
    onCollected
  } = props;
  const [taskStatus, setTaskStatus] = (0,react.useState)(task_status);
  const [loading, setLoading] = (0,react.useState)(false);
  const [showToast, setShowToast] = (0,react.useState)(false);
  const client = (0,react.useMemo)(() => MatrixClientPeg/* MatrixClientPeg */.p.get(), []);
  const {
    data,
    run,
    runAsync
  } = (0,ahooks_lib.useRequest)(code => client.bindDiscord(code), {
    manual: true,
    refreshDeps: [client]
  });
  const onClaimed = (0,react.useCallback)(async e => {
    e.preventDefault();
    e.stopPropagation();
    if (taskStatus === task/* TaskStatus */.hY.FinishedAndNotReceived) {
      setShowToast(true);
      setLoading(true);
      client.postPointsBalance({
        task_id,
        trans_type: task/* TransactionType */.iU.Claimed
      }).then(res => {
        if (res !== null && res !== void 0 && res.balance) {
          onCollected(res.balance);
          setTaskStatus(task/* TaskStatus */.hY.Received);
          setTimeout(() => {
            setShowToast(false);
          }, 2000);
        }
      }).catch(() => {
        dist.SdMessage.error("you claimed this fail, please try later!");
      }).finally(() => setLoading(false));
    }
  }, [taskStatus]);
  const handleStorage = async ev => {
    if (ev.key === "task_discord_bind") {
      try {
        const {
          code
        } = JSON.parse(ev.newValue);
        if (code) {
          await runAsync(code);
          joinSendingLabs(extra_json.squad_name);
        }
      } catch {
        lib.Modal.error({
          title: "Connect Discord Failed",
          content: "We can't connect your discord account. Please try again."
        });
      }
    }
  };
  const onJoin = () => {
    window.removeEventListener("storage", handleStorage);
    if (data) {
      joinSendingLabs(extra_json.squad_name);
    } else {
      openDiscordAuthWindow("task_discord_bind");
      window.addEventListener("storage", handleStorage, false);
    }
  };
  const onVerify = async () => {
    try {
      const {
        task_status
      } = await client.verfiyJoinDiscord(extra_json.squad_id);
      if (task_status === 2) {
        lib.Modal.error({
          title: "Verify Failed",
          content: "The discord account connected with current SendingMe account has already claimed point. Please choose a new discord account to connect."
        });
      } else if (task_status === 1) {
        setTaskStatus(task/* TaskStatus */.hY.FinishedAndNotReceived);
      } else {
        lib.Modal.error({
          title: "Verify Failed",
          content: "Please check if you have joined specified discord squad"
        });
      }
    } catch (err) {
      lib.Modal.error({
        title: "Verify Failed",
        content: "You have not authorized your Discord account. Please connect your Discord account." //err?.data?.error || JSON.stringify(err),
      });
    }
  };

  (0,react.useEffect)(() => {
    if (client) {
      run();
    }
    return () => {
      window.removeEventListener("storage", handleStorage);
    };
  }, [client]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("div", {
    className: "task-item"
  }, /*#__PURE__*/react.createElement("div", {
    className: "task-item-inner"
  }, /*#__PURE__*/react.createElement("div", {
    className: "task-info"
  }, /*#__PURE__*/react.createElement("img", {
    src: task_logo,
    className: "task-logo",
    alt: task_name
  }), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()({
      "flex flex-col flex-1 justify-between": true,
      "self-stretch": (extra_json === null || extra_json === void 0 ? void 0 : extra_json.required_count) > 0
    })
  }, /*#__PURE__*/react.createElement("span", {
    className: "task-name"
  }, task_name), taskStatus === task/* TaskStatus */.hY.NotFinished && /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement(lib.Button, {
    type: "link",
    onClick: onJoin,
    style: {
      paddingLeft: 0
    }
  }, "Join"), /*#__PURE__*/react.createElement(lib.Button, {
    type: "link",
    onClick: onVerify
  }, "Verify")))), /*#__PURE__*/react.createElement("span", {
    role: "button",
    className: classnames_default()(["task-point-num-btn", {
      "task-point-num-notfinished": taskStatus === task/* TaskStatus */.hY.NotFinished,
      "task-point-num-active": taskStatus === task/* TaskStatus */.hY.FinishedAndNotReceived,
      "task-point-num-received": taskStatus === task/* TaskStatus */.hY.Received
    }]),
    onClick: onClaimed
  }, taskStatus === task/* TaskStatus */.hY.Received ? "Claimed" : /*#__PURE__*/react.createElement(react.Fragment, null, "+", reward_count)))), showToast && /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement("div", {
    className: "task-toast"
  }), /*#__PURE__*/react.createElement("div", {
    className: "task-toast-content"
  }, loading ? /*#__PURE__*/react.createElement(Spinner/* default */.Z, null) : /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("span", null, (0,languageHandler._t)("You have obtained")), /*#__PURE__*/react.createElement("span", {
    className: "points"
  }, "+", reward_count), /*#__PURE__*/react.createElement("span", null, "Points")))));
}));
function joinSendingLabs(squadName) {
  window.open(`https://discord.com/invite/${squadName}`, "SendingLabs", "popup");
}
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/points_task/TaskList.tsx

















const TaskRowItem = props => {
  var _extra_json$bar_unit2;
  const {
    task_name,
    extra_json,
    task_status,
    reward_count,
    action_type,
    task_id,
    task_logo,
    count_status,
    need_load_task,
    onCollected
  } = props;
  const [taskStatus, setTaskStatus] = (0,react.useState)(task_status);
  const [countStatus, setCountStatus] = (0,react.useState)(count_status);
  const [loading, setLoading] = (0,react.useState)(false);
  const [showToast, setShowToast] = (0,react.useState)(false);
  const client = (0,react.useContext)(MatrixClientContext/* default */.Z);
  const getPoints = (0,react.useCallback)(async e => {
    e.preventDefault();
    e.stopPropagation();
    if (taskStatus === task/* TaskStatus */.hY.FinishedAndNotReceived) {
      setShowToast(true);
      setLoading(true);
      client.postPointsBalance({
        task_id,
        trans_type: task/* TransactionType */.iU.Claimed
      }).then(res => {
        if (res !== null && res !== void 0 && res.balance) {
          onCollected(res.balance);
          setTaskStatus(task/* TaskStatus */.hY.Received);
          setTimeout(() => {
            setShowToast(false);
          }, 2000);
        }
      }).catch(() => {
        dist.SdMessage.error("you claimed this fail, please try later!");
      }).finally(() => setLoading(false));
    }
  }, [taskStatus]);
  const changeView = () => {
    const link = extra_json === null || extra_json === void 0 ? void 0 : extra_json.link;
    if (action_type === task/* TaskAction */.Vv.Transfer) {
      dispatcher/* default */.ZP.dispatch({
        action: actions/* Action */.a.SetRightPanelPhase,
        phase: RightPanelStorePhases/* RightPanelPhases */.q4.IframeWidget,
        refireParams: {
          params: {
            title: "Transfer",
            src: link
          }
        }
      });
      return;
    }
    if (link.startsWith("#/explore") || link.startsWith("#/inbox") || link.startsWith("#/markets")) {
      if (link.startsWith("#/explore")) {
        dispatcher/* default */.ZP.dispatch({
          action: LeftPanelStore/* CHANGE_LEFT_PANEL_UI_STATE */.Us,
          target: LeftPanelStore/* EXPLORE_TAB */.bA,
          value: {
            clientId: extra_json === null || extra_json === void 0 ? void 0 : extra_json.room_id,
            openPanel: extra_json === null || extra_json === void 0 ? void 0 : extra_json.open_panel
          }
        });
        LeftPanelStore/* default */.ZP.instance.updateSelected(LeftPanelStore/* EXPLORE_TAB */.bA);
      }
      if (link.startsWith("#/inbox")) {
        LeftPanelStore/* default */.ZP.instance.updateSelected(LeftPanelStore/* INBOX_TAB */.J9);
      }
      if (link.startsWith("#/markets")) {
        LeftPanelStore/* default */.ZP.instance.updateSelected(LeftPanelStore/* DAPP_TAB */.bJ);
      }
      dispatcher/* default */.ZP.dispatch({
        action: actions/* Action */.a.ShowRoomPanel
      });
      dispatcher/* default */.ZP.dispatch({
        action: actions/* Action */.a.HideLeftPanel
      });
    } else if (link.startsWith("#/room")) {
      dispatcher/* default */.ZP.dispatch({
        action: "view_room",
        room_id: link.replace("#/room/", "")
      });
    } else if (link.startsWith("#/search/user")) {
      (0,RoomInvite/* showStartChatInviteDialog */.VR)();
    } else if (link.startsWith("#/walletassets")) {
      const user = client.getUser(client.getUserId());
      dispatcher/* default */.ZP.dispatch({
        action: actions/* Action */.a.SetRightPanelPhase,
        phase: RightPanelStorePhases/* RightPanelPhases */.q4.AssetsMore,
        refireParams: {
          member: user,
          params: {
            showAssetMore: true,
            assetDefaultTab: "tokens",
            network: "ethereum",
            userId: client.getUserId(),
            walletAddress: user.walletAddress
          }
        }
      });
    } else {
      var _subAction$split;
      const [view, subAction] = link.replace(/^[^a-zA-z]*/, "").split("?");
      dispatcher/* default */.ZP.dispatch({
        action: `view_${view}`,
        subAction: subAction === null || subAction === void 0 ? void 0 : (_subAction$split = subAction.split("=")) === null || _subAction$split === void 0 ? void 0 : _subAction$split[1]
      }, true);
      if (view === "recommendation") {
        LeftPanelStore/* default */.ZP.instance.updateSelected(LeftPanelStore/* CONTACT_TAB */.YJ);
      }
    }
  };
  (0,react.useEffect)(() => {
    if (need_load_task) {
      client.getTaskStatus(task_id).then(res => {
        setTaskStatus(res.task_status);
        setCountStatus(res.count_status);
      });
    }
  }, []);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("div", {
    className: "task-item",
    onClick: changeView
  }, /*#__PURE__*/react.createElement("div", {
    className: "task-item-inner"
  }, /*#__PURE__*/react.createElement("div", {
    className: "task-info"
  }, /*#__PURE__*/react.createElement("img", {
    className: "task-logo",
    src: task_logo,
    alt: task_name
  }), /*#__PURE__*/react.createElement("div", {
    style: {
      cursor: extra_json !== null && extra_json !== void 0 && extra_json.link ? "pointer" : "default"
    }
  }, /*#__PURE__*/react.createElement("div", {
    className: "task-name"
  }, task_name), (extra_json === null || extra_json === void 0 ? void 0 : extra_json.required_count) > 0 && (extra_json !== null && extra_json !== void 0 && extra_json.bar_display ? /*#__PURE__*/react.createElement(lib.Progress, {
    format: () => {
      var _extra_json$bar_unit;
      return /*#__PURE__*/react.createElement("span", {
        style: {
          whiteSpace: "normal",
          width: "6em",
          display: "block"
        }
      }, countStatus, "/", extra_json.required_count, (_extra_json$bar_unit = extra_json.bar_unit) !== null && _extra_json$bar_unit !== void 0 ? _extra_json$bar_unit : "");
    },
    percent: countStatus / extra_json.required_count * 100,
    style: {
      width: "140px"
    },
    strokeColor: "#FC774B",
    size: "small"
  }) : /*#__PURE__*/react.createElement("span", {
    className: classnames_default()({
      "task-point-num-finished": taskStatus !== task/* TaskStatus */.hY.NotFinished
    })
  }, countStatus, (_extra_json$bar_unit2 = extra_json.bar_unit) !== null && _extra_json$bar_unit2 !== void 0 ? _extra_json$bar_unit2 : "")))), /*#__PURE__*/react.createElement("span", {
    className: classnames_default()(["task-point-num-btn", {
      "task-point-num-notfinished": taskStatus === task/* TaskStatus */.hY.NotFinished,
      "task-point-num-active": taskStatus === task/* TaskStatus */.hY.FinishedAndNotReceived,
      "task-point-num-received": taskStatus === task/* TaskStatus */.hY.Received
    }]),
    onClick: getPoints
  }, taskStatus === task/* TaskStatus */.hY.Received ? "Claimed" : /*#__PURE__*/react.createElement(react.Fragment, null, "+", reward_count)))), showToast && /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement("div", {
    className: "task-toast"
  }), /*#__PURE__*/react.createElement("div", {
    className: "task-toast-content"
  }, loading ? /*#__PURE__*/react.createElement(Spinner/* default */.Z, null) : /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("span", null, (0,languageHandler._t)("You have obtained")), /*#__PURE__*/react.createElement("span", {
    className: "points"
  }, "+", reward_count), /*#__PURE__*/react.createElement("span", null, "Points")))));
};
const GuideTaskItem = props => {
  const {
    task_logo,
    task_name,
    task_name_tips,
    task_desc,
    link
  } = props;
  return /*#__PURE__*/react.createElement("div", {
    className: "task-item"
  }, /*#__PURE__*/react.createElement("div", {
    className: "task-item-inner"
  }, /*#__PURE__*/react.createElement("div", {
    className: "task-info"
  }, /*#__PURE__*/react.createElement("img", {
    className: "task-logo",
    src: task_logo
  }), /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement("div", {
    className: "task-name"
  }, task_name, /*#__PURE__*/react.createElement("span", {
    style: {
      color: "#FC774B",
      fontSize: 10,
      marginLeft: 6
    },
    dangerouslySetInnerHTML: {
      __html: task_name_tips
    }
  })), /*#__PURE__*/react.createElement("div", {
    dangerouslySetInnerHTML: {
      __html: task_desc
    }
  }))), /*#__PURE__*/react.createElement("a", {
    href: link,
    target: "_blank",
    className: "task-point-num-btn task-point-num-active"
  }, "Go")));
};
const TaskList = ({
  onCollected
}) => {
  var _guideTasks$subtask;
  const [list, setList] = (0,react.useState)({});
  const [guideTasks, setGuideTasks] = (0,react.useState)();
  const [loading, setLoading] = (0,react.useState)(false);
  const client = (0,react.useContext)(MatrixClientContext/* default */.Z);
  const taskGroupName = {
    [task/* TaskType */.UA.New]: (0,languageHandler._t)("New User Tasks"),
    [task/* TaskType */.UA.Daily]: (0,languageHandler._t)("Daily Tasks")
  };
  (0,react.useEffect)(() => {
    let didCancel = false;
    setLoading(true);
    client.getPointsTaskList().then(res => {
      if (!didCancel && !(0,isEmpty/* default */.Z)(res === null || res === void 0 ? void 0 : res.data)) {
        setList((0,groupBy/* default */.Z)(res.data, "task_type"));
        setGuideTasks(res.guide_tasks);
        setLoading(false);
      }
    }).catch(() => {
      setLoading(false);
    });
    return () => {
      didCancel = true;
    };
  }, []);
  if (loading) {
    // return <Spinner />;
    return /*#__PURE__*/react.createElement("div", {
      className: "mx_points_list_skeleton"
    }, Array.from({
      length: 5
    }, () => {
      return /*#__PURE__*/react.createElement("div", {
        className: "mx_points_list_skeleton_item"
      }, /*#__PURE__*/react.createElement(dist.SdSkeleton.Avatar, {
        active: true
      }), /*#__PURE__*/react.createElement("div", {
        className: "mx_points_list_skeleton_center"
      }, /*#__PURE__*/react.createElement(dist.SdSkeleton.Input, {
        active: true
      }), /*#__PURE__*/react.createElement(dist.SdSkeleton.Input, {
        active: true
      })), /*#__PURE__*/react.createElement(dist.SdSkeleton.Button, {
        active: true
      }));
    }));
  }
  return /*#__PURE__*/react.createElement("div", {
    className: "mx_PointsTask_list"
  }, guideTasks && /*#__PURE__*/react.createElement("div", {
    key: guideTasks.task_name
  }, /*#__PURE__*/react.createElement("h3", {
    className: "task-group-name",
    style: {
      paddingBottom: 0,
      marginBottom: 0
    }
  }, guideTasks.task_name), /*#__PURE__*/react.createElement("p", {
    style: {
      fontSize: 10,
      paddingLeft: 15,
      color: "#979797"
    }
  }, guideTasks.task_desc), (_guideTasks$subtask = guideTasks.subtask) === null || _guideTasks$subtask === void 0 ? void 0 : _guideTasks$subtask.map(item => /*#__PURE__*/react.createElement(GuideTaskItem, item))), (0,toPairs/* default */.Z)(list).map(([taskType, tasks]) => {
    return /*#__PURE__*/react.createElement("div", {
      key: taskType
    }, /*#__PURE__*/react.createElement("h3", {
      className: "task-group-name"
    }, taskGroupName[taskType]), tasks.map(item => {
      if (item.action_type === task/* TaskAction */.Vv.Twitter) {
        return /*#__PURE__*/react.createElement(FollowX, (0,esm_extends/* default */.Z)({
          key: item.task_id
        }, item, {
          onCollected: onCollected
        }));
      } else if (item.action_type === task/* TaskAction */.Vv.Discord) {
        return /*#__PURE__*/react.createElement(JoinDiscord, (0,esm_extends/* default */.Z)({
          key: item.task_id
        }, item, {
          onCollected: onCollected
        }));
      } else {
        return /*#__PURE__*/react.createElement(TaskRowItem, (0,esm_extends/* default */.Z)({
          key: item.task_id
        }, item, {
          onCollected: onCollected
        }));
      }
    }));
  }));
};
/* harmony default export */ const points_task_TaskList = (TaskList);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/elements/AccessibleTooltipButton.tsx
var AccessibleTooltipButton = __webpack_require__(717919);
// EXTERNAL MODULE: ./node_modules/lodash-es/noop.js
var noop = __webpack_require__(442054);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/elements/Tooltip.tsx
var Tooltip = __webpack_require__(578413);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/points_task/PointsTaskView.tsx












const PointTip = () => {
  return /*#__PURE__*/react.createElement("div", {
    className: "mx_PointTask_tip"
  }, /*#__PURE__*/react.createElement("h2", null, (0,languageHandler._t)("SendingMe Points")), /*#__PURE__*/react.createElement("p", null, (0,languageHandler._t)("The non-tradable tokens that are your testament to active engagement.")), /*#__PURE__*/react.createElement("ul", null, /*#__PURE__*/react.createElement("li", null, (0,languageHandler._t)("Secure your spot for exclusive airdrops. ✅")), /*#__PURE__*/react.createElement("li", null, (0,languageHandler._t)("Use points to unlock advanced app functionalities. 🔓")), /*#__PURE__*/react.createElement("li", null, (0,languageHandler._t)("Trade your points for exciting items in our Points Store. 🎁")), /*#__PURE__*/react.createElement("li", null, (0,languageHandler._t)("Stay active, and you'll be in for a world of unexpected rewards! 🚀"))));
};
const PointCard = ({
  balance
}) => {
  const [points, setPoints] = (0,react.useState)(0);
  const [total, setTotal] = (0,react.useState)(0);
  const [boostRate, setBoostRate] = (0,react.useState)(0);
  const [loading, setLoading] = (0,react.useState)(false);
  const totalRef = (0,react.useRef)(0);
  const client = (0,react.useContext)(MatrixClientContext/* default */.Z);
  const {
    onChangeView
  } = (0,react.useContext)(points_task_PointsViewContext);
  (0,react.useEffect)(() => {
    let didCancel = false;
    setLoading(true);
    Promise.all([client.getPointsTaskList(), client.getMyPointsRank({
      rank_type: task/* RankType */.cP.Daily
    })]).then(([task, rank]) => {
      if (!didCancel) {
        if ((task === null || task === void 0 ? void 0 : task.boost_rate) >= 0 && (task === null || task === void 0 ? void 0 : task.balance) >= 0) {
          totalRef.current = task.balance;
          setBoostRate(task.boost_rate);
          setTotal(task.balance);
        }
        if (rank !== null && rank !== void 0 && rank.balance) {
          setPoints(rank.balance);
        }
      }
    }).finally(() => {
      setLoading(false);
    });
    return () => {
      didCancel = true;
    };
  }, []);
  (0,react.useEffect)(() => {
    if (balance >= 0) {
      setTotal(balance);
      const prev = totalRef.current;
      setPoints(p => p + (balance - prev));
      totalRef.current = balance;
    }
  }, [balance]);
  return /*#__PURE__*/react.createElement("div", {
    className: "card"
  }, /*#__PURE__*/react.createElement("h2", {
    className: "card-title"
  }, (0,languageHandler._t)("My Earning"), /*#__PURE__*/react.createElement(AccessibleTooltipButton/* default */.Z, {
    title: "",
    tooltip: /*#__PURE__*/react.createElement(PointTip, null),
    onClick: noop/* default */.Z,
    alignment: Tooltip/* Alignment */.v.Bottom,
    tooltipClassName: "mx_PointTask_tip_container"
  })), /*#__PURE__*/react.createElement("div", {
    className: "points-num"
  }, loading ? /*#__PURE__*/react.createElement(dist.SdSkeleton.Button, {
    active: true
  }) : /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("div", {
    style: {
      height: 28
    }
  }, /*#__PURE__*/react.createElement("span", {
    style: {
      display: "inline-block",
      width: 50
    }
  }, "DAILY"), /*#__PURE__*/react.createElement("img", {
    src: __webpack_require__(393988)
  }), /*#__PURE__*/react.createElement("span", {
    className: "num"
  }, points), /*#__PURE__*/react.createElement("div", {
    style: {
      display: "inline-flex",
      alignItems: "center"
    }
  }, /*#__PURE__*/react.createElement("img", {
    style: {
      marginLeft: "6px",
      width: 14,
      height: 14
    },
    src: __webpack_require__(295740)
  }), /*#__PURE__*/react.createElement("div", {
    style: {
      display: "flex",
      flexDirection: "column",
      fontSize: 10,
      lineHeight: 1
    }
  }, /*#__PURE__*/react.createElement("span", null, "+", boostRate, "%"), /*#__PURE__*/react.createElement("span", null, "Extra Points")))), /*#__PURE__*/react.createElement("div", {
    style: {
      height: 28
    }
  }, /*#__PURE__*/react.createElement("span", {
    style: {
      display: "inline-block",
      width: 50
    }
  }, "TOTAL"), /*#__PURE__*/react.createElement("img", {
    src: __webpack_require__(393988)
  }), /*#__PURE__*/react.createElement("span", {
    className: "num"
  }, total)))), /*#__PURE__*/react.createElement("div", {
    className: "btn-record",
    role: "button",
    onClick: () => onChangeView(PointView.Record)
  }, /*#__PURE__*/react.createElement("span", null, (0,languageHandler._t)("Points Record"))));
};
const PointRankButton = props => {
  const [rank, setRank] = (0,react.useState)("0");
  const [loading, setLoading] = (0,react.useState)(false);
  const client = (0,react.useContext)(MatrixClientContext/* default */.Z);
  const {
    onChangeView
  } = (0,react.useContext)(points_task_PointsViewContext);
  (0,react.useEffect)(() => {
    let didCancel = false;
    setLoading(true);
    client.getMyPointsRank({
      rank_type: task/* RankType */.cP.Daily
    }).then(res => {
      if (!didCancel) {
        setRank(res.rank);
        setLoading(false);
      }
    }).catch(() => {
      setLoading(false);
    });
    return () => {
      didCancel = true;
    };
  }, []);
  return /*#__PURE__*/react.createElement("div", {
    className: "rank-view"
  }, /*#__PURE__*/react.createElement("div", {
    className: "rank-content"
  }, /*#__PURE__*/react.createElement("span", {
    className: "rank-icon"
  }), /*#__PURE__*/react.createElement("div", {
    className: "renk-info"
  }, /*#__PURE__*/react.createElement("h2", {
    className: "rank-view-title"
  }, (0,languageHandler._t)("Points List")), /*#__PURE__*/react.createElement("span", {
    className: "renk-detail"
  }, (0,languageHandler._t)("Current ranking"), ": ", "No.", loading ? /*#__PURE__*/react.createElement(Spinner/* default */.Z, {
    w: 18,
    h: 18
  }) : rank))), /*#__PURE__*/react.createElement("div", {
    className: "rank-btn",
    role: "button",
    onClick: () => onChangeView(PointView.Rank)
  }, /*#__PURE__*/react.createElement("span", null, (0,languageHandler._t)("View"))));
};
const PointsTaskView = () => {
  const [balance, setBalance] = (0,react.useState)();
  const onCollect = balance => {
    setBalance(balance);
  };
  return /*#__PURE__*/react.createElement("div", {
    className: "mx_PointsTaskView"
  }, /*#__PURE__*/react.createElement(PointCard, {
    balance: balance
  }), /*#__PURE__*/react.createElement(PointRankButton, null), /*#__PURE__*/react.createElement(points_task_TaskList, {
    onCollected: onCollect
  }));
};
/* harmony default export */ const points_task_PointsTaskView = (PointsTaskView);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/elements/ErrorBoundary.tsx
var ErrorBoundary = __webpack_require__(618675);
// EXTERNAL MODULE: ./node_modules/lodash-es/last.js
var last = __webpack_require__(200935);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/points_task/index.tsx










const PointsTaskIndex = props => {
  var _viewTitle$pointView;
  const {
    title,
    onClose
  } = props;
  const [pointView, setPointView] = (0,react.useState)(PointView.Mian);
  const historyRef = (0,react.useRef)([PointView.Mian]);
  const onChangeView = view => {
    historyRef.current.push(view);
    setPointView(view);
  };
  let childView = null;
  switch (pointView) {
    case PointView.Record:
      childView = /*#__PURE__*/react.createElement(points_task_RecordList, null);
      break;
    case PointView.Rank:
      childView = /*#__PURE__*/react.createElement(points_task_PointsRank, null);
      break;
    // case PointView.Detail:
    //     childView = <TaskDetail/>;
    //      break;
    default:
      childView = /*#__PURE__*/react.createElement(points_task_PointsTaskView, null);
  }
  const viewGoback = () => {
    var _ref;
    const currentView = historyRef.current.pop();
    const prevView = (0,last/* default */.Z)(historyRef.current);
    setPointView((_ref = prevView !== null && prevView !== void 0 ? prevView : currentView) !== null && _ref !== void 0 ? _ref : PointView.Mian);
  };
  const viewTitle = {
    [PointView.Mian]: (0,languageHandler._t)("Points"),
    [PointView.Rank]: (0,languageHandler._t)("Leaderboard"),
    [PointView.Record]: (0,languageHandler._t)("Points Record"),
    [PointView.Detail]: (0,languageHandler._t)("Points")
  };
  return /*#__PURE__*/react.createElement(points_task_PointsViewContext.Provider, {
    value: {
      onChangeView
    }
  }, /*#__PURE__*/react.createElement(ErrorBoundary/* default */.Z, null, /*#__PURE__*/react.createElement("div", {
    className: "mx_PointsTaskView_header"
  }, /*#__PURE__*/react.createElement("div", null, PointView.Mian !== pointView && /*#__PURE__*/react.createElement("span", {
    className: "back-btn",
    onClick: viewGoback
  }), (0,languageHandler._t)((_viewTitle$pointView = viewTitle[pointView]) !== null && _viewTitle$pointView !== void 0 ? _viewTitle$pointView : title)), /*#__PURE__*/react.createElement("span", {
    className: "close-btn",
    onClick: onClose
  })), /*#__PURE__*/react.createElement("div", {
    className: "mx_PointsTaskView_content"
  }, childView)));
};
const PointsListSkeleton = () => {
  return /*#__PURE__*/react.createElement("div", {
    className: "mx_points_list_skeleton_item"
  }, /*#__PURE__*/react.createElement(dist.SdSkeleton.Avatar, {
    active: true
  }), /*#__PURE__*/react.createElement("div", {
    className: "mx_points_list_skeleton_center"
  }, /*#__PURE__*/react.createElement(dist.SdSkeleton.Input, {
    active: true
  }), /*#__PURE__*/react.createElement(dist.SdSkeleton.Input, {
    active: true
  })), /*#__PURE__*/react.createElement(dist.SdSkeleton.Button, {
    active: true
  }));
};
/* harmony default export */ const points_task = (PointsTaskIndex);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/structures/UserMenu.tsx + 6 modules
var UserMenu = __webpack_require__(127251);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/lib/constants.ts
var constants = __webpack_require__(877294);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/utils/UrlUtils.ts
var UrlUtils = __webpack_require__(58238);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/WalletStore.ts
var WalletStore = __webpack_require__(644764);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/hooks/useForceUpdate.ts

const useForceUpdate = () => {
  const [, setTrigger] = (0,react.useState)(false);
  return (0,react.useCallback)(() => {
    setTrigger(trigger => !trigger);
  }, []);
};
/* harmony default export */ const hooks_useForceUpdate = (useForceUpdate);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/cards/AssetsMoreCard.tsx

function AssetsMoreCard_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function AssetsMoreCard_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? AssetsMoreCard_ownKeys(Object(t), !0).forEach(function (r) { (0,defineProperty/* default */.Z)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : AssetsMoreCard_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }


















const AssetsMoreCard = props => {
  const client = MatrixClientPeg/* MatrixClientPeg */.p.get();
  const [loading, setLoading] = (0,react.useState)(false);
  const [network, setNetwork] = (0,react.useState)("linea");
  const [tokenWorth, setTokenWorth] = (0,react.useState)();
  const [tokens, setTokens] = (0,react.useState)([]);
  const [walletList, setWalletList] = (0,react.useState)(WalletStore/* default */.ZP.get());
  const [poaps, setPoaps] = (0,react.useState)();
  const refreshRef = (0,react.useRef)(null);
  const forceUpdate = hooks_useForceUpdate();
  // const [refreshTime, setRefreshTime] = useState(null);
  const [user, setUser] = (0,react.useState)(() => {
    if (props.userId) {
      return client === null || client === void 0 ? void 0 : client.getUser(props.userId);
    }
  });
  const [options, setOptions] = (0,react.useState)(() => {
    if (props.userId === client.getUserId()) {
      return props.options || [];
    }
    return [];
  });
  (0,react.useEffect)(() => {
    if (!user) {
      client.getProfileInfo(props.userId).then(res => {
        const _user = new browser_index/* User */.n5(props.userId);
        _user.avatarUrl = res.avatar_url;
        _user.walletAddress = res.wallet_address;
        _user.displayName = res.displayname;
        setUser(_user);
      });
    }
  }, [props.userId, user === null || user === void 0 ? void 0 : user.userId]);
  // get poaps list
  (0,react.useEffect)(() => {
    const getPoApsList = async () => {
      const client = MatrixClientPeg/* MatrixClientPeg */.p.get();
      client.getPoAps(user.walletAddress).then(res => {
        const poap_list = res.poap_list;
        setPoaps(poap_list);
      });
    };
    if (user.walletAddress) {
      getPoApsList();
    }
  }, [props.userId, user === null || user === void 0 ? void 0 : user.walletAddress]);
  const isSelf = props.userId === client.getUserId();
  (0,react.useEffect)(() => {
    WalletStore/* default */.ZP.instance.on(WalletStore/* LinkWalletListUpdated */.Hp, setWalletList);
    return () => {
      WalletStore/* default */.ZP.instance.off(WalletStore/* LinkWalletListUpdated */.Hp, setWalletList);
    };
  }, []);
  (0,react.useEffect)(() => {
    const avatar = user === null || user === void 0 ? void 0 : user.getMxcAvatarUrl();
    const displayname = localStorage.getItem("mx_profile_displayname") || "";
    const localWalletAddress = localStorage.getItem("mx_profile_wallet_address") || "";
    const myAvatarUrl = avatar ? avatar : (0,utils_avatar/* getDefaultAvatar */.W)({
      id: localStorage.getItem("mx_user_id")
    });
    const options = [{
      checked: true,
      value: localWalletAddress,
      id: localWalletAddress,
      type: "owner",
      label: /*#__PURE__*/react.createElement("div", {
        className: "item_label"
      }, /*#__PURE__*/react.createElement("img", {
        style: SeaUserProfile/* iconStyle */.o,
        src: myAvatarUrl
      }), /*#__PURE__*/react.createElement("div", {
        className: "mx_item_label_wallet_info"
      }, /*#__PURE__*/react.createElement("div", null, displayname), /*#__PURE__*/react.createElement("div", null, (0,util/* shortStr */.lS)(localWalletAddress))))
    }, ...(walletList || []).map(item => ({
      checked: true,
      value: item.wallet_address,
      id: item.wallet_address,
      type: item.verify_source,
      label: /*#__PURE__*/react.createElement("div", {
        className: "item_label"
      }, /*#__PURE__*/react.createElement("img", {
        style: SeaUserProfile/* iconStyle */.o,
        src: item === null || item === void 0 ? void 0 : item.verify_source_logo
      }), /*#__PURE__*/react.createElement("div", {
        className: "mx_item_label_wallet_info"
      }, /*#__PURE__*/react.createElement("div", null, item.wallet_name), /*#__PURE__*/react.createElement("div", null, (0,util/* shortStr */.lS)(item.wallet_address))))
    }))];
    if (isSelf) {
      setOptions(options);
    }
  }, [JSON.stringify(walletList), user === null || user === void 0 ? void 0 : user.walletAddress]);
  let avatarUrl = (user === null || user === void 0 ? void 0 : user.getMxcAvatarUrl()) || (0,utils_avatar/* getDefaultAvatar */.W)({
    id: props === null || props === void 0 ? void 0 : props.userId
  });
  const getNetworkToken = (one, two, refresh) => OpenseaStore/* default */.Z.instance.getAssetsByOwner(one, two, refresh);
  const {
    addresses,
    walletAddress
  } = (0,react.useMemo)(() => {
    let _address = user === null || user === void 0 ? void 0 : user.walletAddress;
    let walletAddress = (user === null || user === void 0 ? void 0 : user.walletAddress) || "";
    if (isSelf) {
      const linkWalletAddress = options.filter(item => item.checked).map(item => item.value).join(",");
      _address = linkWalletAddress ? linkWalletAddress : "";
      if (!linkWalletAddress) {
        walletAddress = "";
      }
    }
    return {
      addresses: _address,
      walletAddress
    };
  }, [props.userId, user === null || user === void 0 ? void 0 : user.userId, JSON.stringify(options)]);
  const loadMore = () => {
    return OpenseaStore/* default */.Z.instance.getNftsByOwner(addresses, network).then(res => {
      if (!res) {
        return [];
      }
      const {
        nfts
      } = res;
      return (nfts || []).map(nft => {
        return {
          tokenId: nft.token_id,
          imageUrl: nft.image_url,
          contractAddress: nft.contract_address,
          collectionName: nft.name
        };
      });
    });
  };
  const showSelfAsset = () => {
    const client = MatrixClientPeg/* MatrixClientPeg */.p.get();
    const user = client.getUser(client.getUserId());
    dispatcher/* default */.ZP.dispatch({
      action: actions/* Action */.a.SetRightPanelPhase,
      phase: RightPanelStorePhases/* RightPanelPhases */.q4.UserProfile,
      refireParams: {
        member: user,
        params: {
          showAssetMore: true,
          assetDefaultTab: UserMenu/* AssetType */.h.Token,
          network: "ethereum"
        }
      }
    });
  };
  const showOtherAsset = () => {
    dispatcher/* default */.ZP.dispatch({
      action: actions/* Action */.a.SetRightPanelPhase,
      phase: RightPanelStorePhases/* RightPanelPhases */.q4.UserProfile,
      refireParams: {
        member: user,
        params: {
          showAssetMore: true,
          showOtherAssetMore: true,
          assetDefaultTab: UserMenu/* AssetType */.h.Token,
          network: "ethereum"
        }
      }
    });
  };
  const onRefresh = () => {
    refreshRef.current = Date.now();
    forceUpdate();
    setTimeout(() => {
      refreshRef.current = null;
    }, 500);
  };
  const assetAction = (path, queryParams) => {
    const queryStr = (0,UrlUtils/* stringifyQuery */.Oh)(AssetsMoreCard_objectSpread({
      st: "sdn",
      from: "wallet"
    }, queryParams));
    dispatcher/* default */.ZP.dispatch({
      action: actions/* Action */.a.SetRightPanelPhase,
      phase: RightPanelStorePhases/* RightPanelPhases */.q4.IframeWidget,
      refireParams: {
        params: {
          src: `${constants/* TRANSFER_URL */._p}${path}?${queryStr}`,
          title: "Transfer"
        }
      }
    });
  };
  const onChangeNetwork = _network => {
    setNetwork(_network);
  };
  const onChangeOptions = options => {
    setOptions(options);
  };
  return /*#__PURE__*/react.createElement(BaseCard/* default */.C, {
    onClose: props.onClose,
    onRefresh: onRefresh,
    previousPhase: RightPanelStorePhases/* RightPanelPhases */.q4.UserProfile,
    refireParams: {
      member: user
    },
    className: "mx_RightPanel_Assets_More",
    key: `BaseCard_key_${options.length}`
  }, user && /*#__PURE__*/react.createElement(react_dist.AssetsMore, {
    _t: languageHandler._t,
    refreshTime: refreshRef.current,
    avatarUrl: avatarUrl,
    getNetworkToken: getNetworkToken,
    setNetwork: onChangeNetwork,
    network: network,
    tokenWorth: tokenWorth,
    walletAddress: walletAddress,
    address: addresses,
    poaps: (poaps || []).map(poap => {
      return {
        tokenId: poap.token_id,
        name: poap.event.name,
        imageUrl: poap.event.image_url,
        eventUrl: poap.event.event_url,
        startDate: poap.event.start_date
      };
    }),
    options: options,
    onChangeOptions: onChangeOptions,
    isShowSelectWallet: isSelf,
    hasMore: () => {
      return OpenseaStore/* default */.Z.instance.hasMoreNfts(network + addresses);
    },
    loadMore: loadMore,
    tokens: tokens,
    assetDefaultTab: props.assetDefaultTab,
    onClickNft: nft => {
      if (network != "ethereum") {
        return;
      }
      dispatcher/* default */.ZP.dispatch({
        action: actions/* Action */.a.SetRightPanelPhase,
        phase: RightPanelStorePhases/* RightPanelPhases */.q4.IframeWidget,
        refireParams: {
          params: {
            src: `${constants/* FAV_HOST_URL */.AU}/nft/${nft.contractAddress}/${nft.tokenId}`,
            title: "NFT Profile"
          }
        }
      });
    },
    onLinkWalletAction: () => dispatcher/* default */.ZP.dispatch({
      action: actions/* Action */.a.OpenLinkWalletAction,
      roomId: undefined
    }),
    menuItems: !isSelf ? [{
      name: "Send",
      icon: "Send",
      action: () => assetAction("/create", {
        chain: network,
        address: addresses,
        userId: props.userId
      })
    }] : [{
      name: "Send",
      icon: "Send",
      action: () => assetAction("/create", {
        chain: network
      })
    }, {
      name: "Swap",
      icon: "Swap",
      action: () => assetAction("/swap", {
        chain: network
      })
    }, {
      name: props.userId === client.getUserId() ? "Buy&Sell" : "Buy",
      icon: "Buy",
      action: () => assetAction("/buy", {
        chain: network
      })
    }]
  }));
};
/* harmony default export */ const cards_AssetsMoreCard = (AssetsMoreCard);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/right_panel/EditNickname.tsx





const EditNickname = /*#__PURE__*/(0,react.memo)(props => {
  // first notice has problam. textForRoomMemberNameEvent
  const {
    room,
    userId,
    onClose
  } = props;
  const cli = MatrixClientPeg/* MatrixClientPeg */.p.get();
  const realUserId = userId !== null && userId !== void 0 ? userId : cli.getUserId();
  const isSelf = realUserId === cli.getUserId();
  const roomNickName = room.getRoomUserNickName(realUserId) || room.getMember(realUserId).nickName;
  const [nickname, setNickname] = (0,react.useState)(roomNickName !== null && roomNickName !== void 0 ? roomNickName : "");
  const [busy, setBusy] = (0,react.useState)(false);
  const onNicknameChange = ev => {
    setNickname(ev.target.value);
  };
  const onSave = async () => {
    lib.message.config({
      getContainer: () => document.querySelector(".mx_EditNickname") || document.body
    });
    try {
      if (!busy) {
        setBusy(true);
        if (room.isGroup() || room.isSpaceRoom()) {
          await room.setNickName(nickname, realUserId);
        } else {
          var _room$getParentRoom;
          await ((_room$getParentRoom = room.getParentRoom()) === null || _room$getParentRoom === void 0 ? void 0 : _room$getParentRoom.setNickName(nickname, realUserId));
        }
        dist.SdMessage.success("Change Saved", () => {
          onClose === null || onClose === void 0 ? void 0 : onClose();
          lib.message.destroy();
        });
      }
    } catch (err) {
      dist.SdMessage.error("Change Failed", () => {
        lib.message.destroy();
      });
    }
    setBusy(false);
  };
  const onCancel = () => {
    onClose === null || onClose === void 0 ? void 0 : onClose();
  };
  return /*#__PURE__*/react.createElement("div", {
    className: "mx_EditNickname"
  }, /*#__PURE__*/react.createElement("span", {
    role: "button",
    onClick: onClose,
    className: "mx_EditNickname_close"
  }), /*#__PURE__*/react.createElement("h2", {
    className: "mx_EditNickname_header"
  }, (0,languageHandler._t)("Edit member's Alias")), /*#__PURE__*/react.createElement("div", {
    className: "mx_EditNickname_content"
  }, /*#__PURE__*/react.createElement(dist.SdInput, {
    type: "text",
    placeholder: "Add member's Alias",
    value: nickname,
    onChange: onNicknameChange
  }), /*#__PURE__*/react.createElement("span", null, "After the Alias is changed, it will be visible to everyone in the room")), /*#__PURE__*/react.createElement("div", {
    className: "mx_EditNickname_footer"
  }, /*#__PURE__*/react.createElement(dist.SdButton, {
    type: "associate",
    onClick: onCancel
  }, "Cancel"), /*#__PURE__*/react.createElement(dist.SdButton, {
    type: "primary",
    loading: busy,
    onClick: onSave
  }, "Comfirm")));
});
/* harmony default export */ const right_panel_EditNickname = (EditNickname);
// EXTERNAL MODULE: ./node_modules/lodash/isEqual.js
var isEqual = __webpack_require__(618446);
var isEqual_default = /*#__PURE__*/__webpack_require__.n(isEqual);
// EXTERNAL MODULE: ./node_modules/matrix-js-sdk/src/models/poll/poll-start-event.ts + 2 modules
var poll_start_event = __webpack_require__(402371);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/dialogs/QuestionDialog.js
var QuestionDialog = __webpack_require__(433773);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/utils/arrays.ts
var arrays = __webpack_require__(902232);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/elements/Field.tsx
var Field = __webpack_require__(455537);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/elements/PollCreatePanel.tsx



// third




//












// import BaseDialog from "../dialogs/BaseDialog";
var FocusTarget = /*#__PURE__*/function (FocusTarget) {
  FocusTarget[FocusTarget["Topic"] = 0] = "Topic";
  FocusTarget[FocusTarget["NewOption"] = 1] = "NewOption";
  return FocusTarget;
}(FocusTarget || {});
const MIN_OPTIONS = 2;
// const MAX_OPTIONS = 20;
// the maximum of vote is 9
const MAX_OPTIONS = 9;
const DEFAULT_NUM_OPTIONS = 2;
const MAX_QUESTION_LENGTH = 340;
const MAX_OPTION_LENGTH = 340;
function creatingInitialState() {
  return {
    title: (0,languageHandler._t)("New poll"),
    actionLabel: (0,languageHandler._t)("Create"),
    canSubmit: false,
    // need to add a question and at least one option first
    question: "",
    options: (0,arrays/* arraySeed */.Hf)("", DEFAULT_NUM_OPTIONS),
    busy: false,
    kind: _types_event/* EventType */.tw.PollDisclosed,
    autoFocusTarget: FocusTarget.Topic,
    isMultiple: false
  };
}
function editingInitialState(editingMxEvent) {
  try {
    const poll = new poll_start_event/* PollStartEvent */.I(editingMxEvent.event);
    return {
      title: (0,languageHandler._t)("Edit poll"),
      actionLabel: (0,languageHandler._t)("Done"),
      canSubmit: true,
      question: poll.question.text,
      options: poll.answers.map(ans => ans.text),
      busy: false,
      kind: poll.kind,
      autoFocusTarget: FocusTarget.Topic,
      isMultiple: poll.maxSelections > 1
    };
  } catch (error) {
    return creatingInitialState();
  }
}
class PollCreatePanel extends react.Component {
  constructor(props) {
    super(props);
    (0,defineProperty/* default */.Z)(this, "addOptionRef", /*#__PURE__*/(0,react.createRef)());
    (0,defineProperty/* default */.Z)(this, "matrixClient", MatrixClientPeg/* MatrixClientPeg */.p.get());
    (0,defineProperty/* default */.Z)(this, "onQuestionChange", e => {
      this.setState({
        question: e.target.value
      }, () => this.checkCanSubmit());
    });
    (0,defineProperty/* default */.Z)(this, "onOptionChange", (i, e) => {
      const newOptions = (0,arrays/* arrayFastClone */.iP)(this.state.options);
      newOptions[i] = e.target.value;
      this.setState({
        options: newOptions
      }, () => this.checkCanSubmit());
    });
    (0,defineProperty/* default */.Z)(this, "onOptionRemove", i => {
      const newOptions = (0,arrays/* arrayFastClone */.iP)(this.state.options);
      newOptions.splice(i, 1);
      this.setState({
        options: newOptions
      }, () => this.checkCanSubmit());
    });
    (0,defineProperty/* default */.Z)(this, "onOptionAdd", () => {
      const newOptions = (0,arrays/* arrayFastClone */.iP)(this.state.options);
      newOptions.push("");
      this.setState({
        options: newOptions,
        autoFocusTarget: FocusTarget.NewOption
      }, () => {
        var _this$addOptionRef$cu, _this$addOptionRef$cu2;
        // Scroll the button into view after the state update to ensure we don't experience
        // a pop-in effect, and to avoid the button getting cut off due to a mid-scroll render.
        (_this$addOptionRef$cu = this.addOptionRef.current) === null || _this$addOptionRef$cu === void 0 ? void 0 : (_this$addOptionRef$cu2 = _this$addOptionRef$cu.scrollIntoView) === null || _this$addOptionRef$cu2 === void 0 ? void 0 : _this$addOptionRef$cu2.call(_this$addOptionRef$cu);
      });
    });
    (0,defineProperty/* default */.Z)(this, "onSubmit", e => {
      e.stopPropagation();
      e.preventDefault();
      if (!this.state.canSubmit) return; // pretend the submit button was disabled
      this.submit();
    });
    (0,defineProperty/* default */.Z)(this, "onCancel", () => {
      this.cancel();
    });
    (0,defineProperty/* default */.Z)(this, "HandleMultipleSwitch", value => {
      this.setState({
        isMultiple: value
      });
    });
    (0,defineProperty/* default */.Z)(this, "onPollTypeChange", e => {
      this.setState({
        kind: e.target.value
      });
    });
    this.state = props.editingMxEvent ? editingInitialState(props.editingMxEvent) : creatingInitialState();
  }
  componentDidUpdate(prevProps) {
    if (!isEqual_default()(prevProps, this.props)) {
      this.setState(this.props.editingMxEvent ? editingInitialState(this.props.editingMxEvent) : creatingInitialState());
    }
  }
  componentWillUnmount() {
    this.state = creatingInitialState();
  }
  checkCanSubmit() {
    this.setState({
      canSubmit: !this.state.busy && this.state.question.trim().length > 0 && this.state.options.filter(op => op.trim().length > 0).length >= MIN_OPTIONS
    });
  }
  createEvent() {
    const optionsAfterFilter = this.state.options.map(a => a.trim()).filter(a => !!a);
    const pollStart = poll_start_event/* PollStartEvent */.I.from(this.state.question.trim(), optionsAfterFilter, this.state.kind, this.state.isMultiple ? optionsAfterFilter.length : 1).serialize();
    if (!this.props.editingMxEvent) {
      return pollStart;
    } else {
      var _this$props$editingMx, _this$props$editingMx2, _this$props$editingMx3;
      return {
        content: {
          "m.new_content": pollStart.content,
          "m.relates_to": {
            rel_type: "m.replace",
            //  we post Relation id first
            // if relation is is empty ,use the event id
            event_id: ((_this$props$editingMx = this.props.editingMxEvent) === null || _this$props$editingMx === void 0 ? void 0 : (_this$props$editingMx2 = _this$props$editingMx.getRelation()) === null || _this$props$editingMx2 === void 0 ? void 0 : _this$props$editingMx2.event_id) || ((_this$props$editingMx3 = this.props.editingMxEvent) === null || _this$props$editingMx3 === void 0 ? void 0 : _this$props$editingMx3.getId())
          }
        },
        type: pollStart.type
      };
    }
  }
  submit() {
    this.setState({
      busy: true,
      canSubmit: false
    });
    const pollEvent = this.createEvent();
    this.matrixClient.sendEvent(this.props.room.roomId, pollEvent.type, pollEvent.content).then(() => this.props.onFinished(true)).catch(e => {
      console.error("Failed to post poll:", e);
      Modal/* default */.Z.createDialog(QuestionDialog/* default */.Z, {
        title: (0,languageHandler._t)("Failed to post poll"),
        description: (0,languageHandler._t)("Sorry, the poll you tried to create was not posted."),
        button: (0,languageHandler._t)("Try again"),
        cancelButton: (0,languageHandler._t)("Cancel"),
        onFinished: tryAgain => {
          if (!tryAgain) {
            this.cancel();
          } else {
            this.setState({
              busy: false,
              canSubmit: true
            });
          }
        }
      });
    });
  }
  cancel() {
    this.props.onFinished(false);
  }
  renderContent() {
    return /*#__PURE__*/react.createElement("div", {
      className: classnames_default()("mx_PollCreateDialog", "mx_PollCreatePanel_body")
    }, /*#__PURE__*/react.createElement("h2", null, (0,languageHandler._t)("What is your poll question or topic?")), /*#__PURE__*/react.createElement(Field/* default */.Z, {
      id: "poll-topic-input",
      className: "mx_PollCreatePanel_deep_BG",
      value: this.state.question,
      maxLength: MAX_QUESTION_LENGTH,
      element: "textarea",
      rows: 4
      // label={_t("Question or topic")}
      ,
      placeholder: (0,languageHandler._t)("Write a question or topic"),
      onChange: this.onQuestionChange,
      disabled: this.state.busy,
      autoFocus: this.state.autoFocusTarget === FocusTarget.Topic
    }), /*#__PURE__*/react.createElement("h2", null, (0,languageHandler._t)("Create options")), this.state.options.map((op, i) => /*#__PURE__*/react.createElement("div", {
      key: `option_${i}`,
      className: "mx_PollCreateDialog_option"
    }, /*#__PURE__*/react.createElement(Field/* default */.Z, {
      id: `pollcreate_option_${i}`,
      className: "mx_PollCreatePanel_deep_BG",
      value: op,
      element: "textarea",
      maxLength: MAX_OPTION_LENGTH,
      rows: 1,
      autoHeight: true,
      label: (0,languageHandler._t)("Option %(number)s", {
        number: i + 1
      }),
      placeholder: (0,languageHandler._t)("Write an option"),
      onChange: e => this.onOptionChange(i, e),
      disabled: this.state.busy,
      autoFocus: this.state.autoFocusTarget === FocusTarget.NewOption && i === this.state.options.length - 1
    }), /*#__PURE__*/react.createElement(elements_AccessibleButton/* default */.Z, {
      onClick: () => this.onOptionRemove(i),
      className: "mx_PollCreateDialog_removeOption",
      disabled: this.state.busy
    }))), /*#__PURE__*/react.createElement(elements_AccessibleButton/* default */.Z, {
      onClick: this.onOptionAdd,
      disabled: this.state.busy || this.state.options.length >= MAX_OPTIONS,
      kind: "secondary",
      className: "mx_PollCreateDialog_addOption",
      inputRef: this.addOptionRef
    }, (0,languageHandler._t)("Add option")), this.state.busy && /*#__PURE__*/react.createElement("div", {
      className: "mx_PollCreateDialog_busy"
    }, /*#__PURE__*/react.createElement(Spinner/* default */.Z, null)));
  }
  render() {
    return /*#__PURE__*/react.createElement(BaseCard/* default */.C, {
      className: "mx_PollCreatePanel_baseCard",
      header: /*#__PURE__*/react.createElement("h1", null, this.state.title),
      onClose: this.onCancel,
      footer: /*#__PURE__*/react.createElement("div", {
        className: "mx_PollCreatePanel_action"
      }, /*#__PURE__*/react.createElement(elements_AccessibleButton/* default */.Z, {
        onClick: this.onCancel,
        kind: "primary_outline",
        element: "button"
      }, (0,languageHandler._t)("Close")), /*#__PURE__*/react.createElement(elements_AccessibleButton/* default */.Z, {
        onClick: this.onSubmit,
        kind: "primary",
        disabled: !this.state.canSubmit,
        type: "submit",
        element: "button"
      }, this.state.actionLabel))
    }, /*#__PURE__*/react.createElement("form", {
      onSubmit: this.onSubmit,
      className: "mx_PollCreatePanel"
    }, /*#__PURE__*/react.createElement("div", {
      className: "mx_PollCreatePanel_content"
    }, this.renderContent()), /*#__PURE__*/react.createElement("div", {
      className: "mx_PollCreatePanel_switcher"
    }, /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement("h2", null, "Multiple Answers"), /*#__PURE__*/react.createElement("p", null, "Allow users to select multiple options")), /*#__PURE__*/react.createElement(lib.Switch, {
      disabled: this.state.busy,
      checked: this.state.isMultiple,
      onChange: this.HandleMultipleSwitch
    }))));
  }
}

// function pollTypeNotes(
//     kind: EventType.PollDisclosed | EventType.PollUndisclosed
// ): string {
//     if (kind === EventType.PollDisclosed) {
//         return _t("Voters see results as soon as they have voted");
//     } else {
//         return _t("Results are only revealed when you end the poll");
//     }
// }
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/activity/ama_view/UserListened.tsx



const UserListened = props => {
  const {
    avatar,
    username,
    walletAddress
  } = props;
  return /*#__PURE__*/react.createElement("div", {
    className: classnames_default()({
      mx_Listened: true,
      mx_Listened_sdm: username || walletAddress
    })
  }, /*#__PURE__*/react.createElement("img", {
    src: avatar,
    className: "listener-avatar"
  }), /*#__PURE__*/react.createElement("div", {
    className: "listener-info"
  }, /*#__PURE__*/react.createElement("span", {
    className: "listener-name"
  }, username), walletAddress && /*#__PURE__*/react.createElement("span", {
    className: "listener-wallet"
  }, (0,token/* formatWallet */.Tl)(walletAddress))));
};
/* harmony default export */ const ama_view_UserListened = (/*#__PURE__*/(0,react.memo)(UserListened));
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/activity/ama_view/UserHost.tsx

const UserHost = props => {
  const {
    avatar,
    host
  } = props;
  return /*#__PURE__*/react.createElement("div", {
    className: "mx_UserHost"
  }, /*#__PURE__*/react.createElement("img", {
    src: avatar,
    className: "host-avatar"
  }), /*#__PURE__*/react.createElement("div", {
    className: "host-info"
  }, /*#__PURE__*/react.createElement("span", {
    className: "host-name"
  }, host), /*#__PURE__*/react.createElement("span", {
    className: "host-tag"
  }, "Host")));
};
/* harmony default export */ const ama_view_UserHost = (/*#__PURE__*/(0,react.memo)(UserHost));
// EXTERNAL MODULE: ./node_modules/lodash-es/upperFirst.js
var upperFirst = __webpack_require__(611288);
// EXTERNAL MODULE: ./node_modules/dayjs/dayjs.min.js
var dayjs_min = __webpack_require__(727484);
var dayjs_min_default = /*#__PURE__*/__webpack_require__.n(dayjs_min);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/activity/ama_view/ReminderView.tsx



const ReminderView = props => {
  const {
    startTime,
    scheduledStart,
    spaceState
  } = props;
  const weekday = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
  const [remminderd, setRemminderd] = (0,react.useState)(false);
  const setReminder = () => {
    props.setReminder().then(res => {
      dist.SdMessage.success("Settings Successful");
      setRemminderd(true);
    }).catch(err => {
      var _err$data;
      if (err !== null && err !== void 0 && (_err$data = err.data) !== null && _err$data !== void 0 && _err$data.error) {
        dist.SdMessage.error(err.data.error);
      }
    });
  };
  return /*#__PURE__*/react.createElement("div", {
    className: "mx_Reminder"
  }, /*#__PURE__*/react.createElement("span", {
    className: "date"
  }), /*#__PURE__*/react.createElement("p", {
    className: "remote-date"
  }, scheduledStart), /*#__PURE__*/react.createElement("p", {
    className: "tips"
  }, "Local Start Time"), spaceState !== "canceled" && /*#__PURE__*/react.createElement("p", {
    className: "local-date"
  }, dayjs_min_default()(startTime).format(`E, MMM D, hh:mm A`).replace("E", weekday[+dayjs_min_default()(startTime).get("d")])), spaceState === "canceled" && /*#__PURE__*/react.createElement("p", null, "This AMA has been Canceled"), props.children, spaceState !== "canceled" ? /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("div", {
    className: "mx_Reminder_buttons"
  }, props.isSetReminder || remminderd ? /*#__PURE__*/react.createElement("button", {
    className: "set-reminder-button setted",
    onClick: props.setReminder
  }, /*#__PURE__*/react.createElement("span", null, "Awaiting Reminder")) : /*#__PURE__*/react.createElement("button", {
    className: "set-reminder-button",
    onClick: setReminder
  }, "Set Reminder"), props.isCommunity ? /*#__PURE__*/react.createElement("button", {
    className: "set-reminder-button",
    onClick: props.setAirDrop
  }, "Set Airdrop") : null)) : null);
};
/* harmony default export */ const ama_view_ReminderView = (/*#__PURE__*/(0,react.memo)(ReminderView));
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/activity/ama_view/AirdropList.tsx





const AirdropList = props => {
  const [airdropList, setAirdropList] = (0,react.useState)([]);
  const [activeIndex, setActiveindex] = (0,react.useState)(0);
  const dotSlideRef = /*#__PURE__*/(0,react.createRef)();
  (0,react.useEffect)(() => {
    MatrixClientPeg/* MatrixClientPeg */.p.get().getXSpaceBindAirdrops(props.xSpaceId).then(res => {
      if (res.success) {
        setAirdropList(res.result);
      }
    });
  }, [props.xSpaceId]);
  const handleDotClick = (index, needScroll = true) => {
    setActiveindex(index);
    let dotSlideLeft = 0;
    const dotSideNode = document.getElementsByClassName("mx_AirdropItem_dots")[0];
    if (index > 1) {
      if (index + 1 < airdropList.length) {
        dotSlideLeft = (index - 1) * 20;
        dotSideNode.scrollLeft = dotSlideLeft;
      }
    } else {
      dotSideNode.scrollLeft = 0;
    }
    if (needScroll) {
      handleScroll(index);
    }
  };
  const handleScroll = index => {
    const airdropNode = document.getElementsByClassName("mx_AirdropList")[0];
    const airdropItemWidth = document.getElementsByClassName("mx_AirdropItem")[0].offsetWidth + 10;
    const sideNodeWidth = document.getElementsByClassName("mx_AirdropList_slide")[0].offsetWidth;
    const maxScrollLeft = sideNodeWidth - airdropNode.offsetWidth;
    const distance = index * airdropItemWidth;
    const targetLeft = distance > maxScrollLeft ? maxScrollLeft : distance;
    moveSlow(airdropNode, targetLeft);
  };
  const moveSlow = (currentNode, targetLeft) => {
    const step = 20;
    const currentLeft = currentNode.scrollLeft;
    if (currentLeft < targetLeft) {
      const scrollLeft = currentLeft + step > targetLeft ? targetLeft : currentLeft + step;
      currentNode.scrollLeft = scrollLeft;
      setTimeout(() => {
        moveSlow(currentNode, targetLeft);
      }, 10);
    } else if (currentLeft > targetLeft) {
      const scrollLeft = currentLeft - step < targetLeft ? targetLeft : currentLeft - step;
      currentNode.scrollLeft = scrollLeft;
      setTimeout(() => {
        moveSlow(currentNode, targetLeft);
      }, 10);
    } else {
      return;
    }
  };
  const handleAirdropsScroll = e => {
    const currentLeft = e.currentTarget.scrollLeft;
    const airdropNode = document.getElementsByClassName("mx_AirdropList")[0];
    const airdropItemWidth = document.getElementsByClassName("mx_AirdropItem")[0].offsetWidth + 10;
    const sideNodeWidth = document.getElementsByClassName("mx_AirdropList_slide")[0].offsetWidth;
    const maxScrollLeft = sideNodeWidth - airdropNode.offsetWidth;
    let index = Math.round(currentLeft / airdropItemWidth);
    if (currentLeft >= maxScrollLeft) index = airdropList.length - 1;
    handleDotClick(index, false);
  };
  const handleAirdropClick = item => {
    dispatcher/* default */.ZP.dispatch({
      action: actions/* Action */.a.SetRightPanelPhase,
      phase: RightPanelStorePhases/* RightPanelPhases */.q4.IframeWidget,
      refireParams: {
        params: {
          src: item.airdropLink,
          title: item === null || item === void 0 ? void 0 : item.airdropName
        }
      }
    });
  };
  return /*#__PURE__*/react.createElement(react.Fragment, null, airdropList.length > 0 ? /*#__PURE__*/react.createElement("div", {
    className: "mx_Airdrops"
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_Airdrops_title"
  }, "Airdrops"), /*#__PURE__*/react.createElement("div", {
    className: "mx_AirdropList",
    onWheelCapture: handleAirdropsScroll
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_AirdropList_slide"
  }, airdropList.map((item, index) => {
    var _item$rewardInfo, _item$rewardInfo2, _item$rewardInfo3;
    return /*#__PURE__*/react.createElement("div", {
      className: `mx_AirdropItem ${airdropList.length === 1 ? 'single' : ''} ${activeIndex === index ? 'active' : ''}`,
      key: item.airdropLink,
      onClick: () => handleAirdropClick(item)
    }, /*#__PURE__*/react.createElement("div", {
      className: "mx_AirdropItem_header"
    }, /*#__PURE__*/react.createElement("div", {
      className: "avatar"
    }, /*#__PURE__*/react.createElement("img", {
      src: item === null || item === void 0 ? void 0 : item.roomImage,
      alt: ""
    })), /*#__PURE__*/react.createElement("div", {
      className: "name"
    }, item === null || item === void 0 ? void 0 : item.roomName)), /*#__PURE__*/react.createElement("div", {
      className: "mx_AirdropItem_content"
    }, item === null || item === void 0 ? void 0 : item.airdropName), /*#__PURE__*/react.createElement("div", {
      className: "mx_AirdropItem_footer"
    }, /*#__PURE__*/react.createElement("div", {
      className: "mx_AirdropItem_coins"
    }, /*#__PURE__*/react.createElement("img", {
      src: item === null || item === void 0 ? void 0 : (_item$rewardInfo = item.rewardInfo) === null || _item$rewardInfo === void 0 ? void 0 : _item$rewardInfo.tokenIcon,
      alt: ""
    }), /*#__PURE__*/react.createElement("span", null, item === null || item === void 0 ? void 0 : (_item$rewardInfo2 = item.rewardInfo) === null || _item$rewardInfo2 === void 0 ? void 0 : _item$rewardInfo2.tokenAmount, " ", item === null || item === void 0 ? void 0 : (_item$rewardInfo3 = item.rewardInfo) === null || _item$rewardInfo3 === void 0 ? void 0 : _item$rewardInfo3.tokenName)), item !== null && item !== void 0 && item.qualifiedNumber ? /*#__PURE__*/react.createElement("div", {
      className: "mx_AirdropItem_members"
    }, /*#__PURE__*/react.createElement("span", null, item.qualifiedNumber), /*#__PURE__*/react.createElement("span", null, "qualified")) : null));
  }))), airdropList.length > 1 ? /*#__PURE__*/react.createElement("div", {
    className: "mx_AirdropItem_dots",
    ref: dotSlideRef
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_AirdropItem_dots_slide"
  }, airdropList.map((item, index) => {
    return /*#__PURE__*/react.createElement("div", {
      key: index,
      className: `mx_AirdropItem_dot_item ${activeIndex === index ? 'active' : ''}`,
      onClick: () => handleDotClick(index)
    });
  }))) : null) : null);
};
/* harmony default export */ const ama_view_AirdropList = (AirdropList);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/activity/ama_view/AudioSpaceView.tsx


















function transUserAccount(userInfo) {
  return {
    avatar: userInfo.avatar_url,
    username: userInfo.displayname,
    walletAddress: userInfo.wallet_address
  };
}
const AudioSpaceView = props => {
  var _data$data;
  const {
    preview,
    xSpaceUrl,
    roomId,
    onFinished
  } = props;
  const xSpaceId = preview["og:card_id"];
  const tagDescription = preview["og:tag_description"];
  const title = preview["og:title"];
  const hostName = preview["og:host:name"];
  const hostAvatar = preview["og:host:avatar"];
  const participantAvatar = preview["og:participant:avatar[]"];
  const participantCount = preview["og:participant:count"];
  const client = (0,react.useMemo)(() => MatrixClientPeg/* MatrixClientPeg */.p.get(), []);
  const {
    loading,
    data
  } = (0,ahooks_lib.useRequest)(() => client.getTwitterSpaceListened(xSpaceId), {
    refreshDeps: [xSpaceId]
  });
  let {
    loading: xSpaceLoading,
    data: XSpaceDetail
  } = (0,ahooks_lib.useRequest)(() => client.getXSpaceDetail(xSpaceId), {
    refreshDeps: [xSpaceId]
  });
  const speakerAvatars = (0,react.useMemo)(() => {
    const _s = (XSpaceDetail === null || XSpaceDetail === void 0 ? void 0 : XSpaceDetail.speaker_avatars.length) > 0 ? XSpaceDetail.speaker_avatars : participantAvatar;
    return [...new Set([hostAvatar, ..._s])];
  }, [XSpaceDetail, participantAvatar, hostAvatar]);
  const isEnded = (0,react.useMemo)(() => {
    return (XSpaceDetail === null || XSpaceDetail === void 0 ? void 0 : XSpaceDetail.space_state) === "ended" || tagDescription === "ended";
  }, [XSpaceDetail, tagDescription]);
  const isLive = (0,react.useMemo)(() => {
    return (XSpaceDetail === null || XSpaceDetail === void 0 ? void 0 : XSpaceDetail.space_state) === "live" || tagDescription === "live";
  }, [XSpaceDetail, tagDescription]);
  const listenerCount = (0,react.useMemo)(() => {
    return (XSpaceDetail === null || XSpaceDetail === void 0 ? void 0 : XSpaceDetail.participant) || participantCount || 0;
  }, [XSpaceDetail, participantCount]);
  const isCommunity = (0,react.useMemo)(() => {
    const room = MatrixClientPeg/* MatrixClientPeg */.p.get().getRoom(roomId);
    return (0,getRoomScene/* isCommunityRoom */.eg)(room);
  }, [roomId]);
  const setReminder = () => {
    const userId = client.getUserId();
    const user = client.getUser(userId);
    const creds = JSON.parse(localStorage.getItem("mx_Homeserver_Creds")) || null;
    const avatar = user.getMxcAvatarUrl();
    const user_info = {
      user_id: user.userId,
      display_name: user.rawDisplayName,
      wallet_address: user.walletAddress,
      avatar: avatar ? `${avatar}?access_token=${creds === null || creds === void 0 ? void 0 : creds.accessToken}` : "",
      ens: !!user.ens,
      source: "web"
    };
    return client.setXSpaceReminder({
      is_reminder: true,
      user_info: user_info,
      xSpaceId: xSpaceId
    });
  };
  const setAirDrop = () => {
    var _SdkConfig$get;
    const airdrop_url = (_SdkConfig$get = SdkConfig/* default */.Z.get("socialswap")) === null || _SdkConfig$get === void 0 ? void 0 : _SdkConfig$get.airdrop_url;
    const room = MatrixClientPeg/* MatrixClientPeg */.p.get().getRoom(roomId);
    const squadId = room.hasSpaceParent() ? room.getParentRoom().roomId : roomId;
    const url = `${airdrop_url}/create?st=sdn&squadId=${squadId}&ama=${xSpaceId}`;
    dispatcher/* default */.ZP.dispatch({
      action: actions/* Action */.a.SetRightPanelPhase,
      phase: RightPanelStorePhases/* RightPanelPhases */.q4.IframeWidget,
      refireParams: {
        params: {
          src: url,
          title: ""
        }
      }
    });
  };
  return /*#__PURE__*/react.createElement("div", {
    className: classnames_default()("mx_AudioSpace", props.className)
  }, /*#__PURE__*/react.createElement(ErrorBoundary/* default */.Z, null, /*#__PURE__*/react.createElement("div", {
    className: "mx_AudioSpace_header"
  }, /*#__PURE__*/react.createElement("span", {
    className: classnames_default()({
      status: true,
      "status-live": isLive,
      "status-end": isEnded
    })
  }, tagDescription === "scheduled" ? "Upcoming" : (0,upperFirst/* default */.Z)(tagDescription)), !props.hiddenClose && /*#__PURE__*/react.createElement("span", {
    className: "close",
    onClick: onFinished
  })), /*#__PURE__*/react.createElement("div", {
    className: "mx_AudioSpace_title"
  }, title), /*#__PURE__*/react.createElement("div", {
    className: "mx_AudioSpace_host"
  }, /*#__PURE__*/react.createElement(ama_view_UserHost, {
    avatar: hostAvatar,
    host: hostName
  })), !isEnded && !isLive && XSpaceDetail ? /*#__PURE__*/react.createElement(ama_view_ReminderView, {
    startTime: XSpaceDetail.start_time,
    scheduledStart: XSpaceDetail.scheduled_start,
    setReminder: setReminder,
    setAirDrop: setAirDrop,
    isSetReminder: XSpaceDetail === null || XSpaceDetail === void 0 ? void 0 : XSpaceDetail.user_set_reminder,
    spaceState: XSpaceDetail.space_state,
    isCommunity: isCommunity
  }, /*#__PURE__*/react.createElement(ama_view_AirdropList, {
    xSpaceId: xSpaceId
  })) : /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("div", {
    className: "mx_AudioSpace_speaker"
  }, /*#__PURE__*/react.createElement("div", {
    className: "header"
  }, "Speakers:", (speakerAvatars === null || speakerAvatars === void 0 ? void 0 : speakerAvatars.length) > 0 && /*#__PURE__*/react.createElement("div", {
    style: {
      display: "flex",
      gap: "12px"
    }
  }, speakerAvatars.slice(0, 5).map(item => /*#__PURE__*/react.createElement(ama_view_UserListened, {
    key: item,
    avatar: item
  }))))), /*#__PURE__*/react.createElement("div", {
    className: "mx_AudioSpace_twitter"
  }, /*#__PURE__*/react.createElement("div", {
    className: "header"
  }, listenerCount, " listened in X(twitter)", /*#__PURE__*/react.createElement("a", {
    href: xSpaceUrl,
    target: "_blank",
    className: "right"
  }, "X Space"))), /*#__PURE__*/react.createElement(ama_view_AirdropList, {
    xSpaceId: xSpaceId
  }), /*#__PURE__*/react.createElement("div", {
    className: "mx_AudioSpace_sdm"
  }, /*#__PURE__*/react.createElement("div", {
    className: "header"
  }, data === null || data === void 0 ? void 0 : data.total, " listened in SendingMe"), /*#__PURE__*/react.createElement(AutoHideScrollbar/* default */.Z, null, loading ? /*#__PURE__*/react.createElement(Spinner/* default */.Z, null) : (data === null || data === void 0 ? void 0 : (_data$data = data.data) === null || _data$data === void 0 ? void 0 : _data$data.length) > 0 && /*#__PURE__*/react.createElement("div", {
    style: {
      display: "flex",
      gap: "8px",
      flexDirection: "column"
    }
  }, data.data.map(item => /*#__PURE__*/react.createElement(ama_view_UserListened, (0,esm_extends/* default */.Z)({
    key: item.user_id
  }, transUserAccount(item))))))))));
};
/* harmony default export */ const ama_view_AudioSpaceView = (/*#__PURE__*/(0,react.memo)(AudioSpaceView));
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/dialogs/InviteDialog.tsx + 2 modules
var InviteDialog = __webpack_require__(97845);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/CreateExternalGroupStore.ts
var CreateExternalGroupStore = __webpack_require__(424758);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/right_panel/components/CreateExternalGroupRightPanel.tsx





const CreateExternalGroupRightPanel = ({
  roomId
}) => {
  const handleMembersChange = members => {
    dispatcher/* default */.ZP.dispatch({
      action: CreateExternalGroupStore/* CreateExternalGroupStoreAction */.cT.UpdateSelectedMembers,
      params: members
    });
  };
  return /*#__PURE__*/react.createElement(BaseCard/* default */.C, {
    disableHeader: true,
    className: "mx_external_group_panel_baseCard",
    footer: null
  }, /*#__PURE__*/react.createElement(InviteDialog/* InviteDialogContent */.WZ, {
    kind: InviteDialog/* KIND_INVITE */.q0,
    roomKind: InviteDialog/* InviteRoomKind */.qq.SquadRoom,
    initialText: "",
    roomId: roomId,
    onFinished: () => null,
    call: null
    // new attr for invite panel ⬇
    ,
    autoFocusSearch: false,
    disableFooter: true,
    disableAction: true,
    disableSearchInTab: true,
    disableMemberJoinedAttr: true,
    disableMemberInSearchBar: true,
    showExternalHeader: true,
    showExternalSearch: true,
    lockDisabled: true,
    onMemberChange: handleMembersChange,
    teleEnabled: false
  }));
};
/* harmony default export */ const components_CreateExternalGroupRightPanel = (CreateExternalGroupRightPanel);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/StickerStore.tsx
var StickerStore = __webpack_require__(478396);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/stickerpicker/Search.tsx
var Search = __webpack_require__(858687);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/res/img/emojipicker/empty_icon.svg
var empty_icon = __webpack_require__(925747);
var empty_icon_default = /*#__PURE__*/__webpack_require__.n(empty_icon);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/hooks/stickers/useGetStickerState.ts
var useGetStickerState = __webpack_require__(761982);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/hooks/stickers/useChangeStickerStyle.ts

const useChangeStickerStyle = props => {
  const {
    id
  } = props;
  const diff = "410px";
  (0,react.useEffect)(() => {
    const ele = document.getElementById(id);
    if (ele) {
      ele.style.width = `calc(100% - ${diff})`;
    }
    return () => {
      const ele = document.getElementById(id);
      if (ele) {
        ele.style.width = "100%";
      }
    };
  }, [id]);
};
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/right_panel/stickers/StickersShopStoreRightPanel.tsx










let StickerAction = /*#__PURE__*/function (StickerAction) {
  StickerAction["ADD"] = "add";
  StickerAction["REMOVE"] = "remove";
  return StickerAction;
}({});
const StickersShopStoreRightPanel = props => {
  const {
    onClose = () => {}
  } = props;
  const [filter, setFilter] = (0,react.useState)();
  const [filterResult, setFilterResult] = (0,react.useState)([]);
  const [isSearch, setIsSearch] = (0,react.useState)(false);
  const stickerState = (0,useGetStickerState/* useGetStickerState */.X)();
  const {
    personalStickers = [],
    stickers: shopStickers = [],
    loading
  } = stickerState || {};
  useChangeStickerStyle({
    id: 'mx_ContextualMenu_background_id'
  });
  const emptyEle = (0,react.useMemo)(() => {
    return /*#__PURE__*/react.createElement("div", {
      className: "mx_StickerPicker_empty"
    }, /*#__PURE__*/react.createElement("img", {
      src: (empty_icon_default()),
      alt: ""
    }), /*#__PURE__*/react.createElement("p", null, "No stickers found"));
  }, [(empty_icon_default())]);
  (0,react.useEffect)(() => {
    onEnterFilter();
  }, [filter]);
  function handleClose() {
    onClose();
  }
  async function handleActionClick(res) {
    const {
      sticker,
      action
    } = res;
    if (action === StickerAction.ADD) {
      await StickerStore/* default */.ZP.instance.addStickerToPersonal(sticker);
      res.callback && res.callback();
      return;
    }
    if (action === StickerAction.REMOVE) {
      await StickerStore/* default */.ZP.instance.removePersonalSticker(sticker);
      res.callback && res.callback();
      return;
    }
  }
  function renderHeader() {
    return /*#__PURE__*/react.createElement("div", {
      style: {
        fontSize: 14,
        marginLeft: 8,
        marginTop: -8,
        textOverflow: 'ellipsis',
        overflow: 'hidden',
        whiteSpace: 'nowrap',
        maxWidth: 300
      }
    }, (0,languageHandler._t)("Stickers"));
  }
  function renderCardItem(sticker) {
    return /*#__PURE__*/react.createElement(StickerShoppingItem, {
      sticker: sticker,
      hasSelected: personalStickers.find(s => s.package_id === sticker.package_id) !== undefined,
      handleActionClick: res => handleActionClick(res)
    });
  }
  const onChangeFilter = filter => {
    setFilter(filter);
  };
  function onEnterFilter() {
    if (filter) {
      setIsSearch(true);
      const lcFilter = filter.toLowerCase().trim(); // filter is case insensitive
      const res = shopStickers.filter(i => i.package_name.toLowerCase().includes(lcFilter) || i.package_description.toLowerCase().includes(lcFilter)) || [];
      setFilterResult(res);
    } else {
      setIsSearch(false);
    }
  }
  function renderSearch() {
    return /*#__PURE__*/react.createElement(Search/* default */.Z, {
      query: filter,
      onChange: onChangeFilter,
      onEnter: onEnterFilter,
      className: "mx_StickersShopStoreRightPanel_search"
    });
  }
  function renderContent() {
    if (isSearch) {
      return filterResult.length <= 0 ? emptyEle : /*#__PURE__*/react.createElement("div", {
        className: "mx_StickersShopStoreRightPanel_content"
      }, filterResult.map(sticker => renderCardItem(sticker)));
    }
    if (shopStickers.length <= 0) {
      return emptyEle;
    }
    return /*#__PURE__*/react.createElement("div", {
      className: "mx_StickersShopStoreRightPanel_content"
    }, shopStickers.map(sticker => renderCardItem(sticker)));
  }
  return /*#__PURE__*/react.createElement(BaseCard/* default */.C, {
    className: "mx_stickers_shopping_panel_BaseCard",
    onClose: handleClose,
    header: renderHeader(),
    footer: null
  }, renderSearch(), renderContent());
};
/* harmony default export */ const stickers_StickersShopStoreRightPanel = (StickersShopStoreRightPanel);
function StickerShoppingItem(props) {
  var _sticker$images;
  const {
    sticker,
    hasSelected,
    handleActionClick
  } = props;
  const [loading, setLoading] = (0,react.useState)(false);
  function handleClick() {
    if (loading) return;
    setLoading(true);
    handleActionClick && handleActionClick({
      sticker,
      action: hasSelected ? StickerAction.REMOVE : StickerAction.ADD,
      callback: () => {
        setLoading(false);
      }
    });
  }
  return /*#__PURE__*/react.createElement("div", {
    className: "sticker_shopping_card"
  }, /*#__PURE__*/react.createElement("div", {
    className: "top"
  }, /*#__PURE__*/react.createElement("div", {
    className: "top_info"
  }, /*#__PURE__*/react.createElement("div", {
    className: "title"
  }, sticker.package_name), /*#__PURE__*/react.createElement("div", {
    className: "description"
  }, ((_sticker$images = sticker.images) === null || _sticker$images === void 0 ? void 0 : _sticker$images.length) || 0, " ", /*#__PURE__*/react.createElement("span", {
    className: "description_stickers"
  }, (0,languageHandler._t)("stickers")))), /*#__PURE__*/react.createElement("div", {
    className: "action"
  }, /*#__PURE__*/react.createElement(lib.Spin, {
    spinning: loading
  }, /*#__PURE__*/react.createElement(elements_AccessibleButton/* default */.Z, {
    className: "sticker_action_button",
    kind: "primary",
    onClick: () => handleClick(),
    disabled: loading
  }, hasSelected ? (0,languageHandler._t)("Remove") : (0,languageHandler._t)("Add"))))), /*#__PURE__*/react.createElement("div", {
    className: "bottom"
  }, (sticker.images || []).slice(0, 5).map(i => /*#__PURE__*/react.createElement("img", {
    className: "card_imgs",
    src: i.url
  }))));
}
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/right_panel/stickers/StickersViewAllRightPanel.tsx









let StickersViewAllRightPanel_StickerAction = /*#__PURE__*/function (StickerAction) {
  StickerAction["ADD"] = "add";
  StickerAction["REMOVE"] = "remove";
  return StickerAction;
}({});
const StickersViewAllRightPanel = props => {
  const {
    onClose = () => {},
    sticker
  } = props;
  const stickerState = (0,useGetStickerState/* useGetStickerState */.X)();
  const {
    personalStickers = [],
    stickers: shopStickers = [],
    loading
  } = stickerState || {};
  const [packageInfo, setPackageInfo] = (0,react.useState)();
  const [actionLoading, setActionLoading] = (0,react.useState)(false);
  const isPersonalPackage = (0,react.useMemo)(() => {
    return personalStickers.some(i => i.package_id === sticker.package_id);
  }, [personalStickers, sticker]);
  useChangeStickerStyle({
    id: 'mx_ContextualMenu_background_id'
  });
  (0,react.useEffect)(() => {
    if (sticker && sticker.package_id) {
      setPackageInfo(shopStickers.find(p => p.package_id === sticker.package_id));
    }
  }, [sticker]);
  const emptyEle = (0,react.useMemo)(() => {
    return /*#__PURE__*/react.createElement("div", {
      className: "mx_StickerPicker_empty"
    }, /*#__PURE__*/react.createElement("img", {
      src: (empty_icon_default()),
      alt: ""
    }), /*#__PURE__*/react.createElement("p", null, "No stickers found"));
  }, [(empty_icon_default())]);
  function handleClose() {
    onClose();
  }
  function handleActionPreClick() {
    if (isPersonalPackage) {
      var _personalStickers$fin;
      const packageName = (_personalStickers$fin = personalStickers.find(i => i.package_id === sticker.package_id)) === null || _personalStickers$fin === void 0 ? void 0 : _personalStickers$fin.package_name;
      lib.Modal.confirm({
        className: "mx_modal_confirm_base",
        zIndex: 5000,
        content: /*#__PURE__*/react.createElement("div", {
          className: "confirm_base_content_wrapper"
        }, /*#__PURE__*/react.createElement("div", {
          className: "confirm_base_content_wrapper_title"
        }, (0,languageHandler._t)(`Remove "${packageName || 'Sticker Pack'}"`))),
        onOk: () => handleActionClick()
      });
    } else {
      handleActionClick();
    }
  }
  async function handleActionClick() {
    setActionLoading(true);
    if (isPersonalPackage) {
      await StickerStore/* default */.ZP.instance.removePersonalSticker(sticker);
    } else {
      await StickerStore/* default */.ZP.instance.addStickerToPersonal(sticker);
    }
    setActionLoading(false);
  }
  function renderHeader() {
    return /*#__PURE__*/react.createElement("div", {
      style: {
        fontSize: 14,
        marginLeft: 8,
        marginTop: -8,
        textOverflow: 'ellipsis',
        overflow: 'hidden',
        whiteSpace: 'nowrap',
        maxWidth: 300
      }
    }, (packageInfo === null || packageInfo === void 0 ? void 0 : packageInfo.package_name) || (0,languageHandler._t)("Stickers"));
  }
  function renderContent() {
    if (!packageInfo) {
      return emptyEle;
    }
    return /*#__PURE__*/react.createElement("div", {
      className: "sticker_list"
    }, (packageInfo.images || []).map(i => {
      return /*#__PURE__*/react.createElement("div", {
        className: `sticker_list_item`
      }, /*#__PURE__*/react.createElement("img", {
        src: i.url,
        alt: i.name
      }));
    }));
  }
  function renderFooter() {
    return /*#__PURE__*/react.createElement("div", {
      className: "mx_stickers_view_all_BaseCard_button"
    }, /*#__PURE__*/react.createElement(lib.Spin, {
      spinning: actionLoading
    }, /*#__PURE__*/react.createElement(elements_AccessibleButton/* default */.Z, {
      className: "sticker_save_button",
      kind: "primary",
      onClick: () => handleActionPreClick(),
      disabled: actionLoading
    }, isPersonalPackage ? (0,languageHandler._t)("Remove") : (0,languageHandler._t)("Add"))));
  }
  return /*#__PURE__*/react.createElement(BaseCard/* default */.C, {
    className: "mx_stickers_view_all_BaseCard",
    onClose: handleClose,
    onRefresh: () => {},
    header: renderHeader(),
    footer: renderFooter()
  }, renderContent());
};
/* harmony default export */ const stickers_StickersViewAllRightPanel = (StickersViewAllRightPanel);
// EXTERNAL MODULE: ./node_modules/react-beautiful-dnd/dist/react-beautiful-dnd.cjs.js
var react_beautiful_dnd_cjs = __webpack_require__(323605);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/right_panel/stickers/StickersSettingRightPanel.tsx










let StickersSettingRightPanel_StickerAction = /*#__PURE__*/function (StickerAction) {
  StickerAction["ADD"] = "add";
  StickerAction["REMOVE"] = "remove";
  return StickerAction;
}({});
const StickersSettingRightPanel = props => {
  const {
    onClose = () => {}
  } = props;
  const stickerState = (0,useGetStickerState/* useGetStickerState */.X)();
  const {
    personalStickers = [],
    stickers: shopStickers = []
  } = stickerState || {};
  const [settingStickerList, setSettingStickerList] = (0,react.useState)([]);
  const [loading, setLoading] = (0,react.useState)(false);
  useChangeStickerStyle({
    id: 'mx_ContextualMenu_background_id'
  });
  (0,react.useEffect)(() => {
    if (personalStickers) {
      setSettingStickerList(JSON.parse(JSON.stringify(personalStickers)));
    } else {
      setSettingStickerList([]);
    }
  }, [personalStickers]);
  const emptyEle = (0,react.useMemo)(() => {
    return /*#__PURE__*/react.createElement("div", {
      className: "mx_StickerPicker_empty"
    }, /*#__PURE__*/react.createElement("img", {
      src: (empty_icon_default()),
      alt: ""
    }), /*#__PURE__*/react.createElement("p", null, "No stickers found"));
  }, [(empty_icon_default())]);
  function handleClose() {
    onClose();
  }
  function changeCacheData(result) {
    const newItems = Array.from(settingStickerList);
    const [removed] = newItems.splice(result.source.index, 1);
    newItems.splice(result.destination.index, 0, removed);
    setSettingStickerList(newItems);
  }
  async function handleOnDragEnd(result) {
    if (!result.destination) return;
    changeCacheData(result);
    const sourceIndex = result.source.index;
    const targetIndex = result.destination.index;
    const order_offset = sourceIndex - targetIndex;
    const package_id = parseInt(result === null || result === void 0 ? void 0 : result.draggableId, 10);
    if (!package_id) return;
    if (order_offset === 0) return;
    setLoading(true);
    await StickerStore/* default */.ZP.instance.changePersonalStickersRankNumber(package_id, order_offset);
    setLoading(false);
  }
  async function handleRemoveFavorite(stickers) {
    setLoading(true);
    await StickerStore/* default */.ZP.instance.removePersonalSticker(stickers);
    setLoading(false);
  }
  function renderHeader() {
    return /*#__PURE__*/react.createElement("div", {
      style: {
        fontSize: 14,
        marginLeft: 8,
        marginTop: -8,
        textOverflow: 'ellipsis',
        overflow: 'hidden',
        whiteSpace: 'nowrap',
        maxWidth: 300
      }
    }, (0,languageHandler._t)("Sticker Setting"));
  }
  function rednerContent() {
    if ((settingStickerList === null || settingStickerList === void 0 ? void 0 : settingStickerList.length) === 0) return emptyEle;
    return /*#__PURE__*/react.createElement(lib.Spin, {
      spinning: loading
    }, /*#__PURE__*/react.createElement(react_beautiful_dnd_cjs/* DragDropContext */.Z5, {
      onDragEnd: handleOnDragEnd
    }, /*#__PURE__*/react.createElement(react_beautiful_dnd_cjs/* Droppable */.bK, {
      droppableId: "mx_stickers_setting_main"
    }, provided => /*#__PURE__*/react.createElement("div", (0,esm_extends/* default */.Z)({
      className: "mx_stickers_setting_main"
    }, provided.droppableProps, {
      ref: provided.innerRef
    }), settingStickerList.map((stickerPackage, index) => {
      const {
        package_id,
        package_name,
        package_description,
        thumbnail,
        images = []
      } = stickerPackage;
      return /*#__PURE__*/react.createElement(react_beautiful_dnd_cjs/* Draggable */._l, {
        key: package_id,
        draggableId: `${package_id}`,
        index: index
      }, provided => /*#__PURE__*/react.createElement("div", (0,esm_extends/* default */.Z)({
        className: "sticker_setting_item_wrapper",
        ref: provided.innerRef
      }, provided.draggableProps, provided.dragHandleProps), /*#__PURE__*/react.createElement("div", {
        className: "sticker_setting_item_wrapper_left"
      }, /*#__PURE__*/react.createElement("div", {
        className: "sticker_setting_item_wrapper_left_icon"
      })), /*#__PURE__*/react.createElement("div", {
        className: "sticker_setting_item_wrapper_right"
      }, /*#__PURE__*/react.createElement("div", {
        className: "sticker_setting_item_image"
      }, /*#__PURE__*/react.createElement("img", {
        src: thumbnail
      })), /*#__PURE__*/react.createElement("div", {
        className: "sticker_setting_item_content"
      }, /*#__PURE__*/react.createElement("div", {
        className: "sticker_setting_item_content_name"
      }, package_name), /*#__PURE__*/react.createElement("div", {
        className: "sticker_setting_item_content_desc"
      }, `${(images === null || images === void 0 ? void 0 : images.length) || 0} ${(0,languageHandler._t)("Stickers")}`))), /*#__PURE__*/react.createElement("div", {
        className: "sticker_setting_item_wrapper_extra"
      }, /*#__PURE__*/react.createElement("div", {
        className: "sticker_setting_item_wrapper_extra_icon",
        onClick: () => handleRemoveFavorite(stickerPackage)
      }))));
    }), provided.placeholder))));
  }
  return /*#__PURE__*/react.createElement(BaseCard/* default */.C, {
    className: "mx_stickers_setting_BaseCard",
    onClose: handleClose,
    onRefresh: () => {},
    header: renderHeader(),
    footer: null
  }, rednerContent());
};
/* harmony default export */ const stickers_StickersSettingRightPanel = (StickersSettingRightPanel);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/res/img/stickers-picker/add.svg
var add = __webpack_require__(848168);
var add_default = /*#__PURE__*/__webpack_require__.n(add);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/res/img/feather-customised/check.svg
var check = __webpack_require__(120494);
var check_default = /*#__PURE__*/__webpack_require__.n(check);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/right_panel/stickers/StickersUploadFavoriteRightPanel.tsx













let StickersUploadFavoriteRightPanel_StickerAction = /*#__PURE__*/function (StickerAction) {
  StickerAction["ADD"] = "add";
  StickerAction["REMOVE"] = "remove";
  return StickerAction;
}({});
const StickersUploadFavoriteRightPanel = props => {
  const {
    onClose = () => {},
    sticker
  } = props;
  const stickerState = (0,useGetStickerState/* useGetStickerState */.X)();
  const {
    collectStickers
  } = stickerState || {};
  const [isEdit, setIsEdit] = (0,react.useState)(false);
  const [actionLoading, setActionLoading] = (0,react.useState)(false);
  const [contentLoading, setContentLoading] = (0,react.useState)(false);
  const [selectedList, setSelectedList] = (0,react.useState)([]);
  const uploadRef = (0,react.useRef)();
  useChangeStickerStyle({
    id: 'mx_ContextualMenu_background_id'
  });
  function handleClose() {
    onClose();
  }
  function handleClickImg(data) {
    if (!isEdit) return;
    const deepCloneSelectedList = JSON.parse(JSON.stringify(selectedList));
    if (deepCloneSelectedList.some(i => i.url === data.url)) {
      setSelectedList(deepCloneSelectedList.filter(i => i.url !== data.url));
    } else {
      deepCloneSelectedList.push(data);
      setSelectedList(deepCloneSelectedList);
    }
  }
  function filterUnSelectedList() {
    return collectStickers.filter(sticker => {
      return !selectedList.some(i => i.url === sticker.url);
    });
  }
  async function handleDeleteFavoriteSticker() {
    if (selectedList.length === 0) {
      return;
    }
    setActionLoading(true);
    const list = filterUnSelectedList();
    await StickerStore/* default */.ZP.instance.updateFavoriteStickers(list);
    setActionLoading(false);
    setSelectedList([]);
  }
  async function handleMoveToFrontFavoriteSticker() {
    if (selectedList.length === 0) {
      return;
    }
    setActionLoading(true);
    const list = filterUnSelectedList();
    const newList = [...selectedList, ...list];
    await StickerStore/* default */.ZP.instance.updateFavoriteStickers(newList);
    setActionLoading(false);
    setSelectedList([]);
  }
  function handleCloseEdit() {
    setIsEdit(false);
    setSelectedList([]);
  }
  function handleUploadSticker(e) {
    var _uploadRef$current;
    e === null || e === void 0 ? void 0 : e.stopPropagation();
    e === null || e === void 0 ? void 0 : e.preventDefault();
    uploadRef === null || uploadRef === void 0 ? void 0 : (_uploadRef$current = uploadRef.current) === null || _uploadRef$current === void 0 ? void 0 : _uploadRef$current.click();
  }
  async function onFileChanged(e) {
    if (!e.target.files || !e.target.files.length) {
      return null;
    }
    const file = e.target.files[0];
    const maxSizeBytes = 512 * 1024;
    const allowedExtensions = /(\.apng|\.png|\.gif)$/i;
    if (!allowedExtensions.exec(file.name.toLocaleLowerCase())) {
      dist.SdMessage.warning((0,languageHandler._t)("Stickers must be static (PNG) or animated (APNG)"));
      return;
    }
    if (file.size > maxSizeBytes) {
      dist.SdMessage.warning((0,languageHandler._t)("Stickers must be less than 512KB"));
      return;
    }
    setContentLoading(true);
    const client = MatrixClientPeg/* MatrixClientPeg */.p.get();
    const fileUrl = await client.uploadContent(file);
    const obj = {
      // id as the unique identification key of the sticker object
      // Why not use filekey as id? Because filekey is string type data, IOS or Android requires int type data.
      // Now take the time as the unique identifier for uploading
      id: Date.now(),
      url: fileUrl,
      package_id: StickerStore/* SYSTEM_STICKER_PACKAGE */.l5.FAVORITE.id,
      name: StickerStore/* SYSTEM_STICKER_PACKAGE */.l5.FAVORITE.name,
      description: "",
      info: {}
    };
    const list = [obj, ...collectStickers];
    await StickerStore/* default */.ZP.instance.updateFavoriteStickers(list);
    setContentLoading(false);
  }
  ;
  function renderHeader() {
    return /*#__PURE__*/react.createElement("div", {
      style: {
        fontSize: 14,
        marginLeft: 16,
        marginTop: -8,
        textOverflow: 'ellipsis',
        overflow: 'hidden',
        whiteSpace: 'nowrap',
        maxWidth: 300
      }
    }, (0,languageHandler._t)("Added stickers"));
  }
  function renderContent() {
    return /*#__PURE__*/react.createElement(lib.Spin, {
      spinning: contentLoading
    }, /*#__PURE__*/react.createElement("div", {
      className: "stickers_favorite_management_content"
    }, /*#__PURE__*/react.createElement("div", {
      className: "stickers_favorite_management_content_description"
    }, /*#__PURE__*/react.createElement("div", {
      className: "description_item"
    }, "Upload instructions\uFF1A"), /*#__PURE__*/react.createElement("div", {
      className: "description_item"
    }, "Stickers can be static (PNG) or animated (APNG). Stickers must be between 128x128 and 512x512 pixels and no larger than 512 KB. We will automatically resize static PNG stickers for you.")), /*#__PURE__*/react.createElement("div", {
      className: "stickers_favorite_management_content_list"
    }, /*#__PURE__*/react.createElement("div", {
      className: "item_wrapper item_wrapper_upload"
    }, /*#__PURE__*/react.createElement("input", {
      type: "file",
      style: {
        display: "none"
      },
      ref: uploadRef,
      onChange: onFileChanged,
      accept: "image/*"
    }), /*#__PURE__*/react.createElement("img", {
      className: "item_wrapper_image item_wrapper_image_upload",
      src: (add_default()),
      onClick: e => handleUploadSticker(e)
    })), (collectStickers || []).map(i => /*#__PURE__*/react.createElement("div", {
      className: classnames_default()("item_wrapper", {
        "item_wrapper_editing": isEdit
      }),
      onClick: () => handleClickImg(i)
    }, /*#__PURE__*/react.createElement("img", {
      className: "item_wrapper_image",
      src: i.url
    }), isEdit && /*#__PURE__*/react.createElement("div", {
      className: "item_wrapper_select_box"
    }, /*#__PURE__*/react.createElement("div", {
      className: classnames_default()("select_box_wrapper", {
        "select_box_wrapper_selected": selectedList.some(item => item.url === i.url)
      })
    }, /*#__PURE__*/react.createElement("img", {
      className: "select_box_wrapper_icon",
      src: (check_default())
    }))))))));
  }
  function renderFooter() {
    if (isEdit) {
      return /*#__PURE__*/react.createElement(lib.Spin, {
        spinning: actionLoading
      }, /*#__PURE__*/react.createElement("div", {
        className: "mx_stickers_favorite_management_BaseCard_button mx_stickers_favorite_management_BaseCard_button_isEdit"
      }, /*#__PURE__*/react.createElement("div", {
        className: "sticker_management_action_left_area"
      }, /*#__PURE__*/react.createElement("div", {
        className: "selected_text_icon",
        onClick: () => handleCloseEdit()
      }), /*#__PURE__*/react.createElement("div", {
        className: "selected_text"
      }, `${selectedList.length} ${(0,languageHandler._t)("Sticker selected")}`)), /*#__PURE__*/react.createElement("div", {
        className: "sticker_management_action_right_area"
      }, /*#__PURE__*/react.createElement("div", {
        className: "text_action text_action_move",
        onClick: () => handleMoveToFrontFavoriteSticker()
      }, /*#__PURE__*/react.createElement("div", {
        className: "selected_button_icon selected_button_icon_move"
      }), (0,languageHandler._t)("MoveTop")), /*#__PURE__*/react.createElement("div", {
        className: "text_action text_action_delete",
        onClick: () => handleDeleteFavoriteSticker()
      }, /*#__PURE__*/react.createElement("div", {
        className: "selected_button_icon selected_button_icon_delete"
      }), (0,languageHandler._t)("Delete")))));
    }
    return /*#__PURE__*/react.createElement("div", {
      className: "mx_stickers_favorite_management_BaseCard_button"
    }, /*#__PURE__*/react.createElement(elements_AccessibleButton/* default */.Z, {
      className: "sticker_management_button",
      kind: "primary",
      onClick: () => setIsEdit(true),
      disabled: actionLoading
    }, (0,languageHandler._t)("Manage")));
  }
  return /*#__PURE__*/react.createElement(BaseCard/* default */.C, {
    className: "mx_stickers_favorite_management_BaseCard",
    onClose: handleClose,
    header: renderHeader(),
    footer: renderFooter()
  }, renderContent());
};
/* harmony default export */ const stickers_StickersUploadFavoriteRightPanel = (StickersUploadFavoriteRightPanel);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/elements/wysiwyg/Wysiwyg.tsx + 7 modules
var Wysiwyg = __webpack_require__(724344);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/elements/wysiwyg/components/FileItem.tsx
var FileItem = __webpack_require__(385479);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/elements/ImageView.tsx + 1 modules
var ImageView = __webpack_require__(95727);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/elements/wysiwyg/components/ImageViewWrapper.tsx



function ImageViewWrapper(props) {
  const {
    children
  } = props;
  const imageViewRef = (0,react.useRef)();
  (0,react.useEffect)(() => {
    if (imageViewRef.current) {
      var _imageViewRef$current;
      (_imageViewRef$current = imageViewRef.current) === null || _imageViewRef$current === void 0 ? void 0 : _imageViewRef$current.addEventListener("click", handleClick, false);
    }
    return () => {
      var _imageViewRef$current2;
      (_imageViewRef$current2 = imageViewRef.current) === null || _imageViewRef$current2 === void 0 ? void 0 : _imageViewRef$current2.removeEventListener("click", handleClick);
    };
  }, [imageViewRef]);
  function handleClick(e) {
    if (e.target.nodeName === 'IMG') {
      const imgSrc = e.target.src;
      const params = {
        src: imgSrc,
        name: name
      };
      Modal/* default */.Z.createDialog(ImageView/* default */.Z, params, "mx_Dialog_lightbox mx_ImageView_Dialog", null, false);
    }
  }
  return /*#__PURE__*/react.createElement("div", {
    className: "mx_Wysiwyg_image_view",
    ref: imageViewRef
  }, children);
}
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/right_panel/AnnouncementPanel.tsx












const AnnouncementPanel = props => {
  const {
    roomId,
    room,
    announcement: originAnnouncement,
    onClose,
    sourceRoomId
  } = props;
  const [isEdit, setIsEdit] = (0,react.useState)(false);
  const [loading, setLoading] = (0,react.useState)(false);
  const [hasPermission, setHasPermission] = (0,react.useState)(false);
  // The last recorded announcement information
  const [originalAnnouncement, setOriginalAnnouncement] = (0,react.useState)();
  const [announcement, setAnnouncement] = (0,react.useState)();
  const [originalFileList, setOriginalFileList] = (0,react.useState)([]);
  const [fileList, setFileList] = (0,react.useState)([]);
  const [refreshCount, setRefreshCount] = (0,react.useState)(0);

  // What is passed is reference type data
  // Copy a copy of the data and process it separately without affecting the delivery content.
  const parentAnnouncement = (0,react.useMemo)(() => {
    return originAnnouncement && JSON.parse(JSON.stringify(originAnnouncement));
  }, [originAnnouncement]);
  (0,react.useEffect)(() => {
    // If the announcement is not a message about the room to which it belongs
    // No permission to edit, do not display button groups
    if ((parentAnnouncement === null || parentAnnouncement === void 0 ? void 0 : parentAnnouncement.sourceRoomId) !== roomId) {
      setHasPermission(false);
      return;
    }
    if (!roomId) {
      setHasPermission(false);
      return;
    }
    const [result] = PermissionStore/* default */.ZP.hasPermission(roomId, PermissionStore/* PermissionMap */.$W.SquadManageRoom);
    setHasPermission(!!result);
  }, [roomId, parentAnnouncement && parentAnnouncement.sourceRoomId]);
  (0,react.useEffect)(() => {
    setAnnouncement(parentAnnouncement.content);
    setOriginalAnnouncement(parentAnnouncement.content);
    const parentAnnouncementFileList = parentAnnouncement.file_list && JSON.parse(JSON.stringify(parentAnnouncement.file_list));
    setFileList(parentAnnouncement.file_list || []);
    setOriginalFileList(parentAnnouncementFileList || []);
  }, [parentAnnouncement]);
  function handleEdit() {
    setIsEdit(!isEdit);
  }
  function handleChange(value) {
    setAnnouncement(value);
  }
  function handleFilesChange(files) {
    setFileList(files);
  }
  function handleClose() {
    onClose();
    setIsEdit(false);
    setRefreshCount(Math.floor(Math.random() * 10000));
  }
  function handlePreSave() {
    lib.Modal.confirm({
      className: "mx_modal_confirm_base",
      zIndex: 5000,
      content: /*#__PURE__*/react.createElement("div", {
        className: "confirm_base_content_wrapper"
      }, /*#__PURE__*/react.createElement("div", {
        className: "confirm_base_content_wrapper_title"
      }, (0,languageHandler._t)("Saving and publishing Now？")), /*#__PURE__*/react.createElement("div", {
        className: "confirm_base_content_wrapper_description"
      }, (0,languageHandler._t)("Notice Updated! Sharing to the community?"))),
      onOk: () => handleSave()
    });
  }
  async function handleSave() {
    const client = MatrixClientPeg/* MatrixClientPeg */.p.get();
    if (originalAnnouncement !== announcement || JSON.stringify(originalFileList) !== JSON.stringify(fileList)) {
      setLoading(true);
      const res = await client.setRoomAnnouncement(roomId, {
        content: announcement,
        file_list: fileList
      });
      if (res.event_id) {
        // success
        setIsEdit(false);
        setOriginalAnnouncement(announcement);
        setOriginalFileList(fileList);
        dist.SdMessage.success((0,languageHandler._t)("Saved successfully"));
      } else {
        dist.SdMessage.error((0,languageHandler._t)("Save failed"));
      }
      setLoading(false);
    }
  }
  function renderHeader() {
    return /*#__PURE__*/react.createElement("div", null, (0,languageHandler._t)("Room Notice"));
  }
  function renderContent() {
    if (!isEdit) {
      return /*#__PURE__*/react.createElement(ImageViewWrapper, {
        name: room === null || room === void 0 ? void 0 : room.name
      }, announcement && /*#__PURE__*/react.createElement("div", {
        className: "mx_MAnnouncement_ele",
        dangerouslySetInnerHTML: {
          __html: announcement
        }
      }), /*#__PURE__*/react.createElement("div", {
        className: "mx_MAnnouncement_file_area"
      }, fileList.map(i => /*#__PURE__*/react.createElement(FileItem/* default */.Z, i))));
    }
    return /*#__PURE__*/react.createElement(Wysiwyg/* default */.Z, {
      className: "mx_MAnnouncement_wysiwyg",
      value: announcement,
      onChange: handleChange,
      refreshCount: refreshCount,
      file_list: fileList,
      onFileListChange: files => handleFilesChange(files)
    });
  }
  function renderFooter() {
    if (!hasPermission) return null;
    if (isEdit) {
      return /*#__PURE__*/react.createElement("div", {
        className: "mx_announcement_panel_baseCard_button mx_announcement_panel_baseCard_button_multiple"
      }, /*#__PURE__*/react.createElement(elements_AccessibleButton/* default */.Z, {
        className: "announcement_cancel_button",
        kind: "secondary",
        onClick: () => {
          setAnnouncement(originalAnnouncement);
          setFileList(originalFileList);
          setIsEdit(false);
          setRefreshCount(Math.floor(Math.random() * 10000));
        }
      }, (0,languageHandler._t)("Cancel")), /*#__PURE__*/react.createElement(lib.Spin, {
        spinning: loading
      }, /*#__PURE__*/react.createElement(elements_AccessibleButton/* default */.Z, {
        className: "announcement_save_button",
        kind: "primary",
        onClick: () => handlePreSave(),
        disabled: loading
      }, (0,languageHandler._t)("Save"))));
    }
    return /*#__PURE__*/react.createElement("div", {
      className: "mx_announcement_panel_baseCard_button"
    }, /*#__PURE__*/react.createElement(elements_AccessibleButton/* default */.Z, {
      className: "announcement_edit_button",
      kind: "primary",
      onClick: () => handleEdit()
    }, (0,languageHandler._t)("Edit")));
  }
  return /*#__PURE__*/react.createElement(BaseCard/* default */.C, {
    className: "mx_announcement_panel_baseCard",
    onClose: handleClose,
    onRefresh: () => {
      setAnnouncement(originalAnnouncement);
      setFileList(originalFileList);
      setRefreshCount(Math.floor(Math.random() * 10000));
    },
    header: renderHeader(),
    footer: renderFooter()
  }, renderContent());
};
/* harmony default export */ const right_panel_AnnouncementPanel = (AnnouncementPanel);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/right_panel/Explore.tsx
var Explore = __webpack_require__(746487);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/utils/EventUtils.ts
var EventUtils = __webpack_require__(26031);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/rooms/EventTileType.tsx
var EventTileType = __webpack_require__(442025);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/right_panel/MessageDetailCard.tsx









const MessageDetailCard = props => {
  const {
    tileHandler
  } = (0,EventUtils/* getEventDisplayInfo */.UL)(props.mxEvent);
  const alwaysShowTimestamps = SettingsStore/* default */.C.getValue("alwaysShowTimestamps");
  // const EventTileType = sdk.getComponent(tileHandler);
  const replyThread = /*#__PURE__*/react.createRef();
  let thread;
  // When the "showHiddenEventsInTimeline" lab is enabled,
  // avoid showing replies for hidden events (events without tiles)
  if ((0,EventTile/* haveTileForEvent */.K3)(props.mxEvent)) {
    thread = ReplyThread/* default */.Z.makeThread(props.mxEvent, props.onHeightChanged, props.permalinkCreator, replyThread, Layout/* Layout */.A.IRC, alwaysShowTimestamps, props.forPreview);
  }
  return /*#__PURE__*/react.createElement(BaseCard/* default */.C, {
    className: "mx_MessageDetailCard",
    onClose: props.onClose,
    header: (0,languageHandler._t)("Message View")
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_EventTile",
    "data-layout": "bubble",
    "data-has-reply": !!thread
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_EventTile_line",
    key: "mx_EventTile_line"
  }, thread, /*#__PURE__*/react.createElement(EventTileType/* default */.Z, {
    messageType: tileHandler,
    mxEvent: props.mxEvent,
    replacingEventId: props.replacingEventId,
    editState: props.editState,
    highlights: props.highlights,
    highlightLink: props.highlightLink,
    showUrlPreview: props.showUrlPreview,
    permalinkCreator: props.permalinkCreator,
    onHeightChanged: props.onHeightChanged,
    forPreview: props.forPreview,
    displayWebsiteLinkSetting: props.displayWebsiteLinkSetting,
    interceptMessage: false
  }))));
};
/* harmony default export */ const right_panel_MessageDetailCard = (MessageDetailCard);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/SquadWidgetStore.tsx
var SquadWidgetStore = __webpack_require__(233685);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/right_panel/squadHomePage/SquadWidgetSortRightPanel.tsx


function SquadWidgetSortRightPanel_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function SquadWidgetSortRightPanel_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? SquadWidgetSortRightPanel_ownKeys(Object(t), !0).forEach(function (r) { (0,defineProperty/* default */.Z)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : SquadWidgetSortRightPanel_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }









const SquadWidgetSortRightPanel = props => {
  const {
    onClose = () => {},
    roomId
  } = props;
  const [generalList, setGeneraList] = (0,react.useState)([]);
  const [originWidgetConfigList, setOriginWidgetConfigList] = (0,react.useState)([]);
  const [widgetConfigList, setWidgetConfigList] = (0,react.useState)([]);
  const [hiddenWidgetConfigList, setHiddenWidgetConfigList] = (0,react.useState)([]);
  const [loading, setLoading] = (0,react.useState)(false);
  const [actionLoading, setActionLoading] = (0,react.useState)(false);
  (0,react.useEffect)(() => {
    init();
  }, []);
  const init = async () => {
    setLoading(true);
    // await getGeneraList();
    await getWidgetConfigList();
    setLoading(false);
  };
  const getGeneraList = async () => {
    const res = await SquadWidgetStore/* default */.ZP.instance.getGeneralWidgetList();
    setGeneraList(res);
  };
  const getWidgetConfigList = async () => {
    const res = await SquadWidgetStore/* default */.ZP.instance.getWidgetConfigListBySquadId(roomId);
    setOriginWidgetConfigList(res);
  };

  // NOTE: The return value of the configuration is the result of server-side processing.
  (0,react.useEffect)(() => {
    const showList = originWidgetConfigList.filter(i => i.show);
    const hiddenList = originWidgetConfigList.filter(i => !i.show);
    setWidgetConfigList(showList);
    setHiddenWidgetConfigList(hiddenList);
  }, [originWidgetConfigList]);
  const emptyEle = (0,react.useMemo)(() => {
    return /*#__PURE__*/react.createElement("div", {
      className: "mx_SquadHomePage_widget_empty"
    }, /*#__PURE__*/react.createElement("img", {
      src: (empty_icon_default()),
      alt: ""
    }), /*#__PURE__*/react.createElement("p", null, "No widget found"));
  }, [(empty_icon_default())]);
  function handleClose() {
    onClose();
  }
  function changeCacheData(result) {
    const newItems = Array.from(widgetConfigList);
    const [removed] = newItems.splice(result.source.index, 1);
    newItems.splice(result.destination.index, 0, removed);
    setWidgetConfigList(newItems);
  }
  async function handleOnDragEnd(result) {
    if (!result.destination) return;
    changeCacheData(result);
  }
  async function handleSave() {
    setActionLoading(true);
    await SquadWidgetStore/* default */.ZP.instance.saveWidgetConfigList(roomId, [...widgetConfigList, ...hiddenWidgetConfigList]);
    lib.message.success((0,languageHandler._t)("Save success"));
    setActionLoading(false);
  }
  function handleChangeStatus(widget) {
    const {
      show = false
    } = widget;
    if (show) {
      setWidgetConfigList(widgetConfigList.filter(i => i.code !== widget.code));
      setHiddenWidgetConfigList([...hiddenWidgetConfigList, SquadWidgetSortRightPanel_objectSpread(SquadWidgetSortRightPanel_objectSpread({}, widget), {}, {
        show: false
      })]);
    } else {
      setHiddenWidgetConfigList(hiddenWidgetConfigList.filter(i => i.code !== widget.code));
      setWidgetConfigList([...widgetConfigList, SquadWidgetSortRightPanel_objectSpread(SquadWidgetSortRightPanel_objectSpread({}, widget), {}, {
        show: true
      })]);
    }
  }
  function renderHeader() {
    return /*#__PURE__*/react.createElement("div", null, (0,languageHandler._t)("Widget sort settings"));
  }
  function renderFooter() {
    return /*#__PURE__*/react.createElement("div", {
      className: "mx_squadHomePage_widget_buttons"
    }, /*#__PURE__*/react.createElement(dist.SdButton, {
      className: "cancel_button",
      type: "associate",
      size: "large",
      disabled: actionLoading,
      onClick: () => onClose && onClose()
    }, (0,languageHandler._t)("Cancel")), /*#__PURE__*/react.createElement(lib.Spin, {
      spinning: actionLoading
    }, /*#__PURE__*/react.createElement(dist.SdButton, {
      className: "save_button",
      type: "primary",
      size: "large",
      disabled: actionLoading,
      onClick: () => handleSave()
    }, (0,languageHandler._t)("Save"))));
  }
  function rednerContent() {
    if ((widgetConfigList === null || widgetConfigList === void 0 ? void 0 : widgetConfigList.length) === 0 && (hiddenWidgetConfigList === null || hiddenWidgetConfigList === void 0 ? void 0 : hiddenWidgetConfigList.length) === 0) {
      return /*#__PURE__*/react.createElement(lib.Spin, {
        spinning: loading
      }, emptyEle);
    }
    return /*#__PURE__*/react.createElement(lib.Spin, {
      spinning: loading
    }, (widgetConfigList === null || widgetConfigList === void 0 ? void 0 : widgetConfigList.length) > 0 && /*#__PURE__*/react.createElement(react_beautiful_dnd_cjs/* DragDropContext */.Z5, {
      onDragEnd: handleOnDragEnd
    }, /*#__PURE__*/react.createElement(react_beautiful_dnd_cjs/* Droppable */.bK, {
      droppableId: "mx_squadHomePage_widget_setting_main"
    }, provided => /*#__PURE__*/react.createElement("div", (0,esm_extends/* default */.Z)({
      className: "mx_squadHomePage_widget_setting_main"
    }, provided.droppableProps, {
      ref: provided.innerRef
    }), widgetConfigList.map((configItem, index) => {
      const {
        code,
        name
      } = configItem;
      return /*#__PURE__*/react.createElement(react_beautiful_dnd_cjs/* Draggable */._l, {
        key: code,
        draggableId: code,
        index: index
      }, provided => {
        return /*#__PURE__*/react.createElement("div", (0,esm_extends/* default */.Z)({
          className: "drag_item_ref_wrapper",
          ref: provided.innerRef
        }, provided.draggableProps, provided.dragHandleProps), /*#__PURE__*/react.createElement(DragWidget, {
          weiget: configItem,
          onHiddenAction: () => handleChangeStatus(configItem)
        }));
      });
    }), provided.placeholder))), hiddenWidgetConfigList.length > 0 && /*#__PURE__*/react.createElement("div", {
      className: "mx_squadHomePage_widget_hidden_area"
    }, /*#__PURE__*/react.createElement("div", {
      className: "area_title"
    }, (0,languageHandler._t)("Hide")), hiddenWidgetConfigList.map(i => /*#__PURE__*/react.createElement(DragWidget, {
      weiget: i,
      disabled: true,
      onHiddenAction: () => handleChangeStatus(i)
    }))));
  }
  return /*#__PURE__*/react.createElement(BaseCard/* default */.C, {
    className: "mx_squadHomePage_widget_setting_BaseCard",
    onClose: handleClose,
    header: renderHeader(),
    footer: renderFooter()
  }, rednerContent());
};
/* harmony default export */ const squadHomePage_SquadWidgetSortRightPanel = (SquadWidgetSortRightPanel);
const DragWidget = props => {
  const {
    weiget,
    disabled,
    onHiddenAction
  } = props;
  return /*#__PURE__*/react.createElement("div", {
    className: classnames_default()("squad_home_widget_drag_item_wrapper", {
      squad_home_widget_drag_item_wrapper_disabled: disabled
    })
  }, /*#__PURE__*/react.createElement("div", {
    className: "squad_home_widget_drag_item_wrapper_left"
  }, /*#__PURE__*/react.createElement("div", {
    className: "squad_home_widget_drag_item_wrapper_left_icon"
  })), /*#__PURE__*/react.createElement("div", {
    className: "squad_home_widget_drag_item_wrapper_right"
  }, /*#__PURE__*/react.createElement("div", null, weiget.name)), /*#__PURE__*/react.createElement("div", {
    className: "squad_home_widget_drag_item_wrapper_extra"
  }, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()({
      squad_home_widget_drag_item_wrapper_extra_icon: true,
      squad_home_widget_drag_item_wrapper_extra_icon_hide: !disabled,
      squad_home_widget_drag_item_wrapper_extra_icon_show: disabled
    }),
    onClick: () => onHiddenAction()
  })));
};
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/res/img/empty-cover/empty-data.svg
var empty_data = __webpack_require__(211856);
var empty_data_default = /*#__PURE__*/__webpack_require__.n(empty_data);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/structures/space_home/hooks/useAnnouncements.ts
var useAnnouncements = __webpack_require__(807065);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/structures/space_home/components/AncCardInfo.tsx
var AncCardInfo = __webpack_require__(135605);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/structures/space_home/components/NoticeView.tsx




function NoticeView(props) {
  const {
    room,
    matrixEvent
  } = props;
  const [announcement, setAnnouncement] = (0,react.useState)();
  const [fileList, setFileList] = (0,react.useState)([]);
  (0,react.useEffect)(() => {
    var _data$announcement, _data$announcement2;
    const data = matrixEvent.getContent();
    setAnnouncement((data === null || data === void 0 ? void 0 : (_data$announcement = data.announcement) === null || _data$announcement === void 0 ? void 0 : _data$announcement.content) || "");
    setFileList((data === null || data === void 0 ? void 0 : (_data$announcement2 = data.announcement) === null || _data$announcement2 === void 0 ? void 0 : _data$announcement2.file_list) || []);
  }, []);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(AncCardInfo/* default */.Z, {
    type: "NOTICE",
    mxEvent: matrixEvent,
    className: "mb-12"
  }), /*#__PURE__*/react.createElement(ImageViewWrapper, {
    name: room === null || room === void 0 ? void 0 : room.name
  }, announcement && /*#__PURE__*/react.createElement("div", {
    className: "mx_MAnnouncement_ele",
    dangerouslySetInnerHTML: {
      __html: announcement
    }
  }), /*#__PURE__*/react.createElement("div", {
    className: "mx_MAnnouncement_file_area"
  }, fileList.map(i => /*#__PURE__*/react.createElement(FileItem/* default */.Z, i)))));
}
/* harmony default export */ const components_NoticeView = (NoticeView);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/structures/space_home/components/AMAView.tsx





function AMAView(props) {
  const {
    room,
    matrixEvent
  } = props;
  const [preview, setPreview] = (0,react.useState)();
  const [loading, setLoading] = (0,react.useState)(true);
  const cli = MatrixClientPeg/* MatrixClientPeg */.p.get();
  const ts = matrixEvent.getTs();
  const {
    content
  } = matrixEvent.getEffectiveEvent();
  const link = content.body;
  (0,react.useEffect)(() => {
    setLoading(true);
    cli.getUrlPreview(link, ts).then(res => {
      setPreview(res);
      setLoading(false);
    });
  }, []);
  if (loading) {
    return /*#__PURE__*/react.createElement(dist.SdSkeleton.SimpleList, null);
  }
  if (!preview) return null;
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(AncCardInfo/* default */.Z, {
    type: "AMA",
    mxEvent: matrixEvent,
    className: "mb-12"
  }), /*#__PURE__*/react.createElement(ama_view_AudioSpaceView, {
    preview: preview,
    roomId: room.roomId,
    xSpaceUrl: link,
    hiddenClose: true,
    className: "p-0"
  }));
}
/* harmony default export */ const components_AMAView = (AMAView);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/structures/space_home/components/MsgView.tsx




function MsgView(props) {
  const {
    room,
    matrixEvent
  } = props;
  return /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement(AncCardInfo/* default */.Z, {
    type: "MSG",
    mxEvent: matrixEvent,
    className: "mb-12"
  }), /*#__PURE__*/react.createElement(MessageEvent["default"], {
    mxEvent: matrixEvent,
    maxImageHeight: 150,
    onHeightChanged: () => {},
    tileShape: EventTile/* TileShape */.GO.Pinned
  }));
}
/* harmony default export */ const components_MsgView = (MsgView);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/structures/space_home/widgets/Announcement.tsx
var Announcement = __webpack_require__(224424);
// EXTERNAL MODULE: ./node_modules/lodash-es/orderBy.js
var orderBy = __webpack_require__(803695);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/avatars/DecoratedRoomAvatar.tsx + 1 modules
var DecoratedRoomAvatar = __webpack_require__(795776);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/right_panel/squadHomePage/SquadAnnouncementCardRightPanel.tsx















const SquadAnnouncementCardRightPanel = props => {
  const {
    onClose = () => {},
    roomId,
    space,
    defaultShowInfo
  } = props;
  const {
    loading,
    mxEvents,
    pinnedMap
  } = (0,useAnnouncements/* default */.ZP)(space);
  const [loadingEvents, setLoadingEvents] = (0,react.useState)(true);
  const [groupEvents, setGroupEvents] = (0,react.useState)();
  const [showDetail, setShowDetail] = (0,react.useState)(false);
  const [currentEvent, setCurrentEvent] = (0,react.useState)();
  const [currentRoom, setCurrentRoom] = (0,react.useState)();
  const allRooms = (0,react.useMemo)(() => {
    return (0,useAnnouncements/* getRooms */.A4)(space);
  }, []);
  (0,react.useEffect)(() => {
    if (defaultShowInfo) {
      setShowDetail(defaultShowInfo.showInfo);
      setCurrentEvent(defaultShowInfo.mxEvent);
      setCurrentRoom(defaultShowInfo.room);
    }
  }, [defaultShowInfo]);
  (0,react.useEffect)(() => {
    if (mxEvents !== null && mxEvents !== void 0 && mxEvents.length) {
      Promise.all(mxEvents).then(events => {
        const sortEvens = (0,orderBy/* default */.Z)(events, "event.origin_server_ts", "desc").filter(Boolean);
        const groupEvents = (0,groupBy/* default */.Z)(sortEvens, "event.room_id");
        setGroupEvents(groupEvents);
      }).catch(() => {
        setLoadingEvents(false);
      });
    } else {
      setLoadingEvents(false);
    }
  }, [mxEvents]);
  const emptyEle = (0,react.useMemo)(() => {
    return /*#__PURE__*/react.createElement("div", {
      className: "mx_SquadHomePage_widget_empty"
    }, /*#__PURE__*/react.createElement("img", {
      src: (empty_data_default()),
      alt: ""
    }), /*#__PURE__*/react.createElement("p", null, (0,languageHandler._t)("There's nothing more to see here for now.")));
  }, [(empty_data_default())]);
  function handleClose() {
    onClose();
  }
  function renderHeader() {
    if (showDetail) return null;
    return /*#__PURE__*/react.createElement("div", {
      style: {
        fontSize: 14,
        marginLeft: 8,
        marginTop: -8,
        textOverflow: "ellipsis",
        overflow: "hidden",
        whiteSpace: "nowrap",
        maxWidth: 300
      }
    }, (0,languageHandler._t)("Announcement"));
  }
  const detailView = (0,react.useMemo)(() => {
    if (!showDetail || !currentRoom || !currentEvent) return null;
    const eventId = currentEvent.getId();
    const type = pinnedMap.get(eventId);
    let renderView = null;
    switch (type) {
      case "AMA":
        console.log("click ama");
        renderView = /*#__PURE__*/react.createElement(components_AMAView, {
          room: currentRoom,
          matrixEvent: currentEvent
        });
        break;
      case "NOTICE":
        console.log("click notice");
        renderView = /*#__PURE__*/react.createElement(components_NoticeView, {
          room: currentRoom,
          matrixEvent: currentEvent
        });
        break;
      case "MSG":
        console.log("click msg");
        renderView = /*#__PURE__*/react.createElement(components_MsgView, {
          room: currentRoom,
          matrixEvent: currentEvent
        });
        break;
      default:
        break;
    }
    return /*#__PURE__*/react.createElement("div", {
      className: "flex-col flex-gap-24 p-24"
    }, renderView, /*#__PURE__*/react.createElement(dist.SdButton, {
      onClick: () => {
        dispatcher/* default */.ZP.dispatch({
          action: "view_room",
          show_room_tile: true,
          // make sure the room is visible in the list
          room_id: currentRoom.roomId
          // clear_search: ev && (ev.key === Key.ENTER || ev.key === Key.SPACE),
        });

        dispatcher/* default */.ZP.dispatch({
          action: actions/* Action */.a.ShowRoomPanel
        });
      }
    }, (0,languageHandler._t)("Channel")));
  }, [currentEvent, currentRoom, showDetail]);
  const handleClick = (ev, room) => {
    setShowDetail(true);
    setCurrentEvent(ev);
    setCurrentRoom(room);
  };
  const handleOnBack = () => {
    setShowDetail(false);
    setCurrentEvent(null);
    setCurrentRoom(null);
  };
  function renderRoomList() {
    let renderList = [];
    for (let key in groupEvents) {
      const room = allRooms.find(i => i.roomId === key);
      if (!room) continue;
      const name = room.name;
      const events = groupEvents[key];
      renderList.push( /*#__PURE__*/react.createElement("div", {
        className: "mx_SquadHomePage_anc_roomList"
      }, /*#__PURE__*/react.createElement("div", {
        className: "flex flex-gap-12 items-center justify-start mb-26"
      }, /*#__PURE__*/react.createElement(DecoratedRoomAvatar/* default */.Z, {
        room: room,
        size: 34,
        style: {
          borderRadius: "50%"
        }
      }), /*#__PURE__*/react.createElement("div", {
        className: "text-16 fw-500"
      }, name)), /*#__PURE__*/react.createElement("div", {
        className: "flex-col flex-gap-12"
      }, events.map(ev => /*#__PURE__*/react.createElement(Announcement/* default */.Z, {
        space: space,
        room: room,
        mxEvent: ev,
        pinnedMap: pinnedMap,
        direction: "vertical",
        onClick: () => handleClick(ev, room)
      }))), /*#__PURE__*/react.createElement("div", {
        className: "divide mt-20"
      })));
    }
    return renderList;
  }
  function rednerContent() {
    var _Object$keys;
    let content;
    if (loading || loadingEvents) {
      content = /*#__PURE__*/react.createElement(dist.SdSkeleton.SimpleList, {
        style: {
          padding: "0px 8px"
        },
        active: true
      });
    } else if (groupEvents && (_Object$keys = Object.keys(groupEvents)) !== null && _Object$keys !== void 0 && _Object$keys.length) {
      content = /*#__PURE__*/react.createElement("div", {
        className: "flex-col flex-gap-24 pb-24"
      }, renderRoomList());
    } else {
      content = emptyEle;
    }
    return /*#__PURE__*/react.createElement("div", {
      className: classnames_default()("px-12", {
        "hidden": showDetail
      })
    }, content);
  }
  return /*#__PURE__*/react.createElement(BaseCard/* default */.C, {
    className: "mx_squadHomePage_Announcement_BaseCard",
    onClose: handleClose,
    header: renderHeader(),
    footer: null,
    onBack: showDetail ? handleOnBack : null
  }, detailView, rednerContent());
};
/* harmony default export */ const squadHomePage_SquadAnnouncementCardRightPanel = (SquadAnnouncementCardRightPanel);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/structures/space_home/widgets/TwitterEmbed.tsx
var TwitterEmbed = __webpack_require__(971616);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/right_panel/TwitterTimeline.tsx



/* harmony default export */ const TwitterTimeline = (/*#__PURE__*/(0,react.memo)(function TwitterTimeline(props) {
  var _url$pathname;
  const {
    twitterProfileUrl,
    onClose
  } = props;
  const url = new URL(twitterProfileUrl);
  const sourceName = (_url$pathname = url.pathname) === null || _url$pathname === void 0 ? void 0 : _url$pathname.replace("/", "");
  return /*#__PURE__*/react.createElement("div", {
    className: "mx_TwitterTimeline flex-grow flex-col"
  }, /*#__PURE__*/react.createElement("div", {
    className: "flex items-center justify-between p-12"
  }, /*#__PURE__*/react.createElement("span", {
    className: "text-14"
  }, "X (Twitter)"), /*#__PURE__*/react.createElement("div", {
    className: "rounded size-18 bg-838791 flex items-center justify-center"
  }, /*#__PURE__*/react.createElement(dist.SdIcon, {
    icon: "CloseOutlines",
    className: "cursor-pointer",
    onClick: onClose
  }))), /*#__PURE__*/react.createElement(TwitterEmbed/* default */.Z, {
    sourceName: sourceName
  }));
}));
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/inbox/components/NotificationDrawer.tsx + 6 modules
var NotificationDrawer = __webpack_require__(461951);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/right_panel/InviteGroupPanel.tsx
var InviteGroupPanel = __webpack_require__(289791);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/structures/RightPanel.tsx


var RightPanel_dec, RightPanel_class, RightPanel_class2;
function RightPanel_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function RightPanel_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? RightPanel_ownKeys(Object(t), !0).forEach(function (r) { (0,defineProperty/* default */.Z)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : RightPanel_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
/*
Copyright 2019 Michael Telatynski <7t3chguy@gmail.com>
Copyright 2015 - 2021 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/



















// import FilePanel from "./FilePanel";









































const FEED_HOST_URL = SdkConfig/* default */.Z.get()["feed"];
let SHOW_LEFT_PANEL = false;
const isLocalWalletAddress = (walletAddress1, walletAddress2) => {
  return walletAddress1 === walletAddress2;
};
let RightPanel = (RightPanel_dec = (0,replaceableComponent/* replaceableComponent */.U)("structures.RightPanel"), RightPanel_dec(RightPanel_class = (RightPanel_class2 = class RightPanel extends react.PureComponent {
  constructor(props, context) {
    var _this$state, _this$state$params;
    super(props, context);
    (0,defineProperty/* default */.Z)(this, "dispatcherRef", void 0);
    (0,defineProperty/* default */.Z)(this, "delayedUpdate", (0,throttle/* default */.Z)(() => {
      this.forceUpdate();
    }, 500, {
      leading: true,
      trailing: true
    }));
    (0,defineProperty/* default */.Z)(this, "setSelectedAddress", options => {
      console.log("🚀 ~ file: RightPanel.tsx:263 ~ RightPanel ~ options:", options);
      const address = options.filter(item => item.checked).map(item => item.value).join(",") || "Unknown";
      this.setState({
        address
      });
    });
    (0,defineProperty/* default */.Z)(this, "onChangeOptions", options => {
      this.setSelectedAddress(options);
    });
    (0,defineProperty/* default */.Z)(this, "getFeedEntry", member => {
      var _member$user, _member$user$userRema, _member$user3, _member$user3$userRem, _member$user4, _member$user4$userRem;
      if (!member) return null;
      const client = MatrixClientPeg/* MatrixClientPeg */.p.get();
      let src;
      if ((_member$user = member.user) !== null && _member$user !== void 0 && (_member$user$userRema = _member$user.userRemark) !== null && _member$user$userRema !== void 0 && _member$user$userRema.images) {
        var _member$user2, _member$user2$userRem;
        src = (0,util/* urlBindAccessToken */.U)((_member$user2 = member.user) === null || _member$user2 === void 0 ? void 0 : (_member$user2$userRem = _member$user2.userRemark) === null || _member$user2$userRem === void 0 ? void 0 : _member$user2$userRem.images[0]);
      }
      if (member.userId === client.getUserId()) {
        return null;
      }
      if (!SdkConfig/* default */.Z.get("UNABLE_FUN_PERMISSION")) return null;
      return /*#__PURE__*/react.createElement(react.Fragment, null, (_member$user3 = member.user) !== null && _member$user3 !== void 0 && (_member$user3$userRem = _member$user3.userRemark) !== null && _member$user3$userRem !== void 0 && _member$user3$userRem.note || src ? /*#__PURE__*/react.createElement("div", {
        className: "mx_RoomSummaryCard_actionRemark",
        onClick: () => {
          if (MatrixClientPeg/* MatrixClientPeg */.p.get().isGuest()) return;
          dispatcher/* default */.ZP.dispatch({
            action: actions/* Action */.a.SetRightPanelPhase,
            phase: RightPanelStorePhases/* RightPanelPhases */.q4.EditRemark,
            refireParams: {
              member
            }
          });
        }
      }, /*#__PURE__*/react.createElement("div", {
        className: "mx_RoomSummaryCard_actionRemark_left"
      }, /*#__PURE__*/react.createElement("span", {
        className: "mx_RoomSummaryCard_actionRemark_title"
      }, "Note"), /*#__PURE__*/react.createElement("span", {
        className: "mx_RoomSummaryCard_actionRemark_content"
      }, src && /*#__PURE__*/react.createElement(lib.Avatar, {
        size: 26,
        style: {
          minWidth: 26
        },
        shape: "square",
        src: src
      }), /*#__PURE__*/react.createElement("span", {
        className: "mx_RoomSummaryCard_actionRemark_note"
      }, (_member$user4 = member.user) === null || _member$user4 === void 0 ? void 0 : (_member$user4$userRem = _member$user4.userRemark) === null || _member$user4$userRem === void 0 ? void 0 : _member$user4$userRem.note)))) : null);
    });
    (0,defineProperty/* default */.Z)(this, "onGroupStoreUpdated", () => {
      this.setState({
        isUserPrivilegedInGroup: GroupStore/* default */.ZP.isUserPrivileged(this.props.groupId)
      });
    });
    (0,defineProperty/* default */.Z)(this, "onRoomStateMember", (ev, state, member) => {
      var _this$props$room, _this$props$room2, _this$props$room3;
      if (!this.props.room || member.roomId !== ((_this$props$room = this.props.room) === null || _this$props$room === void 0 ? void 0 : _this$props$room.roomId)) {
        return;
      }
      // redraw the badge on the membership list
      if (this.state.phase === RightPanelStorePhases/* RightPanelPhases */.q4.RoomMemberList && member.roomId === ((_this$props$room2 = this.props.room) === null || _this$props$room2 === void 0 ? void 0 : _this$props$room2.roomId)) {
        this.delayedUpdate();
      } else if (this.state.phase === RightPanelStorePhases/* RightPanelPhases */.q4.RoomMemberInfo && member.roomId === ((_this$props$room3 = this.props.room) === null || _this$props$room3 === void 0 ? void 0 : _this$props$room3.roomId) && member.userId === this.state.member.userId) {
        // refresh the member info (e.g. new power level)
        this.delayedUpdate();
      }
    });
    (0,defineProperty/* default */.Z)(this, "onAction", payload => {
      if (payload.action === actions/* Action */.a.AfterRightPanelPhaseChange) {
        var _payload$params, _payload$params2, _payload$params3;
        this.setState({
          phase: payload.phase,
          groupRoomId: payload.groupRoomId,
          groupId: payload.groupId,
          member: payload.member,
          event: payload.event,
          verificationRequest: payload.verificationRequest,
          verificationRequestPromise: payload.verificationRequestPromise,
          widgetId: payload.widgetId,
          space: payload.space,
          token: payload.token,
          network: payload === null || payload === void 0 ? void 0 : (_payload$params = payload.params) === null || _payload$params === void 0 ? void 0 : _payload$params.network,
          params: payload.params,
          outerWalletAddress: ((_payload$params2 = payload.params) === null || _payload$params2 === void 0 ? void 0 : _payload$params2.outerWalletAddress) || "",
          showOtherAssetMore: (_payload$params3 = payload.params) === null || _payload$params3 === void 0 ? void 0 : _payload$params3.showOtherAssetMore
        });
      }
    });
    (0,defineProperty/* default */.Z)(this, "onClose", () => {
      if (this.props.onClose) {
        this.props.onClose();
        return;
      }
      // XXX: There are three different ways of 'closing' this panel depending on what state
      // things are in... this knows far more than it should do about the state of the rest
      // of the app and is generally a bit silly.
      if (this.props.user) {
        // If we have a user prop then we're displaying a user from the 'user' page type
        // in LoggedInView, so need to change the page type to close the panel (we switch
        // to the home page which is not obviously the correct thing to do, but I'm not sure
        // anything else is - we could hide the close button altogether?)
        dispatcher/* default */.ZP.dispatch({
          action: "view_home_page"
        });
      } else if (this.state.phase === RightPanelStorePhases/* RightPanelPhases */.q4.EncryptionPanel && this.state.verificationRequest && this.state.verificationRequest.pending) {
        // When the user clicks close on the encryption panel cancel the pending request first if any
        this.state.verificationRequest.cancel();
      } else {
        if (this.state.phase === RightPanelStorePhases/* RightPanelPhases */.q4.RoomMemberList || this.state.phase === RightPanelStorePhases/* RightPanelPhases */.q4.FilePanel) {
          dispatcher/* default */.ZP.dispatch({
            action: actions/* Action */.a.SetRightPanelPhase,
            phase: RightPanelStorePhases/* RightPanelPhases */.q4.RoomSummary
          });
        }
        // the RightPanelStore has no way of knowing which mode room/group it is in, so we handle closing here
        dispatcher/* default */.ZP.dispatch({
          action: actions/* Action */.a.ToggleRightPanel,
          type: this.props.groupId ? "group" : "room"
        });
      }
      this.props.resizeNotifier.emit("middlePanelResizedNoisy");
    });
    this.state = RightPanel_objectSpread(RightPanel_objectSpread({}, RightPanelStore/* default */.Z.getSharedInstance().roomPanelPhaseParams), {}, {
      phase: this.getPhaseFromProps(),
      isUserPrivilegedInGroup: null,
      member: this.getUserForPanel(),
      network: "ethereum",
      address: ((_this$state = this.state) === null || _this$state === void 0 ? void 0 : (_this$state$params = _this$state.params) === null || _this$state$params === void 0 ? void 0 : _this$state$params.multiAddress) || "",
      avatarUrl: "",
      loading: false
    });
  }
  // Helper function to split out the logic for getPhaseFromProps() and the constructor
  // as both are called at the same time in the constructor.
  getUserForPanel() {
    var _this$props$room4;
    if (this.state && this.state.member) return this.state.member;
    if ((_this$props$room4 = this.props.room) !== null && _this$props$room4 !== void 0 && _this$props$room4.isDmRoom()) {
      var _this$props$room5, _this$props$room6;
      return (_this$props$room5 = this.props.room) === null || _this$props$room5 === void 0 ? void 0 : _this$props$room5.getMember((_this$props$room6 = this.props.room) === null || _this$props$room6 === void 0 ? void 0 : _this$props$room6.getDMAnotherMember());
    }
    const lastParams = RightPanelStore/* default */.Z.getSharedInstance().roomPanelPhaseParams;
    return this.props.user || lastParams["member"];
  }

  // gets the current phase from the props and also maybe the store
  getPhaseFromProps() {
    var _this$props$room7, _this$props$room9;
    const rps = RightPanelStore/* default */.Z.getSharedInstance();
    const userForPanel = this.getUserForPanel();
    if (this.props.groupId) {
      if (!RightPanelStorePhases/* RIGHT_PANEL_PHASES_NO_ARGS */.dw.includes(rps.groupPanelPhase)) {
        dispatcher/* default */.ZP.dispatch({
          action: actions/* Action */.a.SetRightPanelPhase,
          phase: RightPanelStorePhases/* RightPanelPhases */.q4.GroupMemberList
        });
        return RightPanelStorePhases/* RightPanelPhases */.q4.GroupMemberList;
      }
      return rps.groupPanelPhase;
    } else if (SpaceStore/* default */.ZP.spacesEnabled && (_this$props$room7 = this.props.room) !== null && _this$props$room7 !== void 0 && _this$props$room7.isSpaceRoom() && !RightPanelStorePhases/* RIGHT_PANEL_SPACE_PHASES */.fi.includes(rps.roomPanelPhase)) {
      var _this$props$room8;
      if (rps.roomPanelPhase === RightPanelStorePhases/* RightPanelPhases */.q4.SpaceActivityCreate && (_this$props$room8 = this.props.room) !== null && _this$props$room8 !== void 0 && _this$props$room8.currentState.maySendStateEvent(_types_event/* EventType */.tw.SpaceChild, MatrixClientPeg/* MatrixClientPeg */.p.get().getUserId())) {
        return rps.roomPanelPhase;
      }
      return RightPanelStorePhases/* RightPanelPhases */.q4.SpaceMemberList;
    } else if (userForPanel) {
      // XXX FIXME AAAAAARGH: What is going on with this class!? It takes some of its state
      // from its props and some from a store, except if the contents of the store changes
      // while it's mounted in which case it replaces all of its state with that of the store,
      // except it uses a dispatch instead of a normal store listener?
      // Unfortunately rewriting this would almost certainly break showing the right panel
      // in some of the many cases, and I don't have time to re-architect it and test all
      // the flows now, so adding yet another special case so if the store thinks there is
      // a verification going on for the member we're displaying, we show that, otherwise
      // we race if a verification is started while the panel isn't displayed because we're
      // not mounted in time to get the dispatch.
      // Until then, let this code serve as a warning from history.
      if (rps.roomPanelPhaseParams.member && userForPanel.userId === rps.roomPanelPhaseParams.member.userId && rps.roomPanelPhaseParams.verificationRequest) {
        return rps.roomPanelPhase;
      }
      return RightPanelStorePhases/* RightPanelPhases */.q4.RoomMemberInfo;
    } else if ((_this$props$room9 = this.props.room) !== null && _this$props$room9 !== void 0 && _this$props$room9.isDmRoom()) {
      return RightPanelStorePhases/* RightPanelPhases */.q4.UserProfile;
    }
    return rps.roomPanelPhase;
  }
  static isShow() {
    return SHOW_LEFT_PANEL;
  }
  async componentDidMount() {
    this.dispatcherRef = dispatcher/* default */.ZP.register(this.onAction);
    SHOW_LEFT_PANEL = true;
    const cli = this.context;
    cli.on("RoomState.members", this.onRoomStateMember);
    this.initGroupStore(this.props.groupId);
  }
  componentWillUnmount() {
    dispatcher/* default */.ZP.unregister(this.dispatcherRef);
    SHOW_LEFT_PANEL = false;
    if (this.context) {
      this.context.removeListener("RoomState.members", this.onRoomStateMember);
    }
    this.unregisterGroupStore();
  }

  // TODO: [REACT-WARNING] Replace with appropriate lifecycle event
  UNSAFE_componentWillReceiveProps(newProps) {
    // eslint-disable-line
    if (newProps.groupId !== this.props.groupId) {
      this.unregisterGroupStore();
      this.initGroupStore(newProps.groupId);
    }
  }
  initGroupStore(groupId) {
    if (!groupId) return;
    GroupStore/* default */.ZP.registerListener(groupId, this.onGroupStoreUpdated);
  }
  unregisterGroupStore() {
    GroupStore/* default */.ZP.unregisterListener(this.onGroupStoreUpdated);
  }
  render() {
    var _this$props$room10, _params$content, _params$content$base_, _this$context$getRoom, _this$state$member, _this$state$member2, _this$state$member3, _this$state$member4, _this$props$room11, _this$state$member5, _this$state$member6, _this$state$member7, _this$state2, _this$state3, _this$state3$params, _this$state4, _this$state4$params, _this$state5, _this$state5$params, _this$state6, _this$state6$params, _this$state7, _this$state7$params;
    let panel = /*#__PURE__*/react.createElement("div", null);
    const roomId = this.props.room ? (_this$props$room10 = this.props.room) === null || _this$props$room10 === void 0 ? void 0 : _this$props$room10.roomId : undefined;
    const recommendation = this.props.recommendation;
    let phase = this.state.phase;
    const activeSpace = SpaceStore/* default */.ZP.instance.activeSpace;
    const activeSpaceId = activeSpace === null || activeSpace === void 0 ? void 0 : activeSpace.roomId;
    if (!activeSpaceId && (phase === RightPanelStorePhases/* RightPanelPhases */.q4.SpaceActivityCreate || phase === RightPanelStorePhases/* RightPanelPhases */.q4.SpaceActivityManage || phase === RightPanelStorePhases/* RightPanelPhases */.q4.SpaceApproveList)) {
      phase = RightPanelStorePhases/* RightPanelPhases */.q4.SpaceMemberList;
    }
    if (recommendation) {
      if (recommendation.joined === 2) {
        phase = RightPanelStorePhases/* RightPanelPhases */.q4.SpaceEvent;
      } else if (![RightPanelStorePhases/* RightPanelPhases */.q4.UserProfile, RightPanelStorePhases/* RightPanelPhases */.q4.FeedPanel, RightPanelStorePhases/* RightPanelPhases */.q4.IframeWidget, RightPanelStorePhases/* RightPanelPhases */.q4.AssetsMore].includes(phase)) {
        phase = RightPanelStorePhases/* RightPanelPhases */.q4.UserProfile;
      }
    }
    console.log("phase", {
      phase
    });
    switch (phase) {
      case RightPanelStorePhases/* RightPanelPhases */.q4.GroupNote:
        const params = this.state.params;
        const room = this.props.room;
        panel = /*#__PURE__*/react.createElement(rooms_GroupNotePanel, {
          key: room.roomId + (params === null || params === void 0 ? void 0 : params.eventId),
          room: room,
          id: params === null || params === void 0 ? void 0 : (_params$content = params.content) === null || _params$content === void 0 ? void 0 : (_params$content$base_ = _params$content.base_info) === null || _params$content$base_ === void 0 ? void 0 : _params$content$base_.note_id,
          onClose: this.onClose
        });
        break;
      case RightPanelStorePhases/* RightPanelPhases */.q4.SpaceApproveList:
        panel = /*#__PURE__*/react.createElement(ApproveListPanel/* default */.Z, {
          room: activeSpace,
          useDialog: true,
          onClose: this.onClose
        });
        break;
      case RightPanelStorePhases/* RightPanelPhases */.q4.SpaceEvent:
        panel = /*#__PURE__*/react.createElement(Squad/* default */.Z, {
          detail: {
            id: recommendation === null || recommendation === void 0 ? void 0 : recommendation.data.roomId
          },
          recommendEvent: recommendation === null || recommendation === void 0 ? void 0 : recommendation.data,
          onClose: this.onClose
        });
        break;
      case RightPanelStorePhases/* RightPanelPhases */.q4.SpaceMemberList:
        panel = /*#__PURE__*/react.createElement("div", {
          className: "mx_SpaceRoomView_MemberList"
        }, /*#__PURE__*/react.createElement(MemberList, {
          roomId: this.state.space ? this.state.space.roomId : roomId,
          key: this.state.space ? this.state.space.roomId : roomId,
          onClose: this.onClose
        }));
        this.props.resizeNotifier.emit("middlePanelResizedNoisy");
        break;
      case RightPanelStorePhases/* RightPanelPhases */.q4.SpaceActivityCreate:
        panel = /*#__PURE__*/react.createElement(spaces_ActivityCreate, {
          roomId: activeSpaceId,
          key: activeSpaceId,
          onClose: this.onClose
        });
        break;
      case RightPanelStorePhases/* RightPanelPhases */.q4.SpaceActivityManage:
        panel = /*#__PURE__*/react.createElement(spaces_ActivityManage, {
          roomId: activeSpaceId,
          key: activeSpaceId,
          onClose: this.onClose
        });
        break;
      case RightPanelStorePhases/* RightPanelPhases */.q4.TokenPanel:
        panel = /*#__PURE__*/react.createElement(structures_TokenPanel, {
          token: this.state.token,
          onClose: this.onClose
        });
        break;
      case RightPanelStorePhases/* RightPanelPhases */.q4.GroupMemberList:
        if (this.props.groupId) {
          panel = /*#__PURE__*/react.createElement(GroupMemberList, {
            groupId: this.props.groupId,
            key: this.props.groupId
          });
        }
        break;
      case RightPanelStorePhases/* RightPanelPhases */.q4.GroupRoomList:
        panel = /*#__PURE__*/react.createElement(GroupRoomList, {
          groupId: this.props.groupId,
          key: this.props.groupId
        });
        break;

      // case RightPanelPhases.RoomMemberInfo:
      case RightPanelStorePhases/* RightPanelPhases */.q4.SpaceMemberInfo:
      case RightPanelStorePhases/* RightPanelPhases */.q4.EncryptionPanel:
        panel = /*#__PURE__*/react.createElement(UserInfo/* default */.ZP, {
          user: this.state.member,
          room: (_this$context$getRoom = this.context.getRoom((_this$state$member = this.state.member) === null || _this$state$member === void 0 ? void 0 : _this$state$member.roomId)) !== null && _this$context$getRoom !== void 0 ? _this$context$getRoom : this.props.room,
          key: roomId || ((_this$state$member2 = this.state.member) === null || _this$state$member2 === void 0 ? void 0 : _this$state$member2.userId),
          onClose: this.onClose,
          phase: this.state.phase,
          verificationRequest: this.state.verificationRequest,
          verificationRequestPromise: this.state.verificationRequestPromise
        });
        break;
      case RightPanelStorePhases/* RightPanelPhases */.q4.Room3pidMemberInfo:
      case RightPanelStorePhases/* RightPanelPhases */.q4.Space3pidMemberInfo:
        panel = /*#__PURE__*/react.createElement(ThirdPartyMemberInfo, {
          event: this.state.event,
          key: roomId
        });
        break;
      case RightPanelStorePhases/* RightPanelPhases */.q4.GroupMemberInfo:
        panel = /*#__PURE__*/react.createElement(UserInfo/* default */.ZP, {
          user: this.state.member,
          groupId: this.props.groupId,
          key: (_this$state$member3 = this.state.member) === null || _this$state$member3 === void 0 ? void 0 : _this$state$member3.userId,
          phase: this.state.phase,
          onClose: this.onClose
        });
        break;
      case RightPanelStorePhases/* RightPanelPhases */.q4.RoomMemberInfo:
      case RightPanelStorePhases/* RightPanelPhases */.q4.UserProfile:
        const user = this.props.user;
        const userId = ((_this$state$member4 = this.state.member) === null || _this$state$member4 === void 0 ? void 0 : _this$state$member4.userId) || (user === null || user === void 0 ? void 0 : user.userId);
        let dmRoom;
        if ((_this$props$room11 = this.props.room) !== null && _this$props$room11 !== void 0 && _this$props$room11.isDmRoom()) {
          dmRoom = this.props.room;
        } else {
          const dmRooms = MatrixClientPeg/* MatrixClientPeg */.p.get().getDmRoomByUserId(userId);
          dmRoom = dmRooms[dmRooms.length - 1];
        }
        panel = /*#__PURE__*/react.createElement(SeaUserProfile/* default */.Z, {
          room: this.props.room,
          dmRoom: dmRoom,
          user: ((_this$state$member5 = this.state.member) === null || _this$state$member5 === void 0 ? void 0 : _this$state$member5.user) || user,
          userId: ((_this$state$member6 = this.state.member) === null || _this$state$member6 === void 0 ? void 0 : _this$state$member6.userId) || (user === null || user === void 0 ? void 0 : user.userId),
          key: (_this$state$member7 = this.state.member) === null || _this$state$member7 === void 0 ? void 0 : _this$state$member7.hashKey,
          onClose: this.onClose,
          feedNode: this.getFeedEntry((_this$state2 = this.state) === null || _this$state2 === void 0 ? void 0 : _this$state2.member),
          showAssetMore: (_this$state3 = this.state) === null || _this$state3 === void 0 ? void 0 : (_this$state3$params = _this$state3.params) === null || _this$state3$params === void 0 ? void 0 : _this$state3$params.showAssetMore,
          showFooter: true,
          showOtherAssetMore: (_this$state4 = this.state) === null || _this$state4 === void 0 ? void 0 : (_this$state4$params = _this$state4.params) === null || _this$state4$params === void 0 ? void 0 : _this$state4$params.showOtherAssetMore,
          assetDefaultTab: (_this$state5 = this.state) === null || _this$state5 === void 0 ? void 0 : (_this$state5$params = _this$state5.params) === null || _this$state5$params === void 0 ? void 0 : _this$state5$params.assetDefaultTab,
          network: (_this$state6 = this.state) === null || _this$state6 === void 0 ? void 0 : (_this$state6$params = _this$state6.params) === null || _this$state6$params === void 0 ? void 0 : _this$state6$params.network,
          outerWalletAddress: (_this$state7 = this.state) === null || _this$state7 === void 0 ? void 0 : (_this$state7$params = _this$state7.params) === null || _this$state7$params === void 0 ? void 0 : _this$state7$params.outerWalletAddress,
          recommendation: recommendation,
          resizeNotifier: this.props.resizeNotifier
        });
        break;
      case RightPanelStorePhases/* RightPanelPhases */.q4.EditRemark:
        panel = /*#__PURE__*/react.createElement(right_panel_EditUserRemark, {
          userId: this.state.member.userId,
          member: this.state.member,
          onClose: this.onClose
        });
        break;
      case RightPanelStorePhases/* RightPanelPhases */.q4.GroupRoomInfo:
        panel = /*#__PURE__*/react.createElement(GroupRoomInfo, {
          groupRoomId: this.state.groupRoomId,
          groupId: this.props.groupId,
          key: this.state.groupRoomId
        });
        break;

      // case RightPanelPhases.NotificationPanel:
      //     panel = <NotificationPanel onClose={this.onClose} />;
      //     break;

      case RightPanelStorePhases/* RightPanelPhases */.q4.PinnedMessages:
        if (SettingsStore/* default */.C.getValue("feature_pinning")) {
          panel = /*#__PURE__*/react.createElement(PinnedMessagesCard/* default */.ZP, {
            room: this.props.room,
            onClose: this.onClose
          });
        }
        break;
      case RightPanelStorePhases/* RightPanelPhases */.q4.ChatHistory:
        panel = /*#__PURE__*/react.createElement(ChatHistoryCard, (0,esm_extends/* default */.Z)({
          onClose: this.onClose
        }, this.state.params));
        break;
      case RightPanelStorePhases/* RightPanelPhases */.q4.ThreadView:
        panel = /*#__PURE__*/react.createElement(ThreadView, {
          room: this.props.room,
          resizeNotifier: this.props.resizeNotifier,
          onClose: this.onClose,
          mxEvent: this.state.event,
          permalinkCreator: this.props.permalinkCreator,
          e2eStatus: this.props.e2eStatus
        });
        break;
      case RightPanelStorePhases/* RightPanelPhases */.q4.ThreadPanel:
        panel = /*#__PURE__*/react.createElement(ThreadPanel, {
          roomId: roomId,
          resizeNotifier: this.props.resizeNotifier,
          onClose: this.onClose
        });
        break;
      case RightPanelStorePhases/* RightPanelPhases */.q4.RoomMemberList:
      case RightPanelStorePhases/* RightPanelPhases */.q4.FilePanel:
      case RightPanelStorePhases/* RightPanelPhases */.q4.FeedPanel:
      case RightPanelStorePhases/* RightPanelPhases */.q4.RoomSummary:
      case RightPanelStorePhases/* RightPanelPhases */.q4.TopicSummaryPanel:
        panel = /*#__PURE__*/react.createElement(right_panel_RoomSummaryCard, {
          room: this.props.room,
          onClose: this.onClose,
          phase: this.state.phase,
          resizeNotifier: this.props.resizeNotifier,
          groupId: this.props.groupId
        });
        break;
      case RightPanelStorePhases/* RightPanelPhases */.q4.Widget:
        panel = /*#__PURE__*/react.createElement(right_panel_WidgetCard, {
          room: this.props.room,
          widgetId: this.state.widgetId,
          onClose: this.onClose
        });
        break;
      case RightPanelStorePhases/* RightPanelPhases */.q4.IframeWidget:
        panel = /*#__PURE__*/react.createElement(IframeWidget/* default */.Z, (0,esm_extends/* default */.Z)({}, RightPanel_objectSpread(RightPanel_objectSpread({}, this.state.params), {}, {
          src: `${this.state.params.src}`
        }), {
          onClose: this.onClose
        }));
        this.props.resizeNotifier.emit("middlePanelResizedNoisy");
        break;
      case RightPanelStorePhases/* RightPanelPhases */.q4.AssetsMore:
        {
          var _this$state8, _this$state8$params;
          panel = /*#__PURE__*/react.createElement(cards_AssetsMoreCard, {
            room: this.props.room,
            userId: this.state.params.userId,
            options: this.state.params.options,
            assetDefaultTab: (_this$state8 = this.state) === null || _this$state8 === void 0 ? void 0 : (_this$state8$params = _this$state8.params) === null || _this$state8$params === void 0 ? void 0 : _this$state8$params.assetDefaultTab,
            onClose: this.onClose
          });
        }
        break;
      case RightPanelStorePhases/* RightPanelPhases */.q4.TopicDetail:
        panel = /*#__PURE__*/react.createElement(structures_TopicDetailPanel, (0,esm_extends/* default */.Z)({}, this.state.params, {
          onClose: this.onClose
        }));
        break;
      case RightPanelStorePhases/* RightPanelPhases */.q4.TopicReply:
        panel = /*#__PURE__*/react.createElement(structures_TopicReplyPanel, (0,esm_extends/* default */.Z)({}, this.state.params, {
          onClose: this.onClose
        }));
        break;
      case RightPanelStorePhases/* RightPanelPhases */.q4.PointsTask:
        panel = /*#__PURE__*/react.createElement(points_task, (0,esm_extends/* default */.Z)({}, this.state.params, {
          onClose: this.onClose
        }));
        break;
      case RightPanelStorePhases/* RightPanelPhases */.q4.EditNickname:
        panel = /*#__PURE__*/react.createElement(right_panel_EditNickname, (0,esm_extends/* default */.Z)({}, this.state.params, {
          onClose: this.onClose
        }));
        break;
      case RightPanelStorePhases/* RightPanelPhases */.q4.CreatePoll:
      case RightPanelStorePhases/* RightPanelPhases */.q4.EditPoll:
        {
          const params = phase === RightPanelStorePhases/* RightPanelPhases */.q4.EditPoll ? this.state.params : {};
          panel = /*#__PURE__*/react.createElement(PollCreatePanel, (0,esm_extends/* default */.Z)({}, params, {
            room: this.props.room,
            onFinished: this.onClose
          }));
          break;
        }
      case RightPanelStorePhases/* RightPanelPhases */.q4.XSpace:
        {
          panel = /*#__PURE__*/react.createElement(ama_view_AudioSpaceView, (0,esm_extends/* default */.Z)({}, this.state.params, {
            room: this.props.room,
            onFinished: this.onClose
          }));
          break;
        }
      case RightPanelStorePhases/* RightPanelPhases */.q4.SelectMember:
        {
          panel = /*#__PURE__*/react.createElement(components_CreateExternalGroupRightPanel, {
            roomId: roomId
          });
          break;
        }
      case RightPanelStorePhases/* RightPanelPhases */.q4.Announcement:
        {
          panel = /*#__PURE__*/react.createElement(right_panel_AnnouncementPanel, (0,esm_extends/* default */.Z)({
            roomId: roomId,
            room: this.props.room,
            onClose: this.onClose
          }, this.state.params));
          break;
        }
      case RightPanelStorePhases/* RightPanelPhases */.q4.StickerShopping:
        {
          panel = /*#__PURE__*/react.createElement(stickers_StickersShopStoreRightPanel, (0,esm_extends/* default */.Z)({
            roomId: roomId,
            room: this.props.room,
            onClose: this.onClose
          }, this.state.params));
          break;
        }
      case RightPanelStorePhases/* RightPanelPhases */.q4.StickerSetting:
        {
          panel = /*#__PURE__*/react.createElement(stickers_StickersSettingRightPanel, (0,esm_extends/* default */.Z)({
            roomId: roomId,
            room: this.props.room,
            onClose: this.onClose
          }, this.state.params));
          break;
        }
      case RightPanelStorePhases/* RightPanelPhases */.q4.SquadHomePageWidgetSort:
        {
          panel = /*#__PURE__*/react.createElement(squadHomePage_SquadWidgetSortRightPanel, (0,esm_extends/* default */.Z)({
            roomId: roomId,
            onClose: this.onClose
          }, this.state.params));
          break;
        }
      case RightPanelStorePhases/* RightPanelPhases */.q4.StickerViewAll:
        {
          panel = /*#__PURE__*/react.createElement(stickers_StickersViewAllRightPanel, (0,esm_extends/* default */.Z)({
            roomId: roomId,
            room: this.props.room,
            onClose: this.onClose
          }, this.state.params));
          break;
        }
      case RightPanelStorePhases/* RightPanelPhases */.q4.StickerFavoriteManagement:
        {
          panel = /*#__PURE__*/react.createElement(stickers_StickersUploadFavoriteRightPanel, (0,esm_extends/* default */.Z)({
            roomId: roomId,
            room: this.props.room,
            onClose: this.onClose
          }, this.state.params));
          break;
        }
      case RightPanelStorePhases/* RightPanelPhases */.q4.MessageDetail:
        {
          panel = /*#__PURE__*/react.createElement(right_panel_MessageDetailCard, (0,esm_extends/* default */.Z)({}, this.state.params, {
            onClose: this.onClose
          }));
          break;
        }
      case RightPanelStorePhases/* RightPanelPhases */.q4.InvitePanel:
        {
          panel = /*#__PURE__*/react.createElement(InviteGroupPanel/* default */.Z, (0,esm_extends/* default */.Z)({
            roomId: roomId
          }, this.state.params, {
            onClose: this.onClose
          }));
          break;
        }
      case RightPanelStorePhases/* RightPanelPhases */.q4.Explore:
        {
          panel = /*#__PURE__*/react.createElement(Explore/* default */.Z, (0,esm_extends/* default */.Z)({}, this.state.params, {
            onClose: this.onClose
          }));
          break;
        }
      case RightPanelStorePhases/* RightPanelPhases */.q4.TwitterTimeline:
        {
          panel = /*#__PURE__*/react.createElement(TwitterTimeline, (0,esm_extends/* default */.Z)({}, this.state.params, {
            onClose: this.onClose
          }));
          break;
        }
      case RightPanelStorePhases/* RightPanelPhases */.q4.SquadRequestApprove:
        {
          panel = /*#__PURE__*/react.createElement(ApproveListPanel/* default */.Z, (0,esm_extends/* default */.Z)({}, this.state.params, {
            room: this.props.room,
            onClose: this.onClose,
            useDialog: true
          }));
          break;
        }
      case RightPanelStorePhases/* RightPanelPhases */.q4.SquadHomePageAnnouncementList:
        {
          panel = /*#__PURE__*/react.createElement(squadHomePage_SquadAnnouncementCardRightPanel, (0,esm_extends/* default */.Z)({
            roomId: roomId,
            onClose: this.onClose
          }, this.state.params));
          break;
        }
      case RightPanelStorePhases/* RightPanelPhases */.q4.NotificationDrawer:
        {
          panel = /*#__PURE__*/react.createElement(NotificationDrawer/* default */.Z, {
            onClose: this.onClose
          });
          break;
        }

      // NotificationDrawer
    }

    return /*#__PURE__*/react.createElement("aside", {
      className: classnames_default()({
        mx_RightPanel: true,
        "dark-panel": true,
        mx_RightPanel_User_Profile: this.state.phase === RightPanelStorePhases/* RightPanelPhases */.q4.UserProfile
      }),
      id: "mx_RightPanel"
    }, panel);
  }
}, (0,defineProperty/* default */.Z)(RightPanel_class2, "contextType", MatrixClientContext/* default */.Z), RightPanel_class2)) || RightPanel_class);


/***/ }),

/***/ 102420:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  T_: () => (/* binding */ SpacePreview),
  ZP: () => (/* binding */ SpaceRoomView),
  qr: () => (/* binding */ useMyRoomMembership)
});

// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/node_modules/@babel/runtime/helpers/esm/defineProperty.js
var defineProperty = __webpack_require__(225259);
// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(667294);
// EXTERNAL MODULE: ./node_modules/matrix-js-sdk/src/@types/event.ts
var _types_event = __webpack_require__(907977);
// EXTERNAL MODULE: ./node_modules/matrix-js-sdk/src/@types/partials.ts
var partials = __webpack_require__(85047);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/contexts/MatrixClientContext.ts
var MatrixClientContext = __webpack_require__(311878);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/avatars/RoomAvatar.tsx
var RoomAvatar = __webpack_require__(139319);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/languageHandler.tsx
var languageHandler = __webpack_require__(867614);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/elements/AccessibleButton.tsx
var AccessibleButton = __webpack_require__(805035);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/elements/RoomTopic.tsx
var RoomTopic = __webpack_require__(756810);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/elements/InlineSpinner.tsx
var InlineSpinner = __webpack_require__(650193);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/RoomInvite.tsx + 1 modules
var RoomInvite = __webpack_require__(106579);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/hooks/useRoomMembers.ts
var hooks_useRoomMembers = __webpack_require__(573266);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/createRoom.ts
var createRoom = __webpack_require__(147022);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/elements/Field.tsx
var Field = __webpack_require__(455537);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/hooks/useEventEmitter.ts
var useEventEmitter = __webpack_require__(457771);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/elements/Validation.tsx
var Validation = __webpack_require__(997038);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/email.ts
var email = __webpack_require__(654776);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/dispatcher/dispatcher.ts
var dispatcher = __webpack_require__(245539);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/dispatcher/actions.ts
var actions = __webpack_require__(473627);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/structures/MainSplit.tsx
var MainSplit = __webpack_require__(409957);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/elements/ErrorBoundary.tsx
var ErrorBoundary = __webpack_require__(618675);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/structures/RightPanel.tsx + 56 modules
var RightPanel = __webpack_require__(285243);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/RightPanelStore.ts
var RightPanelStore = __webpack_require__(652458);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/RightPanelStorePhases.ts
var RightPanelStorePhases = __webpack_require__(274057);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/hooks/useStateArray.ts
/*
Copyright 2021 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/



// Hook to simplify managing state of arrays of a common type
const useStateArray = (initialSize, initialState) => {
  const [data, setData] = (0,react.useState)(() => {
    return Array.isArray(initialState) ? initialState : new Array(initialSize).fill(initialState);
  });
  return [data, (index, value) => setData(data => {
    const copy = [...data];
    copy[index] = value;
    return copy;
  })];
};
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/spaces/SpacePublicShare.tsx
var SpacePublicShare = __webpack_require__(20628);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/avatars/MemberAvatar.tsx
var MemberAvatar = __webpack_require__(6156);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/SpaceStore.tsx + 2 modules
var SpaceStore = __webpack_require__(387579);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/dialogs/AddExistingToSpaceDialog.tsx
var AddExistingToSpaceDialog = __webpack_require__(313026);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/beta/BetaCard.tsx + 1 modules
var BetaCard = __webpack_require__(498398);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/dialogs/UserSettingsDialog.tsx + 47 modules
var UserSettingsDialog = __webpack_require__(449878);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/hooks/useDispatcher.ts
var useDispatcher = __webpack_require__(694284);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/utils/strings.ts
var strings = __webpack_require__(653848);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/structures/LinkWallet.tsx + 2 modules
var LinkWallet = __webpack_require__(103041);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/ApproveStore.ts
var ApproveStore = __webpack_require__(107541);
// EXTERNAL MODULE: ./node_modules/classnames/index.js
var classnames = __webpack_require__(294184);
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/UIStore.ts
var UIStore = __webpack_require__(563869);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/WalletStore.ts
var WalletStore = __webpack_require__(644764);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/customisations/Media.ts + 1 modules
var Media = __webpack_require__(834208);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/SdkConfig.ts
var SdkConfig = __webpack_require__(374312);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/PermissionStore.ts
var PermissionStore = __webpack_require__(825291);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/MatrixClientPeg.ts + 3 modules
var MatrixClientPeg = __webpack_require__(933393);
// EXTERNAL MODULE: ./node_modules/lodash-es/isEmpty.js
var isEmpty = __webpack_require__(479697);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/external_group/ExternalGroupForm.tsx


const initialState = {
  groupName: "",
  topic: "",
  displayName: ""
};
const ExternalGroupForm = ({
  value,
  onChange: handleChange
}) => {
  const myRef1 = (0,react.useRef)(null);
  const myRef2 = (0,react.useRef)(null);
  const myRef3 = (0,react.useRef)(null);
  return /*#__PURE__*/react.createElement("form", null, /*#__PURE__*/react.createElement(Field/* default */.Z, {
    id: "groupName",
    key: "groupName",
    className: "",
    label: "Name",
    name: "groupName",
    type: "text",
    value: value.groupName,
    autoComplete: "off",
    onChange: handleChange,
    onClick: ev => {
      ev.preventDefault();
      ev.stopPropagation();
    }
  }), /*#__PURE__*/react.createElement(Field/* default */.Z, {
    id: "topic",
    key: "topic",
    className: "",
    label: "Topic",
    type: "text",
    name: "topic",
    value: value.topic,
    autoComplete: "off",
    onChange: handleChange,
    element: "textarea",
    onClick: ev => {
      ev.preventDefault();
      ev.stopPropagation();
    }
  }), /*#__PURE__*/react.createElement(Field/* default */.Z, {
    id: "displayName",
    key: "",
    className: "",
    label: "Display name in the group",
    type: "text",
    name: "displayName",
    value: value.displayName,
    autoComplete: "off",
    onChange: handleChange,
    onClick: ev => {
      ev.preventDefault();
      ev.stopPropagation();
    }
  }));
};
/* harmony default export */ const external_group_ExternalGroupForm = (ExternalGroupForm);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/CreateExternalGroupStore.ts
var CreateExternalGroupStore = __webpack_require__(424758);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/hooks/useCreateExternalGroup.ts


const useCreateExternalGroupState = () => {
  const [state, setState] = (0,react.useState)([]);
  (0,react.useEffect)(() => {
    const handler = members => {
      setState(members);
    };
    CreateExternalGroupStore/* default */.ZP.instance.on(CreateExternalGroupStore/* CreateExternalGroupStoreAction */.cT.CreateExternalGroupStoreUpdateUIState, handler);
    return () => {
      CreateExternalGroupStore/* default */.ZP.instance.removeListener(CreateExternalGroupStore/* CreateExternalGroupStoreAction */.cT.CreateExternalGroupStoreUpdateUIState, handler);
    };
  }, []);
  return state;
};
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/hooks/useCreateRoom.tsx
var useCreateRoom = __webpack_require__(423342);
// EXTERNAL MODULE: ./node_modules/antd/lib/index.js
var lib = __webpack_require__(769215);
// EXTERNAL MODULE: ./node_modules/sendingme-ui/dist/index.js
var dist = __webpack_require__(602271);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/external_group/CreateExternalGroup.tsx

function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0,defineProperty/* default */.Z)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }












const CreateExternalGroup = props => {
  const client = MatrixClientPeg/* MatrixClientPeg */.p.get();
  const {
    squadId
  } = props;
  const squadMembers = client.getRoom(squadId).getJoinedMembers();
  const squadMembersSets = new Set(squadMembers.map(item => item.userId));
  const selected = useCreateExternalGroupState();
  const {
    createGroup,
    handleAfterExternalGroup
  } = (0,useCreateRoom/* useCreateRoom */.uL)();
  const {
    inGroupMember,
    outGroupMember
  } = (0,react.useMemo)(() => {
    let inGroupMember = [];
    let outGroupMember = [];
    for (let value of selected) {
      if (squadMembersSets.has(value.userId)) {
        inGroupMember.push(value);
      } else {
        outGroupMember.push(value);
      }
    }
    return {
      inGroupMember: {
        list: inGroupMember.slice(0, 5),
        count: inGroupMember.length
      },
      outGroupMember: {
        list: outGroupMember.slice(0, 5),
        count: outGroupMember.length
      }
    };
  }, [selected, squadMembersSets]);
  const [groupState, setGroupState] = (0,react.useState)({
    groupName: "",
    topic: "",
    displayName: ""
  });
  const isCreateDisabled = (0,react.useMemo)(() => {
    const emptyMembers = !(inGroupMember.count > 0 || outGroupMember.count > 0);
    if (emptyMembers) {
      return true;
    }
    return false;
  }, [inGroupMember, outGroupMember]);
  const onStateChange = ({
    target: {
      value,
      name
    }
  }) => {
    console.log("event change", value);
    setGroupState(_objectSpread(_objectSpread({}, groupState), {}, {
      [name]: value
    }));
  };
  const handleCancel = () => {
    console.log("handleCancel");
    dispatcher/* default */.ZP.dispatch({
      action: "view_room",
      room_id: props.squadId
    }, true);
    dispatcher/* default */.ZP.dispatch({
      action: actions/* Action */.a.SetRightPanelPhase,
      phase: RightPanelStorePhases/* RightPanelPhases */.q4.SpaceMemberList
      // refireParams: {
      // },
    });
  };

  const handleCreate = async e => {
    try {
      const groupMembers = [...inGroupMember.list, ...outGroupMember.list];
      const externalOptions = {
        display_space_id: props.squadId
        // parentSpace: client.getRoom(props.squadId),
      };

      if (groupMembers.length === 1) {
        return lib.message.warn("External Group needs more than 2 members");
      }
      const result = await createGroup([...inGroupMember.list, ...outGroupMember.list], externalOptions);
      if (typeof result === "string") {
        await handleAfterExternalGroup({
          groupId: result,
          squadId: props.squadId
        });
        groupState.groupName && client.setRoomName(result, groupState.groupName);
        groupState.topic && client.setRoomTopic(result, groupState.topic);
        groupState.displayName && client.setNickName(result, client.getUserId(), groupState.displayName);
        dist.SdMessage.success((0,languageHandler._t)("Create Successful"));
      }
    } catch (error) {
      dist.SdMessage.error((0,languageHandler._t)("Create Failed"));
    }
  };
  return /*#__PURE__*/react.createElement("div", {
    className: "mx_SpaceRoomView_create_external_group"
  }, /*#__PURE__*/react.createElement("h1", {
    className: "mx_SpaceRoomView_create_external_group_title"
  }, (0,languageHandler._t)("Create a Group")), /*#__PURE__*/react.createElement("div", {
    className: "mx_SpaceRoomView_create_external_group_content"
  }, /*#__PURE__*/react.createElement("h3", null, "General"), /*#__PURE__*/react.createElement(external_group_ExternalGroupForm, {
    value: groupState,
    onChange: onStateChange
  }), /*#__PURE__*/react.createElement("h3", null, "Members"), /*#__PURE__*/react.createElement("div", null, Boolean(inGroupMember.count) && /*#__PURE__*/react.createElement("div", {
    className: "mx_SpaceRoomView_create_external_group_content_members"
  }, inGroupMember.list.map(m => /*#__PURE__*/react.createElement(MemberAvatar/* default */.Z, {
    member: m,
    size: 34,
    "aria-hidden": "true"
  })), /*#__PURE__*/react.createElement("div", {
    className: "mx_SpaceRoomView_create_external_group_content_members_count"
  }, inGroupMember.count)), Boolean(outGroupMember.count) && /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("h3", null, "External"), /*#__PURE__*/react.createElement("p", null, "You will create a squad group that includes external users"), /*#__PURE__*/react.createElement("div", {
    className: "mx_SpaceRoomView_create_external_group_content_members"
  }, outGroupMember.list.map(m => /*#__PURE__*/react.createElement(MemberAvatar/* default */.Z, {
    member: m,
    size: 34,
    "aria-hidden": "true"
  })), /*#__PURE__*/react.createElement("div", {
    className: "mx_SpaceRoomView_create_external_group_content_members_count"
  }, "+", outGroupMember.count)))), /*#__PURE__*/react.createElement("div", {
    style: {
      flex: 1
    }
  }), /*#__PURE__*/react.createElement("div", {
    className: "mx_SpaceRoomView_create_external_group_action"
  }, /*#__PURE__*/react.createElement(dist.SdButton, {
    onClick: handleCancel,
    type: "associate"
  }, (0,languageHandler._t)("Cancel")), /*#__PURE__*/react.createElement(dist.SdButton, {
    onClick: handleCreate,
    disabled: isCreateDisabled
  }, (0,languageHandler._t)("Confirm")))));
};
CreateExternalGroup.displayName = "CreateExternalGroup";
/* harmony default export */ const external_group_CreateExternalGroup = (CreateExternalGroup);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/elements/RoomName.tsx
var RoomName = __webpack_require__(75865);
// EXTERNAL MODULE: ./node_modules/ahooks/lib/index.js
var ahooks_lib = __webpack_require__(924737);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/structures/space_home/components/RoomVisible.tsx






/* harmony default export */ const RoomVisible = (/*#__PURE__*/(0,react.memo)(function RoomVisible(props) {
  const {
    room
  } = props;
  const roomId = room.roomId;
  const {
    loading,
    data
  } = (0,ahooks_lib.useRequest)(() => MatrixClientPeg/* MatrixClientPeg */.p.get().getRoomDirectoryVisibility(roomId), {
    refreshDeps: [roomId]
  });
  if ((data === null || data === void 0 ? void 0 : data.visibility) === partials/* Visibility */.EE.Public) {
    return /*#__PURE__*/react.createElement("div", {
      className: "mx_SpaceRoomView_info_item flex flex-gap-4"
    }, /*#__PURE__*/react.createElement(dist.SdIcon, {
      icon: "PlanetOutlines",
      title: (0,languageHandler._t)("Public")
    }), /*#__PURE__*/react.createElement("span", {
      className: "mx_description_text"
    }, " ", (0,languageHandler._t)("Public")));
  }
  if ((data === null || data === void 0 ? void 0 : data.visibility) === partials/* Visibility */.EE.Private) {
    return /*#__PURE__*/react.createElement("div", {
      className: "mx_SpaceRoomView_info_item flex flex-gap-4"
    }, /*#__PURE__*/react.createElement(dist.SdIcon, {
      icon: "PlanetOutlines",
      title: (0,languageHandler._t)("Private")
    }), /*#__PURE__*/react.createElement("span", {
      className: "mx_description_text"
    }, " ", (0,languageHandler._t)("Private")));
  }
  return null;
}));
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/AccessTokenStore.ts + 1 modules
var AccessTokenStore = __webpack_require__(295640);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/structures/space_home/components/RoomJoinRule.tsx








/* harmony default export */ const RoomJoinRule = (/*#__PURE__*/(0,react.memo)(function RoomJoinRule(props) {
  const {
    room
  } = props;
  const [joinRuleContent, setJoinRuleContent] = (0,react.useState)(() => {
    var _room$currentState, _room$currentState$ge;
    return room === null || room === void 0 ? void 0 : (_room$currentState = room.currentState) === null || _room$currentState === void 0 ? void 0 : (_room$currentState$ge = _room$currentState.getStateEvents(_types_event/* EventType */.tw.RoomJoinRules, "")) === null || _room$currentState$ge === void 0 ? void 0 : _room$currentState$ge.getContent();
  });
  let tokenSuffix = null;
  let text = "";
  if ((joinRuleContent === null || joinRuleContent === void 0 ? void 0 : joinRuleContent.join_rule) === partials/* JoinRule */.iE.Public) {
    text = (0,languageHandler._t)("No limit");
  } else if ((joinRuleContent === null || joinRuleContent === void 0 ? void 0 : joinRuleContent.join_rule) === partials/* JoinRule */.iE.Invite) {
    text = (0,languageHandler._t)("Invitation based");
  } else if ((joinRuleContent === null || joinRuleContent === void 0 ? void 0 : joinRuleContent.join_rule) === partials/* JoinRule */.iE.Approve) {
    text = (0,languageHandler._t)("Admain approve");
  } else if ((joinRuleContent === null || joinRuleContent === void 0 ? void 0 : joinRuleContent.join_rule) === partials/* JoinRule */.iE.Token) {
    text = (0,languageHandler._t)("Token gating");
    if (joinRuleContent !== null && joinRuleContent !== void 0 && joinRuleContent.join_params) {
      var _ref;
      const {
        join_params
      } = joinRuleContent;
      tokenSuffix = /*#__PURE__*/react.createElement(lib.Tooltip, {
        placement: "bottom",
        overlayClassName: "mx_SpaceRoomView_info_token_gated_tooltip",
        title: /*#__PURE__*/react.createElement("div", {
          className: "token_gated_detail_tooltip_wrapper"
        }, /*#__PURE__*/react.createElement("div", {
          className: "tooltip_title"
        }, (join_params === null || join_params === void 0 ? void 0 : join_params.logic) === partials/* TokenAccessLogic */.S4.ALL ? (0,languageHandler._t)("token meet all") : (0,languageHandler._t)("token meet one")), (_ref = join_params.requirements || []) === null || _ref === void 0 ? void 0 : _ref.map(i => {
          var _i$requiredToken;
          return /*#__PURE__*/react.createElement("div", {
            className: "token_gated_item"
          }, /*#__PURE__*/react.createElement("div", {
            className: "token_gated_item_left"
          }, /*#__PURE__*/react.createElement("img", {
            src: i.requiredToken.logo
          })), /*#__PURE__*/react.createElement("div", {
            className: "token_gated_item_right"
          }, /*#__PURE__*/react.createElement("div", {
            className: "right_top"
          }, /*#__PURE__*/react.createElement("div", null, (_i$requiredToken = i.requiredToken) === null || _i$requiredToken === void 0 ? void 0 : _i$requiredToken.name), /*#__PURE__*/react.createElement("div", null, AccessTokenStore/* default */.Z.isNFT(i.requiredToken.type) ? "1NFT" : i.requiredAmount)), /*#__PURE__*/react.createElement("div", {
            className: "right_bottom"
          }, i.chain)));
        }))
      }, /*#__PURE__*/react.createElement("span", {
        className: "mx_SpaceRoomView_info_item_tooltip_icon"
      }));
    }
  }
  const icon = (joinRuleContent === null || joinRuleContent === void 0 ? void 0 : joinRuleContent.join_rule) === partials/* JoinRule */.iE.Public ? /*#__PURE__*/react.createElement(dist.SdIcon, {
    icon: "UnlockOutlines",
    title: text
  }) : /*#__PURE__*/react.createElement(dist.SdIcon, {
    icon: "LockOutlines",
    title: text
  });
  (0,react.useEffect)(() => {
    const onJoinRleUpdate = mxEvent => {
      if (mxEvent.getType() === _types_event/* EventType */.tw.RoomJoinRules && mxEvent.getRoomId() === room.roomId) {
        const content = mxEvent.getContent() || {};
        setJoinRuleContent(content);
      }
    };
    room.on("Room.timeline", onJoinRleUpdate);
    return () => {
      room.off("Room.timeline", onJoinRleUpdate);
    };
  }, [room]);
  return /*#__PURE__*/react.createElement("div", {
    className: "mx_SpaceRoomView_info_item flex flex-gap-4 items-center"
  }, icon, /*#__PURE__*/react.createElement("span", {
    className: classnames_default()("mx_description_text", {
      mx_description_text_show: tokenSuffix
    })
  }, text), tokenSuffix);
}));
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/structures/space_home/components/RoomMemberCount.tsx



/**
 * Squad member calculation rules
 * success Join Squad，Squad Member +1
 * not include Invted but not accept user
 * not include request but not approve user
 * success Leave Squad，Squad Member -1
 */
/* harmony default export */ const RoomMemberCount = (/*#__PURE__*/(0,react.memo)(function RoomMemberCount(props) {
  const {
    room
  } = props;
  const [, setUpdate] = (0,react.useState)();
  const memberCount = room.getJoinedMemberCount();
  (0,react.useEffect)(() => {
    const onMemberUpdate = mxEvent => {
      if (mxEvent.getType() === _types_event/* EventType */.tw.RoomMember && mxEvent.getRoomId() === room.roomId) {
        setUpdate({});
      }
    };
    room.on(_types_event/* EventType */.tw.RoomMember, onMemberUpdate);
    return () => {
      room.off(_types_event/* EventType */.tw.RoomMember, onMemberUpdate);
    };
  }, [room]);
  return /*#__PURE__*/react.createElement("div", {
    className: "mx_SpaceRoomView_info_item flex flex-gap-4"
  }, /*#__PURE__*/react.createElement(dist.SdIcon, {
    icon: "HomeMembersOutlines",
    style: {
      fontSize: "18px"
    }
  }), /*#__PURE__*/react.createElement("span", null, memberCount));
}));
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/structures/space_home/components/SocialButton.tsx







let SocialType = /*#__PURE__*/function (SocialType) {
  SocialType["Twitter"] = "Twitter";
  return SocialType;
}({});
const SocialList = [{
  key: SocialType.Twitter,
  iconName: "TwitterOutlines",
  socailName: "Twitter"
}];
/* harmony default export */ const SocialButton = (/*#__PURE__*/(0,react.memo)(function SocialButton(props) {
  const {
    room,
    type
  } = props;
  const roomId = room.roomId;
  const {
    iconName,
    socailName
  } = (0,react.useMemo)(() => {
    const social = SocialList.find(item => item.key === type);
    return {
      iconName: social === null || social === void 0 ? void 0 : social.iconName,
      socailName: social === null || social === void 0 ? void 0 : social.socailName
    };
  }, [type]);
  const {
    loading,
    data
  } = (0,ahooks_lib.useRequest)(() => {
    if (type === SocialType.Twitter) {
      return MatrixClientPeg/* MatrixClientPeg */.p.get().getFirstTweetBySquadId(roomId);
    }
    return {
      loading,
      data
    };
  }, {
    ready: !!roomId,
    refreshDeps: [roomId, type]
  });
  const socialHandler = () => {
    switch (type) {
      case SocialType.Twitter:
        dispatcher/* default */.ZP.dispatch({
          action: actions/* Action */.a.SetRightPanelPhase,
          phase: RightPanelStorePhases/* RightPanelPhases */.q4.TwitterTimeline,
          refireParams: {
            params: {
              twitterProfileUrl: data === null || data === void 0 ? void 0 : data.twitter_profile_url
            }
          }
        });
        break;
      default:
        break;
    }
  };
  if (type === SocialType.Twitter && !(data !== null && data !== void 0 && data.twitter_profile_url)) {
    return null;
  }
  return /*#__PURE__*/react.createElement(react.Fragment, null, props.prefixNode, /*#__PURE__*/react.createElement("div", {
    onClick: () => socialHandler(),
    className: "mx_squadHomePage_socialButton flex flex-gap-4 click-text"
  }, /*#__PURE__*/react.createElement(dist.SdIcon, {
    icon: iconName
  }), /*#__PURE__*/react.createElement("span", {
    className: "mx_description_text"
  }, socailName)));
}));
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/structures/space_home/components/RoomJoinRequest.tsx








/* harmony default export */ const RoomJoinRequest = (/*#__PURE__*/(0,react.memo)(function RoomJoinRequest(props) {
  const {
    room
  } = props;
  const [approveCount, setApproveCount] = (0,react.useState)(0);
  const roomId = room === null || room === void 0 ? void 0 : room.roomId;
  const [canManageRoom] = PermissionStore/* default */.ZP.hasPermission(roomId, [PermissionStore/* PermissionMap */.$W.SquadManageRoom]);
  const showApproveListBtn = !!canManageRoom && room.getJoinRule() === partials/* JoinRule */.iE.Approve;
  (0,react.useEffect)(() => {
    const refresh = async () => {
      await ApproveStore/* default */.Z.instance.fetchList(roomId, true);
      setApproveCount(ApproveStore/* default */.Z.instance.getListCount() || 0);
    };
    ApproveStore/* default */.Z.instance.on("ApproveListChanged", refresh);
    if (showApproveListBtn) {
      refresh();
    }
    return () => {
      ApproveStore/* default */.Z.instance.off("ApproveListChanged", refresh);
    };
  }, [roomId, showApproveListBtn]);
  function handleRequestClick() {
    dispatcher/* default */.ZP.dispatch({
      action: actions/* Action */.a.SetRightPanelPhase,
      phase: RightPanelStorePhases/* RightPanelPhases */.q4.SquadRequestApprove
    });
  }
  if (!roomId) {
    return null;
  }
  if (approveCount === 0) return null;
  return /*#__PURE__*/react.createElement("div", {
    className: "mx_SpaceRoomView_info_item flex items-center flex-gap-4 rounded-full cursor-pointer bg-1e212b py-5 px-12",
    onClick: () => handleRequestClick()
  }, /*#__PURE__*/react.createElement("span", {
    className: "rounded size-6 bg-ff6161"
  }), /*#__PURE__*/react.createElement("span", {
    className: "text-base"
  }, (0,languageHandler._t)("Request"), " ", approveCount));
}));
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/elements/FacePile.tsx
var FacePile = __webpack_require__(566334);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/structures/space_home/components/Split.tsx
var Split = __webpack_require__(583282);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/structures/space_home/SpaceInfo.tsx











/* harmony default export */ const SpaceInfo = (/*#__PURE__*/(0,react.memo)(function SpaceInfo(props) {
  const {
    space
  } = props;
  const onMembersClick = () => {
    dispatcher/* default */.ZP.dispatch({
      action: actions/* Action */.a.SetRightPanelPhase,
      phase: RightPanelStorePhases/* RightPanelPhases */.q4.SpaceMemberList,
      refireParams: {
        space
      }
    });
  };
  if (space) {
    return /*#__PURE__*/react.createElement("div", {
      className: "mx_squadHomePage_Header_info mx_SpaceRoomView_info flex-gap-12"
    }, /*#__PURE__*/react.createElement(RoomVisible, {
      room: space
    }), /*#__PURE__*/react.createElement(Split/* default */.Z, null), /*#__PURE__*/react.createElement(RoomJoinRule, {
      room: space
    }), /*#__PURE__*/react.createElement(Split/* default */.Z, null), /*#__PURE__*/react.createElement(RoomMemberCount, {
      room: space
    }), /*#__PURE__*/react.createElement(SocialButton, {
      room: space,
      type: SocialType.Twitter,
      prefixNode: /*#__PURE__*/react.createElement(Split/* default */.Z, null)
    }), /*#__PURE__*/react.createElement("div", {
      className: "flex items-center ml-auto flex-gap-12"
    }, /*#__PURE__*/react.createElement(RoomJoinRequest, {
      room: space
    }), /*#__PURE__*/react.createElement(FacePile/* default */.Z, {
      room: space,
      onlyKnownUsers: false,
      numShown: 4,
      onClick: onMembersClick,
      showOurselves: true,
      size: 26
    })));
  }
  return null;
}));
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/structures/space_home/SpaceLandingHead.tsx









const SpaceLandingHead = props => {
  const {
    space
  } = props;
  const sortHandler = () => {
    dispatcher/* default */.ZP.dispatch({
      action: actions/* Action */.a.SetRightPanelPhase,
      phase: RightPanelStorePhases/* RightPanelPhases */.q4.SquadHomePageWidgetSort
    });
  };
  return /*#__PURE__*/react.createElement("div", {
    className: "mx_SpaceLanding_Head flex-col flex-gap-12 rounded-12 p-24 bg-161823"
  }, /*#__PURE__*/react.createElement("div", {
    className: "flex justify-between items-start"
  }, /*#__PURE__*/react.createElement(RoomAvatar/* default */.Z, {
    room: space,
    size: 62,
    viewAvatarOnClick: true
  }), space.isOwner() && /*#__PURE__*/react.createElement("div", {
    className: "flex flex-gap-12 items-center"
  }, /*#__PURE__*/react.createElement(dist.SdIcon, {
    icon: "HomeSettingOutlines",
    className: "cursor-pointer text-16",
    onClick: () => sortHandler()
  }))), /*#__PURE__*/react.createElement(RoomName/* default */.Z, {
    room: space
  }, name => {
    return /*#__PURE__*/react.createElement("div", {
      className: "space-name"
    }, /*#__PURE__*/react.createElement("h1", null, name));
  }), /*#__PURE__*/react.createElement(RoomTopic/* default */.Z, {
    room: space
  }, (topic, ref) => /*#__PURE__*/react.createElement("div", {
    className: "space-topic",
    ref: ref
  }, topic)), /*#__PURE__*/react.createElement(SpaceInfo, {
    space: space
  }));
};
/* harmony default export */ const space_home_SpaceLandingHead = (/*#__PURE__*/(0,react.memo)(SpaceLandingHead));
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/structures/space_home/SpaceHomeCardWrapper.tsx


/* harmony default export */ const SpaceHomeCardWrapper = (/*#__PURE__*/(0,react.memo)(function SpaceHomeCardWrapper(props) {
  const {
    title,
    tools,
    children,
    content,
    headerSticky
  } = props;
  return /*#__PURE__*/react.createElement("div", {
    className: classnames_default()("mx_SquadHomePage_card_wrapper p-24 rounded-12 bg-161823", {
      "mx_SquadHomePage_card_wrapper_sticky": headerSticky
    })
  }, (title || tools || content) && /*#__PURE__*/react.createElement("div", {
    className: classnames_default()({
      "mx_SquadHomePage_card_header_sticky": headerSticky
    })
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_SquadHomePage_card_header flex justify-end items-center mt--12 mb-12"
  }, /*#__PURE__*/react.createElement("h2", {
    className: "text-16 mb-0 mr-auto"
  }, title), tools), content), children);
}));
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/structures/space_home/WidgetEvents.tsx







/* harmony default export */ const WidgetEvents = (/*#__PURE__*/(0,react.memo)(function WidgetEvents(props) {
  const {
    space
  } = props;
  const toolHandler = () => {
    dispatcher/* default */.ZP.dispatch({
      action: actions/* Action */.a.SetRightPanelPhase,
      phase: RightPanelStorePhases/* RightPanelPhases */.q4.SpaceMemberList,
      refireParams: {
        space
      }
    });
  };
  return /*#__PURE__*/react.createElement(SpaceHomeCardWrapper, {
    title: (0,languageHandler._t)("Official Events"),
    tools: /*#__PURE__*/react.createElement(dist.SdIcon, {
      icon: "RightOutlines",
      style: {
        fontSize: "22px"
      },
      onClick: () => toolHandler()
    })
  }, /*#__PURE__*/react.createElement("div", {
    className: "flex-col"
  }, /*#__PURE__*/react.createElement("img", {
    src: ""
  }), /*#__PURE__*/react.createElement("h3", null), /*#__PURE__*/react.createElement("div", null, "Time: "), /*#__PURE__*/react.createElement("div", null, "Type: "), /*#__PURE__*/react.createElement("div", null, "Location: ")));
}));
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/structures/space_home/DappButtons.tsx + 1 modules
var DappButtons = __webpack_require__(249135);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/lib/constants.ts
var constants = __webpack_require__(877294);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/structures/space_home/RoomDapps.tsx





/* harmony default export */ const RoomDapps = (/*#__PURE__*/(0,react.memo)(function RoomDapps(props) {
  const {
    space
  } = props;
  const client = MatrixClientPeg/* MatrixClientPeg */.p.get();
  const myUserId = client.getUserId();
  const contextParams = {
    userId: myUserId,
    squadId: space.roomId,
    powerLevel: space.currentState.getMember(myUserId).powerLevel,
    timestamp: constants/* DAY_TIMESTAMP */.BG
  };
  return /*#__PURE__*/react.createElement(SpaceHomeCardWrapper, {
    title: "Dapps"
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_Dapps_container grid flex-gap-12"
  }, /*#__PURE__*/react.createElement(DappButtons/* default */.Z, {
    context: contextParams,
    displayPosition: space.isAdmin(myUserId) ? DappButtons/* DisplayPosition */.n.SQUAD_HOME_ADMIN : DappButtons/* DisplayPosition */.n.SQUAD_HOME
  })));
}));
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/structures/space_home/widgets/TwitterEmbed.tsx
var TwitterEmbed = __webpack_require__(971616);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/structures/space_home/WidgetTwitter.tsx










/* harmony default export */ const WidgetTwitter = (/*#__PURE__*/(0,react.memo)(function WidgetTwitter(props) {
  const {
    space
  } = props;
  const roomId = space.roomId;
  const {
    loading,
    data
  } = (0,ahooks_lib.useRequest)(() => MatrixClientPeg/* MatrixClientPeg */.p.get().getFirstTweetBySquadId(roomId), {
    ready: !!roomId,
    refreshDeps: [roomId]
  });
  const toolHandler = () => {
    dispatcher/* default */.ZP.dispatch({
      action: actions/* Action */.a.SetRightPanelPhase,
      phase: RightPanelStorePhases/* RightPanelPhases */.q4.TwitterTimeline,
      refireParams: {
        params: {
          twitterProfileUrl: data === null || data === void 0 ? void 0 : data.twitter_profile_url
        }
      }
    });
  };
  if (loading) {
    return /*#__PURE__*/react.createElement(SpaceHomeCardWrapper, null, /*#__PURE__*/react.createElement(dist.SdSkeleton, {
      avatar: true,
      active: true,
      paragraph: {
        rows: 3
      }
    }));
  } else if (data !== null && data !== void 0 && data.conversation_id) {
    return /*#__PURE__*/react.createElement(SpaceHomeCardWrapper, {
      title: "X (Twitter)",
      tools: /*#__PURE__*/react.createElement(dist.SdIcon, {
        icon: "RightOutlines",
        style: {
          fontSize: "22px"
        },
        className: "cursor-pointer",
        onClick: () => toolHandler()
      })
    }, /*#__PURE__*/react.createElement(TwitterEmbed/* default */.Z, {
      tweetId: data.conversation_id
    }));
  } else {
    return /*#__PURE__*/react.createElement(SpaceHomeCardWrapper, {
      title: "X (Twitter)"
    }, /*#__PURE__*/react.createElement("div", {
      className: "flex items-center justify-start flex-gap-12 text-16 text-tertiary"
    }, /*#__PURE__*/react.createElement(dist.SdIcon, {
      icon: "BulbOutlines"
    }), (0,languageHandler._t)("Not linked to Twitter yet.")));
  }
}));
// EXTERNAL MODULE: ./node_modules/lodash-es/throttle.js
var throttle = __webpack_require__(300111);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/structures/space_home/hooks/useAnnouncements.ts
var useAnnouncements = __webpack_require__(807065);
// EXTERNAL MODULE: ./node_modules/lodash-es/orderBy.js
var orderBy = __webpack_require__(803695);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/structures/space_home/widgets/Announcement.tsx
var Announcement = __webpack_require__(224424);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/structures/space_home/WidgetAnnouncements.tsx










/* harmony default export */ const WidgetAnnouncements = (/*#__PURE__*/(0,react.memo)(function WidgetAnnouncements(props) {
  const {
    space
  } = props;
  const [cardEvents, setCardEvents] = (0,react.useState)();
  const {
    loading,
    mxEvents,
    pinnedMap
  } = (0,useAnnouncements/* default */.ZP)(space);
  const [loadingEvents, setLoadingEvents] = (0,react.useState)(true);
  const allRooms = (0,react.useMemo)(() => {
    return (0,useAnnouncements/* getRooms */.A4)(space);
  }, []);
  const toolHandler = () => {
    dispatcher/* default */.ZP.dispatch({
      action: actions/* Action */.a.SetRightPanelPhase,
      phase: RightPanelStorePhases/* RightPanelPhases */.q4.SquadHomePageAnnouncementList,
      refireParams: {
        params: {
          space
        }
      }
    });
  };
  const handleAnnouncementItemClick = ev => {
    const room = allRooms.find(i => {
      var _ev$event;
      return i.roomId === (ev === null || ev === void 0 ? void 0 : (_ev$event = ev.event) === null || _ev$event === void 0 ? void 0 : _ev$event.room_id);
    });
    dispatcher/* default */.ZP.dispatch({
      action: actions/* Action */.a.SetRightPanelPhase,
      phase: RightPanelStorePhases/* RightPanelPhases */.q4.SquadHomePageAnnouncementList,
      refireParams: {
        params: {
          space,
          defaultShowInfo: {
            showInfo: true,
            room: room,
            mxEvent: ev
          }
        }
      }
    });
  };
  (0,react.useEffect)(() => {
    if (mxEvents !== null && mxEvents !== void 0 && mxEvents.length) {
      Promise.all(mxEvents).then(events => {
        // display one ama, one msg, one anc
        const sortEvens = (0,orderBy/* default */.Z)(events, "event.origin_server_ts", "desc").filter(Boolean);
        const firstAMA = sortEvens.find(i => pinnedMap.get(i.event.event_id) === "AMA");
        const firstNOC = sortEvens.find(i => pinnedMap.get(i.event.event_id) === "NOTICE");
        const firstMSG = sortEvens.find(i => pinnedMap.get(i.event.event_id) === "MSG");
        setCardEvents([firstAMA, firstNOC, firstMSG].filter(Boolean));
      }).catch(() => {
        setLoadingEvents(false);
      });
    } else {
      setLoadingEvents(false);
    }
  }, [mxEvents]);
  let content = /*#__PURE__*/react.createElement("div", {
    className: "flex items-center justify-start flex-gap-12 text-tertiary text-16"
  }, /*#__PURE__*/react.createElement(dist.SdIcon, {
    icon: "BulbOutlines"
  }), (0,languageHandler._t)("There's nothing more to see here for now."));
  if (loading || loadingEvents) {
    content = /*#__PURE__*/react.createElement(dist.SdSkeleton.SimpleList, {
      active: true
    });
  } else if (cardEvents !== null && cardEvents !== void 0 && cardEvents.length) {
    console.log(cardEvents);
    content = /*#__PURE__*/react.createElement("div", {
      className: "flex-col flex-gap-24"
    }, cardEvents.map(ev => /*#__PURE__*/react.createElement(Announcement/* default */.Z, {
      space: space,
      mxEvent: ev,
      pinnedMap: pinnedMap,
      onClick: () => handleAnnouncementItemClick(ev)
    })));
  }
  return /*#__PURE__*/react.createElement(SpaceHomeCardWrapper, {
    title: (0,languageHandler._t)("Announcements"),
    tools: /*#__PURE__*/react.createElement(dist.SdIcon, {
      icon: "RightOutlines",
      style: {
        fontSize: "22px"
      },
      className: "cursor-pointer",
      onClick: () => toolHandler()
    })
  }, content);
}));
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/SquadWidgetStore.tsx
var SquadWidgetStore = __webpack_require__(233685);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/structures/space_home/hooks/useGetWidgetList.ts


const useGetWidgetList = () => {
  const state = (0,useEventEmitter/* useEventEmitterState */.k)(SquadWidgetStore/* default */.ZP.instance, SquadWidgetStore/* SquadWidgetStoreAction */.Xq.updateSquadWidgetHooksState, () => SquadWidgetStore/* default */.ZP.instance.getState());
  return state;
};
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/HomeButton.tsx
var HomeButton = __webpack_require__(508380);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/utils/units.ts
var units = __webpack_require__(612559);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/structures/space_home/SpaceLanding.tsx












const SpaceLanding = props => {
  var _widgetConf$filter;
  const {
    space,
    resizeNotifier
  } = props;
  const roomId = space.roomId;
  const containerRef = (0,react.useRef)(null);
  const {
    squadWidgetConfigMap
  } = useGetWidgetList();
  const [loading, setLoading] = (0,react.useState)(true);
  const [hasHittingBottom, setHasHittingBottom] = (0,react.useState)(false);
  const widgets = [];
  (0,react.useEffect)(() => {
    if (!roomId) return;
    setLoading(true);
    SquadWidgetStore/* default */.ZP.instance.getWidgetConfigListBySquadId(roomId).then(res => {
      SquadWidgetStore/* default */.ZP.instance.updateProtectionState();
      setLoading(false);
    });
  }, [roomId]);
  const scrollEventListener = (0,throttle/* default */.Z)(() => {
    const {
      clientHeight,
      scrollTop,
      scrollHeight
    } = containerRef.current;
    const diff = 0;
    if (scrollHeight - clientHeight - diff <= scrollTop) {
      setHasHittingBottom(true);
      // console.log("到底了")
    } else {
      // console.log("没到底+++++++")
      setHasHittingBottom(false);
    }
  }, 300);
  const widgetConf = squadWidgetConfigMap.get(roomId) || [];
  widgetConf === null || widgetConf === void 0 ? void 0 : (_widgetConf$filter = widgetConf.filter(item => item.show)) === null || _widgetConf$filter === void 0 ? void 0 : _widgetConf$filter.map(item => {
    switch (item.code) {
      case "events":
        widgets.push( /*#__PURE__*/react.createElement(WidgetEvents, {
          space: space
        }));
        break;
      case "twitter":
        widgets.push( /*#__PURE__*/react.createElement(WidgetTwitter, {
          space: space
        }));
        break;
      case "announcement":
        widgets.push( /*#__PURE__*/react.createElement(WidgetAnnouncements, {
          space: space
        }));
        break;
      case "dapp":
        widgets.push( /*#__PURE__*/react.createElement(RoomDapps, {
          space: space
        }));
        break;
    }
  });
  return /*#__PURE__*/react.createElement("div", {
    id: "mx_squadHomePage_wrapper_id",
    onScroll: scrollEventListener,
    ref: containerRef,
    className: "mx_squadHomePage_wrapper flex-col flex-gap-10"
  }, (0,units/* isMobile */.tq)() && /*#__PURE__*/react.createElement(HomeButton/* default */.Z, null), /*#__PURE__*/react.createElement(space_home_SpaceLandingHead, {
    space: space
  }), loading && /*#__PURE__*/react.createElement(dist.SdSkeleton.SimpleList, {
    active: true
  }), widgets.map(w => w));
};
/* harmony default export */ const space_home_SpaceLanding = (/*#__PURE__*/(0,react.memo)(SpaceLanding));
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/SquadConfigStateStore.ts
var SquadConfigStateStore = __webpack_require__(910162);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/icons/IconOfficial.tsx
var IconOfficial = __webpack_require__(65246);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/panelcontent/TagInfo.tsx


const TagInfo = tagInfoProps => {
  if (tagInfoProps.joinRules !== "token.access" && !tagInfoProps.member) {
    return null;
  }
  return /*#__PURE__*/react.createElement("div", {
    className: "explore_item_info_wrap"
  }, /*#__PURE__*/react.createElement("div", {
    className: "explore_item_count_item"
  }, /*#__PURE__*/react.createElement(dist.SdIcon, {
    icon: "MembersOutlines"
  }), /*#__PURE__*/react.createElement("img", {
    className: "explore_item_tag",
    src: __webpack_require__(833250)
  }), /*#__PURE__*/react.createElement("span", {
    className: "explore_tag_name"
  }, tagInfoProps.member)), tagInfoProps.joinRules === "token.access" ? /*#__PURE__*/react.createElement("div", {
    className: "explore_item_count_item"
  }, /*#__PURE__*/react.createElement("img", {
    className: "explore_item_tag",
    src: __webpack_require__(596395)
  }), /*#__PURE__*/react.createElement("span", {
    className: "explore_tag_name"
  }, "Token Gated")) : null);
};
/* harmony default export */ const panelcontent_TagInfo = (TagInfo);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/panelcontent/TokenGatedRequirement.tsx
var TokenGatedRequirement = __webpack_require__(872607);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/structures/SpaceInfoInvite.tsx
/*
Copyright 2021 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/










const SpaceInfoInvite = ({
  space,
  roomInfo,
  noJoinRule = false,
  detailToken = false,
  detailTokenData = undefined,
  approveApplied = null
}) => {
  var _space$currentState, _space$currentState$g;
  if (noJoinRule) {
    return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("div", {
      className: "mx_SpaceRoomView_info mx_TagInfo",
      style: {
        marginBottom: "20px",
        justifyContent: "center"
      }
    }, /*#__PURE__*/react.createElement(panelcontent_TagInfo, {
      auth: roomInfo.auth,
      member: roomInfo.memberCount,
      joinRules: roomInfo.join_rules
    })), /*#__PURE__*/react.createElement("div", {
      className: "mx_TokenGated_joinparams",
      style: {
        width: "400px"
      }
    }, detailToken ? /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(TokenGatedRequirement/* default */.Z, {
      joinparams: detailTokenData === null || detailTokenData === void 0 ? void 0 : detailTokenData.join_params,
      joinadvance: detailTokenData === null || detailTokenData === void 0 ? void 0 : detailTokenData.join_advance
    })) : /*#__PURE__*/react.createElement(TokenGatedRequirement/* default */.Z, {
      joinparams: roomInfo === null || roomInfo === void 0 ? void 0 : roomInfo.join_params,
      joinadvance: roomInfo === null || roomInfo === void 0 ? void 0 : roomInfo.join_advance
    })), approveApplied ? /*#__PURE__*/react.createElement("div", {
      className: "mx_SpaceRoomView_preview_approveTips"
    }, (0,languageHandler._t)(approveApplied.status ? approveApplied.msg || "You have applied, please wait for administrator approval." : "Joining the room must be approved by the room owner or administrator.")) : null);
  }
  const tokenGatedRuleContent = space === null || space === void 0 ? void 0 : (_space$currentState = space.currentState) === null || _space$currentState === void 0 ? void 0 : (_space$currentState$g = _space$currentState.getStateEvents(_types_event/* EventType */.tw.RoomJoinRules, "")) === null || _space$currentState$g === void 0 ? void 0 : _space$currentState$g.getContent();
  let visibilitySection = null;
  if (roomInfo !== null && roomInfo !== void 0 && roomInfo.visibility) {
    if ((tokenGatedRuleContent === null || tokenGatedRuleContent === void 0 ? void 0 : tokenGatedRuleContent.join_rule) === partials/* JoinRule */.iE.Token && tokenGatedRuleContent !== null && tokenGatedRuleContent !== void 0 && tokenGatedRuleContent.join_params) {
      var _ref;
      const {
        join_params
      } = tokenGatedRuleContent;
      visibilitySection = /*#__PURE__*/react.createElement("span", {
        className: "mx_SpaceRoomView_info_item"
      }, /*#__PURE__*/react.createElement(dist.SdIcon, {
        icon: "PlanetOutlines"
      }), /*#__PURE__*/react.createElement("span", null, " ", (0,languageHandler._t)("Token Gating")), /*#__PURE__*/react.createElement(lib.Tooltip, {
        placement: "bottom",
        overlayClassName: "mx_SpaceRoomView_info_token_gated_tooltip",
        title: /*#__PURE__*/react.createElement("div", {
          className: "token_gated_detail_tooltip_wrapper"
        }, /*#__PURE__*/react.createElement("div", {
          className: "tooltip_title"
        }, (join_params === null || join_params === void 0 ? void 0 : join_params.logic) === partials/* TokenAccessLogic */.S4.ALL ? (0,languageHandler._t)("token meet all") : (0,languageHandler._t)("token meet one")), (_ref = join_params.requirements || []) === null || _ref === void 0 ? void 0 : _ref.map(i => {
          var _i$requiredToken;
          return /*#__PURE__*/react.createElement("div", {
            className: "token_gated_item"
          }, /*#__PURE__*/react.createElement("div", {
            className: "token_gated_item_left"
          }, /*#__PURE__*/react.createElement("img", {
            src: i.requiredToken.logo
          })), /*#__PURE__*/react.createElement("div", {
            className: "token_gated_item_right"
          }, /*#__PURE__*/react.createElement("div", {
            className: "right_top"
          }, /*#__PURE__*/react.createElement("div", null, (_i$requiredToken = i.requiredToken) === null || _i$requiredToken === void 0 ? void 0 : _i$requiredToken.name), /*#__PURE__*/react.createElement("div", null, AccessTokenStore/* default */.Z.isNFT(i.requiredToken.type) ? "1NFT" : i.requiredAmount)), /*#__PURE__*/react.createElement("div", {
            className: "right_bottom"
          }, i.chain)));
        }))
      }, /*#__PURE__*/react.createElement("span", {
        className: "mx_SpaceRoomView_info_item_tooltip_icon"
      })));
    } else if ((roomInfo === null || roomInfo === void 0 ? void 0 : roomInfo.visibility) === "public") {
      visibilitySection = /*#__PURE__*/react.createElement("span", {
        className: "mx_SpaceRoomView_info_item"
      }, /*#__PURE__*/react.createElement(dist.SdIcon, {
        icon: "PlanetOutlines"
      }), /*#__PURE__*/react.createElement("span", null, " ", (0,languageHandler._t)("Public")));
    } else {
      visibilitySection = /*#__PURE__*/react.createElement("span", {
        className: "mx_SpaceRoomView_info_item"
      }, /*#__PURE__*/react.createElement(dist.SdIcon, {
        icon: "PlanetOutlines"
      }), /*#__PURE__*/react.createElement("span", null, " ", (0,languageHandler._t)("Private")));
    }
  }
  return /*#__PURE__*/react.createElement("div", {
    className: "mx_SpaceRoomView_info"
  }, visibilitySection);
};
/* harmony default export */ const structures_SpaceInfoInvite = (SpaceInfoInvite);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/structures/SpaceRoomView.tsx

/*
Copyright 2021 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/





























// import { ChevronFace, ContextMenuButton, useContextMenu } from "./ContextMenu";
// import IconizedContextMenu, {
//     IconizedContextMenuOption,
//     IconizedContextMenuOptionList,
// } from "../views/context_menus/IconizedContextMenu";


// import { SpaceFeedbackPrompt } from "../views/spaces/SpaceCreateMenu";
// import { CreateEventField, IGroupSummary } from "../views/dialogs/CreateSpaceFromCommunityDialog";
// import { useAsyncMemo } from "../../hooks/useAsyncMemo";
// import Spinner from "../views/elements/Spinner";
// import GroupAvatar from "../views/avatars/GroupAvatar";



















// import SpaceInfo from "./space_home/SpaceInfo";

var Phase = /*#__PURE__*/function (Phase) {
  Phase[Phase["Landing"] = 0] = "Landing";
  Phase[Phase["PublicCreateRooms"] = 1] = "PublicCreateRooms";
  Phase[Phase["PublicShare"] = 2] = "PublicShare";
  Phase[Phase["PrivateScope"] = 3] = "PrivateScope";
  Phase[Phase["PrivateInvite"] = 4] = "PrivateInvite";
  Phase[Phase["PrivateCreateRooms"] = 5] = "PrivateCreateRooms";
  Phase[Phase["PrivateExistingRooms"] = 6] = "PrivateExistingRooms";
  Phase[Phase["CreateExternalGroup"] = 7] = "CreateExternalGroup";
  return Phase;
}(Phase || {});
const SpaceRoomView_RoomMemberCount = ({
  room,
  children
}) => {
  const members = useRoomMembers(room);
  const count = members.length;
  if (children) return children(count);
  return count;
};
const useMyRoomMembership = room => {
  const [membership, setMembership] = (0,react.useState)(room ? room.getMyMembership() : null);
  (0,useEventEmitter/* useEventEmitter */.x)(room, "Room.myMembership", () => {
    setMembership(room.getMyMembership());
  });
  return membership;
};
const onPreferencesClick = () => {
  dispatcher/* default */.ZP.dispatch({
    action: actions/* Action */.a.ViewUserSettings,
    initialTabId: UserSettingsDialog/* UserTab */.oX.Preferences
  });
};
const SpacePreview = ({
  space,
  roomInfo,
  onJoinButtonClicked,
  onRejectButtonClicked,
  onRejectAndIgnoreClick
}) => {
  var _roomInfo$space, _roomInfo$space2, _roomInfo$space3, _roomInfo$room_id, _squadConfig$data;
  const cli = (0,react.useContext)(MatrixClientContext/* default */.Z);
  const myMembership = useMyRoomMembership(space);

  // const urlFrom = new URL(window.href).searchParams.get('from')
  // console.log('echo urlFrom', {urlFrom})

  const {
    data: squadConfig
  } = (0,ahooks_lib.useRequest)(() => cli.fetchSquadConfig({
    squadId: space.roomId
  }));
  const {
    data: roomDetails
  } = (0,ahooks_lib.useRequest)(() => cli.getSdnSquadInfo((space === null || space === void 0 ? void 0 : space.roomId) || roomInfo.room_id));
  (0,useDispatcher/* useDispatcher */.P)(dispatcher/* default */.ZP, payload => {
    if (payload.action === actions/* Action */.a.JoinRoomError && payload.roomId === ((space === null || space === void 0 ? void 0 : space.roomId) || roomInfo.room_id)) {
      setBusy(false); // stop the spinner, join failed
      if (payload.err.qualified !== undefined) {
        setDetailToken(true);
        setDetailTokenData(payload.err);
      } else if (payload.err.privateApply) {
        setPrivateApply(true);
      }
    }
    if (payload.action === "token_qualified_error") {
      setBusy(false);
    }
  });
  const [busy, setBusy] = (0,react.useState)(false);
  const [detailToken, setDetailToken] = (0,react.useState)(false);
  const [detailTokenData, setDetailTokenData] = (0,react.useState)(null);
  const [privateApply, setPrivateApply] = (0,react.useState)(false);
  const [showLinkWallet, setShowLinkWallet] = (0,react.useState)(false);
  const [walletList, setWalletList] = (0,react.useState)([]);
  const isMaxWallet = walletList.length >= 10;
  const isTokenGating = roomInfo.join_rules === partials/* JoinRule */.iE.Token;
  const spacesEnabled = SpaceStore/* default */.ZP.spacesEnabled;
  const [isSpaceApprove, setIsSpaceApprove] = (0,react.useState)(myMembership !== "invite" && myMembership !== "join" && !!(roomInfo !== null && roomInfo !== void 0 && (_roomInfo$space = roomInfo.space) !== null && _roomInfo$space !== void 0 && _roomInfo$space.room_id) && !SpaceStore/* default */.ZP.instance.getSpace(roomInfo === null || roomInfo === void 0 ? void 0 : (_roomInfo$space2 = roomInfo.space) === null || _roomInfo$space2 === void 0 ? void 0 : _roomInfo$space2.room_id) && (roomInfo === null || roomInfo === void 0 ? void 0 : (_roomInfo$space3 = roomInfo.space) === null || _roomInfo$space3 === void 0 ? void 0 : _roomInfo$space3.join_rules) === partials/* JoinRule */.iE.Approve);
  const roomInfoReal = isSpaceApprove ? roomInfo.space : roomInfo;
  const [approveApplied, setApproveApplied] = (0,react.useState)({
    status: false,
    msg: ""
  });
  const joinRules = (roomInfoReal === null || roomInfoReal === void 0 ? void 0 : roomInfoReal.join_rules) || (space === null || space === void 0 ? void 0 : space.getJoinRule());
  const isApproveRule = myMembership !== "invite" && joinRules === partials/* JoinRule */.iE.Approve;
  const isSpace = isSpaceApprove || (space === null || space === void 0 ? void 0 : space.isSpaceRoom()) || roomInfoReal.type === "m.space";
  const client = MatrixClientPeg/* MatrixClientPeg */.p.get();
  const cannotJoin = false;
  (0,react.useEffect)(() => {
    if (roomInfo.parent_id) {
      const space = MatrixClientPeg/* MatrixClientPeg */.p.get().getRoom(roomInfo.parent_id);
      if (!space) {
        dispatcher/* default */.ZP.dispatch({
          action: "view_room",
          room_id: roomInfo.parent_id
        });
      }
    }
  }, [roomInfo === null || roomInfo === void 0 ? void 0 : roomInfo.parent_id]);
  (0,react.useEffect)(() => {
    const refresh = () => {
      var _roomInfo$space4, _roomInfo$space5, _roomInfo$space6;
      const next = myMembership !== "invite" && myMembership !== "join" && !!(roomInfo !== null && roomInfo !== void 0 && (_roomInfo$space4 = roomInfo.space) !== null && _roomInfo$space4 !== void 0 && _roomInfo$space4.room_id) && !SpaceStore/* default */.ZP.instance.getSpace(roomInfo === null || roomInfo === void 0 ? void 0 : (_roomInfo$space5 = roomInfo.space) === null || _roomInfo$space5 === void 0 ? void 0 : _roomInfo$space5.room_id) && (roomInfo === null || roomInfo === void 0 ? void 0 : (_roomInfo$space6 = roomInfo.space) === null || _roomInfo$space6 === void 0 ? void 0 : _roomInfo$space6.join_rules) === partials/* JoinRule */.iE.Approve;
      setIsSpaceApprove(next);
      if (isSpaceApprove && !next) {
        setApproveApplied({
          status: false,
          msg: ""
        });
      }
    };
    setTimeout(refresh, 400);
    SpaceStore/* default */.ZP.instance.on(SpaceStore/* UPDATE_TOP_LEVEL_SPACES */.Ue, refresh);
    return () => {
      SpaceStore/* default */.ZP.instance.off(SpaceStore/* UPDATE_TOP_LEVEL_SPACES */.Ue, refresh);
      // roomStoreToken.remove();
    };
  }, []);
  (0,react.useEffect)(() => {
    checkTokenGatedPremission();
  }, []);
  const checkTokenGatedPremission = async () => {
    if (isTokenGating) {
      const sendObj = {
        join_rule: roomInfo === null || roomInfo === void 0 ? void 0 : roomInfo.join_rules,
        join_params: roomInfo === null || roomInfo === void 0 ? void 0 : roomInfo.join_params
      };
      const res = await client.checkTokenGated(sendObj);
      if ((res === null || res === void 0 ? void 0 : res.qualified) !== undefined) {
        // roomInfo.join_params = join_params;
        setDetailToken(true);
        setDetailTokenData(res === null || res === void 0 ? void 0 : res.content);
      }
    }
  };
  const onApproveApply = () => {
    if (approveApplied.status) {
      return;
    }
    ApproveStore/* default */.Z.applyApprove(roomInfoReal.room_id || (space === null || space === void 0 ? void 0 : space.roomId)).then(res => {
      setApproveApplied({
        status: true,
        msg: (res === null || res === void 0 ? void 0 : res.error) || ""
      });
    });
  };
  let inviterSection;
  let joinButtons;
  let ignoreSection;
  let errorText;
  let walletSection = isApproveRule || isMaxWallet || !isTokenGating ? null : /*#__PURE__*/react.createElement("div", {
    className: "mx_walletSection_operation"
  }, /*#__PURE__*/react.createElement("div", {
    onClick: () => setShowLinkWallet(true)
  }, /*#__PURE__*/react.createElement("img", {
    src: __webpack_require__(570560)
  }), /*#__PURE__*/react.createElement("span", null, "Link another wallet")));
  const getWalletList = async () => {
    const userId = cli.getUserId();
    const walletListResult = await WalletStore/* default */.ZP.instance.getWalletList(userId, true);
    if (walletListResult.data) {
      setWalletList(walletListResult.data || []);
    }
  };
  (0,react.useEffect)(() => {
    getWalletList();
  }, []);
  if (!space && !(roomInfo !== null && roomInfo !== void 0 && (_roomInfo$room_id = roomInfo.room_id) !== null && _roomInfo$room_id !== void 0 && _roomInfo$room_id.startsWith("!"))) {
    dispatcher/* default */.ZP.dispatch({
      action: "view_home_page"
    });
  }
  if (isTokenGating && (0,isEmpty/* default */.Z)(roomInfo.join_params)) {
    const room = space || (roomInfo.room_id ? cli.getRoom(roomInfo.room_id) : null);
    if (room) {
      var _room$currentState, _room$currentState$ge, _room$getMembers;
      const {
        join_params,
        join_advance
      } = (room === null || room === void 0 ? void 0 : (_room$currentState = room.currentState) === null || _room$currentState === void 0 ? void 0 : (_room$currentState$ge = _room$currentState.getStateEvents(_types_event/* EventType */.tw.RoomJoinRules, "")) === null || _room$currentState$ge === void 0 ? void 0 : _room$currentState$ge.getContent()) || {};
      roomInfo.join_params = join_params;
      roomInfo.join_advance = join_advance;
      roomInfo.memberCount = room === null || room === void 0 ? void 0 : (_room$getMembers = room.getMembers()) === null || _room$getMembers === void 0 ? void 0 : _room$getMembers.length;
    }
  }
  if (myMembership === "join") {
    // XXX remove this when spaces leaves Beta
    joinButtons = /*#__PURE__*/react.createElement(AccessibleButton/* default */.Z, {
      kind: "danger_outline",
      onClick: () => {
        dispatcher/* default */.ZP.dispatch({
          action: "leave_room",
          room_id: space.roomId
        });
      }
    }, (0,languageHandler._t)("Leave"));
  } else if (myMembership === "invite") {
    var _inviteMember$events$, _inviteMember$events$2, _inviteMember$events, _inviteMember$events$3, _detailTokenData$join;
    const inviteMember = space.getMember(cli.getUserId());
    const inviteSender = inviteMember === null || inviteMember === void 0 ? void 0 : (_inviteMember$events$ = inviteMember.events.member) === null || _inviteMember$events$ === void 0 ? void 0 : _inviteMember$events$.getSender();
    const {
      content: {
        sender_display_name = "",
        sender_avatar_url = ""
      }
    } = (_inviteMember$events$2 = inviteMember === null || inviteMember === void 0 ? void 0 : (_inviteMember$events = inviteMember.events) === null || _inviteMember$events === void 0 ? void 0 : (_inviteMember$events$3 = _inviteMember$events.member) === null || _inviteMember$events$3 === void 0 ? void 0 : _inviteMember$events$3.event) !== null && _inviteMember$events$2 !== void 0 ? _inviteMember$events$2 : {};
    const inviter = inviteSender && space.getMember(inviteSender);
    if (inviteSender) {
      inviterSection = /*#__PURE__*/react.createElement("div", {
        className: "mx_SpaceRoomView_preview_inviter"
      }, /*#__PURE__*/react.createElement("div", {
        className: "mx_SpaceRoomView_preview_inviter_row_one"
      }, !sender_avatar_url ? /*#__PURE__*/react.createElement(MemberAvatar/* default */.Z, {
        member: inviter,
        fallbackUserId: inviteSender,
        size: 20
      }) : /*#__PURE__*/react.createElement("img", {
        src: sender_avatar_url,
        width: 20,
        height: 20,
        style: {
          borderRadius: "50%"
        },
        alt: ""
      }), /*#__PURE__*/react.createElement("div", {
        className: "mx_SpaceRoomView_preview_inviter_name"
      }, /*#__PURE__*/react.createElement("b", null, sender_display_name || (0,strings/* getDisplayUserId */.RL)(inviteSender)), /*#__PURE__*/react.createElement("span", null, "(", (0,strings/* getDisplayUserId */.RL)(inviteSender), ")"))), /*#__PURE__*/react.createElement("div", null, "invites you"));
      ignoreSection = /*#__PURE__*/react.createElement(AccessibleButton/* default */.Z, {
        kind: "link",
        onClick: async () => {
          setBusy(true);
          const ignoredUsers = cli.getIgnoredUsers();
          ignoredUsers.push(inviteSender);
          await cli.setIgnoredUsers(ignoredUsers);
          onRejectButtonClicked(inviteSender);
        }
      }, (0,languageHandler._t)("Reject & Ignore user"));
    }
    joinButtons = /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(dist.SdButton, {
      type: "associate",
      size: "large",
      onClick: () => {
        setBusy(true);
        onRejectButtonClicked(inviteSender).finally(() => {
          setBusy(false);
        });
      }
    }, (0,languageHandler._t)("Reject")), /*#__PURE__*/react.createElement(dist.SdButton, {
      type: "primary",
      size: "large",
      onClick: () => {
        setBusy(true);
        onJoinButtonClicked(undefined, undefined, inviteSender, undefined).then(({
          roomId
        }) => {
          if (roomId) {
            const room = client.getRoom(roomId);
            if (room.isSpaceRoom() || room.getParentRoom()) {
              client.pointReport({
                action_type: "join_squad",
                room_id: room.isSpaceRoom() ? roomId : room.getParentRoom().roomId
              });
            }
          }
        });
      },
      disabled: detailTokenData && !(detailTokenData !== null && detailTokenData !== void 0 && (_detailTokenData$join = detailTokenData.join_params) !== null && _detailTokenData$join !== void 0 && _detailTokenData$join.qualified) || !spacesEnabled
    }, (0,languageHandler._t)("Accept")));
  } else {
    if (cannotJoin) {
      errorText = /*#__PURE__*/react.createElement("div", {
        className: "mx_SpaceRoomView_errorDialog_text"
      }, (0,languageHandler._t)("Private room inaccessible"));
      joinButtons = /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("button", {
        className: "mx_SpaceRoomView_errorDialog_button",
        onClick: () => {
          setBusy(true);
          dispatcher/* default */.ZP.dispatch({
            action: "view_home_page"
          });
        }
      }, (0,languageHandler._t)("Close")));
    } else {
      var _detailTokenData$join2;
      joinButtons = /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(AccessibleButton/* default */.Z, {
        kind: "primary_outline",
        onClick: () => {
          setBusy(true);
          dispatcher/* default */.ZP.dispatch({
            action: "view_home_page"
          });
        }
      }, (0,languageHandler._t)("Close")), /*#__PURE__*/react.createElement(AccessibleButton/* default */.Z, {
        kind: "primary",
        onClick: () => {
          var _space$getMember, _space$getMember$even;
          if (isApproveRule) {
            onApproveApply();
            return;
          }
          setBusy(true);
          onJoinButtonClicked(space ? space.roomId : roomInfo.room_id, true, space === null || space === void 0 ? void 0 : (_space$getMember = space.getMember(cli.getUserId())) === null || _space$getMember === void 0 ? void 0 : (_space$getMember$even = _space$getMember.events.member) === null || _space$getMember$even === void 0 ? void 0 : _space$getMember$even.getSender(), roomInfo === null || roomInfo === void 0 ? void 0 : roomInfo.parent_id).then(({
            roomId
          }) => {
            if (roomId) {
              const room = client.getRoom(roomId);
              if (room.isSpaceRoom() || room.getParentRoom()) {
                client.pointReport({
                  action_type: "join_squad",
                  room_id: room.isSpaceRoom() ? roomId : room.getParentRoom().roomId
                });
              }
            }
          }).catch(error => {
            console.error(error);
          });
        },
        disabled: !spacesEnabled || cannotJoin || detailTokenData && !(detailTokenData !== null && detailTokenData !== void 0 && (_detailTokenData$join2 = detailTokenData.join_params) !== null && _detailTokenData$join2 !== void 0 && _detailTokenData$join2.qualified) || privateApply || approveApplied.status
      }, (0,languageHandler._t)(isApproveRule ? "Apply" : "Join")));
    }
  }
  if (busy) {
    joinButtons = /*#__PURE__*/react.createElement(InlineSpinner/* default */.Z, {
      w: 32,
      h: 32
    });
  }
  let footer;
  if (!spacesEnabled) {
    footer = /*#__PURE__*/react.createElement("div", {
      className: "mx_SpaceRoomView_preview_spaceBetaPrompt"
    }, myMembership === "join" ? (0,languageHandler._t)("To view this Squad, hide communities in your <a>preferences</a>", {}, {
      a: sub => /*#__PURE__*/react.createElement(AccessibleButton/* default */.Z, {
        onClick: onPreferencesClick,
        kind: "link"
      }, sub)
    }) : (0,languageHandler._t)("To join this Squad, hide communities in your <a>preferences</a>", {}, {
      a: sub => /*#__PURE__*/react.createElement(AccessibleButton/* default */.Z, {
        onClick: onPreferencesClick,
        kind: "link"
      }, sub)
    }));
  }
  let style = {};
  const config = SdkConfig/* default */.Z.get();
  const baseUrl = config["default_server_config"]["m.homeserver"]["base_url"];
  let roomAvatar;
  if (space) {
    roomAvatar = space.getAvatarUrl(baseUrl, 66, 66, "crop");
  } else if (roomInfo.avatar) {
    roomAvatar = (0,Media/* mediaFromMxc */.TS)(roomInfo.avatar).srcHttp;
  }
  if (space !== null && space !== void 0 && space.isSpaceRoom()) {
    var _space$currentState$g, _space$currentState$g2;
    const bgUrl = (_space$currentState$g = space.currentState.getStateEvents(_types_event/* EventType */.tw.RoomBanner, "")) === null || _space$currentState$g === void 0 ? void 0 : (_space$currentState$g2 = _space$currentState$g.getContent()) === null || _space$currentState$g2 === void 0 ? void 0 : _space$currentState$g2.url;
    style["--roomAvatarBackground"] = `url(${bgUrl})`;
  } else if (roomInfo.background) {
    style["--roomAvatarBackground"] = `url(${roomInfo.background})`;
  }
  const onCloseWalletLink = () => {
    console.log("onCloseWalletLink");
    setShowLinkWallet(false);
  };
  const renderSpacePreview = showLinkWallet ? /*#__PURE__*/react.createElement("div", {
    className: "mx_SpacePreview_wallet_wrapper"
  }, /*#__PURE__*/react.createElement(LinkWallet/* default */.ZP, {
    step: LinkWallet/* WalletStep */.Ww.LINK_WALLET,
    closeElement: /*#__PURE__*/react.createElement("span", {
      className: "mx_LinkWallet_header_close",
      onClick: onCloseWalletLink
    }, /*#__PURE__*/react.createElement("img", {
      src: __webpack_require__(101727)
    })),
    onClose: () => setShowLinkWallet(false)
  })) : /*#__PURE__*/react.createElement(react.Fragment, null, style && /*#__PURE__*/react.createElement("div", {
    className: "mx_SpaceRoomView_topBackground",
    style: style
  }), roomInfoReal !== null && roomInfoReal !== void 0 && roomInfoReal.avatar ? /*#__PURE__*/react.createElement("img", {
    src: roomInfoReal.avatar,
    className: "mx_SpaceRoomView_avatar"
  }) : /*#__PURE__*/react.createElement(RoomAvatar/* default */.Z, {
    room: space,
    roomInfo: roomInfo,
    size: "large",
    viewAvatarOnClick: true
  }), inviterSection || /*#__PURE__*/react.createElement("div", {
    className: "mx_SpaceRoomView_preview_inviter"
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_SpaceRoomView_preview_inviter_name"
  }, (0,languageHandler._t)("Do you want to join in"))), cannotJoin && /*#__PURE__*/react.createElement("div", {
    className: "mx_SpaceRoomView_topBackground",
    style: style
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_SpaceRoomView_topBackgroundMask"
  })), /*#__PURE__*/react.createElement("h1", {
    className: "mx_SpaceRoomView_preview_name"
  }, Boolean(squadConfig === null || squadConfig === void 0 ? void 0 : (_squadConfig$data = squadConfig.data) === null || _squadConfig$data === void 0 ? void 0 : _squadConfig$data.is_official) && /*#__PURE__*/react.createElement("div", {
    style: {
      display: "flex",
      marginBottom: "-3px"
    }
  }, /*#__PURE__*/react.createElement(IconOfficial/* default */.Z, null)), /*#__PURE__*/react.createElement(lib.Typography.Title, {
    level: 5
  }, (roomDetails === null || roomDetails === void 0 ? void 0 : roomDetails.name) || (roomInfo === null || roomInfo === void 0 ? void 0 : roomInfo.name))), space && !cannotJoin && /*#__PURE__*/react.createElement(RoomTopic/* default */.Z, {
    room: space
  }, (topic, ref) => /*#__PURE__*/react.createElement("div", {
    className: "mx_SpaceRoomView_preview_topic",
    ref: ref
  }, topic)), /*#__PURE__*/react.createElement(structures_SpaceInfoInvite, {
    space: space,
    roomInfo: roomInfo,
    noJoinRule: (roomInfo === null || roomInfo === void 0 ? void 0 : roomInfo.join_rules) === partials/* JoinRule */.iE.Approve || isTokenGating,
    approveApplied: isApproveRule && !busy ? approveApplied : null,
    detailToken: detailToken,
    detailTokenData: detailTokenData
  }), walletSection, privateApply && /*#__PURE__*/react.createElement("div", {
    className: "mx_SpaceRoomView_preview_privateApply"
  }, (0,languageHandler._t)("Private planet only supports invitation to join")), errorText, /*#__PURE__*/react.createElement("div", {
    className: "mx_SpaceRoomView_preview_joinButtons"
  }, joinButtons), ignoreSection, footer);
  if (space !== null && space !== void 0 && space.isJoining) {
    return null;
  }
  return /*#__PURE__*/react.createElement("div", {
    className: classnames_default()("mx_SpaceRoomView_preview", {
      mx_SpaceRoomView_preview_default_padding: !showLinkWallet,
      mx_SpaceRoomView_preview_linkwallet_padding: showLinkWallet
    })
  }, renderSpacePreview);
};
const SpaceSetupFirstRooms = ({
  space,
  title,
  description,
  onFinished,
  isPrivate
}) => {
  const [copyText, setCopyText] = (0,react.useState)((0,languageHandler._t)("Copy Squad link"));
  const [busy, setBusy] = (0,react.useState)(false);
  const [error, setError] = (0,react.useState)("");
  const numFields = 3;
  const placeholders = [(0,languageHandler._t)("General"), (0,languageHandler._t)("Announcement"), (0,languageHandler._t)("Support")];
  const [roomNames, setRoomName] = useStateArray(numFields, [(0,languageHandler._t)("General"), (0,languageHandler._t)("Announcement"), ""]);
  const {
    space_type
  } = space.currentState.getStateEvents(_types_event/* EventType */.tw.RoomCreate, "").getContent();
  console.log(space_type);
  const fields = new Array(numFields).fill(0).map((x, i) => {
    const name = "roomName" + i;
    return /*#__PURE__*/react.createElement(Field/* default */.Z, {
      key: name,
      name: name,
      type: "text",
      label: (0,languageHandler._t)("Room name"),
      placeholder: placeholders[i],
      value: roomNames[i],
      onChange: ev => setRoomName(i, ev.target.value),
      autoFocus: i === 2,
      disabled: busy,
      autoComplete: "off"
    });
  });
  const onNextClick = async ev => {
    ev.preventDefault();
    if (busy) return;
    setError("");
    setBusy(true);
    try {
      const isPublic = space.getJoinRule() === partials/* JoinRule */.iE.Public;
      const filteredRoomNames = roomNames.map(name => name.trim()).filter(Boolean);
      const roomIds = await Promise.all(filteredRoomNames.map((name, index) => {
        return (0,createRoom/* default */.ZP)({
          createOpts: {
            preset: isPublic ? partials/* Preset */.Sk.PublicChat : partials/* Preset */.Sk.PrivateChat,
            name,
            visibility: partials/* Visibility */.EE.Public,
            creation_content: {
              space_type
            }
          },
          spinner: false,
          encryption: false,
          andView: false,
          inlineErrors: true,
          parentSpace: space,
          joinRule: partials/* JoinRule */.iE.Public,
          suggested: true,
          avatar: index === 0 ? "🎉" : "🐚"
        });
      }));
      onFinished(roomIds[0]);
    } catch (e) {
      console.error("Failed to create initial squad rooms", e);
      setError((0,languageHandler._t)("Failed to create initial squad rooms"));
    }
    setBusy(false);
  };
  let onClick = ev => {
    ev.preventDefault();
    onFinished();
  };
  let buttonLabel = (0,languageHandler._t)("Skip for now");
  if (roomNames.some(name => name.trim())) {
    onClick = onNextClick;
    buttonLabel = busy ? (0,languageHandler._t)("Creating rooms...") : (0,languageHandler._t)("Continue");
  }
  return /*#__PURE__*/react.createElement("div", {
    className: "mx_SpaceSetup"
  }, /*#__PURE__*/react.createElement(RoomAvatar/* default */.Z, {
    size: 80,
    room: space
  }), /*#__PURE__*/react.createElement("h1", null, title), /*#__PURE__*/react.createElement("div", {
    className: "mx_SpaceRoomView_description"
  }, description), /*#__PURE__*/react.createElement("div", {
    className: "mx_SpaceSetup_actions"
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_SpaceSetup_action invite",
    onClick: () => {
      (0,RoomInvite/* showRoomInviteDialog */.DE)(space.roomId);
    }
  }, (0,languageHandler._t)("Invite your friends")), !isPrivate ? /*#__PURE__*/react.createElement("div", {
    className: "mx_SpaceSetup_action copy",
    onClick: () => {
      (0,SpacePublicShare/* copyLink */.fB)(space, setCopyText, (0,languageHandler._t)("Copy Squad link"));
    }
  }, copyText) : null), /*#__PURE__*/react.createElement("div", {
    className: "mx_SpaceSetup_title"
  }, (0,languageHandler._t)("Create Room")), error && /*#__PURE__*/react.createElement("div", {
    className: "mx_SpaceRoomView_errorText"
  }, error), /*#__PURE__*/react.createElement("form", {
    onSubmit: onClick,
    id: "mx_SpaceSetupFirstRooms"
  }, fields), /*#__PURE__*/react.createElement("div", {
    className: "mx_SpaceRoomView_buttons"
  }, /*#__PURE__*/react.createElement(AccessibleButton/* default */.Z, {
    kind: "primary",
    disabled: busy,
    onClick: onClick,
    element: "input",
    type: "submit",
    form: "mx_SpaceSetupFirstRooms",
    value: buttonLabel
  })));
};
const SpaceAddExistingRooms = ({
  space,
  onFinished
}) => {
  return /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement("h1", null, (0,languageHandler._t)("What do you want to organise?")), /*#__PURE__*/react.createElement("div", {
    className: "mx_SpaceRoomView_description"
  }, (0,languageHandler._t)("Pick rooms or conversations to add. This is just a squad for you, " + "no one will be informed. You can add more later.")), /*#__PURE__*/react.createElement(AddExistingToSpaceDialog/* AddExistingToSpace */.o8, {
    space: space,
    emptySelectionButton: /*#__PURE__*/react.createElement(AccessibleButton/* default */.Z, {
      kind: "primary",
      onClick: onFinished
    }, (0,languageHandler._t)("Skip for now")),
    filterPlaceholder: (0,languageHandler._t)("Search for rooms or squads"),
    onFinished: onFinished,
    roomsRenderer: AddExistingToSpaceDialog/* defaultRoomsRenderer */.tS,
    spacesRenderer: AddExistingToSpaceDialog/* defaultSpacesRenderer */.x5,
    dmsRenderer: AddExistingToSpaceDialog/* defaultDmsRenderer */.hD
  }));
};
const SpaceSetupPublicShare = ({
  justCreatedOpts,
  space,
  onFinished,
  firstRoomId
}) => {
  var _justCreatedOpts$crea;
  return /*#__PURE__*/react.createElement("div", {
    className: "mx_SpaceRoomView_publicShare"
  }, /*#__PURE__*/react.createElement("h1", null, (0,languageHandler._t)("Share %(name)s", {
    name: (justCreatedOpts === null || justCreatedOpts === void 0 ? void 0 : (_justCreatedOpts$crea = justCreatedOpts.createOpts) === null || _justCreatedOpts$crea === void 0 ? void 0 : _justCreatedOpts$crea.name) || space.name
  })), /*#__PURE__*/react.createElement("div", {
    className: "mx_SpaceRoomView_description"
  }, (0,languageHandler._t)("It's just you at the moment, it will be even better with others.")), /*#__PURE__*/react.createElement(SpacePublicShare/* default */.ZP, {
    space: space
  }), /*#__PURE__*/react.createElement("div", {
    className: "mx_SpaceRoomView_buttons"
  }, /*#__PURE__*/react.createElement(AccessibleButton/* default */.Z, {
    kind: "primary",
    onClick: onFinished
  }, firstRoomId ? (0,languageHandler._t)("Go to my first room") : (0,languageHandler._t)("Go to my squad"))));
};
const SpaceSetupPrivateScope = ({
  space,
  justCreatedOpts,
  onFinished
}) => {
  var _justCreatedOpts$crea2;
  return /*#__PURE__*/react.createElement("div", {
    className: "mx_SpaceRoomView_privateScope"
  }, /*#__PURE__*/react.createElement("h1", null, (0,languageHandler._t)("Who are you working with?")), /*#__PURE__*/react.createElement("div", {
    className: "mx_SpaceRoomView_description"
  }, (0,languageHandler._t)("Make sure the right people have access to %(name)s", {
    name: (justCreatedOpts === null || justCreatedOpts === void 0 ? void 0 : (_justCreatedOpts$crea2 = justCreatedOpts.createOpts) === null || _justCreatedOpts$crea2 === void 0 ? void 0 : _justCreatedOpts$crea2.name) || space.name
  })), /*#__PURE__*/react.createElement(AccessibleButton/* default */.Z, {
    className: "mx_SpaceRoomView_privateScope_justMeButton",
    onClick: () => {
      onFinished(false);
    }
  }, /*#__PURE__*/react.createElement("h3", null, (0,languageHandler._t)("Just me")), /*#__PURE__*/react.createElement("div", null, (0,languageHandler._t)("A private squad to organise your rooms"))), /*#__PURE__*/react.createElement(AccessibleButton/* default */.Z, {
    className: "mx_SpaceRoomView_privateScope_meAndMyTeammatesButton",
    onClick: () => {
      onFinished(true);
    }
  }, /*#__PURE__*/react.createElement("h3", null, (0,languageHandler._t)("Me and my teammates")), /*#__PURE__*/react.createElement("div", null, (0,languageHandler._t)("A private squad for you and your teammates"))), /*#__PURE__*/react.createElement("div", {
    className: "mx_SpaceRoomView_betaWarning"
  }, /*#__PURE__*/react.createElement("h3", null, (0,languageHandler._t)("Teammates might not be able to view or join any private rooms you make.")), /*#__PURE__*/react.createElement("p", null, (0,languageHandler._t)("We're working on this, but just want to let you know."))));
};
const validateEmailRules = (0,Validation/* default */.Z)({
  rules: [{
    key: "email",
    test: ({
      value
    }) => !value || email/* looksValid */.s(value),
    invalid: () => (0,languageHandler._t)("Doesn't look like a valid email address")
  }]
});
const SpaceSetupPrivateInvite = ({
  space,
  onFinished
}) => {
  const [busy, setBusy] = (0,react.useState)(false);
  const [error, setError] = (0,react.useState)("");
  const numFields = 3;
  const fieldRefs = [(0,react.useRef)(), (0,react.useRef)(), (0,react.useRef)()];
  const [emailAddresses, setEmailAddress] = useStateArray(numFields, "");
  const fields = new Array(numFields).fill(0).map((x, i) => {
    const name = "emailAddress" + i;
    return /*#__PURE__*/react.createElement(Field/* default */.Z, {
      key: name,
      name: name,
      type: "text",
      label: (0,languageHandler._t)("Email address"),
      placeholder: (0,languageHandler._t)("Email"),
      value: emailAddresses[i],
      onChange: ev => setEmailAddress(i, ev.target.value),
      ref: fieldRefs[i],
      onValidate: validateEmailRules,
      autoFocus: i === 0,
      disabled: busy
    });
  });
  const onNextClick = async ev => {
    ev.preventDefault();
    if (busy) return;
    setError("");
    for (let i = 0; i < fieldRefs.length; i++) {
      const fieldRef = fieldRefs[i];
      const valid = await fieldRef.current.validate({
        allowEmpty: true
      });
      if (valid === false) {
        // true/null are allowed
        fieldRef.current.focus();
        fieldRef.current.validate({
          allowEmpty: true,
          focused: true
        });
        return;
      }
    }
    setBusy(true);
    const targetIds = emailAddresses.map(name => name.trim()).filter(Boolean);
    try {
      const result = await (0,RoomInvite/* inviteMultipleToRoom */.I9)(space.roomId, targetIds);
      const failedUsers = Object.keys(result.states).filter(a => result.states[a] === "error");
      if (failedUsers.length > 0) {
        console.log("Failed to invite users to squad: ", result);
        setError((0,languageHandler._t)("Failed to invite the following users to your squad: %(csvUsers)s", {
          csvUsers: failedUsers.join(", ")
        }));
      } else {
        onFinished();
      }
    } catch (err) {
      console.error("Failed to invite users to squad: ", err);
      setError((0,languageHandler._t)("We couldn't invite those users. Please check the users you want to invite and try again."));
    }
    setBusy(false);
  };
  let onClick = ev => {
    ev.preventDefault();
    onFinished();
  };
  let buttonLabel = (0,languageHandler._t)("Skip for now");
  if (emailAddresses.some(name => name.trim())) {
    onClick = onNextClick;
    buttonLabel = busy ? (0,languageHandler._t)("Inviting...") : (0,languageHandler._t)("Continue");
  }
  return /*#__PURE__*/react.createElement("div", {
    className: "mx_SpaceRoomView_inviteTeammates"
  }, /*#__PURE__*/react.createElement("h1", null, (0,languageHandler._t)("Invite your teammates")), /*#__PURE__*/react.createElement("div", {
    className: "mx_SpaceRoomView_description"
  }, (0,languageHandler._t)("Make sure the right people have access. You can invite more later.")), /*#__PURE__*/react.createElement("div", {
    className: "mx_SpaceRoomView_inviteTeammates_betaDisclaimer"
  }, /*#__PURE__*/react.createElement(BetaCard/* BetaPill */.r, null), (0,languageHandler._t)("<b>This is an experimental feature.</b> For now, " + "new users receiving an invite will have to open the invite on <link/> to actually join.", {}, {
    b: sub => /*#__PURE__*/react.createElement("b", null, sub),
    link: () => /*#__PURE__*/react.createElement("a", {
      href: "https://app.element.io/",
      rel: "noreferrer noopener",
      target: "_blank"
    }, "app.element.io")
  })), error && /*#__PURE__*/react.createElement("div", {
    className: "mx_SpaceRoomView_errorText"
  }, error), /*#__PURE__*/react.createElement("form", {
    onSubmit: onClick,
    id: "mx_SpaceSetupPrivateInvite"
  }, fields), /*#__PURE__*/react.createElement("div", {
    className: "mx_SpaceRoomView_inviteTeammates_buttons"
  }, /*#__PURE__*/react.createElement(AccessibleButton/* default */.Z, {
    className: "mx_SpaceRoomView_inviteTeammates_inviteDialogButton",
    onClick: () => (0,RoomInvite/* showRoomInviteDialog */.DE)(space.roomId)
  }, (0,languageHandler._t)("Invite by username"))), /*#__PURE__*/react.createElement("div", {
    className: "mx_SpaceRoomView_buttons"
  }, /*#__PURE__*/react.createElement(AccessibleButton/* default */.Z, {
    kind: "primary",
    disabled: busy,
    onClick: onClick,
    element: "input",
    type: "submit",
    form: "mx_SpaceSetupPrivateInvite",
    value: buttonLabel
  })));
};
class SpaceRoomView extends react.PureComponent {
  constructor(props, context) {
    var _this$props$space$cur;
    super(props, context);
    (0,defineProperty/* default */.Z)(this, "creator", void 0);
    (0,defineProperty/* default */.Z)(this, "dispatcherRef", void 0);
    (0,defineProperty/* default */.Z)(this, "rightPanelStoreToken", void 0);
    (0,defineProperty/* default */.Z)(this, "onMyMembership", (room, myMembership) => {
      if (room.roomId === this.props.space.roomId) {
        this.setState({
          myMembership
        });
      }
    });
    (0,defineProperty/* default */.Z)(this, "onRightPanelStoreUpdate", () => {
      this.setState({
        showRightPanel: RightPanelStore/* default */.Z.getSharedInstance().isOpenForRoom
      });
    });
    (0,defineProperty/* default */.Z)(this, "onAction", payload => {
      if (payload.action === actions/* Action */.a.HideRoomPanel) {
        this.setState({
          hideThisPanel: true
        });
      }
      if (payload.action === "view_room" && payload.room_id === this.props.space.roomId) {
        var _payload$params, _payload$params2;
        this.setState({
          phase: (_payload$params = payload.params) !== null && _payload$params !== void 0 && _payload$params.externalGroupCreate && ((_payload$params2 = payload.params) === null || _payload$params2 === void 0 ? void 0 : _payload$params2.subAction) === "create_group" ? Phase.CreateExternalGroup : Phase.Landing
        });
        return;
      }
      if (payload.action !== actions/* Action */.a.ViewUser && payload.action !== "view_3pid_invite") {
        return;
      }
      if (payload.action === actions/* Action */.a.ViewUser && payload.member) {
        dispatcher/* default */.ZP.dispatch({
          action: actions/* Action */.a.SetRightPanelPhase,
          phase: RightPanelStorePhases/* RightPanelPhases */.q4.SpaceMemberInfo,
          refireParams: {
            space: this.props.space,
            member: payload.member
          }
        });
      } else if (payload.action === "view_3pid_invite" && payload.event) {
        dispatcher/* default */.ZP.dispatch({
          action: actions/* Action */.a.SetRightPanelPhase,
          phase: RightPanelStorePhases/* RightPanelPhases */.q4.Space3pidMemberInfo,
          refireParams: {
            space: this.props.space,
            event: payload.event
          }
        });
      } else {
        dispatcher/* default */.ZP.dispatch({
          action: actions/* Action */.a.SetRightPanelPhase,
          phase: RightPanelStorePhases/* RightPanelPhases */.q4.SpaceMemberList,
          refireParams: {
            space: this.props.space
          }
        });
      }
    });
    (0,defineProperty/* default */.Z)(this, "goToFirstRoom", async () => {
      if (this.state.firstRoomId) {
        dispatcher/* default */.ZP.dispatch({
          action: "view_room",
          room_id: this.state.firstRoomId
        });
        return;
      }
      this.setState({
        phase: Phase.Landing
      });
    });
    let phase = Phase.Landing;
    this.creator = (_this$props$space$cur = this.props.space.currentState.getStateEvents(_types_event/* EventType */.tw.RoomCreate, "")) === null || _this$props$space$cur === void 0 ? void 0 : _this$props$space$cur.getSender();
    const showSetup = this.props.justCreatedOpts && this.context.getUserId() === this.creator;
    if (showSetup) {
      phase = this.props.justCreatedOpts.createOpts.preset === partials/* Preset */.Sk.PublicChat ? Phase.PublicCreateRooms : Phase.PrivateCreateRooms;
    }
    this.state = {
      phase,
      showRightPanel: RightPanelStore/* default */.Z.getSharedInstance().isOpenForRoom,
      myMembership: this.props.space.getMyMembership(),
      hideThisPanel: false
    };
    this.dispatcherRef = dispatcher/* default */.ZP.register(this.onAction);
    this.rightPanelStoreToken = RightPanelStore/* default */.Z.getSharedInstance().addListener(this.onRightPanelStoreUpdate);
    this.context.on("Room.myMembership", this.onMyMembership);
    PermissionStore/* default */.ZP.instance.getPermissionByRoom(this.props.space.roomId);
    //   fetch squad config
    this.props.space.roomId && (0,SquadConfigStateStore/* RefreshSquadConfigData */.f)(this.props.space.roomId);
  }
  componentWillUnmount() {
    dispatcher/* default */.ZP.unregister(this.dispatcherRef);
    this.rightPanelStoreToken.remove();
    this.context.off("Room.myMembership", this.onMyMembership);
    // ClearSquadConfigData();
  }

  renderBody() {
    var _this$props$justCreat, _this$props$justCreat2;
    switch (this.state.phase) {
      case Phase.Landing:
        if (this.state.myMembership === "join" && SpaceStore/* default */.ZP.spacesEnabled || this.props.space.isJoining) {
          return /*#__PURE__*/react.createElement(space_home_SpaceLanding, {
            space: this.props.space,
            resizeNotifier: this.props.resizeNotifier
          });
        } else {
          return /*#__PURE__*/react.createElement(SpacePreview, {
            space: this.props.space,
            onJoinButtonClicked: this.props.onJoinButtonClicked,
            onRejectButtonClicked: this.props.onRejectButtonClicked,
            onRejectAndIgnoreClick: this.props.onRejectAndIgnoreClick
          });
        }
      case Phase.PublicCreateRooms:
        return /*#__PURE__*/react.createElement(SpaceSetupFirstRooms, {
          space: this.props.space,
          title: (0,languageHandler._t)("What are some things you want to discuss in %(spaceName)s?", {
            spaceName: ((_this$props$justCreat = this.props.justCreatedOpts) === null || _this$props$justCreat === void 0 ? void 0 : (_this$props$justCreat2 = _this$props$justCreat.createOpts) === null || _this$props$justCreat2 === void 0 ? void 0 : _this$props$justCreat2.name) || this.props.space.name
          }),
          description: (0,languageHandler._t)("Let's create some rooms for Squad members to chat and interact once they join."),
          onFinished: firstRoomId => this.setState({
            phase: Phase.Landing,
            firstRoomId
          }),
          isPrivate: false
        });
      case Phase.PublicShare:
        return /*#__PURE__*/react.createElement(SpaceSetupPublicShare, {
          justCreatedOpts: this.props.justCreatedOpts,
          space: this.props.space,
          onFinished: this.goToFirstRoom,
          firstRoomId: this.state.firstRoomId
        });
      case Phase.PrivateScope:
        return /*#__PURE__*/react.createElement(SpaceSetupPrivateScope, {
          space: this.props.space,
          justCreatedOpts: this.props.justCreatedOpts,
          onFinished: invite => {
            this.setState({
              phase: invite ? Phase.PrivateInvite : Phase.PrivateExistingRooms
            });
          }
        });
      case Phase.PrivateInvite:
        return /*#__PURE__*/react.createElement(SpaceSetupPrivateInvite, {
          space: this.props.space,
          onFinished: () => this.setState({
            phase: Phase.PrivateCreateRooms
          })
        });
      case Phase.PrivateCreateRooms:
        return /*#__PURE__*/react.createElement(SpaceSetupFirstRooms, {
          space: this.props.space,
          title: (0,languageHandler._t)("What projects are you working on?"),
          description: (0,languageHandler._t)("We'll create rooms for each of them. " + "You can add more later too, including already existing ones."),
          onFinished: firstRoomId => this.setState({
            phase: Phase.Landing,
            firstRoomId
          }),
          isPrivate: true
        });
      case Phase.PrivateExistingRooms:
        return /*#__PURE__*/react.createElement(SpaceAddExistingRooms, {
          space: this.props.space,
          onFinished: () => this.setState({
            phase: Phase.Landing
          })
        });
      case Phase.CreateExternalGroup:
        return /*#__PURE__*/react.createElement(external_group_CreateExternalGroup, {
          squadId: this.props.space.roomId
        });
    }
  }
  render() {
    const isCorrectPhase = this.state.phase === Phase.Landing || this.state.phase === Phase.CreateExternalGroup;
    const rightPanel = this.state.showRightPanel && isCorrectPhase ? /*#__PURE__*/react.createElement(RightPanel/* default */.Z, {
      room: this.props.space,
      resizeNotifier: this.props.resizeNotifier
    }) : null;
    return /*#__PURE__*/react.createElement("main", {
      className: classnames_default()(["mx_SpaceRoomView", {
        mx_SpaceRoomView_mini: UIStore/* default */.Z.instance.windowWidth <= 640 && !this.state.hideThisPanel
      }])
    }, /*#__PURE__*/react.createElement(ErrorBoundary/* default */.Z, null, /*#__PURE__*/react.createElement(MainSplit/* default */.Z, {
      panel: rightPanel,
      resizeNotifier: this.props.resizeNotifier
    }, this.renderBody())));
  }
}
(0,defineProperty/* default */.Z)(SpaceRoomView, "contextType", MatrixClientContext/* default */.Z);

/***/ }),

/***/ 274184:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(667294);
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(294184);
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _settings_SettingsStore__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(571879);



const StereoButton = props => {
  const [busy, setBusy] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);
  const theme = _settings_SettingsStore__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .C.getValue("theme") === "light" ? "light" : "dark";
  const {
    shadowColor = theme === "light" ? "#000000" : "#fcb097",
    backgroundColor = "#FC774B"
  } = props;
  const style = {
    "--backgroundColor": backgroundColor,
    "--shadowColor": shadowColor
  };
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("button", {
    style: style,
    className: classnames__WEBPACK_IMPORTED_MODULE_1___default()("mx_StereoButton", props.className),
    onClick: e => {
      if (busy) return;
      setBusy(true);
      setTimeout(() => {
        props.onClick(e);
        setBusy(false);
      }, 500);
    }
  }, props.children);
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StereoButton);

/***/ }),

/***/ 672214:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Z: () => (/* binding */ structures_TimelinePanel)
});

// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/node_modules/@babel/runtime/helpers/esm/defineProperty.js
var defineProperty = __webpack_require__(225259);
// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(667294);
// EXTERNAL MODULE: ./node_modules/react-dom/index.js
var react_dom = __webpack_require__(973935);
// EXTERNAL MODULE: ./node_modules/matrix-js-sdk/src/models/room.ts + 1 modules
var room = __webpack_require__(335435);
// EXTERNAL MODULE: ./node_modules/matrix-js-sdk/src/models/event-timeline.ts
var event_timeline = __webpack_require__(185354);
// EXTERNAL MODULE: ./node_modules/matrix-js-sdk/src/timeline-window.ts
var timeline_window = __webpack_require__(166344);
// EXTERNAL MODULE: ./node_modules/matrix-js-sdk/src/@types/event.ts
var _types_event = __webpack_require__(907977);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/settings/SettingsStore.ts + 9 modules
var SettingsStore = __webpack_require__(571879);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/languageHandler.tsx
var languageHandler = __webpack_require__(867614);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/MatrixClientPeg.ts + 3 modules
var MatrixClientPeg = __webpack_require__(933393);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/contexts/RoomContext.ts
var contexts_RoomContext = __webpack_require__(880133);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/UserActivity.ts
var UserActivity = __webpack_require__(181924);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/Modal.tsx + 1 modules
var Modal = __webpack_require__(241648);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/dispatcher/dispatcher.ts
var dispatcher = __webpack_require__(245539);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/Keyboard.ts
var Keyboard = __webpack_require__(389310);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/utils/Timer.ts
var Timer = __webpack_require__(317494);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/shouldHideEvent.ts
var shouldHideEvent = __webpack_require__(870639);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/rooms/EventTile.tsx + 7 modules
var EventTile = __webpack_require__(585340);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/settings/UIFeature.ts
var UIFeature = __webpack_require__(187565);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/utils/replaceableComponent.ts
var replaceableComponent = __webpack_require__(90287);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/utils/arrays.ts
var arrays = __webpack_require__(902232);
// EXTERNAL MODULE: ./node_modules/matrix-js-sdk/src/browser-index.js
var browser_index = __webpack_require__(407637);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/DateUtils.ts
var DateUtils = __webpack_require__(466556);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/dispatcher/actions.ts
var actions = __webpack_require__(473627);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/settings/Layout.ts
var Layout = __webpack_require__(244088);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/elements/ErrorBoundary.tsx
var ErrorBoundary = __webpack_require__(618675);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/elements/Draggable.tsx

var _dec, _class;
/*
Copyright 2020 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/



let Draggable = (_dec = (0,replaceableComponent/* replaceableComponent */.U)("views.elements.Draggable"), _dec(_class = class Draggable extends react.Component {
  constructor(props) {
    super(props);
    (0,defineProperty/* default */.Z)(this, "onMouseDown", event => {
      this.setState({
        location: {
          currentX: event.clientX,
          currentY: event.clientY
        }
      });
      document.addEventListener("mousemove", this.state.onMouseMove);
      document.addEventListener("mouseup", this.state.onMouseUp);
    });
    (0,defineProperty/* default */.Z)(this, "onMouseUp", event => {
      document.removeEventListener("mousemove", this.state.onMouseMove);
      document.removeEventListener("mouseup", this.state.onMouseUp);
      this.props.onMouseUp(event);
    });
    this.state = {
      onMouseMove: this.onMouseMove.bind(this),
      onMouseUp: this.onMouseUp.bind(this),
      location: {
        currentX: 0,
        currentY: 0
      }
    };
  }
  onMouseMove(event) {
    const newLocation = this.props.dragFunc(this.state.location, event);
    this.setState({
      location: newLocation
    });
  }
  render() {
    return /*#__PURE__*/react.createElement("div", {
      className: this.props.className,
      onMouseDown: this.onMouseDown.bind(this)
    });
  }
}) || _class);

// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/settings/SettingLevel.ts
var SettingLevel = __webpack_require__(202385);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/elements/IRCTimelineProfileResizer.tsx

var IRCTimelineProfileResizer_dec, IRCTimelineProfileResizer_class;
/*
Copyright 2020 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/






let IRCTimelineProfileResizer = (IRCTimelineProfileResizer_dec = (0,replaceableComponent/* replaceableComponent */.U)("views.elements.IRCTimelineProfileResizer"), IRCTimelineProfileResizer_dec(IRCTimelineProfileResizer_class = class IRCTimelineProfileResizer extends react.Component {
  constructor(props) {
    super(props);
    (0,defineProperty/* default */.Z)(this, "dragFunc", (location, event) => {
      const offset = event.clientX - location.currentX;
      const newWidth = this.state.width + offset;

      // If we're trying to go smaller than min width, don't.
      if (newWidth < this.props.minWidth) {
        return location;
      }
      if (newWidth > this.props.maxWidth) {
        return location;
      }
      this.setState({
        width: newWidth
      });
      this.updateCSSWidth.bind(this)(newWidth);
      return {
        currentX: event.clientX,
        currentY: location.currentY
      };
    });
    this.state = {
      width: SettingsStore/* default */.C.getValue("ircDisplayNameWidth", this.props.roomId),
      IRCLayoutRoot: null
    };
  }
  componentDidMount() {
    this.setState({
      IRCLayoutRoot: document.querySelector(".mx_IRCLayout")
    }, () => this.updateCSSWidth(this.state.width));
  }
  updateCSSWidth(newWidth) {
    this.state.IRCLayoutRoot.style.setProperty("--name-width", newWidth + "px");
  }
  onMoueUp(event) {
    if (this.props.roomId) {
      SettingsStore/* default */.C.setValue("ircDisplayNameWidth", this.props.roomId, SettingLevel/* SettingLevel */.R.ROOM_DEVICE, this.state.width);
    }
  }
  render() {
    return /*#__PURE__*/react.createElement(Draggable, {
      className: "mx_ProfileResizer",
      dragFunc: this.dragFunc.bind(this),
      onMouseUp: this.onMoueUp.bind(this)
    });
  }
}) || IRCTimelineProfileResizer_class);

// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/elements/Spinner.tsx
var elements_Spinner = __webpack_require__(641542);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/messages/DateSeparator.tsx
var DateSeparator = __webpack_require__(964586);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/messages/TileErrorBoundary.tsx
var TileErrorBoundary = __webpack_require__(667311);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/rooms/WhoIsTypingTile.tsx + 1 modules
var WhoIsTypingTile = __webpack_require__(129033);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/structures/CallEventGrouper.ts
var CallEventGrouper = __webpack_require__(158205);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/structures/ScrollPanel.tsx
var ScrollPanel = __webpack_require__(822507);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/elements/AccessibleButton.tsx
var elements_AccessibleButton = __webpack_require__(805035);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/dialogs/UserSettingsDialog.tsx + 47 modules
var UserSettingsDialog = __webpack_require__(449878);
// EXTERNAL MODULE: ./node_modules/sendingme-ui/dist/index.js
var dist = __webpack_require__(602271);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/structures/groupers/BaseGrouper.tsx

/* Grouper classes determine when events can be grouped together in a summary.
 * Groupers should have the following methods:
 * - canStartGroup (static): determines if a new group should be started with the
 *   given event
 * - shouldGroup: determines if the given event should be added to an existing group
 * - add: adds an event to an existing group (should only be called if shouldGroup
 *   return true)
 * - getTiles: returns the tiles that represent the group
 * - getNewPrevEvent: returns the event that should be used as the new prevEvent
 *   when determining things such as whether a date separator is necessary
 */

class BaseGrouper {
  constructor(panel, event, prevEvent, lastShownEvent, layout, nextEvent, nextEventTile) {
    this.panel = panel;
    this.event = event;
    this.prevEvent = prevEvent;
    this.lastShownEvent = lastShownEvent;
    this.layout = layout;
    this.nextEvent = nextEvent;
    this.nextEventTile = nextEventTile;
    (0,defineProperty/* default */.Z)(this, "events", []);
    // events that we include in the group but then eject out and place above the group.
    (0,defineProperty/* default */.Z)(this, "ejectedEvents", []);
    (0,defineProperty/* default */.Z)(this, "readMarker", void 0);
    this.readMarker = panel.readMarkerForEvent(event.getId(), event === lastShownEvent);
  }
}
(0,defineProperty/* default */.Z)(BaseGrouper, "canStartGroup", (panel, ev) => true);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/structures/DisplayName.tsx
var DisplayName = __webpack_require__(992916);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/contexts/MatrixClientContext.ts
var contexts_MatrixClientContext = __webpack_require__(311878);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/utils/DMRoomMap.ts
var DMRoomMap = __webpack_require__(332506);
// EXTERNAL MODULE: ./node_modules/classnames/index.js
var classnames = __webpack_require__(294184);
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/hooks/useTimeout.ts
var hooks_useTimeout = __webpack_require__(727605);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/Analytics.tsx
var src_Analytics = __webpack_require__(835389);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/CountlyAnalytics.ts
var src_CountlyAnalytics = __webpack_require__(817826);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/elements/MiniAvatarUploader.tsx
/*
Copyright 2020 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/











const AVATAR_SIZE = 48;
const MiniAvatarUploader = ({
  hasAvatar,
  hasAvatarLabel,
  noAvatarLabel,
  setAvatarUrl,
  children
}) => {
  const cli = useContext(MatrixClientContext);
  const [busy, setBusy] = useState(false);
  const [hover, setHover] = useState(false);
  const [show, setShow] = useState(false);
  useTimeout(() => {
    setShow(true);
  }, 3000); // show after 3 seconds
  useTimeout(() => {
    setShow(false);
  }, 13000); // hide after being shown for 10 seconds

  const uploadRef = useRef();
  const label = hasAvatar || busy ? hasAvatarLabel : noAvatarLabel;
  const {
    room
  } = useContext(RoomContext);
  const canSetAvatar = room === null || room === void 0 ? void 0 : room.currentState.maySendStateEvent(EventType.RoomAvatar, cli.getUserId());
  if (!canSetAvatar) return /*#__PURE__*/React.createElement(React.Fragment, null, children);
  const visible = !!label && (hover || show);
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("input", {
    type: "file",
    ref: uploadRef,
    className: "mx_MiniAvatarUploader_input",
    onChange: async ev => {
      var _ev$target$files;
      if (!((_ev$target$files = ev.target.files) !== null && _ev$target$files !== void 0 && _ev$target$files.length)) return;
      setBusy(true);
      Analytics.trackEvent("mini_avatar", "upload");
      CountlyAnalytics.instance.track("mini_avatar_upload");
      const file = ev.target.files[0];
      const uri = await cli.uploadContent(file);
      await setAvatarUrl(uri);
      setBusy(false);
    },
    accept: "image/*"
  }), /*#__PURE__*/React.createElement(AccessibleButton, {
    className: classNames("mx_MiniAvatarUploader", {
      mx_MiniAvatarUploader_busy: busy,
      mx_MiniAvatarUploader_hasAvatar: hasAvatar
    }),
    disabled: busy,
    onClick: () => {
      uploadRef.current.click();
    },
    onMouseOver: () => setHover(true),
    onMouseLeave: () => setHover(false)
  }, children, /*#__PURE__*/React.createElement("div", {
    className: "mx_MiniAvatarUploader_indicator"
  }, busy ? /*#__PURE__*/React.createElement(Spinner, {
    w: 20,
    h: 20
  }) : /*#__PURE__*/React.createElement("div", {
    className: "mx_MiniAvatarUploader_cameraIcon"
  })), /*#__PURE__*/React.createElement("div", {
    className: classNames("mx_Tooltip", {
      "mx_Tooltip_visible": visible,
      "mx_Tooltip_invisible": !visible
    })
  }, /*#__PURE__*/React.createElement("div", {
    className: "mx_Tooltip_chevron"
  }), label)));
};
/* harmony default export */ const elements_MiniAvatarUploader = ((/* unused pure expression or super */ null && (MiniAvatarUploader)));
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/avatars/RoomAvatar.tsx
var RoomAvatar = __webpack_require__(139319);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/SpaceStore.tsx + 2 modules
var SpaceStore = __webpack_require__(387579);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/createRoom.ts
var createRoom = __webpack_require__(147022);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/messages/EventTileBubble.tsx
var EventTileBubble = __webpack_require__(920355);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/node_modules/@babel/runtime/helpers/esm/extends.js
var esm_extends = __webpack_require__(166644);
// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(45697);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/elements/Field.tsx
var Field = __webpack_require__(455537);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/customisations/Media.ts + 1 modules
var Media = __webpack_require__(834208);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/PermissionStore.ts
var PermissionStore = __webpack_require__(825291);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/OwnProfileStore.ts
var OwnProfileStore = __webpack_require__(580089);
// EXTERNAL MODULE: ./node_modules/antd/lib/index.js
var lib = __webpack_require__(769215);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/spaces/SocialMiningManage.tsx
var SocialMiningManage = __webpack_require__(511111);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/settings/ChangeSaveButtons.tsx
var ChangeSaveButtons = __webpack_require__(483663);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/node_modules/@babel/runtime/helpers/esm/objectDestructuringEmpty.js
function _objectDestructuringEmpty(obj) {
  if (obj == null) throw new TypeError("Cannot destructure undefined");
}
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/elements/Slider.tsx
var Slider = __webpack_require__(655380);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/spaces/SlowModeSlider.tsx




const SlowModeSlider = _ref => {
  let props = (0,esm_extends/* default */.Z)({}, (_objectDestructuringEmpty(_ref), _ref));
  const marks = {
    0: "Off",
    5: "5s",
    10: "10s",
    30: "30s",
    60: "1m",
    300: "5m",
    600: "10m",
    1800: "30m",
    3600: "1h"
  };
  const [slowMode, setSlowMode] = (0,react.useState)(() => {
    return props.slowMode;
  });
  const displayFunc = value => {
    return marks[value];
  };
  const handleChange = s => {
    setSlowMode(s);
    props.onChange(s);
  };
  return /*#__PURE__*/react.createElement("div", {
    className: "mx_ProfileSettings_slowmode"
  }, /*#__PURE__*/react.createElement("label", {
    style: {
      fontWeight: 500
    }
  }, "SlowMode"), /*#__PURE__*/react.createElement("span", {
    className: "mx_ProfileSettings_slowmode_tip"
  }, "Roles without permission for this feature are restricted to sending only one message during the specified time period."), /*#__PURE__*/react.createElement("div", {
    className: "mx_ProfileSettings_slowmode_slider"
  }, /*#__PURE__*/react.createElement(Slider/* default */.Z, {
    values: [0, 5, 10, 30, 60, 300, 600, 1800, 3600],
    value: slowMode,
    onSelectionChange: handleChange,
    displayFunc: displayFunc,
    disabled: false
  })));
};
/* harmony default export */ const spaces_SlowModeSlider = (SlowModeSlider);
// EXTERNAL MODULE: ./node_modules/matrix-js-sdk/src/@types/partials.ts
var partials = __webpack_require__(85047);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/settings/tabs/room/HistoryReadField.tsx





function HistoryReadField(props) {
  const {
    roomId,
    history,
    onChange
  } = props;
  const client = MatrixClientPeg/* MatrixClientPeg */.p.get();
  // const state = client.getRoom(roomId).currentState;
  // const canChangeHistory = state.mayClientSendStateEvent(
  //     EventType.RoomHistoryVisibility,
  //     client,
  // );

  // const options = [
  //     {
  //         value: HistoryVisibility.Shared,
  //         label: _t("since the point in time of selecting this option"),
  //     },
  //     {
  //         value: HistoryVisibility.Invited,
  //         label: _t("since they were invited"),
  //     },
  //     {
  //         value: HistoryVisibility.Joined,
  //         label: _t("since they joined"),
  //     },
  // ];

  const _onChange = checked => {
    onChange(checked ? partials/* HistoryVisibility */.GR.Shared : partials/* HistoryVisibility */.GR.Invited);
  };

  // const onHistoryRadioToggle = (history: HistoryVisibility) => {
  //     client
  //         .sendStateEvent(
  //             roomId,
  //             EventType.RoomHistoryVisibility,
  //             {
  //                 history_visibility: history,
  //             },
  //             "",
  //         )
  //         .catch((e) => {
  //             console.error(e);
  //         });
  // };

  // World readable doesn't make sense for encrypted rooms
  // if (!encrypted || history === HistoryVisibility.WorldReadable) {
  //     options.unshift({
  //         value: HistoryVisibility.WorldReadable,
  //         label: _t("Anyone"),
  //     });
  // }

  return /*#__PURE__*/react.createElement("div", {
    style: {
      marginBottom: "24px"
    }
  }, /*#__PURE__*/react.createElement("div", {
    style: {
      display: "flex",
      alignItems: "center",
      justifyContent: "space-between"
    }
  }, /*#__PURE__*/react.createElement("label", {
    style: {
      fontWeight: 500
    }
  }, (0,languageHandler._t)("History Messages Access")), /*#__PURE__*/react.createElement(dist.SdSwitch, {
    onChange: _onChange,
    checked: partials/* HistoryVisibility */.GR.Invited !== history
  })), /*#__PURE__*/react.createElement("span", {
    className: "mx_ProfileSettings_slowmode_tip"
  }, (0,languageHandler._t)("Enable new members to read all history messages upon joining.")));
}
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/settings/SdAvatarUpload.tsx
var SdAvatarUpload = __webpack_require__(206703);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/room_settings/RoomProfileSettings.tsx

var RoomProfileSettings_dec, RoomProfileSettings_class, _class2;
/*
Copyright 2019 New Vector Ltd

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/


















var ProfileSettingsVisible = /*#__PURE__*/function (ProfileSettingsVisible) {
  ProfileSettingsVisible[ProfileSettingsVisible["Name"] = 0] = "Name";
  ProfileSettingsVisible[ProfileSettingsVisible["Avatar"] = 1] = "Avatar";
  ProfileSettingsVisible[ProfileSettingsVisible["Topic"] = 2] = "Topic";
  ProfileSettingsVisible[ProfileSettingsVisible["NickName"] = 3] = "NickName";
  ProfileSettingsVisible[ProfileSettingsVisible["Announcement"] = 4] = "Announcement";
  return ProfileSettingsVisible;
}(ProfileSettingsVisible || {}); // TODO: Merge with ProfileSettings?
let RoomProfileSettings = (RoomProfileSettings_dec = (0,replaceableComponent/* replaceableComponent */.U)("views.room_settings.RoomProfileSettings"), RoomProfileSettings_dec(RoomProfileSettings_class = (_class2 = class RoomProfileSettings extends react.Component {
  constructor(props) {
    var _remarkEvent$getConte, _remarkEvent$getConte2, _announcementEvent$ge, _room$currentState$ge;
    super(props);
    (0,defineProperty/* default */.Z)(this, "cancelProfileChanges", async e => {
      e.stopPropagation();
      e.preventDefault();
      if (!this.state.enableProfileSave) return;
      this.setState({
        enableProfileSave: false,
        displayName: this.state.originalDisplayName,
        topic: this.state.originalTopic,
        avatarUrl: this.state.originalAvatarUrl,
        avatarFile: null,
        announcement: this.state.originalAnnouncement,
        announcementFileList: this.state.originalAnnouncementFileList
        // nickName: this.state.originalNickName,
      }, () => {
        // Asynchronously refresh rich text information
        this.setState({
          announcementRefreshCount: Math.floor(Math.random() * 10000)
        });
      });
    });
    (0,defineProperty/* default */.Z)(this, "preSaveProfile", async e => {
      e.stopPropagation();
      e.preventDefault();
      if (!this.state.enableProfileSave) return;

      // If the announcement is changed
      // It is necessary to confirm whether to save it twice.
      if (this.state.originalAnnouncement !== this.state.announcement || JSON.stringify(this.state.originalAnnouncementFileList) !== JSON.stringify(this.state.announcementFileList)) {
        lib.Modal.confirm({
          className: "mx_modal_confirm_base",
          zIndex: 5000,
          content: /*#__PURE__*/react.createElement("div", {
            className: "confirm_base_content_wrapper"
          }, /*#__PURE__*/react.createElement("div", {
            className: "confirm_base_content_wrapper_title"
          }, (0,languageHandler._t)("Saving and publishing Now？")), /*#__PURE__*/react.createElement("div", {
            className: "confirm_base_content_wrapper_description"
          }, (0,languageHandler._t)("Notice Updated! Sharing to the community?"))),
          onOk: () => this.saveProfile(e)
        });
      } else {
        this.saveProfile(e);
      }
    });
    (0,defineProperty/* default */.Z)(this, "saveProfile", async e => {
      e.stopPropagation();
      e.preventDefault();
      if (!this.state.enableProfileSave) return;
      this.setState({
        enableProfileSave: false
      });
      const client = MatrixClientPeg/* MatrixClientPeg */.p.get();
      let originalDisplayName = this.state.originalDisplayName;
      let avatarUrl = this.state.avatarUrl;
      let originalAvatarUrl = this.state.originalAvatarUrl;
      let originalTopic = this.state.originalTopic;
      let originalRemark = this.state.originalRemark;
      let avatarFile = this.state.avatarFile;
      let originalNickName = this.state.originalNickName;
      let originalAnnouncement = this.state.originalAnnouncement;
      let originalAnnouncementFileList = this.state.announcementFileList;
      let {
        originalSlowMode,
        slowMode
      } = this.state;
      let {
        historyVisibility,
        originalHistoryVisibility
      } = this.state;

      // TODO: What do we do about errors?
      const displayName = this.state.displayName.trim();
      try {
        if (this.state.originalDisplayName !== this.state.displayName) {
          await client.setRoomName(this.props.roomId, displayName);
          originalDisplayName = displayName;
        }
        if (this.state.originalAvatarUrl !== avatarUrl) {
          await client.sendStateEvent(this.props.roomId, "m.room.avatar", {
            url: avatarUrl
          }, "");
          originalAvatarUrl = avatarUrl;
        }
        if (originalSlowMode !== slowMode) {
          await client.sendStateEvent(this.props.roomId, "m.room.slow_mode", {
            cooling_seconds: this.state.slowMode
          }, "");
          originalSlowMode = slowMode;
        }
        if (this.state.originalTopic !== this.state.topic) {
          await client.setRoomTopic(this.props.roomId, this.state.topic);
          originalTopic = this.state.topic;
        }
        if (this.state.originalAnnouncement !== this.state.announcement || JSON.stringify(this.state.originalAnnouncementFileList) !== JSON.stringify(this.state.announcementFileList)) {
          await client.setRoomAnnouncement(this.props.roomId, {
            content: this.state.announcement,
            file_list: this.state.announcementFileList
          });
          originalAnnouncement = this.state.announcement;
          originalAnnouncementFileList = this.state.announcementFileList && JSON.parse(JSON.stringify(this.state.announcementFileList));
        }
        if (originalNickName !== this.state.nickName) {
          await this.setNickName(this.state.nickName);
          originalNickName = this.state.nickName;
        }
        if (this.state.originalRemark !== this.state.remark) {
          var _client$getAccountDat, _client$getAccountDat2;
          const currentRemarkNameMap = ((_client$getAccountDat = client.getAccountData(_types_event/* EventType */.tw.RemarkedRoomList)) === null || _client$getAccountDat === void 0 ? void 0 : (_client$getAccountDat2 = _client$getAccountDat.getContent()) === null || _client$getAccountDat2 === void 0 ? void 0 : _client$getAccountDat2.remarked_room) || {};
          currentRemarkNameMap[this.props.roomId] = {
            remark: this.state.remark
          };
          await client.setAccountData(_types_event/* EventType */.tw.RemarkedRoomList, {
            remarked_room: currentRemarkNameMap
          });
        }
        if (this.state.originalHistoryVisibility !== this.state.historyVisibility) {
          originalHistoryVisibility = historyVisibility;
          await client.sendStateEvent(this.props.roomId, _types_event/* EventType */.tw.RoomHistoryVisibility, {
            history_visibility: this.state.historyVisibility
          }, "");
        }
      } catch (error) {
        dist.SdMessage.error((0,languageHandler._t)("Save failed"));
        console.error(error);
      }
      dist.SdMessage.success({
        content: (0,languageHandler._t)("Saved successfully"),
        icon: /*#__PURE__*/react.createElement(react.Fragment, null),
        className: "mx_Message"
      });
      this.setState({
        originalAvatarUrl,
        avatarUrl,
        originalDisplayName,
        originalTopic,
        originalRemark,
        originalNickName,
        originalAnnouncement,
        originalAnnouncementFileList,
        displayName,
        avatarFile,
        originalSlowMode,
        slowMode,
        originalHistoryVisibility,
        historyVisibility
      });
    });
    (0,defineProperty/* default */.Z)(this, "onDisplayNameChanged", e => {
      this.setState({
        displayName: e.target.value
      });
      if (this.state.originalDisplayName === e.target.value) {
        this.setState({
          enableProfileSave: false
        });
      } else {
        this.setState({
          enableProfileSave: true
        });
      }
    });
    (0,defineProperty/* default */.Z)(this, "onRemarkChanged", e => {
      this.setState({
        remark: e.target.value
      });
      if (this.state.originalRemark === e.target.value) {
        this.setState({
          enableProfileSave: false
        });
      } else {
        this.setState({
          enableProfileSave: true
        });
      }
    });
    (0,defineProperty/* default */.Z)(this, "onTopicChanged", e => {
      this.setState({
        topic: e.target.value
      });
      if (this.state.originalTopic === e.target.value) {
        this.setState({
          enableProfileSave: false
        });
      } else {
        this.setState({
          enableProfileSave: true
        });
      }
    });
    (0,defineProperty/* default */.Z)(this, "onAnnouncementChanged", value => {
      this.setState({
        announcement: value
      });
      if (this.state.originalAnnouncement === value) {
        this.setState({
          enableProfileSave: false
        });
      } else {
        this.setState({
          enableProfileSave: true
        });
      }
    });
    (0,defineProperty/* default */.Z)(this, "onAnnouncementFileListChanged", flieList => {
      this.setState({
        announcementFileList: flieList
      });
      if (this.state.originalAnnouncementFileList === flieList) {
        this.setState({
          enableProfileSave: false
        });
      } else {
        this.setState({
          enableProfileSave: true
        });
      }
    });
    (0,defineProperty/* default */.Z)(this, "onSlowModeChanged", slowMode => {
      this.setState({
        slowMode: slowMode
      });
      if (this.state.originalSlowMode === slowMode) {
        this.setState({
          enableProfileSave: false
        });
      } else {
        this.setState({
          enableProfileSave: true
        });
      }
    });
    (0,defineProperty/* default */.Z)(this, "onNickNameChanged", e => {
      this.setState({
        nickName: e.target.value
      });
      if (this.state.originalNickName === e.target.value) {
        this.setState({
          enableProfileSave: false
        });
      } else {
        this.setState({
          enableProfileSave: true
        });
      }
    });
    (0,defineProperty/* default */.Z)(this, "onHistoryReadableChange", history => {
      this.setState({
        historyVisibility: history
      });
      if (this.state.originalHistoryVisibility !== history) {
        this.setState({
          enableProfileSave: true
        });
      } else {
        this.setState({
          enableProfileSave: false
        });
      }
    });
    (0,defineProperty/* default */.Z)(this, "onAvatarChanged", avatar => {
      if (this.state.originalAvatarUrl === avatar) {
        this.setState({
          enableProfileSave: false
        });
      } else {
        this.setState({
          avatarUrl: avatar,
          enableProfileSave: true
        });
      }
    });
    const _client = MatrixClientPeg/* MatrixClientPeg */.p.get();
    const room = _client.getRoom(props.roomId);
    if (!room) throw new Error(`Expected a room for ID: ${props.roomId}`);
    let _avatarUrl = "";
    if (props.avatarVisible) {
      const avatarEvent = room.currentState.getStateEvents("m.room.avatar", "");
      _avatarUrl = avatarEvent && avatarEvent.getContent() ? avatarEvent.getContent()["url"] : null;
      if (_avatarUrl) {
        _avatarUrl = (0,Media/* mediaFromMxc */.TS)(_avatarUrl).getSquareThumbnailHttp(96);
      }
    }
    const topicEvent = room.currentState.getStateEvents("m.room.topic", "");
    const topic = topicEvent && topicEvent.getContent() ? topicEvent.getContent()["topic"] || "" : "";
    const nameEvent = room.currentState.getStateEvents("m.room.name", "");
    const name = nameEvent && nameEvent.getContent() ? nameEvent.getContent()["name"] || "" : "";
    const remarkEvent = _client.getAccountData(_types_event/* EventType */.tw.RemarkedRoomList);
    const remark = remarkEvent && remarkEvent.getContent() ? ((_remarkEvent$getConte = remarkEvent.getContent()) === null || _remarkEvent$getConte === void 0 ? void 0 : (_remarkEvent$getConte2 = _remarkEvent$getConte.remarked_room[this.props.roomId]) === null || _remarkEvent$getConte2 === void 0 ? void 0 : _remarkEvent$getConte2.remark) || "" : "";
    const nickName = this.getNickName();
    const announcementEvent = room.currentState.getStateEvents(_types_event/* EventType */.tw.RoomAnnouncement, "");
    const announcementInfo = announcementEvent && announcementEvent.getContent() ? (_announcementEvent$ge = announcementEvent.getContent()) === null || _announcementEvent$ge === void 0 ? void 0 : _announcementEvent$ge.announcement : "";
    const announcementInfoClone = announcementInfo && JSON.parse(JSON.stringify(announcementInfo));
    const announcement = announcementInfoClone === null || announcementInfoClone === void 0 ? void 0 : announcementInfoClone.content;
    const announcementFileList = announcementInfoClone === null || announcementInfoClone === void 0 ? void 0 : announcementInfoClone.file_list;
    const announcementFileListClone = (announcementInfoClone === null || announcementInfoClone === void 0 ? void 0 : announcementInfoClone.file_list) && JSON.parse(JSON.stringify(announcementInfo === null || announcementInfo === void 0 ? void 0 : announcementInfo.file_list));
    const slowModeEvent = room.currentState.getStateEvents("m.room.slow_mode", "");
    const _historyVisibility = ((_room$currentState$ge = room.currentState.getStateEvents(_types_event/* EventType */.tw.RoomHistoryVisibility, "")) === null || _room$currentState$ge === void 0 ? void 0 : _room$currentState$ge.getContent().history_visibility) || "joined";
    const _slowMode = slowModeEvent && slowModeEvent.getContent() ? slowModeEvent.getContent()["cooling_seconds"] || 0 : 0;
    const role = room.getMember(_client.getUserId()).getRoomMemberRole(room);
    const slowModePermission = role ? (role === null || role === void 0 ? void 0 : role.id) === "owner" || (role === null || role === void 0 ? void 0 : role.id) === "SA" || (role === null || role === void 0 ? void 0 : role.id) == "Admin" ? true : false : false;
    this.state = {
      originalDisplayName: name,
      displayName: name,
      originalRemark: remark,
      remark,
      originalAvatarUrl: _avatarUrl,
      avatarUrl: _avatarUrl,
      avatarFile: null,
      originalTopic: topic,
      topic: topic,
      originalNickName: nickName,
      nickName,
      announcement,
      originalAnnouncement: announcement,
      announcementFileList,
      originalAnnouncementFileList: announcementFileListClone,
      enableProfileSave: false,
      canSetName: false,
      canSetTopic: false,
      canSetAvatar: false,
      canSetHistoryAccess: false,
      canSetAnnouncement: false,
      announcementRefreshCount: 0,
      originalSlowMode: _slowMode,
      slowMode: _slowMode,
      slowModePermission: slowModePermission,
      originalHistoryVisibility: _historyVisibility,
      historyVisibility: _historyVisibility
    };
  }
  componentDidMount() {
    const result = PermissionStore/* default */.ZP.hasPermission(this.props.roomId, [PermissionStore/* PermissionMap */.$W.SquadManageRoom, PermissionStore/* PermissionMap */.$W.RoomManageMessage]);
    this.setState({
      canSetName: !!(result !== null && result !== void 0 && result[0]),
      canSetTopic: !!(result !== null && result !== void 0 && result[0]),
      canSetAvatar: !!(result !== null && result !== void 0 && result[0]),
      canSetHistoryAccess: !!(result !== null && result !== void 0 && result[1]),
      canSetAnnouncement: !!(result !== null && result !== void 0 && result[0])
    });
  }
  getNickName() {
    let room = MatrixClientPeg/* MatrixClientPeg */.p.get().getRoom(this.props.roomId);
    const spaceRoom = room.getParentRoom();
    if (spaceRoom) {
      room = spaceRoom;
    }
    return room.getNickName();
  }
  setNickName(nickName) {
    let room = MatrixClientPeg/* MatrixClientPeg */.p.get().getRoom(this.props.roomId);
    const spaceRoom = room.getParentRoom();
    const displayName = OwnProfileStore.OwnProfileStore.instance.displayName;
    if (spaceRoom) {
      room = spaceRoom;
    }
    return room.setNickName(nickName || displayName);
  }
  profileSettingVisible(element, oneof) {
    const visibleMap = {
      [ProfileSettingsVisible.Avatar]: this.props.avatarVisible,
      [ProfileSettingsVisible.Name]: this.props.nameVisible,
      [ProfileSettingsVisible.Topic]: this.props.topicVisible,
      [ProfileSettingsVisible.NickName]: this.props.nickNameVisible,
      [ProfileSettingsVisible.Announcement]: this.props.announcementVisible
    };
    if (oneof.some(v => visibleMap[v])) {
      return element;
    }
    return null;
  }
  render() {
    var _PermissionStore$hasP;
    let profileSettingsButtons;
    const enabledSaveBtn = (this.state.canSetName || this.state.canSetTopic || this.state.canSetAvatar || this.state.canSetAnnouncement || this.props.nickNameVisible) && this.state.enableProfileSave;
    profileSettingsButtons = /*#__PURE__*/react.createElement(ChangeSaveButtons/* default */.Z, {
      className: classnames_default()({
        "mx_ChangeSave_buttons_profile": true,
        "mx_ChangeSave_buttons_room_profile": true,
        "mx_ChangeSave_buttons_profile_show": enabledSaveBtn
      }),
      enable: this.state.enableProfileSave,
      onCancel: this.cancelProfileChanges,
      onSave: this.preSaveProfile
    });
    const room = MatrixClientPeg/* MatrixClientPeg */.p.get().getRoom(this.props.roomId);
    const isAlpha = location.origin.includes("chat-alpha") || location.origin.includes("localhost");
    return this.profileSettingVisible( /*#__PURE__*/react.createElement("form", {
      onSubmit: this.saveProfile,
      className: "mx_RoomProfileSetting_form",
      autoComplete: "off",
      noValidate: true
    }, /*#__PURE__*/react.createElement("div", {
      className: "mx_ProfileSettings_profileForm_room_content"
    }, /*#__PURE__*/react.createElement("div", {
      className: "mx_ProfileSettings_profile"
    }, this.profileSettingVisible( /*#__PURE__*/react.createElement(SdAvatarUpload/* default */.Z, {
      id: this.props.roomId,
      name: this.state.displayName,
      src: this.state.originalAvatarUrl,
      onChange: this.onAvatarChanged
    }), [ProfileSettingsVisible.Avatar]), /*#__PURE__*/react.createElement("div", {
      className: "mx_ProfileSettings_controls"
    }, this.profileSettingVisible( /*#__PURE__*/react.createElement("div", {
      className: "mx_SettingsTab mx_SettingsTab_SettingFormItem"
    }, /*#__PURE__*/react.createElement("label", null, room.hasSpaceParent() ? (0,languageHandler._t)("Channel Name") : (0,languageHandler._t)("Group Name")), /*#__PURE__*/react.createElement(dist.SdInput, {
      placeholder: room.hasSpaceParent() ? (0,languageHandler._t)("Channel Name") : (0,languageHandler._t)("Group Name"),
      type: "text",
      value: this.state.displayName,
      autoComplete: "off",
      onChange: this.onDisplayNameChanged,
      disabled: !this.state.canSetName
    })), [ProfileSettingsVisible.Name]), this.profileSettingVisible( /*#__PURE__*/react.createElement("div", {
      className: "mx_SettingsTab mx_SettingsTab_SettingFormItem"
    }, /*#__PURE__*/react.createElement("label", null, room.hasSpaceParent() ? (0,languageHandler._t)("Channel Topic") : (0,languageHandler._t)("Group Topic")), /*#__PURE__*/react.createElement(dist.SdTextArea, {
      placeholder: room.hasSpaceParent() ? (0,languageHandler._t)("Channel Topic") : (0,languageHandler._t)("Group Topic"),
      disabled: !this.state.canSetTopic,
      value: this.state.topic,
      autoComplete: "off",
      onChange: this.onTopicChanged
    })), [ProfileSettingsVisible.Topic]), this.profileSettingVisible( /*#__PURE__*/react.createElement("div", {
      className: "mx_SettingsTab mx_SettingsTab_SettingFormItem"
    }, /*#__PURE__*/react.createElement("label", null, room.hasSpaceParent() ? (0,languageHandler._t)("My Alias in Squad") : (0,languageHandler._t)("My Alias in Group")), /*#__PURE__*/react.createElement(dist.SdInput, {
      placeholder: (0,languageHandler._t)("Add your Alias"),
      value: this.state.nickName,
      disabled: room.hasSpaceParent() || room.isSpaceRoom() ? !((_PermissionStore$hasP = PermissionStore/* default */.ZP.hasPermission(this.props.roomId, PermissionStore/* PermissionMap */.$W.UserChangeNickname)) !== null && _PermissionStore$hasP !== void 0 && _PermissionStore$hasP[0]) : false,
      onChange: this.onNickNameChanged
    })), [ProfileSettingsVisible.NickName]), this.profileSettingVisible( /*#__PURE__*/react.createElement("div", {
      className: "mx_SettingsTab mx_SettingsTab_SettingFormItem"
    }, /*#__PURE__*/react.createElement("label", null, room.hasSpaceParent() ? (0,languageHandler._t)("Channel Remark") : (0,languageHandler._t)("Group Remark")), /*#__PURE__*/react.createElement(dist.SdInput, {
      placeholder: room.hasSpaceParent() ? (0,languageHandler._t)("Channel Remark") : (0,languageHandler._t)("Group Remark"),
      type: "text",
      value: this.state.remark,
      autoComplete: "off",
      onChange: this.onRemarkChanged
    })), [ProfileSettingsVisible.Name]), this.profileSettingVisible( /*#__PURE__*/react.createElement(Field/* default */.Z, {
      className: "mx_ProfileSettings_controls_announcement",
      id: "profileNotice",
      label: room.hasSpaceParent() ? (0,languageHandler._t)("Channel Notice") : (0,languageHandler._t)("Group Notice"),
      disabled: !this.state.canSetAnnouncement,
      type: "text",
      value: this.state.announcement,
      file_list: this.state.announcementFileList,
      autoComplete: "off"
      // @ts-ignore
      ,
      onChange: this.onAnnouncementChanged,
      onFileListChange: this.onAnnouncementFileListChanged,
      element: "richtext",
      refreshCount: this.state.announcementRefreshCount
    }), [ProfileSettingsVisible.Announcement]), this.state.slowModePermission ? /*#__PURE__*/react.createElement(spaces_SlowModeSlider, {
      slowMode: this.state.slowMode,
      onChange: this.onSlowModeChanged
    }) : null)), (room.isGroup() || room.hasSpaceParent()) && this.state.canSetHistoryAccess && /*#__PURE__*/react.createElement(HistoryReadField, {
      roomId: room.roomId,
      history: this.state.historyVisibility,
      onChange: this.onHistoryReadableChange
    }), (room.isGroup() || room.isSpaceRoom()) && room.isOwner() && isAlpha && /*#__PURE__*/react.createElement(SocialMiningManage/* default */.Z, {
      room: room,
      onManageClick: this.props.openFloating
    })), profileSettingsButtons), [ProfileSettingsVisible.Avatar, ProfileSettingsVisible.Name, ProfileSettingsVisible.Topic, ProfileSettingsVisible.NickName, ProfileSettingsVisible.Announcement]);
  }
}, (0,defineProperty/* default */.Z)(_class2, "defaultProps", {
  avatarVisible: true,
  nameVisible: true,
  topicVisible: true,
  nickNameVisible: true,
  announcementVisible: true
}), _class2)) || RoomProfileSettings_class);

// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/index.js + 1 modules
var src = __webpack_require__(47185);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/SdkConfig.ts
var SdkConfig = __webpack_require__(374312);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/elements/SettingsFlag.tsx
var SettingsFlag = __webpack_require__(772884);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/room_settings/UrlPreviewSettings.tsx

/*
Copyright 2016 OpenMarket Ltd
Copyright 2017 Travis Ralston
Copyright 2018, 2019 New Vector Ltd
Copyright 2019 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/









class UrlPreviewSettings extends react.Component {
  constructor(...args) {
    super(...args);
    (0,defineProperty/* default */.Z)(this, "onClickUserSettings", e => {
      e.preventDefault();
      e.stopPropagation();
      dispatcher/* default */.ZP.fire(actions/* Action */.a.ViewUserSettings);
    });
  }
  render() {
    const roomId = this.props.room.roomId;
    const isEncrypted = MatrixClientPeg/* MatrixClientPeg */.p.get().isRoomEncrypted(roomId);
    let previewsForAccount = null;
    let previewsForRoom = null;
    if (!isEncrypted) {
      // Only show account setting state and room state setting state in non-e2ee rooms where they apply
      const accountEnabled = SettingsStore/* default */.C.getValueAt(SettingLevel/* SettingLevel */.R.ACCOUNT, "urlPreviewsEnabled");
      if (accountEnabled) {
        previewsForAccount = (0,languageHandler._t)("You have <a>enabled</a> URL previews by default.", {}, {
          'a': sub => /*#__PURE__*/react.createElement("a", {
            onClick: this.onClickUserSettings,
            href: ""
          }, sub)
        });
      } else {
        previewsForAccount = (0,languageHandler._t)("You have <a>disabled</a> URL previews by default.", {}, {
          'a': sub => /*#__PURE__*/react.createElement("a", {
            onClick: this.onClickUserSettings,
            href: ""
          }, sub)
        });
      }
      if (SettingsStore/* default */.C.canSetValue("urlPreviewsEnabled", roomId, SettingLevel/* SettingLevel */.R.ROOM)) {
        previewsForRoom = /*#__PURE__*/react.createElement("label", null, /*#__PURE__*/react.createElement(SettingsFlag/* default */.Z, {
          name: "urlPreviewsEnabled",
          level: SettingLevel/* SettingLevel */.R.ROOM,
          roomId: roomId,
          isExplicit: true
        }));
      } else {
        let str = (0,languageHandler/* _td */.I8)("URL previews are enabled by default for participants in this room.");
        if (!SettingsStore/* default */.C.getValueAt(SettingLevel/* SettingLevel */.R.ROOM, "urlPreviewsEnabled", roomId, /*explicit=*/true)) {
          str = (0,languageHandler/* _td */.I8)("URL previews are disabled by default for participants in this room.");
        }
        previewsForRoom = /*#__PURE__*/react.createElement("label", null, (0,languageHandler._t)(str));
      }
    } else {
      previewsForAccount = (0,languageHandler._t)("In encrypted rooms, like this one, URL previews are disabled by default to ensure that your " + "homeserver (where the previews are generated) cannot gather information about links you see in " + "this room.");
    }
    const previewsForRoomAccount =
    /*#__PURE__*/
    // in an e2ee room we use a special key to enforce per-room opt-in
    react.createElement(SettingsFlag/* default */.Z, {
      name: isEncrypted ? 'urlPreviewsEnabled_e2ee' : 'urlPreviewsEnabled',
      level: SettingLevel/* SettingLevel */.R.ROOM_ACCOUNT,
      roomId: roomId
    });
    return /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement("div", {
      className: "mx_SettingsTab_subsectionText"
    }, (0,languageHandler._t)('When someone puts a URL in their message, a URL preview can be shown to give more ' + 'information about that link such as the title, description, and an image from the website.')), /*#__PURE__*/react.createElement("div", {
      className: "mx_SettingsTab_subsectionText"
    }, previewsForAccount), previewsForRoom, /*#__PURE__*/react.createElement("label", null, previewsForRoomAccount));
  }
}
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/settings/tabs/room/GeneralRoomSettingsTab.js

var GeneralRoomSettingsTab_dec, GeneralRoomSettingsTab_class, GeneralRoomSettingsTab_class2;
/*
Copyright 2019 New Vector Ltd

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/













// import AliasSettings from '../../../room_settings/AliasSettings'
// import RelatedGroupSettings from '../../../room_settings/RelatedGroupSettings'

let GeneralRoomSettingsTab = (GeneralRoomSettingsTab_dec = (0,replaceableComponent/* replaceableComponent */.U)("views.settings.tabs.room.GeneralRoomSettingsTab"), GeneralRoomSettingsTab_dec(GeneralRoomSettingsTab_class = (GeneralRoomSettingsTab_class2 = class GeneralRoomSettingsTab extends react.Component {
  constructor() {
    super();
    (0,defineProperty/* default */.Z)(this, "_onLeaveClick", () => {
      dispatcher/* default */.ZP.dispatch({
        action: 'leave_room',
        room_id: this.props.roomId
      });
    });
    this.state = {
      isRoomPublished: false // loaded async
    };
  }

  render() {
    const client = this.context;
    const room = client.getRoom(this.props.roomId);
    const canSetAliases = true; // Previously, we arbitrarily only allowed admins to do this
    const canSetCanonical = room.currentState.mayClientSendStateEvent("m.room.canonical_alias", client);
    const canonicalAliasEv = room.currentState.getStateEvents("m.room.canonical_alias", '');
    const canChangeGroups = room.currentState.mayClientSendStateEvent("m.room.related_groups", client);
    const groupsEvent = room.currentState.getStateEvents("m.room.related_groups", "");
    let urlPreviewSettings = /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("span", {
      className: "mx_SettingsTab_subheading"
    }, (0,languageHandler._t)("URL Previews")), /*#__PURE__*/react.createElement("div", {
      className: "mx_SettingsTab_section"
    }, /*#__PURE__*/react.createElement(UrlPreviewSettings, {
      room: room
    })));
    if (!SettingsStore/* default */.C.getValue(UIFeature/* UIFeature */.H.URLPreviews)) {
      urlPreviewSettings = null;
    }
    const topicVisible = SdkConfig/* default */.Z.get("UNABLE_FUN_PERMISSION");
    return /*#__PURE__*/react.createElement("div", {
      className: "mx_SettingsTab mx_GeneralRoomSettingsTab"
    }, /*#__PURE__*/react.createElement("div", {
      className: "mx_SettingsTab_heading"
    }, (0,languageHandler._t)("Overview")), /*#__PURE__*/react.createElement("div", {
      className: "mx_SettingsTab_section mx_GeneralRoomSettingsTab_profileSection"
    }, /*#__PURE__*/react.createElement(RoomProfileSettings, {
      roomId: this.props.roomId,
      openFloating: this.props.openFloating,
      topicVisible: topicVisible
    })));
  }
}, (0,defineProperty/* default */.Z)(GeneralRoomSettingsTab_class2, "propTypes", {
  roomId: (prop_types_default()).string.isRequired,
  openFloating: (prop_types_default()).func.isRequired
}), (0,defineProperty/* default */.Z)(GeneralRoomSettingsTab_class2, "contextType", contexts_MatrixClientContext/* default */.Z), GeneralRoomSettingsTab_class2)) || GeneralRoomSettingsTab_class);

// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/Notifier.ts
var Notifier = __webpack_require__(753687);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/settings/tabs/room/NotificationSettingsTab.js

var NotificationSettingsTab_dec, NotificationSettingsTab_class, NotificationSettingsTab_class2;
/*
Copyright 2019 New Vector Ltd

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/










let NotificationsSettingsTab = (NotificationSettingsTab_dec = (0,replaceableComponent/* replaceableComponent */.U)("views.settings.tabs.room.NotificationsSettingsTab"), NotificationSettingsTab_dec(NotificationSettingsTab_class = (NotificationSettingsTab_class2 = class NotificationsSettingsTab extends react.Component {
  constructor() {
    super();
    (0,defineProperty/* default */.Z)(this, "_soundUpload", /*#__PURE__*/(0,react.createRef)());
    this.state = {
      currentSound: "default",
      uploadedFile: null
    };
  }

  // TODO: [REACT-WARNING] Replace component with real class, use constructor for refs
  UNSAFE_componentWillMount() {
    // eslint-disable-line camelcase
    const soundData = Notifier["default"].getSoundForRoom(this.props.roomId);
    if (!soundData) {
      return;
    }
    this.setState({
      currentSound: soundData.name || soundData.url
    });
  }
  async _triggerUploader(e) {
    e.stopPropagation();
    e.preventDefault();
    this._soundUpload.current.click();
  }
  async _onSoundUploadChanged(e) {
    if (!e.target.files || !e.target.files.length) {
      this.setState({
        uploadedFile: null
      });
      return;
    }
    const file = e.target.files[0];
    this.setState({
      uploadedFile: file
    });
  }
  async _onClickSaveSound(e) {
    e.stopPropagation();
    e.preventDefault();
    try {
      await this._saveSound();
    } catch (ex) {
      console.error(`Unable to save notification sound for ${this.props.roomId}`);
      console.error(ex);
    }
  }
  async _saveSound() {
    if (!this.state.uploadedFile) {
      return;
    }
    let type = this.state.uploadedFile.type;
    if (type === "video/ogg") {
      // XXX: I've observed browsers allowing users to pick a audio/ogg files,
      // and then calling it a video/ogg. This is a lame hack, but man browsers
      // suck at detecting mimetypes.
      type = "audio/ogg";
    }
    const url = await MatrixClientPeg/* MatrixClientPeg */.p.get().uploadContent(this.state.uploadedFile, {
      type
    });
    await SettingsStore/* default */.C.setValue("notificationSound", this.props.roomId, SettingLevel/* SettingLevel */.R.ROOM_ACCOUNT, {
      name: this.state.uploadedFile.name,
      type: type,
      size: this.state.uploadedFile.size,
      url
    });
    this.setState({
      uploadedFile: null,
      currentSound: this.state.uploadedFile.name
    });
  }
  _clearSound(e) {
    e.stopPropagation();
    e.preventDefault();
    SettingsStore/* default */.C.setValue("notificationSound", this.props.roomId, SettingLevel/* SettingLevel */.R.ROOM_ACCOUNT, null);
    this.setState({
      currentSound: "default"
    });
  }
  render() {
    let currentUploadedFile = null;
    if (this.state.uploadedFile) {
      currentUploadedFile = /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement("span", null, (0,languageHandler._t)("Uploaded sound"), ": ", /*#__PURE__*/react.createElement("code", null, this.state.uploadedFile.name)));
    }
    return /*#__PURE__*/react.createElement("div", {
      className: "mx_SettingsTab mx_NotificationUserSettingsTab"
    }, /*#__PURE__*/react.createElement("div", {
      className: "mx_SettingsTab_heading"
    }, (0,languageHandler._t)("Notifications")), /*#__PURE__*/react.createElement("div", {
      className: "mx_SettingsTab_section mx_SettingsTab_subsectionText"
    }, /*#__PURE__*/react.createElement("span", {
      className: "mx_SettingsTab_subheading"
    }, (0,languageHandler._t)("Sounds")), /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement("span", null, (0,languageHandler._t)("Notification sound"), ": ", /*#__PURE__*/react.createElement("code", null, this.state.currentSound)), /*#__PURE__*/react.createElement("br", null), /*#__PURE__*/react.createElement(elements_AccessibleButton/* default */.Z, {
      className: "mx_NotificationSound_resetSound",
      disabled: this.state.currentSound == "default",
      onClick: this._clearSound.bind(this),
      kind: "primary"
    }, (0,languageHandler._t)("Reset"))), /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement("h3", null, (0,languageHandler._t)("Set a new custom sound")), /*#__PURE__*/react.createElement("form", {
      autoComplete: "off",
      noValidate: true
    }, /*#__PURE__*/react.createElement("input", {
      ref: this._soundUpload,
      className: "mx_NotificationSound_soundUpload",
      type: "file",
      onChange: this._onSoundUploadChanged.bind(this),
      accept: "audio/*"
    })), currentUploadedFile, /*#__PURE__*/react.createElement(elements_AccessibleButton/* default */.Z, {
      className: "mx_NotificationSound_browse",
      onClick: this._triggerUploader.bind(this),
      kind: "primary"
    }, (0,languageHandler._t)("Browse")), /*#__PURE__*/react.createElement(elements_AccessibleButton/* default */.Z, {
      className: "mx_NotificationSound_save",
      disabled: this.state.uploadedFile == null,
      onClick: this._onClickSaveSound.bind(this),
      kind: "primary"
    }, (0,languageHandler._t)("Save")), /*#__PURE__*/react.createElement("br", null))));
  }
}, (0,defineProperty/* default */.Z)(NotificationSettingsTab_class2, "propTypes", {
  roomId: (prop_types_default()).string.isRequired
}), NotificationSettingsTab_class2)) || NotificationSettingsTab_class);

// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/elements/Pill.js
var Pill = __webpack_require__(869397);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/utils/permalinks/Permalinks.ts
var Permalinks = __webpack_require__(954105);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/avatars/BaseAvatar.tsx
var BaseAvatar = __webpack_require__(56607);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/HtmlUtils.tsx
var HtmlUtils = __webpack_require__(714813);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/settings/BridgeTile.tsx

var BridgeTile_dec, BridgeTile_class, BridgeTile_class2;
/*
Copyright 2020 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/












/**
 * This should match https://github.com/matrix-org/matrix-doc/blob/hs/msc-bridge-inf/proposals/2346-bridge-info-state-event.md#mbridge
 */
let BridgeTile = (BridgeTile_dec = (0,replaceableComponent/* replaceableComponent */.U)("views.settings.BridgeTile"), BridgeTile_dec(BridgeTile_class = (BridgeTile_class2 = class BridgeTile extends react.PureComponent {
  render() {
    var _content$channel, _content$protocol;
    const content = this.props.ev.getContent();
    // Validate
    if (!((_content$channel = content.channel) !== null && _content$channel !== void 0 && _content$channel.id) || !((_content$protocol = content.protocol) !== null && _content$protocol !== void 0 && _content$protocol.id)) {
      console.warn(`Bridge info event ${this.props.ev.getId()} has missing content. Tile will not render`);
      return null;
    }
    if (!content.bridgebot) {
      // Bridgebot was not required previously, so in order to not break rooms we are allowing
      // the sender to be used in place. When the proposal is merged, this should be removed.
      console.warn(`Bridge info event ${this.props.ev.getId()} does not provide a 'bridgebot' key which` + "is deprecated behaviour. Using sender for now.");
      content.bridgebot = this.props.ev.getSender();
    }
    const {
      channel,
      network,
      protocol
    } = content;
    const protocolName = protocol.displayname || protocol.id;
    const channelName = channel.displayname || channel.id;
    let creator = null;
    if (content.creator) {
      creator = /*#__PURE__*/react.createElement("li", null, (0,languageHandler._t)("This bridge was provisioned by <user />.", {}, {
        user: () => /*#__PURE__*/react.createElement(Pill/* default */.Z, {
          type: Pill/* default */.Z.TYPE_USER_MENTION,
          room: this.props.room,
          url: (0,Permalinks/* makeUserPermalink */.KU)(content.creator),
          shouldShowPillAvatar: SettingsStore/* default */.C.getValue("Pill.shouldShowPillAvatar")
        })
      }));
    }
    const bot = /*#__PURE__*/react.createElement("li", null, (0,languageHandler._t)("This bridge is managed by <user />.", {}, {
      user: () => /*#__PURE__*/react.createElement(Pill/* default */.Z, {
        type: Pill/* default */.Z.TYPE_USER_MENTION,
        room: this.props.room,
        url: (0,Permalinks/* makeUserPermalink */.KU)(content.bridgebot),
        shouldShowPillAvatar: SettingsStore/* default */.C.getValue("Pill.shouldShowPillAvatar")
      })
    }));
    let networkIcon;
    if (protocol.avatar_url) {
      const avatarUrl = (0,Media/* mediaFromMxc */.TS)(protocol.avatar_url).getSquareThumbnailHttp(64);
      networkIcon = /*#__PURE__*/react.createElement(BaseAvatar/* default */.Z, {
        className: "protocol-icon",
        width: 48,
        height: 48,
        resizeMethod: "crop",
        name: protocolName,
        idName: protocolName,
        url: avatarUrl,
        defaultToImageAvatar: false
      });
    } else {
      networkIcon = /*#__PURE__*/react.createElement("div", {
        className: "noProtocolIcon"
      });
    }
    let networkItem = null;
    if (network) {
      const networkName = network.displayname || network.id;
      let networkLink = /*#__PURE__*/react.createElement("span", null, networkName);
      if (typeof network.external_url === "string" && (0,HtmlUtils/* isUrlPermitted */.WI)(network.external_url)) {
        networkLink = /*#__PURE__*/react.createElement("a", {
          href: network.external_url,
          target: "_blank",
          rel: "noreferrer noopener"
        }, networkName);
      }
      networkItem = (0,languageHandler._t)("Workspace: <networkLink/>", {}, {
        networkLink: () => networkLink
      });
    }
    let channelLink = /*#__PURE__*/react.createElement("span", null, channelName);
    if (typeof channel.external_url === "string" && (0,HtmlUtils/* isUrlPermitted */.WI)(channel.external_url)) {
      channelLink = /*#__PURE__*/react.createElement("a", {
        href: channel.external_url,
        target: "_blank",
        rel: "noreferrer noopener"
      }, channelName);
    }
    const id = this.props.ev.getId();
    return /*#__PURE__*/react.createElement("li", {
      key: id
    }, /*#__PURE__*/react.createElement("div", {
      className: "column-icon"
    }, networkIcon), /*#__PURE__*/react.createElement("div", {
      className: "column-data"
    }, /*#__PURE__*/react.createElement("h3", null, protocolName), /*#__PURE__*/react.createElement("p", {
      className: "workspace-channel-details"
    }, networkItem, /*#__PURE__*/react.createElement("span", {
      className: "channel"
    }, (0,languageHandler._t)("Channel: <channelLink/>", {}, {
      channelLink: () => channelLink
    }))), /*#__PURE__*/react.createElement("ul", {
      className: "metadata"
    }, creator, " ", bot)));
  }
}, (0,defineProperty/* default */.Z)(BridgeTile_class2, "propTypes", {
  ev: (prop_types_default()).object.isRequired,
  room: (prop_types_default()).object.isRequired
}), BridgeTile_class2)) || BridgeTile_class);

;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/settings/tabs/room/BridgeSettingsTab.tsx
var BridgeSettingsTab_dec, BridgeSettingsTab_class;
/*
Copyright 2019, 2020 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/






const BRIDGE_EVENT_TYPES = ["uk.half-shot.bridge"
// m.bridge
];

const BRIDGES_LINK = "https://matrix.org/bridges/";
let BridgeSettingsTab = (BridgeSettingsTab_dec = (0,replaceableComponent/* replaceableComponent */.U)("views.settings.tabs.room.BridgeSettingsTab"), BridgeSettingsTab_dec(BridgeSettingsTab_class = class BridgeSettingsTab extends react.Component {
  renderBridgeCard(event, room) {
    const content = event.getContent();
    if (!content || !content.channel || !content.protocol) {
      return null;
    }
    return /*#__PURE__*/react.createElement(BridgeTile, {
      key: event.getId(),
      room: room,
      ev: event
    });
  }
  static getBridgeStateEvents(roomId) {
    const client = MatrixClientPeg/* MatrixClientPeg */.p.get();
    const roomState = client.getRoom(roomId).currentState;
    return BRIDGE_EVENT_TYPES.map(typeName => roomState.getStateEvents(typeName)).flat(1);
  }
  render() {
    // This settings tab will only be invoked if the following function returns more
    // than 0 events, so no validation is needed at this stage.
    const bridgeEvents = BridgeSettingsTab.getBridgeStateEvents(this.props.roomId);
    const client = MatrixClientPeg/* MatrixClientPeg */.p.get();
    const room = client.getRoom(this.props.roomId);
    let content;
    if (bridgeEvents.length > 0) {
      content = /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement("p", null, (0,languageHandler._t)("This room is bridging messages to the following platforms. " + "<a>Learn more.</a>", {}, {
        // TODO: We don't have this link yet: this will prevent the translators
        // having to re-translate the string when we do.
        a: sub => /*#__PURE__*/react.createElement("a", {
          href: BRIDGES_LINK,
          target: "_blank",
          rel: "noreferrer noopener"
        }, sub)
      })), /*#__PURE__*/react.createElement("ul", {
        className: "mx_RoomSettingsDialog_BridgeList"
      }, bridgeEvents.map(event => this.renderBridgeCard(event, room))));
    } else {
      content = /*#__PURE__*/react.createElement("p", null, (0,languageHandler._t)("This room isn’t bridging messages to any platforms. " + "<a>Learn more.</a>", {}, {
        // TODO: We don't have this link yet: this will prevent the translators
        // having to re-translate the string when we do.
        a: sub => /*#__PURE__*/react.createElement("a", {
          href: BRIDGES_LINK,
          target: "_blank",
          rel: "noreferrer noopener"
        }, sub)
      }));
    }
    return /*#__PURE__*/react.createElement("div", {
      className: "mx_SettingsTab"
    }, /*#__PURE__*/react.createElement("div", {
      className: "mx_SettingsTab_heading"
    }, (0,languageHandler._t)("Bridges")), /*#__PURE__*/react.createElement("div", {
      className: "mx_SettingsTab_section mx_SettingsTab_subsectionText"
    }, content));
  }
}) || BridgeSettingsTab_class);

// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/spaces/SpaceSettingsAccessTab.tsx + 6 modules
var SpaceSettingsAccessTab = __webpack_require__(230859);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/elements/RoomName.tsx
var RoomName = __webpack_require__(75865);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/dialogs/ConfirmDeleteRoomDialog.tsx
var ConfirmDeleteRoomDialog = __webpack_require__(254791);
// EXTERNAL MODULE: ./node_modules/@hiseas/react/dist/index.js
var react_dist = __webpack_require__(989638);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/dialogs/RoomUpgradeDialog.tsx
var RoomUpgradeDialog = __webpack_require__(659148);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/dialogs/DevtoolsDialog.tsx
var DevtoolsDialog = __webpack_require__(970974);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/settings/tabs/room/AdvancedRoomSettingsTab.tsx

var AdvancedRoomSettingsTab_dec, AdvancedRoomSettingsTab_class;
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0,defineProperty/* default */.Z)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
/*
Copyright 2019 - 2021 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/










let AdvancedRoomSettingsTab = (AdvancedRoomSettingsTab_dec = (0,replaceableComponent/* replaceableComponent */.U)("views.settings.tabs.room.AdvancedRoomSettingsTab"), AdvancedRoomSettingsTab_dec(AdvancedRoomSettingsTab_class = class AdvancedRoomSettingsTab extends react.Component {
  constructor(props, context) {
    super(props, context);
    (0,defineProperty/* default */.Z)(this, "upgradeRoom", e => {
      const room = MatrixClientPeg/* MatrixClientPeg */.p.get().getRoom(this.props.roomId);
      Modal/* default */.Z.createTrackedDialog('Upgrade Room Version', '', RoomUpgradeDialog/* default */.Z, {
        room
      });
    });
    (0,defineProperty/* default */.Z)(this, "openDevtools", e => {
      Modal/* default */.Z.createDialog(DevtoolsDialog/* default */.Z, {
        roomId: this.props.roomId
      });
    });
    (0,defineProperty/* default */.Z)(this, "onOldRoomClicked", e => {
      e.preventDefault();
      e.stopPropagation();
      dispatcher/* default */.ZP.dispatch({
        action: 'view_room',
        room_id: this.state.oldRoomId,
        event_id: this.state.oldEventId
      });
      this.props.closeSettingsFn();
    });
    this.state = {
      // This is eventually set to the value of room.getRecommendedVersion()
      upgradeRecommendation: null
    };

    // we handle lack of this object gracefully later, so don't worry about it failing here.
    const _room = MatrixClientPeg/* MatrixClientPeg */.p.get().getRoom(this.props.roomId);
    _room.getRecommendedVersion().then(v => {
      const tombstone = _room.currentState.getStateEvents(_types_event/* EventType */.tw.RoomTombstone, "");
      const additionalStateChanges = {};
      const createEvent = _room.currentState.getStateEvents(_types_event/* EventType */.tw.RoomCreate, "");
      const predecessor = createEvent ? createEvent.getContent().predecessor : null;
      if (predecessor && predecessor.room_id) {
        additionalStateChanges.oldRoomId = predecessor.room_id;
        additionalStateChanges.oldEventId = predecessor.event_id;
      }
      this.setState(_objectSpread({
        upgraded: !!(tombstone !== null && tombstone !== void 0 && tombstone.getContent().replacement_room),
        upgradeRecommendation: v
      }, additionalStateChanges));
    });
  }
  render() {
    const client = MatrixClientPeg/* MatrixClientPeg */.p.get();
    const room = client.getRoom(this.props.roomId);
    let unfederatableSection;
    const createEvent = room.currentState.getStateEvents(_types_event/* EventType */.tw.RoomCreate, '');
    if (createEvent && createEvent.getContent()['m.federate'] === false) {
      unfederatableSection = /*#__PURE__*/react.createElement("div", null, (0,languageHandler._t)('This room is not accessible by remote Matrix servers'));
    }

    // let roomUpgradeButton;
    // if (this.state.upgradeRecommendation && this.state.upgradeRecommendation.needsUpgrade && !this.state.upgraded) {
    //     roomUpgradeButton = (
    //         <div>
    //             <p className='mx_SettingsTab_warningText'>
    //                 { _t(
    //                     "<b>Warning</b>: Upgrading a room will <i>not automatically migrate room members " +
    //                     "to the new version of the room.</i> We'll post a link to the new room in the old " +
    //                     "version of the room - room members will have to click this link to join the new room.",
    //                     {}, {
    //                         "b": (sub) => <b>{ sub }</b>,
    //                         "i": (sub) => <i>{ sub }</i>,
    //                     },
    //                 ) }
    //             </p>
    //             <AccessibleButton onClick={this.upgradeRoom} kind='primary'>
    //                 { _t("Upgrade this room to the recommended room version") }
    //             </AccessibleButton>
    //         </div>
    //     );
    // }

    // let oldRoomLink;
    // if (this.state.oldRoomId) {
    //     let name = _t("this room");
    //     const room = MatrixClientPeg.get().getRoom(this.props.roomId);
    //     if (room && room.name) name = room.name;
    //     oldRoomLink = (
    //         <AccessibleButton element='a' onClick={this.onOldRoomClicked}>
    //             { _t("View older messages in %(roomName)s.", { roomName: name }) }
    //         </AccessibleButton>
    //     );
    // }

    return /*#__PURE__*/react.createElement("div", {
      className: "mx_SettingsTab"
    }, /*#__PURE__*/react.createElement("div", {
      className: "mx_SettingsTab_heading"
    }, (0,languageHandler._t)("Advanced")), /*#__PURE__*/react.createElement("div", {
      className: "mx_SettingsTab_section mx_SettingsTab_subsectionText"
    }, /*#__PURE__*/react.createElement("span", {
      className: "mx_SettingsTab_subheading"
    }, room !== null && room !== void 0 && room.isSpaceRoom() ? (0,languageHandler._t)("Squad information") : (0,languageHandler._t)("Room information")), /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement("span", null, (0,languageHandler._t)("Internal room ID"), ":"), "\xA0", this.props.roomId), unfederatableSection));
  }
}) || AdvancedRoomSettingsTab_class);

// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/utils/strings.ts
var strings = __webpack_require__(653848);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/Avatar.ts
var Avatar = __webpack_require__(161992);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/utils/avatar.ts
var avatar = __webpack_require__(9266);
// EXTERNAL MODULE: ./node_modules/lodash-es/get.js
var get = __webpack_require__(216423);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/hiseas/roleMemberManager/index.tsx + 3 modules
var roleMemberManager = __webpack_require__(140309);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/settings/tabs/room/RolesRoomSettingsForRoom.tsx











const getUserRoles = (roleBindings, roles, userId) => {
  let roleIds = [];
  for (const [key, ids] of Object.entries(roleBindings)) {
    console.log('role key', key);
    if (key.toLowerCase() !== "creator") {
      if (ids.find(id => id === userId)) {
        roleIds.push(key);
      }
    }
  }
  return roles.filter(role => roleIds.includes(role.id));
};
const RolesRoomSettingsForRoom = props => {
  var _room$getParentRoom;
  const cli = MatrixClientPeg/* MatrixClientPeg */.p.get();
  const room = cli.getRoom(props.roomId);
  const [adding, setAdding] = (0,react.useState)(null);
  const [editing, setEditing] = (0,react.useState)(null);
  const [loading, setLoading] = (0,react.useState)(false);
  const [canMangeRole] = PermissionStore/* default */.ZP.hasPermission(props.roomId, [PermissionStore/* PermissionMap */.$W.SquadManageRole]);
  const [roomAuth, setRoomAuth] = (0,react.useState)(() => {
    const list = PermissionStore/* default */.ZP.instance.getRoomAuthList(props.roomId);
    if (!canMangeRole) {
      return list.filter(auth => {
        if ('userId' in auth) {
          return auth.id === room.myUserId;
        } else {
          const userRoles = getUserRoles(room.getRoleMembers(), room.getRoles(), room.myUserId);
          return userRoles.find(u => u.id === auth.id);
        }
      });
    }
    return list;
  });
  const [value, setValue] = (0,react.useState)('');
  const selectAuth = v => {
    setEditing(v);
    props.onSelect(v, () => setEditing(null));
  };
  const addAuth = async () => {
    if (adding) {
      if (roomAuth.find(({
        id
      }) => id === adding.id)) {
        selectAuth(adding);
      } else {
        const powerLevelEvent = room.currentState.getStateEvents("m.room.power_levels", "");
        const currentRoomAuths = room.getRoomAuth();
        currentRoomAuths.push({
          type: !(0,get/* default */.Z)(adding, 'userId') ? "role" : "user",
          id: adding.id,
          name: adding.name,
          status: {}
        });
        setLoading(true);
        try {
          await cli.setRoomUserPermissions(props.roomId, currentRoomAuths, powerLevelEvent);
        } catch (e) {
          console.error(e);
        }
        setRoomAuth([adding].concat(roomAuth));
        selectAuth(adding);
        setLoading(false);
        setValue('');
      }
    }
  };
  const deleteAuth = async deleting => {
    if (deleting) {
      if (roomAuth.find(({
        id
      }) => id === deleting.id)) {
        const powerLevelEvent = room.currentState.getStateEvents("m.room.power_levels", "");
        const currentRoomAuths = room.getRoomAuth().filter(v => v.id !== deleting.id);
        setLoading(true);
        try {
          await cli.setRoomUserPermissions(props.roomId, currentRoomAuths, powerLevelEvent);
        } catch (e) {
          console.error(e);
        }
        setRoomAuth(roomAuth.filter(({
          id
        }) => id !== deleting.id));
        setLoading(false);
      }
    }
  };
  const onDeleteClick = v => {
    const {
      close
    } = dist.SdModal.createDialog({
      title: "Delete Permission Settings",
      children: /*#__PURE__*/react.createElement("div", {
        className: "mx_RoleDelete_desc"
      }, /*#__PURE__*/react.createElement("div", null, "Are you sure you want to delete the ", v === null || v === void 0 ? void 0 : v.name, " ", "permissions?"), /*#__PURE__*/react.createElement("div", null, "This action cannot be undone.")),
      okText: (0,languageHandler._t)("Delete"),
      okButtonProps: {
        type: "danger"
      },
      onCancel: () => {
        close === null || close === void 0 ? void 0 : close();
      },
      onOk: async () => {
        deleteAuth(v);
        close === null || close === void 0 ? void 0 : close();
      }
    });
  };
  return /*#__PURE__*/react.createElement("div", {
    className: "mx_SettingsTab mx_RolesGroupRoomSettings"
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_RolesRoomSettings_header"
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_RolesRoomSettings_title"
  }, (0,languageHandler._t)("Roles and Permissions")), /*#__PURE__*/react.createElement("div", {
    className: "mx_RolesRoomSettings_subTitle"
  }, (0,languageHandler._t)("use roles to group your squad members and assign permissions"))), /*#__PURE__*/react.createElement(lib.Spin, {
    spinning: loading
  }, /*#__PURE__*/react.createElement(roleMemberManager/* default */.ZP, {
    value: value,
    onValueChange: setValue,
    showSearch: canMangeRole,
    showCreate: canMangeRole
    // style={{ height: "calc(100vh - 140px)" }}
    ,
    mode: roleMemberManager/* RoleMemberManagerMode */.G5.Modify,
    onClick: addAuth,
    onOptionsSelect: v => setAdding(v),
    _t: languageHandler._t,
    content: {
      editing: (editing === null || editing === void 0 ? void 0 : editing.id) || (editing === null || editing === void 0 ? void 0 : editing.name),
      operator: canMangeRole ? 'edit' : 'view',
      data: roomAuth,
      onRemove: v => onDeleteClick(v),
      onSelect: v => selectAuth(v)
    },
    roleOptions: room === null || room === void 0 ? void 0 : (_room$getParentRoom = room.getParentRoom()) === null || _room$getParentRoom === void 0 ? void 0 : _room$getParentRoom.getRoles().filter(role => {
      if (value) {
        return role.name.toLowerCase().includes(value.toLowerCase());
      }
      return true;
    }),
    memberOptions: room.getJoinedMembers().map(member => {
      return {
        id: member.userId,
        name: (0,strings/* getDisplayName */.Gf)(member),
        userId: (0,strings/* getDisplayUserId */.RL)(member.userId, true),
        avatar: (0,Avatar/* avatarUrlForMember */.xj)(member, 25, 25, "crop", true) || (0,avatar/* getDefaultAvatar */.W)({
          size: 25,
          id: member.userId
        })
      };
    }).filter(member => member.name.toLowerCase().includes(value.toLowerCase()))
  }), /*#__PURE__*/react.createElement("div", {
    className: "mx_RolesGroupRoomSettings_roleName"
  }, (0,languageHandler._t)("Banned list")), /*#__PURE__*/react.createElement("div", {
    className: "mx_GroupMember_wrapper"
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_GroupMember_section",
    onClick: props.onShowBanList
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_GroupMember_section_text"
  }, "Banned", " ", room.getMembersWithMembership("ban").length), /*#__PURE__*/react.createElement(dist.SdIcon, {
    icon: "RightOutlines"
  })))));
};
/* harmony default export */ const room_RolesRoomSettingsForRoom = ((/* unused pure expression or super */ null && (RolesRoomSettingsForRoom)));
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/avatars/MemberAvatar.tsx
var MemberAvatar = __webpack_require__(6156);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/utils/token.ts
var token = __webpack_require__(732094);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/utils/units.ts
var units = __webpack_require__(612559);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/settings/tabs/room/RoleGroupRoomSetting.tsx










const RoleGroupRoomSetting = props => {
  const client = MatrixClientPeg/* MatrixClientPeg */.p.get();
  const [loading, setLoading] = (0,react.useState)(false);
  const [admins, setAdmins] = (0,react.useState)(() => {
    const roles = props.room.getRoleMembers();
    return (0,get/* default */.Z)(roles, "SA", []);
  });
  const members = props.room.getJoinedMembers();
  const [canBan] = PermissionStore/* default */.ZP.hasPermission(props.room.roomId, [PermissionStore/* PermissionMap */.$W.UserBan]);
  (0,react.useEffect)(() => {
    const handleRoomStateEvents = ev => {
      if (ev.getType() === _types_event/* EventType */.tw.RoomPowerLevels) {
        const powerLevel = ev.getContent();
        const _admins = (0,get/* default */.Z)(powerLevel, "role_bindings.SA", []);
        setAdmins(_admins);
      }
    };
    if (client) {
      client.on("RoomState.events", handleRoomStateEvents);
    }
    return () => {
      client.off("RoomState.events", handleRoomStateEvents);
    };
  }, []);
  const onRemove = async userId => {
    setLoading(true);
    const _admins = admins.filter(id => id !== userId);
    const roleMembers = client.getRoom(props.room.roomId).getRoleMembers() || {};
    const powerLevelEvent = props.room.currentState.getStateEvents("m.room.power_levels", "");
    roleMembers["SA"] = _admins;
    try {
      await client.setRoomRoleToUsers(props.room.roomId, roleMembers, powerLevelEvent);
      setAdmins(_admins);
      setLoading(true);
    } catch (error) {
      console.error(error);
      setLoading(true);
    }
  };
  const list = members.filter(member => {
    return admins.find(id => member.userId === id && member.membership === "join");
  });
  return /*#__PURE__*/react.createElement("div", {
    className: "mx_SettingsTab mx_RolesRoomSettings"
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_RolesRoomSettings_header"
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_RolesRoomSettings_title"
  }, (0,languageHandler._t)("Roles and Permissions"))), /*#__PURE__*/react.createElement("div", {
    className: "mx_RolesGroupRoomSettings"
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_RolesGroupRoomSettings_roleName"
  }, (0,languageHandler._t)("Administrators"), props.room.isOwner() && /*#__PURE__*/react.createElement(dist.SdTooltip, {
    placement: "top",
    title: (0,languageHandler._t)("Add")
  }, /*#__PURE__*/react.createElement(dist.SdIcon, {
    icon: "AddOutlines",
    onClick: e => {
      props.onClickAdd(() => {});
    }
  }))), /*#__PURE__*/react.createElement("div", {
    className: "mx_GroupMember_wrapper"
  }, /*#__PURE__*/react.createElement(RoleMemberItem, {
    member: props.room.getMember(props.room.getOwner()),
    onTransfer: client.getUserId() == props.room.getOwner() ? props.onClickTransfer : null
  }), /*#__PURE__*/react.createElement("div", {
    className: "mx_GroupMember_title"
  }, /*#__PURE__*/react.createElement("span", null, (0,languageHandler._t)("Admin")), /*#__PURE__*/react.createElement("span", null, props.max && ` (${list.length}/${props.max})`)), list && list.length > 0 && /*#__PURE__*/react.createElement(react.Fragment, null, list.map(member => {
    return /*#__PURE__*/react.createElement(RoleMemberItem, {
      member: member,
      onRemove: props.room.isOwner() ? onRemove : null
    });
  }))), canBan && /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("div", {
    className: "mx_RolesGroupRoomSettings_roleName"
  }, (0,languageHandler._t)("Banned list")), /*#__PURE__*/react.createElement("div", {
    className: "mx_GroupMember_wrapper"
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_GroupMember_section",
    onClick: props.onShowBanList
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_GroupMember_section_text"
  }, "Banned", " ", props.room.getMembersWithMembership("ban").length), /*#__PURE__*/react.createElement(dist.SdIcon, {
    icon: "RightOutlines"
  }))))));
};
const RoleMemberItem = props => {
  const [loading, setLoading] = (0,react.useState)(false);
  return /*#__PURE__*/react.createElement("div", {
    className: "mx_GroupMember_item"
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_GroupMember_content"
  }, /*#__PURE__*/react.createElement(MemberAvatar/* default */.Z, {
    member: props.member,
    fallbackUserId: props.member.userId,
    size: 44
  }), /*#__PURE__*/react.createElement("div", {
    className: "mx_GroupMember_item_left"
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_GroupMember_name"
  }, props.member.name), /*#__PURE__*/react.createElement("div", {
    className: "mx_GroupMember_wallet"
  }, (0,units/* isMobile */.tq)() ? (0,token/* formatWallet */.Tl)(props.member.walletAddress) : props.member.walletAddress))), (props === null || props === void 0 ? void 0 : props.onTransfer) && /*#__PURE__*/react.createElement("div", {
    className: "mx_GroupMember_operation"
  }, /*#__PURE__*/react.createElement(dist.SdTooltip, {
    placement: "top",
    title: (0,languageHandler._t)("Transfer")
  }, /*#__PURE__*/react.createElement(dist.SdIcon, {
    icon: "TransferOutlines",
    className: "mx_GroupMember_operation_transfer",
    onClick: e => {
      if (props.onTransfer) {
        setLoading(true);
        props.onTransfer(() => {});
        setLoading(false);
      }
    }
  }))), (props === null || props === void 0 ? void 0 : props.onRemove) && /*#__PURE__*/react.createElement("div", {
    className: "mx_GroupMember_operation"
  }, /*#__PURE__*/react.createElement(dist.SdTooltip, {
    placement: "top",
    title: (0,languageHandler._t)("Remove")
  }, /*#__PURE__*/react.createElement(dist.SdIcon, {
    icon: "MemberRemoveOutlines",
    className: "mx_GroupMember_operation_remove",
    onClick: e => {
      if (props.onRemove) {
        setLoading(true);
        props.onRemove(props.member.userId);
        setLoading(false);
      }
    }
  }))));
};
/* harmony default export */ const room_RoleGroupRoomSetting = (RoleGroupRoomSetting);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/settings/tabs/room/RolesRoomSettingsTab.tsx
var RolesRoomSettingsTab = __webpack_require__(304122);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/settings/tabs/room/BannedList.tsx
var BannedList = __webpack_require__(657974);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/settings/tabs/room/SettingAdminsOrOwner.tsx + 2 modules
var SettingAdminsOrOwner = __webpack_require__(847129);
// EXTERNAL MODULE: ./node_modules/@ant-design/icons/lib/index.js
var icons_lib = __webpack_require__(639389);
// EXTERNAL MODULE: ./node_modules/ahooks/lib/index.js
var ahooks_lib = __webpack_require__(924737);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/icons/securityAndPrivacy/Screenshot.tsx
var Screenshot = __webpack_require__(250931);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/icons/securityAndPrivacy/Forwarding.tsx
var Forwarding = __webpack_require__(133699);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/icons/securityAndPrivacy/WaterMark.tsx
var WaterMark = __webpack_require__(902798);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/icons/securityAndPrivacy/Disappear.tsx
var Disappear = __webpack_require__(851527);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/icons/securityAndPrivacy/FlashChat.tsx
var FlashChat = __webpack_require__(141469);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/defenderSettings/settingsStore.ts
var settingsStore = __webpack_require__(650478);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/settings/tabs/user/DefendSettings/DisappearMessageSettingDrawer.tsx






const DisappearMessageSettingDrawer = ({
  isOpen,
  defaultValue,
  closeModal,
  onSettingsChanged
}) => {
  const [isLoading, {
    setTrue: setLoadingEnabled,
    setFalse: setLoadingDisabled
  }] = (0,ahooks_lib.useBoolean)(false);
  const [value, setValue] = (0,react.useState)(defaultValue);
  const handleSave = async () => {
    try {
      setLoadingEnabled();
      await onSettingsChanged({
        messageAliveSecond: value
      });
      closeModal();
    } finally {
      setLoadingDisabled();
    }
  };
  return /*#__PURE__*/react.createElement(lib.Drawer, {
    zIndex: 9999,
    mask: false,
    closable: false,
    placement: "right",
    open: isOpen,
    className: "my-drawer-in-defender",
    contentWrapperStyle: {
      margin: "12px"
    },
    bodyStyle: {
      padding: "20px"
    }
  }, /*#__PURE__*/react.createElement("div", {
    className: "my-drawer-in-defender-content"
  }, /*#__PURE__*/react.createElement("header", {
    className: "my-drawer-in-defender-header"
  }, /*#__PURE__*/react.createElement(lib.Typography.Title, {
    level: 5
  }, "Select time"), /*#__PURE__*/react.createElement(elements_AccessibleButton/* default */.Z, {
    onClick: closeModal
  }, /*#__PURE__*/react.createElement(icons_lib.CloseOutlined, null))), /*#__PURE__*/react.createElement(lib.Space, {
    direction: "vertical",
    size: 12,
    style: {
      width: "100%"
    }
  }, settingsStore/* aliveTimeLists */.bc.map((item, index) => /*#__PURE__*/react.createElement("label", {
    key: item,
    style: {
      display: "flex",
      flexDirection: "row"
    },
    onClick: () => setValue(item)
  }, /*#__PURE__*/react.createElement(lib.Typography.Text, {
    style: {
      flexShrink: 0
    }
  }, settingsStore/* aliveTimeMap2Value */.OT.get(item)), /*#__PURE__*/react.createElement(lib.Radio, {
    style: {
      width: "100%",
      display: "flex",
      flexDirection: "row-reverse"
    },
    value: item,
    checked: item === value
  })))), /*#__PURE__*/react.createElement("div", {
    style: {
      flex: 1
    }
  }), /*#__PURE__*/react.createElement("div", {
    className: "my-drawer-in-defender-action"
  }, /*#__PURE__*/react.createElement(lib.Button, {
    onClick: closeModal,
    className: "cancel"
    // element="button"
  }, "Close"), /*#__PURE__*/react.createElement(lib.Button, {
    loading: isLoading
    // element="button"
    ,
    className: "submit",
    onClick: handleSave
  }, "Save"))));
};
/* harmony default export */ const DefendSettings_DisappearMessageSettingDrawer = (DisappearMessageSettingDrawer);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/settings/tabs/user/DefendSettings/FlashRoomEnsureModal.tsx



const FlashRoomEnsureModal = ({
  isOpen,
  onClose,
  onSettingsChanged
}) => {
  const [isLoading, {
    setTrue,
    setFalse
  }] = (0,ahooks_lib.useBoolean)();
  const handleOk = async () => {
    try {
      setTrue();
      await onSettingsChanged({
        roomAliveTimestamps: new Date().getTime()
      });
      onClose();
    } catch (error) {
      // pass
    } finally {
      setFalse();
    }
  };
  return /*#__PURE__*/react.createElement(lib.Modal, {
    centered: true,
    zIndex: 9999,
    open: isOpen,
    onCancel: onClose,
    okText: "Confirm",
    okButtonProps: {
      shape: "round",
      color: "error",
      style: {
        backgroundColor: "#FF543D",
        color: "#fff"
      }
    },
    cancelButtonProps: {
      shape: "round"
    },
    confirmLoading: isLoading,
    onOk: handleOk
  }, /*#__PURE__*/react.createElement(lib.Typography.Title, {
    style: {
      color: "#FF543D"
    },
    level: 5
  }, "Warning"), /*#__PURE__*/react.createElement(lib.Typography.Text, null, "After enabling the setting, the group chat will automatically disband after 24 hours."), /*#__PURE__*/react.createElement("br", null), /*#__PURE__*/react.createElement(lib.Typography.Text, null, "Once enabled, it cannot be reversed, so please prudently consider before choosing to do so."));
};
/* harmony default export */ const DefendSettings_FlashRoomEnsureModal = (FlashRoomEnsureModal);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/utils/room/getPermissionStuffState.ts
var getPermissionStuffState = __webpack_require__(369012);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/settings/tabs/user/DefendSettings/Securitysettings.tsx

function Securitysettings_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function Securitysettings_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? Securitysettings_ownKeys(Object(t), !0).forEach(function (r) { (0,defineProperty/* default */.Z)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : Securitysettings_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }


















var StateKeysENUM = /*#__PURE__*/function (StateKeysENUM) {
  StateKeysENUM["screenshot"] = "screenshot";
  StateKeysENUM["forwarding"] = "forwarding";
  StateKeysENUM["watermark"] = "watermark";
  StateKeysENUM["roomAliveTimestamps"] = "roomAliveTimestamps";
  StateKeysENUM["messageAliveSecond"] = "messageAliveSecond";
  return StateKeysENUM;
}(StateKeysENUM || {});
const SecuritySettings = ({
  roomId
}) => {
  const cli = (0,react.useContext)(contexts_MatrixClientContext/* default */.Z);
  const isPermissionEnabled = (0,getPermissionStuffState/* getProtectionManagePermission */.$K)({
    roomId
  });
  const [isModelOpen, {
    setTrue: openModal,
    setFalse: closeModal
  }] = (0,ahooks_lib.useBoolean)(false);
  const [isEnsureModelOpen, {
    setTrue: openEnsureModal,
    setFalse: closeEnsureModal
  }] = (0,ahooks_lib.useBoolean)(false);
  const [isLoading, {
    setTrue,
    setFalse
  }] = (0,ahooks_lib.useBoolean)(false);
  const settingsMap = (0,settingsStore/* useDefendSettingsStore */.IO)(state => state.settings);
  const {
    screenshot,
    forwarding,
    watermark,
    messageAliveSecond,
    roomAliveTimestamps
  } = (settingsMap === null || settingsMap === void 0 ? void 0 : settingsMap.get(roomId)) || {};
  const [currentState, setCurrentState] = (0,react.useState)(null);
  const handleChange = async state => {
    try {
      setTrue();
      const newState = Securitysettings_objectSpread({
        forwarding,
        watermark,
        screenshot,
        roomAliveTimestamps,
        messageAliveSecond
      }, state);
      await MatrixClientPeg/* MatrixClientPeg */.p.get().updateSecurityAndPrivacyState(roomId, newState);
      dist.SdMessage.success("Successful");
      (0,settingsStore/* updateDefendSettings */.BA)({
        roomID: roomId,
        value: newState
      });
    } catch (error) {
      dist.SdMessage.error("Failed");
    } finally {
      setFalse();
      setCurrentState(null);
    }
  };
  const handleWrapperClick = e => {
    e.stopPropagation();
    e.preventDefault();
    if (!isPermissionEnabled) {
      lib.message.warn("No permissions set, please contact the administrator.");
    }
  };
  return /*#__PURE__*/react.createElement("div", {
    className: "mx_SettingsTab_security_body"
  }, /*#__PURE__*/react.createElement(lib.Typography.Title, {
    level: 5
  }, (0,languageHandler._t)("Advanced encryption")), /*#__PURE__*/react.createElement("div", {
    className: "mx_SettingsTab_security_body_row",
    onClick: handleWrapperClick
  }, /*#__PURE__*/react.createElement("div", {
    className: "icon_wrapper"
  }, /*#__PURE__*/react.createElement(Screenshot/* default */.Z, null)), /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement("h5", null, "Screenshot protection"), /*#__PURE__*/react.createElement("p", null, "Taking screenshots will be restricted.")), /*#__PURE__*/react.createElement("div", {
    style: {
      flex: 1
    }
  }), /*#__PURE__*/react.createElement(lib.Switch, {
    style: {
      pointerEvents: isPermissionEnabled ? "auto" : "none"
    },
    disabled: isLoading || !isPermissionEnabled,
    loading: isLoading && currentState === StateKeysENUM.screenshot,
    checked: screenshot,
    onChange: val => {
      setCurrentState(StateKeysENUM.screenshot);
      handleChange({
        screenshot: val
      });
    }
  })), /*#__PURE__*/react.createElement("div", {
    className: "mx_SettingsTab_security_body_row",
    onClick: handleWrapperClick
  }, /*#__PURE__*/react.createElement("div", {
    className: "icon_wrapper"
  }, /*#__PURE__*/react.createElement(Forwarding/* default */.Z, null)), /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement("h5", null, "Forwarding restrictions"), /*#__PURE__*/react.createElement("p", null, "Restrict Forwarding of Messages")), /*#__PURE__*/react.createElement("div", {
    style: {
      flex: 1
    }
  }), /*#__PURE__*/react.createElement(lib.Switch, {
    style: {
      pointerEvents: isPermissionEnabled ? "auto" : "none"
    },
    disabled: isLoading || !isPermissionEnabled,
    loading: isLoading && currentState === StateKeysENUM.forwarding,
    checked: forwarding,
    onChange: val => {
      setCurrentState(StateKeysENUM.forwarding);
      handleChange({
        forwarding: val
      });
    }
  })), /*#__PURE__*/react.createElement("div", {
    className: "mx_SettingsTab_security_body_row",
    onClick: handleWrapperClick
  }, /*#__PURE__*/react.createElement("div", {
    className: "icon_wrapper"
  }, /*#__PURE__*/react.createElement(WaterMark/* default */.Z, null)), /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement("h5", null, "Chat watermark"), /*#__PURE__*/react.createElement("p", null, "Show message watermark")), /*#__PURE__*/react.createElement("div", {
    style: {
      flex: 1
    }
  }), /*#__PURE__*/react.createElement(lib.Switch, {
    style: {
      pointerEvents: isPermissionEnabled ? "auto" : "none"
    },
    disabled: isLoading || !isPermissionEnabled,
    loading: isLoading && currentState === StateKeysENUM.watermark,
    checked: watermark,
    onChange: val => {
      setCurrentState(StateKeysENUM.watermark);
      handleChange({
        watermark: val
      });
    }
  })), /*#__PURE__*/react.createElement("div", {
    className: "mx_SettingsTab_security_body_row",
    onClick: handleWrapperClick
  }, /*#__PURE__*/react.createElement("div", {
    className: "icon_wrapper"
  }, /*#__PURE__*/react.createElement(Disappear/* default */.Z, null)), /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement("h5", null, "Disappearing messages"), /*#__PURE__*/react.createElement("p", null, "Messages deleted after some time")), /*#__PURE__*/react.createElement("div", {
    style: {
      flex: 1
    }
  }), /*#__PURE__*/react.createElement(elements_AccessibleButton/* default */.Z, {
    disabled: !isPermissionEnabled,
    onClick: openModal
  }, settingsStore/* aliveTimeMap2Value */.OT.get(messageAliveSecond), " ", /*#__PURE__*/react.createElement(icons_lib.RightOutlined, null))), /*#__PURE__*/react.createElement("div", {
    className: "mx_SettingsTab_security_body_row",
    onClick: handleWrapperClick
  }, /*#__PURE__*/react.createElement("div", {
    className: "icon_wrapper"
  }, /*#__PURE__*/react.createElement(FlashChat/* default */.Z, null)), /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement("h5", null, "FlashChat24"), /*#__PURE__*/react.createElement("p", null, "Automatically disband after 24 hours")), /*#__PURE__*/react.createElement("div", {
    style: {
      flex: 1
    }
  }), /*#__PURE__*/react.createElement(lib.Switch, {
    style: {
      pointerEvents: isPermissionEnabled ? "auto" : "none"
    },
    onClick: openEnsureModal,
    disabled: isLoading || roomAliveTimestamps > 0 || cli.getRoom(roomId).isDmRoom() || cli.getRoom(roomId).hasSpaceParent() || !isPermissionEnabled,
    checked: roomAliveTimestamps > 0,
    loading: isLoading && currentState === StateKeysENUM.roomAliveTimestamps
  })), isEnsureModelOpen && /*#__PURE__*/react.createElement(DefendSettings_FlashRoomEnsureModal, {
    isOpen: isEnsureModelOpen,
    onClose: closeEnsureModal,
    onSettingsChanged: handleChange
  }), isModelOpen && /*#__PURE__*/react.createElement(DefendSettings_DisappearMessageSettingDrawer, {
    defaultValue: messageAliveSecond,
    isOpen: isModelOpen,
    closeModal: closeModal,
    onSettingsChanged: handleChange
  }));
};
/* harmony default export */ const Securitysettings = (SecuritySettings);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/utils/feature/isFeatureEnabled.ts
var isFeatureEnabled = __webpack_require__(94948);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/dialogs/BaseDialog.js
var BaseDialog = __webpack_require__(308043);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/spaces/token_gated/TokenGatedDialogContext.tsx + 8 modules
var TokenGatedDialogContext = __webpack_require__(577146);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/utils/room/getRoomScene.ts
var getRoomScene = __webpack_require__(827337);
// EXTERNAL MODULE: ./node_modules/lodash-es/fromPairs.js
var fromPairs = __webpack_require__(315937);
// EXTERNAL MODULE: ./node_modules/lodash-es/flatten.js
var flatten = __webpack_require__(727961);
// EXTERNAL MODULE: ./node_modules/lodash-es/toPairs.js
var toPairs = __webpack_require__(440471);
// EXTERNAL MODULE: ./node_modules/lodash-es/isEmpty.js
var isEmpty = __webpack_require__(479697);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/dialogs/RoomRoleAndPermissionSetting.tsx

function RoomRoleAndPermissionSetting_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function RoomRoleAndPermissionSetting_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? RoomRoleAndPermissionSetting_ownKeys(Object(t), !0).forEach(function (r) { (0,defineProperty/* default */.Z)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : RoomRoleAndPermissionSetting_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }







/* harmony default export */ const RoomRoleAndPermissionSetting = (/*#__PURE__*/(0,react.memo)(function RoomRoleAndPermissionSetting(props) {
  const {
    roomId,
    editingId,
    editable,
    data,
    onCancel
  } = props;
  const cli = MatrixClientPeg/* MatrixClientPeg */.p.get();
  const room = cli.getRoom(roomId);
  const powerLevelEvent = room.currentState.getStateEvents("m.room.power_levels", "");
  const oldStatus = (0,react.useMemo)(() => {
    return (0,fromPairs/* default */.Z)((0,flatten/* default */.Z)(data.sections.map(s => s.items.map(item => [item.id, item.value]))));
  }, []);
  const [loading, setLaoding] = (0,react.useState)(false);
  const [statusMap, setsStatusMap] = (0,react.useState)();
  const onSave = async () => {
    if (!loading) {
      setLaoding(true);
      const roomAuths = room.getRoomAuth();
      const currentRoomAuth = roomAuths.find(v => v.id === editingId);
      if (currentRoomAuth) {
        (0,toPairs/* default */.Z)(statusMap).map(([id, value]) => {
          currentRoomAuth.status[id] = value;
        });
      }
      try {
        await cli.setRoomUserPermissions(roomId, roomAuths, powerLevelEvent);
        setLaoding(false);
      } catch (e) {
        console.error(e);
        setLaoding(false);
        throw e;
      }
    }
  };
  const handlePermissionChange = (0,react.useCallback)(async (prev, next, item) => {
    if (oldStatus[item.id] !== item.value) {
      setsStatusMap(RoomRoleAndPermissionSetting_objectSpread(RoomRoleAndPermissionSetting_objectSpread({}, statusMap), {}, {
        [item.id]: item.value
      }));
    } else {
      delete statusMap[item.id];
      setsStatusMap(RoomRoleAndPermissionSetting_objectSpread({}, statusMap));
    }
  }, [statusMap, oldStatus]);
  const _onCancel = () => {
    onCancel();
  };
  (0,ahooks_lib.useUnmount)(() => {
    setLaoding(false);
    setsStatusMap({});
  });
  return /*#__PURE__*/react.createElement("div", {
    style: {
      height: "100%",
      overflow: "hidden",
      position: "relative"
    }
  }, /*#__PURE__*/react.createElement(react_dist.PermissionSetting, {
    mode: react_dist.ControlType.ButtonGroup,
    editable: editable,
    onItemChange: handlePermissionChange,
    data: data,
    style: {
      paddingBottom: 80
    }
  }), /*#__PURE__*/react.createElement("div", {
    className: "role_buttons floating_role_buttons",
    style: {
      transform: statusMap && !(0,isEmpty/* default */.Z)(statusMap) ? "translateY(-80px)" : "translateY(40px)"
    }
  }, /*#__PURE__*/react.createElement(dist.SdButton, {
    disabled: !editable,
    onClick: _onCancel,
    type: "associate"
  }, (0,languageHandler._t)("Cancel")), /*#__PURE__*/react.createElement(dist.SdButton, {
    type: "primary",
    loading: loading,
    disabled: loading,
    onClick: onSave
  }, (0,languageHandler._t)("Save"))));
}));
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/dialogs/RoomSettingsDialog.tsx


var RoomSettingsDialog_dec, RoomSettingsDialog_class;
function RoomSettingsDialog_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function RoomSettingsDialog_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? RoomSettingsDialog_ownKeys(Object(t), !0).forEach(function (r) { (0,defineProperty/* default */.Z)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : RoomSettingsDialog_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
/*
Copyright 2019 New Vector Ltd
Copyright 2019 Michael Telatynski <7t3chguy@gmail.com>

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/



// import AdvancedRoomSettingsTab from "../settings/tabs/room/AdvancedRoomSettingsTab";






// import { UIFeature } from "../../../settings/UIFeature";
























const ROOM_GENERAL_TAB = "ROOM_GENERAL_TAB";
const ROOM_ACCESS_TAB = "ROOM_ACCESS_TAB";
const ROOM_SECURITY_AND_PRIVACY_TAB = "ROOM_SECURITY_AND_PRIVACY_TAB";
const ROOM_SECURITY_TAB = "ROOM_SECURITY_TAB";
const ROOM_ROLES_TAB = "ROOM_ROLES_TAB";
const ROOM_NOTIFICATIONS_TAB = "ROOM_NOTIFICATIONS_TAB";
const ROOM_BRIDGES_TAB = "ROOM_BRIDGES_TAB";
const ROOM_ADVANCED_TAB = "ROOM_ADVANCED_TAB";
const ROOM_DELETE = "ROOM_DELETE";
let RoomSettingsDialog = (RoomSettingsDialog_dec = (0,replaceableComponent/* replaceableComponent */.U)("views.dialogs.RoomSettingsDialog"), RoomSettingsDialog_dec(RoomSettingsDialog_class = class RoomSettingsDialog extends react.Component {
  constructor(props) {
    super(props);
    (0,defineProperty/* default */.Z)(this, "dispatcherRef", void 0);
    (0,defineProperty/* default */.Z)(this, "room", void 0);
    (0,defineProperty/* default */.Z)(this, "getPermission", () => {
      const [_hasMangeRoom, _hasMangeRoles] = PermissionStore/* default */.ZP.hasPermission(this.room.roomId, [PermissionStore/* PermissionMap */.$W.SquadManageRoom, PermissionStore/* PermissionMap */.$W.SquadManageRole]);
      let _hasDeleteRoom;
      if (this.room.hasSpaceParent()) {
        var _this$room$getParentR;
        _hasDeleteRoom = ((_this$room$getParentR = this.room.getParentRoom()) === null || _this$room$getParentR === void 0 ? void 0 : _this$room$getParentR.getOwner()) === this.room.myUserId;
      } else {
        _hasDeleteRoom = this.room.myUserId === this.room.getOwner();
      }
      this.setState({
        hasMangeRoom: _hasMangeRoom,
        hasMangeRoles: _hasMangeRoles,
        hasDeleteRoom: _hasDeleteRoom // || _hasMangeRoom,
      });
    });
    (0,defineProperty/* default */.Z)(this, "hasDeleteRoom", () => {
      if (this.room.hasSpaceParent()) {
        var _this$room$getParentR2;
        return ((_this$room$getParentR2 = this.room.getParentRoom()) === null || _this$room$getParentR2 === void 0 ? void 0 : _this$room$getParentR2.getOwner()) === this.room.myUserId;
      } else {
        return this.room.myUserId === this.room.getOwner();
      }
    });
    (0,defineProperty/* default */.Z)(this, "onAction", payload => {
      // When view changes below us, close the room settings
      // whilst the modal is open this can only be triggered when someone hits Leave Room
      if (payload.action === "view_home_page") {
        this.props.onFinished(true);
      }
    });
    (0,defineProperty/* default */.Z)(this, "changeFloating", data => {
      this.setState({
        floating: RoomSettingsDialog_objectSpread({}, data)
      });
    });
    (0,defineProperty/* default */.Z)(this, "onShowBanList", () => {
      this.setState({
        floating: {
          title: (0,languageHandler._t)("Banned List"),
          show: true,
          onHide: () => {
            this.setState({
              floating: null
            });
          },
          content: /*#__PURE__*/react.createElement(BannedList/* default */.Z, {
            room: this.room,
            onCancel: () => {
              this.setState({
                floating: null
              });
            }
          })
        }
      });
    });
    (0,defineProperty/* default */.Z)(this, "onClickAdd", callback => {
      this.setState({
        floating: {
          title: (0,languageHandler._t)("Add member"),
          show: true,
          onHide: () => {
            this.setState({
              floating: null
            });
            if (callback) {
              callback();
            }
          },
          content: /*#__PURE__*/react.createElement(SettingAdminsOrOwner/* SettingAdminsOrOwner */.L, {
            room: this.room,
            max: this.state.max,
            onCancel: () => {
              this.setState({
                floating: null
              });
            },
            setType: "admin"
          })
        }
      });
    });
    (0,defineProperty/* default */.Z)(this, "onClickTransfer", callback => {
      this.setState({
        floating: {
          title: (0,languageHandler._t)("Transfer Ownership"),
          show: true,
          onHide: () => {
            this.setState({
              floating: null
            });
            if (callback) {
              callback();
            }
          },
          content: /*#__PURE__*/react.createElement(SettingAdminsOrOwner/* SettingAdminsOrOwner */.L, {
            room: this.room,
            max: this.state.max,
            onCancel: () => {
              this.setState({
                floating: null
              });
            },
            setType: "transfer"
          })
        }
      });
    });
    (0,defineProperty/* default */.Z)(this, "onTokenGatingClick", tokenGatingProps => {
      this.changeFloating({
        show: true,
        content: /*#__PURE__*/react.createElement(TokenGatedDialogContext/* default */.ZP, (0,esm_extends/* default */.Z)({
          roomId: this.props.roomId,
          onSuccess: () => this.changeFloating(),
          onHide: () => this.changeFloating(null)
        }, tokenGatingProps)),
        header: "token_gated"
      });
    });
    (0,defineProperty/* default */.Z)(this, "permissionTab", () => {
      const roomVersion = this.room.getVersion();
      if (+roomVersion <= 10) {
        return /*#__PURE__*/react.createElement(RolesRoomSettingsTab/* default */.Z, {
          roomId: this.props.roomId
        });
      }
      const room = MatrixClientPeg/* MatrixClientPeg */.p.get().getRoom(this.props.roomId);
      const isCommunity = (0,getRoomScene/* isCommunityRoom */.eg)(room);
      return this.room.isGroup() ? /*#__PURE__*/react.createElement(room_RoleGroupRoomSetting, {
        room: this.room,
        max: this.state.max,
        onClickAdd: this.onClickAdd,
        onClickTransfer: this.onClickTransfer,
        onShowBanList: this.onShowBanList
      }) : /*#__PURE__*/react.createElement(RolesRoomSettingsForRoom, {
        roomId: this.props.roomId,
        onShowBanList: this.onShowBanList,
        onSelect: async (v, callback) => {
          this.setState({
            dataSource: await PermissionStore/* default */.ZP.instance.getAdvancedPermissions(this.props.roomId, v.id, isCommunity),
            editingId: v.id
          });
          setTimeout(() => {
            this.setState({
              floating: {
                title: "Advanced Permissions",
                show: true,
                onHide: () => {
                  this.setState({
                    floating: null
                  });
                  if (callback) {
                    callback();
                  }
                },
                content: /*#__PURE__*/react.createElement(RoomRoleAndPermissionSetting, {
                  editingId: this.state.editingId,
                  roomId: this.props.roomId,
                  editable: this.state.hasMangeRoles,
                  data: this.state.dataSource,
                  onCancel: () => {
                    this.setState({
                      floating: null
                    });
                    if (callback) {
                      callback();
                    }
                  }
                })
                // <PermissionSetting
                //     mode={ControlType.ButtonGroup}
                //     editable={this.state.hasMangeRoles}
                //     onItemChange={
                //         this.handlePermissionChange
                //     }
                //     data={this.state.dataSource}
                // />
              }
            });
          });
        }
      });
    });
    this.room = MatrixClientPeg/* MatrixClientPeg */.p.get().getRoom(this.props.roomId);
    this.state = {
      tabId: this.room.isDmRoom() ? ROOM_SECURITY_AND_PRIVACY_TAB : props.initialTabId || ROOM_GENERAL_TAB,
      showTransferModal: false,
      showHotspotModal: false,
      floating: {
        show: false,
        content: ""
      },
      showPermissionsFloating: false,
      dataSource: {
        sections: []
      },
      editingId: "",
      hasMangeRoom: false,
      hasMangeRoles: false,
      hasDeleteRoom: false,
      max: 3
    };
  }
  componentDidMount() {
    this.getAdvancedPermissions();
    this.dispatcherRef = dispatcher/* default */.ZP.register(this.onAction);
    this.getPermission();
    PermissionStore/* default */.ZP.instance.on(PermissionStore/* UPDATE_PERMISSION */.SH, this.getPermission);
  }
  componentWillUnmount() {
    if (this.dispatcherRef) {
      dispatcher/* default */.ZP.unregister(this.dispatcherRef);
    }
  }
  getAdvancedPermissions() {
    const room = MatrixClientPeg/* MatrixClientPeg */.p.get().getRoom(this.props.roomId);
    const isCommunity = (0,getRoomScene/* isCommunityRoom */.eg)(room);
    PermissionStore/* default */.ZP.instance.getAdvancedPermissions(this.props.roomId, this.state.editingId, isCommunity).then(dataSource => {
      this.setState({
        dataSource
      });
    });
  }
  // private handlePermissionChange = async (prev, next, item) => {
  //     const room = MatrixClientPeg.get().getRoom(this.props.roomId);
  //     const powerLevelEvent = room.currentState.getStateEvents(
  //         "m.room.power_levels",
  //         "",
  //     );
  //     const currentRoomAuths = room.getRoomAuth();
  //     const currentRoomAuth = currentRoomAuths.find(
  //         (v) => v.id === this.state.editingId,
  //     );
  //     if (currentRoomAuth) {
  //         currentRoomAuth.status[item.id] = item.value;
  //     }
  //     try {
  //         await MatrixClientPeg.get().setRoomUserPermissions(
  //             this.props.roomId,
  //             currentRoomAuths,
  //             powerLevelEvent,
  //         );
  //     } catch (e) {
  //         console.error(e);
  //         throw e;
  //     }
  // };
  render() {
    var _this$state$floating;
    const room = MatrixClientPeg/* MatrixClientPeg */.p.get().getRoom(this.props.roomId);
    const roomName = /*#__PURE__*/react.createElement(RoomName/* default */.Z, {
      room: room
    });
    const isDMRoom = room.isDmRoom();
    return /*#__PURE__*/react.createElement(contexts_MatrixClientContext/* default */.Z.Provider, {
      value: MatrixClientPeg/* MatrixClientPeg */.p.get()
    }, /*#__PURE__*/react.createElement(react_dist.SettingPanel, {
      className: classnames_default()("mx_RoomSettingsDialog mx_SpaceSettingsDialog", {
        mx_SpaceSettingsDialog_token_gated: ((_this$state$floating = this.state.floating) === null || _this$state$floating === void 0 ? void 0 : _this$state$floating.header) === "token_gated"
      }),
      tabs: {
        onChange: v => {
          if (v !== this.state.tabId) {
            this.changeFloating({
              show: false,
              content: ""
            });
          }
          this.setState({
            tabId: v
          });
        },
        value: this.state.tabId,
        data: isDMRoom ? [{
          label: (0,languageHandler._t)("Advanced encryption"),
          icon: "SecurityOutlines",
          content: /*#__PURE__*/react.createElement(Securitysettings, {
            roomId: room.roomId
          }),
          key: ROOM_SECURITY_AND_PRIVACY_TAB,
          visible: (0,isFeatureEnabled/* default */.Z)()
        }] : [{
          label: (0,languageHandler._t)("Overview"),
          icon: "SortOutlines",
          content: /*#__PURE__*/react.createElement(GeneralRoomSettingsTab, {
            roomId: this.props.roomId,
            openFloating: this.changeFloating
          }),
          key: ROOM_GENERAL_TAB,
          title: (0,languageHandler._t)(`${room.hasSpaceParent() ? "Channel Settings" : "Group Settings"} - %(roomName)s`, {
            roomName
          })
        }, {
          label: (0,languageHandler._t)(`${(0,strings/* capitalizeFirstLetter */.fm)(room.getRoomType())} Type`),
          icon: "InterfaceOutlines",
          content: /*#__PURE__*/react.createElement(SpaceSettingsAccessTab/* default */.Z, {
            matrixClient: room.client,
            space: room,
            onApproveListStart: this.changeFloating,
            onTokenGatingClick: this.onTokenGatingClick
          }),
          key: ROOM_ACCESS_TAB,
          visible: this.state.hasMangeRoom
        }, {
          label: (0,languageHandler._t)("Advanced encryption"),
          icon: "SecurityOutlines",
          content: /*#__PURE__*/react.createElement(Securitysettings, {
            roomId: room.roomId
          }),
          key: ROOM_SECURITY_AND_PRIVACY_TAB,
          visible: (0,isFeatureEnabled/* default */.Z)()
        }, {
          label: (0,languageHandler._t)("Roles and Permissions"),
          icon: "UsermoreOutlines",
          content: this.permissionTab(),
          visible: true
        }, {
          label: (0,languageHandler._t)("Notifications"),
          icon: "mx_RoomSettingsDialog_notificationsIcon",
          content: /*#__PURE__*/react.createElement(NotificationsSettingsTab, {
            roomId: this.props.roomId
          }),
          key: ROOM_NOTIFICATIONS_TAB,
          visible: false
        }, {
          label: (0,languageHandler._t)("Bridges"),
          icon: "mx_RoomSettingsDialog_bridgesIcon",
          content: /*#__PURE__*/react.createElement(BridgeSettingsTab, {
            roomId: this.props.roomId
          }),
          key: ROOM_BRIDGES_TAB,
          visible: SettingsStore/* default */.C.getValue("feature_bridge_state")
        }, {
          label: (0,languageHandler._t)("Advanced"),
          icon: "mx_RoomSettingsDialog_warningIcon",
          content: /*#__PURE__*/react.createElement(AdvancedRoomSettingsTab, {
            roomId: this.props.roomId,
            closeSettingsFn: () => this.props.onFinished(true)
          }),
          key: ROOM_ADVANCED_TAB,
          visible: SettingsStore/* default */.C.getValue(UIFeature/* UIFeature */.H.AdvancedSettings) && false
        }, {
          label: room.hasSpaceParent() ? (0,languageHandler/* _td */.I8)("Leave Channel") : (0,languageHandler/* _td */.I8)("Leave Group"),
          icon: "ExitOutlines",
          showDividerAbove: true,
          content: null,
          onClick: () => {
            dispatcher/* default */.ZP.dispatch({
              action: "leave_room",
              room_id: this.props.roomId
            });
          },
          visible: !this.hasDeleteRoom()
        }, {
          label: room.hasSpaceParent() ? (0,languageHandler/* _td */.I8)("Delete Channel") : (0,languageHandler/* _td */.I8)("Delete Group"),
          icon: "DeleteOutLines",
          showDividerAbove: true,
          content: null,
          onClick: () => {
            var _room$currentState$ge, _hotspotEvContent$hot;
            const hotspotEvContent = (_room$currentState$ge = room.currentState.getStateEvents(_types_event/* EventType */.tw.RoomMintHotspot, "")) === null || _room$currentState$ge === void 0 ? void 0 : _room$currentState$ge.getContent();
            if (hotspotEvContent && !!((_hotspotEvContent$hot = hotspotEvContent.hotsopt) !== null && _hotspotEvContent$hot !== void 0 && _hotspotEvContent$hot.token_id)) {
              this.setState({
                showHotspotModal: true
              });
              return;
            }
            (0,ConfirmDeleteRoomDialog/* default */.Z)({
              roomName: room.name,
              roomId: room.roomId,
              hideSettings: this.props.onFinished
            });
          },
          visible: this.state.hasDeleteRoom
        }].filter(Boolean)
      },
      show: true,
      floating: this.state.floating,
      onBack: () => this.props.onFinished(false),
      isShotCut: this.props.isShotCut,
      _t: languageHandler._t
    }), /*#__PURE__*/react.createElement(lib.Modal, {
      open: this.state.showHotspotModal,
      className: "mx_Dialog",
      wrapClassName: "mx_SpaceSettingsDialog_Modal",
      footer: null,
      closable: false,
      width: 350,
      centered: true
    }, /*#__PURE__*/react.createElement(BaseDialog/* default */.Z, {
      className: "mx_TransferOwnerErrorDialog",
      hasCancel: false
    }, /*#__PURE__*/react.createElement("div", {
      className: "mx_TransferOwnerErrorDialog_title"
    }, (0,languageHandler._t)("Unable Delete")), /*#__PURE__*/react.createElement("div", {
      className: "mx_TransferOwnerErrorDialog_content"
    }, "the Group/Squad is linked to HOTSPOT. Please unlink first."), /*#__PURE__*/react.createElement("div", {
      className: "mx_TransferOwnerErrorDialog_buttons"
    }, /*#__PURE__*/react.createElement("button", {
      className: "mx_TransferOwnerErrorDialog_button_ok mx_TransferOwnerErrorDialog_button_transfer_ok",
      onClick: () => {
        this.setState({
          showHotspotModal: false
        });
      }
    }, (0,languageHandler._t)("Confirm"))))));
  }
}) || RoomSettingsDialog_class);

// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/RightPanelStorePhases.ts
var RightPanelStorePhases = __webpack_require__(274057);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/rooms/NewRoomIntro.tsx
/*
Copyright 2020, 2021 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/



















function hasExpectedEncryptionSettings(matrixClient, room) {
  const isEncrypted = matrixClient.isRoomEncrypted(room.roomId);
  const isPublic = room.getJoinRule() === "public";
  return isPublic || !(0,createRoom/* privateShouldBeEncrypted */.Gc)() || isEncrypted;
}
const NewRoomIntro = () => {
  const cli = (0,react.useContext)(contexts_MatrixClientContext/* default */.Z);
  const {
    room,
    roomId
  } = (0,react.useContext)(contexts_RoomContext/* default */.Z);
  const dmPartner = DMRoomMap/* default */.Z.shared().getUserIdForRoomId(roomId);
  let body;
  if (dmPartner) {
    let caption;
    if (room.getJoinedMemberCount() + room.getInvitedMemberCount() === 2) {
      caption = (0,languageHandler._t)("Only the two of you are in this conversation.");
    }
    const member = room === null || room === void 0 ? void 0 : room.getMember(dmPartner);
    const displayName = (member === null || member === void 0 ? void 0 : member.rawDisplayName) || dmPartner;
    body = /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(RoomAvatar/* default */.Z, {
      room: room,
      style: {
        borderRadius: 10
      },
      size: AVATAR_SIZE,
      onClick: () => {
        dispatcher/* default */.ZP.dispatch({
          action: actions/* Action */.a.SetRightPanelPhase,
          phase: RightPanelStorePhases/* RightPanelPhases */.q4.UserProfile,
          refireParams: {
            member
          }
        });
        // defaultDispatcher.dispatch<ViewUserPayload>({
        //     action: Action.ViewUser,
        //     // XXX: We should be using a real member object and not assuming what the receiver wants.
        //     member: member || { userId: dmPartner } as User,
        // });
      }
    }), /*#__PURE__*/react.createElement(RoomName/* default */.Z, {
      room: room
    }, (name, remark) => /*#__PURE__*/react.createElement("h2", null, remark || name)), /*#__PURE__*/react.createElement("p", null, (0,languageHandler._t)("This is the beginning of your DM chat with <displayName/>.", {}, {
      displayName: () => /*#__PURE__*/react.createElement("b", null, displayName)
    })), caption && /*#__PURE__*/react.createElement("p", null, caption));
  } else {
    var _room$currentState$ge, _room$currentState$ge2, _room$currentState$ge3, _room$getMember, _SpaceStore$instance$;
    const inRoom = room && room.getMyMembership() === "join";
    const topic = (_room$currentState$ge = room.currentState.getStateEvents(_types_event/* EventType */.tw.RoomTopic, "")) === null || _room$currentState$ge === void 0 ? void 0 : (_room$currentState$ge2 = _room$currentState$ge.getContent()) === null || _room$currentState$ge2 === void 0 ? void 0 : _room$currentState$ge2.topic;
    const canAddTopic = inRoom && room.currentState.maySendStateEvent(_types_event/* EventType */.tw.RoomTopic, cli.getUserId());
    const onTopicClick = () => {
      dispatcher/* default */.ZP.dispatch({
        action: "open_room_settings",
        room_id: roomId
      }, true);
      // focus the topic field to help the user find it as it'll gain an outline
      setImmediate(() => {
        window.document.getElementById("profileTopic").focus();
      });
    };
    let topicText;
    if (canAddTopic && topic) {
      topicText = (0,languageHandler._t)("Topic: %(topic)s (<a>edit</a>)", {
        topic
      }, {
        a: sub => /*#__PURE__*/react.createElement(elements_AccessibleButton/* default */.Z, {
          kind: "link",
          onClick: onTopicClick
        }, sub)
      });
    } else if (topic) {
      topicText = (0,languageHandler._t)("Topic: %(topic)s ", {
        topic
      });
    } else if (canAddTopic) {
      topicText = (0,languageHandler._t)("<a>Add a topic</a> to help people know what it is about.", {}, {
        a: sub => /*#__PURE__*/react.createElement(elements_AccessibleButton/* default */.Z, {
          kind: "link",
          onClick: onTopicClick
        }, sub)
      });
    }
    const creator = (_room$currentState$ge3 = room.currentState.getStateEvents(_types_event/* EventType */.tw.RoomCreate, "")) === null || _room$currentState$ge3 === void 0 ? void 0 : _room$currentState$ge3.getSender();
    const creatorName = (room === null || room === void 0 ? void 0 : (_room$getMember = room.getMember(creator)) === null || _room$getMember === void 0 ? void 0 : _room$getMember.name) || creator;
    const isDM = room === null || room === void 0 ? void 0 : room.isDmRoom();
    const isGroup = room === null || room === void 0 ? void 0 : room.isGroup();
    let createdText;
    if (creator === cli.getUserId()) {
      createdText = isDM ? "" : (0,languageHandler._t)(`You created this ${isGroup ? "group" : "channel"}.`);
    } else {
      createdText = isDM ? "" : (0,languageHandler._t)(`%(displayName)s created this ${isGroup ? "group" : "channel"}.`, {
        displayName: creatorName
      });
    }
    let parentSpace;
    if ((_SpaceStore$instance$ = SpaceStore/* default */.ZP.instance.activeSpace) !== null && _SpaceStore$instance$ !== void 0 && _SpaceStore$instance$.canInvite(cli.getUserId()) && SpaceStore/* default */.ZP.instance.getSpaceFilteredRoomIds(SpaceStore/* default */.ZP.instance.activeSpace).has(room.roomId)) {
      parentSpace = SpaceStore/* default */.ZP.instance.activeSpace;
    }
    let buttons;
    if (parentSpace) {
      buttons = /*#__PURE__*/react.createElement("div", {
        className: "mx_NewRoomIntro_buttons"
      }, room.canInvite(cli.getUserId()) && /*#__PURE__*/react.createElement(elements_AccessibleButton/* default */.Z, {
        className: "mx_NewRoomIntro_inviteButton",
        kind: "primary_outline",
        onClick: () => {
          dispatcher/* default */.ZP.dispatch({
            action: "view_invite",
            roomId
          });
        }
      }, (0,languageHandler._t)("Invite to this channel")));
    } else if (room.canInvite(cli.getUserId())) {
      buttons = /*#__PURE__*/react.createElement("div", {
        className: "mx_NewRoomIntro_buttons"
      }, /*#__PURE__*/react.createElement(elements_AccessibleButton/* default */.Z, {
        className: "mx_NewRoomIntro_inviteButton",
        kind: "primary",
        onClick: () => {
          dispatcher/* default */.ZP.dispatch({
            action: "view_invite",
            roomId
          });
        }
      }, room.hasSpaceParent() ? (0,languageHandler._t)("Invite to this channel") : (0,languageHandler._t)("Invite to this group")));
    }

    // const avatarUrl = room.currentState.getStateEvents(EventType.RoomAvatar, "")?.getContent()?.url;
    body = /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(RoomAvatar/* default */.Z, {
      style: {
        borderRadius: room.isDmRoom() ? "50%" : "7px"
      },
      room: room,
      size: AVATAR_SIZE
    }), /*#__PURE__*/react.createElement(RoomName/* default */.Z, {
      room: room
    }, (name, remark) => /*#__PURE__*/react.createElement("h2", null, remark || name)), /*#__PURE__*/react.createElement("div", {
      className: "mx_EventTile_line mx_TextualEvent",
      "data-notices": "beginning"
    }, createdText, " ", (0,languageHandler._t)(`This is the beginning of  ${isDM ? "DM" : isGroup ? "group" : "channel"} chat ${isDM ? "with" : "in"} <roomName/>.`, {}, {
      roomName: () => /*#__PURE__*/react.createElement(RoomName/* default */.Z, {
        room: room
      })
    })), /*#__PURE__*/react.createElement("div", {
      className: "mx_EventTile_line mx_TextualEvent"
    }, topicText), buttons);
  }
  function openRoomSettings(event) {
    event.preventDefault();
    dispatcher/* default */.ZP.dispatch({
      action: "open_room_settings",
      initial_tab_id: ROOM_SECURITY_TAB
    });
  }
  const subText = (0,languageHandler._t)("Your private messages are normally encrypted, but this room isn't. " + "Usually this is due to an unsupported device or method being used, " + "like email invites.");
  let subButton;
  if (room.currentState.mayClientSendStateEvent(_types_event/* EventType */.tw.RoomEncryption, MatrixClientPeg/* MatrixClientPeg */.p.get())) {
    subButton = /*#__PURE__*/react.createElement("a", {
      onClick: openRoomSettings,
      href: "#"
    }, " ", (0,languageHandler._t)("Enable encryption in settings."));
  }
  const subtitle = /*#__PURE__*/react.createElement("span", null, " ", subText, " ", subButton, " ");
  return /*#__PURE__*/react.createElement("div", {
    className: "mx_NewRoomIntro"
  }, !hasExpectedEncryptionSettings(cli, room) && /*#__PURE__*/react.createElement(EventTileBubble["default"], {
    className: "mx_cryptoEvent mx_cryptoEvent_icon_warning",
    title: (0,languageHandler._t)("End-to-end encryption isn't enabled"),
    subtitle: subtitle
  }), body);
};
/* harmony default export */ const rooms_NewRoomIntro = (NewRoomIntro);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/hooks/useStateToggle.ts
var useStateToggle = __webpack_require__(681638);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/elements/EventListSummary.tsx
/*
Copyright 2019, 2020 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/







const EventListSummary = ({
  events,
  children,
  threshold = 3,
  onToggle,
  startExpanded,
  summaryMembers = [],
  summaryText,
  externalText,
  layout,
  showFirstEvent,
  summaryEventAlign,
  sunmaryType,
  enableCollapse
}) => {
  const eventIds = events.map(e => e.getId()).join(",");
  if (!enableCollapse) {
    return /*#__PURE__*/react.createElement("li", {
      className: classnames_default()({
        mx_EventListSummary: true,
        [`mx_EventListSummary_${sunmaryType}`]: sunmaryType
      }),
      "data-scroll-tokens": eventIds,
      "data-expanded": true,
      "data-layout": layout,
      "data-align": summaryEventAlign
    }, children);
  }
  const [expanded, toggleExpanded] = (0,useStateToggle/* useStateToggle */.R)(startExpanded);

  // Whenever expanded changes call onToggle
  (0,react.useEffect)(() => {
    if (onToggle) {
      onToggle();
    }
  }, [expanded]); // eslint-disable-line react-hooks/exhaustive-deps

  // If we are only given few events then just pass them through
  if (events.length < threshold) {
    return /*#__PURE__*/react.createElement("li", {
      className: classnames_default()({
        mx_EventListSummary: true,
        [`mx_EventListSummary_${sunmaryType}`]: sunmaryType
      }),
      "data-scroll-tokens": eventIds,
      "data-expanded": true,
      "data-layout": layout,
      "data-align": summaryEventAlign
    }, children);
  }
  let body;
  if (expanded) {
    body = /*#__PURE__*/react.createElement(react.Fragment, null, children);
  } else if (showFirstEvent) {
    body = /*#__PURE__*/react.createElement(react.Fragment, null, children[0]);
  } else {
    // const avatars = summaryMembers.map((m, index) => (
    //     <MemberAvatar
    //         key={m.userId + index}
    //         member={m}
    //         width={14}
    //         height={14}
    //     />
    // ));
    body = /*#__PURE__*/react.createElement("div", {
      className: "mx_EventTile_line"
    }, /*#__PURE__*/react.createElement("div", {
      className: "mx_EventTile_info"
    }, /*#__PURE__*/react.createElement("span", {
      className: "mx_TextualEvent mx_EventListSummary_summary"
    }, summaryText), externalText ? /*#__PURE__*/react.createElement("span", {
      className: "mx_TextualEvent"
    }, externalText) : null));
  }
  const classes = classnames_default()({
    mx_EventListSummary: true,
    [`mx_EventListSummary_${sunmaryType}`]: sunmaryType
  });
  return /*#__PURE__*/react.createElement(react.Fragment, null, sunmaryType === "EncryptMessage" ? /*#__PURE__*/react.createElement("li", {
    key: eventIds,
    className: classes,
    "data-align": summaryEventAlign,
    "data-scroll-tokens": eventIds,
    "data-layout": layout,
    "data-expanded": expanded + ""
  }, body, /*#__PURE__*/react.createElement("div", {
    className: `mx_EventListSummary_summary ${expanded ? "expand" : "collapse"}`
  }, !expanded ? /*#__PURE__*/react.createElement("span", {
    className: "mx_EventListSummary_SummaryText"
  }, summaryText) : null, /*#__PURE__*/react.createElement(elements_AccessibleButton/* default */.Z, {
    className: "mx_EventListSummary_toggle",
    onClick: toggleExpanded,
    "aria-expanded": expanded
  }, expanded ? (0,languageHandler._t)("collapse") : (0,languageHandler._t)("expand")))) : /*#__PURE__*/react.createElement("li", {
    key: eventIds,
    className: classes,
    "data-align": summaryEventAlign,
    "data-scroll-tokens": eventIds,
    "data-expanded": expanded + "",
    "data-layout": layout
  }, /*#__PURE__*/react.createElement(elements_AccessibleButton/* default */.Z, {
    className: "mx_EventListSummary_toggle",
    onClick: toggleExpanded,
    "aria-expanded": expanded
  }, expanded ? (0,languageHandler._t)("collapse") : (0,languageHandler._t)("expand")), body));
};
EventListSummary.defaultProps = {
  startExpanded: false,
  layout: Layout/* Layout */.A.Group
};
/* harmony default export */ const elements_EventListSummary = (EventListSummary);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/TextForEvent.tsx
var TextForEvent = __webpack_require__(565597);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/structures/groupers/CreationGrouper.tsx

// Wrap initial room creation events into an EventListSummary
// Grouping only events sent by the same user that sent the `m.room.create` and only until













// the first non-state event or membership event which is not regarding the sender of the `m.room.create` event
class CreationGrouper extends BaseGrouper {
  shouldGroup(ev) {
    const panel = this.panel;
    const createEvent = this.event;
    if (!panel.shouldShowEvent(ev)) {
      return true;
    }
    if (panel.wantsDateSeparator(this.event, ev.getDate())) {
      return false;
    }
    if (ev.getType() === _types_event/* EventType */.tw.RoomMember && (ev.getStateKey() !== createEvent.getSender() || ev.getContent()["membership"] !== "join")) {
      return false;
    }
    if (ev.isState() && ev.getSender() === createEvent.getSender()) {
      return true;
    }
    return false;
  }
  add(ev) {
    const panel = this.panel;
    this.readMarker = this.readMarker || panel.readMarkerForEvent(ev.getId(), ev === this.lastShownEvent);
    if (!panel.shouldShowEvent(ev)) {
      return;
    }
    if (ev.getType() === _types_event/* EventType */.tw.RoomEncryption) {
      this.ejectedEvents.push(ev);
    } else {
      this.events.push(ev);
    }
  }
  getTiles() {
    // If we don't have any events to group, don't even try to group them. The logic
    // below assumes that we have a group of events to deal with, but we might not if
    // the events we were supposed to group were redacted.
    if (!this.events || !this.events.length) return [];
    // Get sender profile from the latest event in the summary as the m.room.create doesn't contain one
    const ev = this.events[this.events.length - 1];
    const room = MatrixClientPeg/* MatrixClientPeg */.p.get().getRoom(ev.getRoomId());
    const isSaveMessageRoom = room === null || room === void 0 ? void 0 : room.isSaveMessageRoom();
    if (isSaveMessageRoom) return [];
    const panel = this.panel;
    const ret = [];
    const isGrouped = true;
    const createEvent = this.event;
    const lastShownEvent = this.lastShownEvent;
    if (panel.wantsDateSeparator(this.prevEvent, createEvent.getDate())) {
      const ts = createEvent.getTs();
      ret.push( /*#__PURE__*/react.createElement("li", {
        key: ts + "~"
      }, /*#__PURE__*/react.createElement(DateSeparator["default"], {
        key: ts + "~",
        ts: ts
      })));
    }

    // If this m.room.create event should be shown (room upgrade) then show it before the summary
    if (panel.shouldShowEvent(createEvent)) {
      // pass in the createEvent as prevEvent as well so no extra DateSeparator is rendered
      ret.push(...panel.getTilesForEvent(createEvent, createEvent));
    }
    for (const ejected of this.ejectedEvents) {
      ret.push(...panel.getTilesForEvent(createEvent, ejected, createEvent === lastShownEvent, isGrouped));
    }
    const eventTiles = this.events.map(e => {
      // In order to prevent DateSeparators from appearing in the expanded form
      // of EventListSummary, render each member event as if the previous
      // one was itself. This way, the timestamp of the previous event === the
      // timestamp of the current event, and no DateSeparator is inserted.
      return panel.getTilesForEvent(e, e, e === lastShownEvent, isGrouped, undefined, undefined, "div");
    }).reduce((a, b) => a.concat(b), []);
    let summaryText;
    let externalText = `Please note that members who join later will see messages.`;
    const roomId = ev.getRoomId();
    const creator = (0,TextForEvent/* getDisplayName */.Gf)(ev.sender, ev) || ev.getSender();
    if (DMRoomMap/* default */.Z.shared().getUserIdForRoomId(roomId)) {
      summaryText = (0,languageHandler._t)("<a>%(creator)s</a> created this invited only DM chat. ", {
        creator
      }, {
        a: sub => /*#__PURE__*/react.createElement(DisplayName/* default */.Z, {
          displayName: sub,
          member: ev.sender
        })
      });
    } else {
      summaryText = (0,languageHandler._t)(`<a>%(creator)s</a> created this invited only ${room !== null && room !== void 0 && room.hasSpaceParent() ? "channel" : "group"} chat.`, {
        creator
      }, {
        a: sub => {
          return /*#__PURE__*/react.createElement(DisplayName/* default */.Z, {
            displayName: sub,
            member: ev.sender
          });
        }
      });
    }
    if (!isSaveMessageRoom) {
      ret.push( /*#__PURE__*/react.createElement("li", null, /*#__PURE__*/react.createElement(rooms_NewRoomIntro, {
        key: "newroomintro"
      })));
    }
    if (!isSaveMessageRoom) {
      var _panel$props$room;
      ret.push( /*#__PURE__*/react.createElement(elements_EventListSummary, {
        key: "roomcreationsummary",
        events: this.events,
        enableCollapse: false,
        onToggle: panel.onHeightChanged // Update scroll state
        ,
        summaryMembers: [((_panel$props$room = panel.props.room) === null || _panel$props$room === void 0 ? void 0 : _panel$props$room.getMember(ev.sender.userId)) || ev.sender],
        summaryText: summaryText,
        externalText: externalText,
        layout: this.layout,
        sunmaryType: "RoomCreation"
      }, eventTiles));
    }
    if (this.readMarker) {
      ret.push(this.readMarker);
    }
    return ret;
  }
  getNewPrevEvent() {
    return this.event;
  }
}
(0,defineProperty/* default */.Z)(CreationGrouper, "canStartGroup", function (panel, ev) {
  return ev.getType() === _types_event/* EventType */.tw.RoomCreate;
});
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/utils/FormattingUtils.ts
var FormattingUtils = __webpack_require__(960882);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/RoomInvite.tsx + 1 modules
var RoomInvite = __webpack_require__(106579);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/utils/ReactUtils.tsx
var ReactUtils = __webpack_require__(792629);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/elements/MemberEventListSummary.tsx

var MemberEventListSummary_dec, MemberEventListSummary_class, MemberEventListSummary_class2;
/*
Copyright 2016 OpenMarket Ltd
Copyright 2019, 2020 The Matrix.org Foundation C.I.C.
Copyright 2019 Michael Telatynski <7t3chguy@gmail.com>

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/














const onPinnedMessagesClick = () => {
  dispatcher/* default */.ZP.dispatch({
    action: actions/* Action */.a.SetRightPanelPhase,
    phase: RightPanelStorePhases/* RightPanelPhases */.q4.PinnedMessages,
    allowClose: false
  });
};
const SENDER_AS_DISPLAY_NAME_EVENTS = [_types_event/* EventType */.tw.RoomServerAcl, _types_event/* EventType */.tw.RoomPinnedEvents];
var TransitionType = /*#__PURE__*/function (TransitionType) {
  TransitionType["Joined"] = "joined";
  TransitionType["Left"] = "left";
  TransitionType["JoinedAndLeft"] = "joined_and_left";
  TransitionType["LeftAndJoined"] = "left_and_joined";
  TransitionType["InviteReject"] = "invite_reject";
  TransitionType["InviteWithdrawal"] = "invite_withdrawal";
  TransitionType["Invited"] = "invited";
  TransitionType["Banned"] = "banned";
  TransitionType["Unbanned"] = "unbanned";
  TransitionType["Kicked"] = "kicked";
  TransitionType["ChangedName"] = "changed_name";
  TransitionType["ChangedAvatar"] = "changed_avatar";
  TransitionType["NoChange"] = "no_change";
  TransitionType["ServerAcl"] = "server_acl";
  TransitionType["ChangedPins"] = "pinned_messages";
  return TransitionType;
}(TransitionType || {});
const SEP = ",";
let MemberEventListSummary = (MemberEventListSummary_dec = (0,replaceableComponent/* replaceableComponent */.U)("views.elements.MemberEventListSummary"), MemberEventListSummary_dec(MemberEventListSummary_class = (MemberEventListSummary_class2 = class MemberEventListSummary extends react.Component {
  shouldComponentUpdate(nextProps) {
    // Update if
    //  - The number of summarised events has changed
    //  - or if the summary is about to toggle to become collapsed
    //  - or if there are fewEvents, meaning the child eventTiles are shown as-is
    return nextProps.events.length !== this.props.events.length || nextProps.events.length < this.props.threshold;
  }

  /**
   * Generate the text for users aggregated by their transition sequences (`eventAggregates`) where
   * the sequences are ordered by `orderedTransitionSequences`.
   * @param {object} eventAggregates a map of transition sequence to array of user display names
   * or user IDs.
   * @param {string[]} orderedTransitionSequences an array which is some ordering of
   * `Object.keys(eventAggregates)`.
   * @returns {string} the textual summary of the aggregated events that occurred.
   */
  generateSummary(eventAggregates, orderedTransitionSequences, nodes) {
    const summaries = orderedTransitionSequences.map(transitions => {
      const userNames = eventAggregates[transitions];
      const nameList = this.renderNameList(userNames);
      if (nodes[transitions]) {
        return (0,languageHandler._t)('%(nameList)s %(transitionList)s', {
          nameList,
          transitionList: nodes[transitions]
        });
      }
      const splitTransitions = transitions.split(SEP);

      // Some neighbouring transitions are common, so canonicalise some into "pair"
      // transitions
      const canonicalTransitions = MemberEventListSummary.getCanonicalTransitions(splitTransitions);
      // Transform into consecutive repetitions of the same transition (like 5
      // consecutive 'joined_and_left's)
      const coalescedTransitions = MemberEventListSummary.coalesceRepeatedTransitions(canonicalTransitions);
      const descs = coalescedTransitions.map(t => {
        return MemberEventListSummary.getDescriptionForTransition(t.transitionType, userNames.length, t.repeats);
      });
      const desc = (0,FormattingUtils/* formatCommaSeparatedList */.Tg)(descs);
      return (0,languageHandler._t)('%(nameList)s %(transitionList)s', {
        nameList,
        transitionList: desc
      });
    });
    if (!summaries) {
      return null;
    }
    return (0,ReactUtils/* jsxJoin */.e)(summaries, ", ");
  }

  /**
   * @param {string[]} users an array of user display names or user IDs.
   * @returns {string} a comma-separated list that ends with "and [n] others" if there are
   * more items in `users` than `this.props.summaryLength`, which is the number of names
   * included before "and [n] others".
   */
  renderNameList(users) {
    return (0,FormattingUtils/* formatCommaSeparatedList */.Tg)(users, this.props.summaryLength);
  }

  /**
   * Canonicalise an array of transitions such that some pairs of transitions become
   * single transitions. For example an input ['joined','left'] would result in an output
   * ['joined_and_left'].
   * @param {string[]} transitions an array of transitions.
   * @returns {string[]} an array of transitions.
   */
  static getCanonicalTransitions(transitions) {
    const modMap = {
      [TransitionType.Joined]: {
        after: TransitionType.Left,
        newTransition: TransitionType.JoinedAndLeft
      },
      [TransitionType.Left]: {
        after: TransitionType.Joined,
        newTransition: TransitionType.LeftAndJoined
      }
      // $currentTransition : {
      //     'after' : $nextTransition,
      //     'newTransition' : 'new_transition_type',
      // },
    };

    const res = [];
    for (let i = 0; i < transitions.length; i++) {
      const t = transitions[i];
      const t2 = transitions[i + 1];
      let transition = t;
      if (i < transitions.length - 1 && modMap[t] && modMap[t].after === t2) {
        transition = modMap[t].newTransition;
        i++;
      }
      res.push(transition);
    }
    return res;
  }

  /**
   * Transform an array of transitions into an array of transitions and how many times
   * they are repeated consecutively.
   *
   * An array of 123 "joined_and_left" transitions, would result in:
   * ```
   * [{
   *   transitionType: "joined_and_left"
   *   repeats: 123
   * }]
   * ```
   * @param {string[]} transitions the array of transitions to transform.
   * @returns {object[]} an array of coalesced transitions.
   */
  static coalesceRepeatedTransitions(transitions) {
    const res = [];
    for (let i = 0; i < transitions.length; i++) {
      if (res.length > 0 && res[res.length - 1].transitionType === transitions[i]) {
        res[res.length - 1].repeats += 1;
      } else {
        res.push({
          transitionType: transitions[i],
          repeats: 1
        });
      }
    }
    return res;
  }

  /**
   * For a certain transition, t, describe what happened to the users that
   * underwent the transition.
   * @param {string} t the transition type.
   * @param {number} userCount number of usernames
   * @param {number} repeats the number of times the transition was repeated in a row.
   * @returns {string} the written Human Readable equivalent of the transition.
   */
  static getDescriptionForTransition(t, userCount, repeats) {
    // The empty interpolations 'severalUsers' and 'oneUser'
    // are there only to show translators to non-English languages
    // that the verb is conjugated to plural or singular Subject.
    let res = null;
    switch (t) {
      case "joined":
        res = userCount > 1 ? (0,languageHandler._t)("%(severalUsers)sjoined %(count)s times", {
          severalUsers: "",
          count: repeats
        }) : (0,languageHandler._t)("%(oneUser)sjoined %(count)s times", {
          oneUser: "",
          count: repeats
        });
        break;
      case "left":
        res = userCount > 1 ? (0,languageHandler._t)("%(severalUsers)sleft %(count)s times", {
          severalUsers: "",
          count: repeats
        }) : (0,languageHandler._t)("%(oneUser)sleft %(count)s times", {
          oneUser: "",
          count: repeats
        });
        break;
      case "joined_and_left":
        res = userCount > 1 ? (0,languageHandler._t)("%(severalUsers)sjoined and left %(count)s times", {
          severalUsers: "",
          count: repeats
        }) : (0,languageHandler._t)("%(oneUser)sjoined and left %(count)s times", {
          oneUser: "",
          count: repeats
        });
        break;
      case "left_and_joined":
        res = userCount > 1 ? (0,languageHandler._t)("%(severalUsers)sleft and rejoined %(count)s times", {
          severalUsers: "",
          count: repeats
        }) : (0,languageHandler._t)("%(oneUser)sleft and rejoined %(count)s times", {
          oneUser: "",
          count: repeats
        });
        break;
      case "invite_reject":
        res = userCount > 1 ? (0,languageHandler._t)("%(severalUsers)srejected their invitations %(count)s times", {
          severalUsers: "",
          count: repeats
        }) : (0,languageHandler._t)("%(oneUser)srejected their invitation %(count)s times", {
          oneUser: "",
          count: repeats
        });
        break;
      case "invite_withdrawal":
        res = userCount > 1 ? (0,languageHandler._t)("%(severalUsers)shad their invitations withdrawn %(count)s times", {
          severalUsers: "",
          count: repeats
        }) : (0,languageHandler._t)("%(oneUser)shad their invitation withdrawn %(count)s times", {
          oneUser: "",
          count: repeats
        });
        break;
      case "invited":
        res = userCount > 1 ? (0,languageHandler._t)("were invited %(count)s times", {
          count: repeats
        }) : (0,languageHandler._t)("was invited %(count)s times", {
          count: repeats
        });
        break;
      case "banned":
        res = userCount > 1 ? (0,languageHandler._t)("were banned %(count)s times", {
          count: repeats
        }) : (0,languageHandler._t)("was banned %(count)s times", {
          count: repeats
        });
        break;
      case "unbanned":
        res = userCount > 1 ? (0,languageHandler._t)("were unbanned %(count)s times", {
          count: repeats
        }) : (0,languageHandler._t)("was unbanned %(count)s times", {
          count: repeats
        });
        break;
      case "kicked":
        res = userCount > 1 ? (0,languageHandler._t)("were kicked %(count)s times", {
          count: repeats
        }) : (0,languageHandler._t)("was kicked %(count)s times", {
          count: repeats
        });
        break;
      case "changed_name":
        res = userCount > 1 ? (0,languageHandler._t)("%(severalUsers)schanged their name %(count)s times", {
          severalUsers: "",
          count: repeats
        }) : (0,languageHandler._t)("%(oneUser)schanged their name %(count)s times", {
          oneUser: "",
          count: repeats
        });
        break;
      case "changed_avatar":
        res = userCount > 1 ? (0,languageHandler._t)("%(severalUsers)schanged their avatar %(count)s times", {
          severalUsers: "",
          count: repeats
        }) : (0,languageHandler._t)("%(oneUser)schanged their avatar %(count)s times", {
          oneUser: "",
          count: repeats
        });
        break;
      case "no_change":
        res = userCount > 1 ? (0,languageHandler._t)("%(severalUsers)smade no changes %(count)s times", {
          severalUsers: "",
          count: repeats
        }) : (0,languageHandler._t)("%(oneUser)smade no changes %(count)s times", {
          oneUser: "",
          count: repeats
        });
        break;
      case "server_acl":
        res = userCount > 1 ? (0,languageHandler._t)("%(severalUsers)schanged the server ACLs %(count)s times", {
          severalUsers: "",
          count: repeats
        }) : (0,languageHandler._t)("%(oneUser)schanged the server ACLs %(count)s times", {
          oneUser: "",
          count: repeats
        });
        break;
      case "pinned_messages":
        res = userCount > 1 ? (0,languageHandler._t)("%(severalUsers)schanged the <a>pinned messages</a> for the room %(count)s times.", {
          severalUsers: "",
          count: repeats
        }, {
          "a": sub => /*#__PURE__*/react.createElement("a", {
            onClick: onPinnedMessagesClick
          }, " ", sub, " ")
        }) : (0,languageHandler._t)("%(oneUser)schanged the <a>pinned messages</a> for the room %(count)s times.", {
          oneUser: "",
          count: repeats
        }, {
          "a": sub => /*#__PURE__*/react.createElement("a", {
            onClick: onPinnedMessagesClick
          }, " ", sub, " ")
        });
        break;
      default:
        res = t;
    }
    return res;
  }
  static getTransitionSequence(events) {
    return events.map(MemberEventListSummary.getTransition);
  }

  /**
   * Label a given membership event, `e`, where `getContent().membership` has
   * changed for each transition allowed by the Matrix protocol. This attempts to
   * label the membership changes that occur in `../../../TextForEvent.js`.
   * @param {MatrixEvent} e the membership change event to label.
   * @returns {string?} the transition type given to this event. This defaults to `null`
   * if a transition is not recognised.
   */
  static getTransition(e) {
    const type = e.mxEvent.getType();
    if (type === _types_event/* EventType */.tw.RoomThirdPartyInvite) {
      // Handle 3pid invites the same as invites so they get bundled together
      if (!(0,RoomInvite/* isValid3pidInvite */.ih)(e.mxEvent)) {
        return TransitionType.InviteWithdrawal;
      }
      return TransitionType.Invited;
    } else if (type === _types_event/* EventType */.tw.RoomServerAcl) {
      return TransitionType.ServerAcl;
    } else if (type === _types_event/* EventType */.tw.RoomPinnedEvents) {
      return TransitionType.ChangedPins;
    }
    const content = e.mxEvent.getContent();
    if (!content.membership) {
      return content.body;
    }
    switch (e.mxEvent.getContent().membership) {
      case 'invite':
        return TransitionType.Invited;
      case 'ban':
        return TransitionType.Banned;
      case 'join':
        if (e.mxEvent.getPrevContent().membership === 'join') {
          if (e.mxEvent.getContent().displayname !== e.mxEvent.getPrevContent().displayname) {
            return TransitionType.ChangedName;
          } else if (e.mxEvent.getContent().avatar_url !== e.mxEvent.getPrevContent().avatar_url) {
            return TransitionType.ChangedAvatar;
          }
          // console.log("MELS ignoring duplicate membership join event");
          return TransitionType.NoChange;
        } else {
          return TransitionType.Joined;
        }
      case 'leave':
        if (e.mxEvent.getSender() === e.mxEvent.getStateKey()) {
          switch (e.mxEvent.getPrevContent().membership) {
            case 'invite':
              return TransitionType.InviteReject;
            default:
              return TransitionType.Left;
          }
        }
        switch (e.mxEvent.getPrevContent().membership) {
          case 'invite':
            return TransitionType.InviteWithdrawal;
          case 'ban':
            return TransitionType.Unbanned;
          // sender is not target and made the target leave, if not from invite/ban then this is a kick
          default:
            return TransitionType.Kicked;
        }
      default:
        return null;
    }
  }
  getAggregate(userEvents) {
    // A map of aggregate type to arrays of display names. Each aggregate type
    // is a comma-delimited string of transitions, e.g. "joined,left,kicked".
    // The array of display names is the array of users who went through that
    // sequence during eventsToRender.
    const aggregate = {
      // $aggregateType : []:string
    };
    // A map of aggregate types to the indices that order them (the index of
    // the first event for a given transition sequence)
    const aggregateIndices = {
      // $aggregateType : int
    };
    const nodes = {};
    const users = Object.keys(userEvents);
    users.forEach(userId => {
      const firstEvent = userEvents[userId][0];
      const displayName = firstEvent.displayName;
      const seq = MemberEventListSummary.getTransitionSequence(userEvents[userId]).join(SEP);
      if (!aggregate[seq]) {
        aggregate[seq] = [];
        aggregateIndices[seq] = -1;
      }
      aggregate[seq].push(displayName);
      const type = firstEvent.mxEvent.getType();
      if (firstEvent.mxEvent.getType() === _types_event/* EventType */.tw.RoomCustomizedEvents) {
        nodes[seq] = (0,TextForEvent/* summaryForCustomizedEvents */.S3)(firstEvent.mxEvent);
      }
      if (aggregateIndices[seq] === -1 || firstEvent.index < aggregateIndices[seq]) {
        aggregateIndices[seq] = firstEvent.index;
      }
    });
    return {
      names: aggregate,
      nodes,
      indices: aggregateIndices
    };
  }
  render() {
    const eventsToRender = this.props.events;

    // Map user IDs to latest Avatar Member. ES6 Maps are ordered by when the key was created,
    // so this works perfectly for us to match event order whilst storing the latest Avatar Member
    const latestUserAvatarMember = new Map();

    // Object mapping user IDs to an array of IUserEvents
    const userEvents = {};
    eventsToRender.forEach((e, index) => {
      const type = e.getType();
      let userId = type === _types_event/* EventType */.tw.RoomServerAcl ? e.getSender() : e.getStateKey();
      const customizedType = type === _types_event/* EventType */.tw.RoomCustomizedEvents;
      if (!userId && customizedType) {
        userId = `${e.getSender()}___${index}`;
      }
      // Initialise a user's events
      if (!userEvents[userId]) {
        userEvents[userId] = [];
      }
      if (SENDER_AS_DISPLAY_NAME_EVENTS.includes(type)) {
        latestUserAvatarMember.set(userId, e.sender);
      } else if (e.target) {
        latestUserAvatarMember.set(userId, e.target);
      }
      let displayName = userId;
      if (type === _types_event/* EventType */.tw.RoomThirdPartyInvite) {
        displayName = e.getContent().display_name;
      } else if (SENDER_AS_DISPLAY_NAME_EVENTS.includes(type) || customizedType) {
        displayName = (0,TextForEvent/* getDisplayName */.Gf)(e.sender, e) || e.sender.name;
      } else if (e.target) {
        displayName = (0,TextForEvent/* getDisplayName */.Gf)(e.target, e) || e.target.name;
      }
      userEvents[userId].push({
        mxEvent: e,
        displayName,
        index: index
      });
    });
    const aggregate = this.getAggregate(userEvents);

    // Sort types by order of lowest event index within sequence
    const orderedTransitionSequences = Object.keys(aggregate.names).sort((seq1, seq2) => aggregate.indices[seq1] - aggregate.indices[seq2]);
    const summaryText = this.generateSummary(aggregate.names, orderedTransitionSequences, aggregate.nodes);
    return /*#__PURE__*/react.createElement(elements_EventListSummary, {
      events: this.props.events,
      threshold: this.props.threshold,
      onToggle: this.props.onToggle,
      startExpanded: this.props.startExpanded,
      children: this.props.children,
      summaryMembers: [...latestUserAvatarMember.values()],
      layout: this.props.layout,
      summaryText: summaryText,
      sunmaryType: "RoomMembers",
      enableCollapse: false
    });
  }
}, (0,defineProperty/* default */.Z)(MemberEventListSummary_class2, "defaultProps", {
  summaryLength: 1,
  threshold: 3,
  avatarsMaxLength: 5,
  layout: Layout/* Layout */.A.Group
}), MemberEventListSummary_class2)) || MemberEventListSummary_class);

;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/structures/groupers/MemberGrouper.tsx









// Wrap consecutive member events in a ListSummary, ignore if redacted
class MemberGrouper extends BaseGrouper {
  constructor(panel, event, prevEvent, lastShownEvent, layout) {
    super(panel, event, prevEvent, lastShownEvent, layout);
    this.panel = panel;
    this.event = event;
    this.prevEvent = prevEvent;
    this.lastShownEvent = lastShownEvent;
    this.layout = layout;
    this.events = [event];
  }
  shouldGroup(ev) {
    if (this.panel.wantsDateSeparator(this.events[0], ev.getDate())) {
      return false;
    }
    return groupedEvents.includes(ev.getType());
  }
  add(ev, showHiddenEvents) {
    if (ev.getType() === _types_event/* EventType */.tw.RoomMember) {
      // We can ignore any events that don't actually have a message to display
      if (!(0,TextForEvent/* hasText */.bZ)(ev, showHiddenEvents)) return;
    }
    this.readMarker = this.readMarker || this.panel.readMarkerForEvent(ev.getId(), ev === this.lastShownEvent);
    this.events.push(ev);
  }
  getTiles() {
    // If we don't have any events to group, don't even try to group them. The logic
    // below assumes that we have a group of events to deal with, but we might not if
    // the events we were supposed to group were redacted.
    if (!this.events || !this.events.length) return [];
    const isGrouped = true;
    const panel = this.panel;
    const lastShownEvent = this.lastShownEvent;
    const ret = [];
    if (panel.wantsDateSeparator(this.prevEvent, this.events[0].getDate())) {
      const ts = this.events[0].getTs();
      ret.push( /*#__PURE__*/react.createElement("li", {
        key: ts + "~"
      }, /*#__PURE__*/react.createElement(DateSeparator["default"], {
        key: ts + "~",
        ts: ts
      })));
    }

    // Ensure that the key of the MemberEventListSummary does not change with new
    // member events. This will prevent it from being re-created unnecessarily, and
    // instead will allow new props to be provided. In turn, the shouldComponentUpdate
    // method on MELS can be used to prevent unnecessary renderings.
    //
    // Whilst back-paginating with a MELS at the top of the panel, prevEvent will be null,
    // so use the key "membereventlistsummary-initial". Otherwise, use the ID of the first
    // membership event, which will not change during forward pagination.
    const key = "membereventlistsummary-" + (this.prevEvent ? this.events[0].getId() : "initial");
    let highlightInMels;
    let eventTiles = this.events.map(e => {
      if (e.getId() === panel.props.highlightedEventId) {
        highlightInMels = true;
      }
      // In order to prevent DateSeparators from appearing in the expanded form
      // of MemberEventListSummary, render each member event as if the previous
      // one was itself. This way, the timestamp of the previous event === the
      // timestamp of the current event, and no DateSeparator is inserted.
      return panel.getTilesForEvent(e, e, e === lastShownEvent, isGrouped, undefined, undefined, "div");
    }).reduce((a, b) => a.concat(b), []);
    if (eventTiles.length === 0) {
      eventTiles = null;
    }
    ret.push( /*#__PURE__*/react.createElement(MemberEventListSummary, {
      key: key,
      events: this.events,
      onToggle: panel.onHeightChanged // Update scroll state
      ,
      startExpanded: highlightInMels,
      layout: this.layout
    }, eventTiles));
    if (this.readMarker) {
      ret.push(this.readMarker);
    }
    return ret;
  }
  getNewPrevEvent() {
    return this.events[0];
  }
}
(0,defineProperty/* default */.Z)(MemberGrouper, "canStartGroup", function (panel, ev) {
  return panel.shouldShowEvent(ev) && groupedEvents.includes(ev.getType());
});
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/structures/groupers/RedactionGrouper.tsx





class RedactionGrouper extends BaseGrouper {
  constructor(panel, ev, prevEvent, lastShownEvent, layout, nextEvent, nextEventTile) {
    super(panel, ev, prevEvent, lastShownEvent, layout, nextEvent, nextEventTile);
    this.events = [ev];
  }
  shouldGroup(ev) {
    // absorb hidden events so that they do not break up streams of messages & redaction events being grouped
    if (!this.panel.shouldShowEvent(ev)) {
      return true;
    }
    if (this.panel.wantsDateSeparator(this.events[0], ev.getDate())) {
      return false;
    }
    const createEvent = this.event;
    return ev.isRedacted() && createEvent.getSender() === ev.getSender();
    ;
  }
  add(ev) {
    this.readMarker = this.readMarker || this.panel.readMarkerForEvent(ev.getId(), ev === this.lastShownEvent);
    if (!this.panel.shouldShowEvent(ev)) {
      return;
    }
    this.events.push(ev);
  }
  getTiles() {
    var _unsigned$redacted_be;
    if (!this.events || !this.events.length) return [];
    const eventIds = this.events.map(e => e.getId()).join(",");
    let message = (0,languageHandler._t)("Message deleted");
    const unsigned = this.event.getUnsigned();
    const redactedBecauseUserId = unsigned === null || unsigned === void 0 ? void 0 : (_unsigned$redacted_be = unsigned.redacted_because) === null || _unsigned$redacted_be === void 0 ? void 0 : _unsigned$redacted_be.sender;
    let room = MatrixClientPeg/* MatrixClientPeg */.p.get().getRoom(this.event.getRoomId());
    const sender = room === null || room === void 0 ? void 0 : room.getMember(redactedBecauseUserId);
    if (this.events.length > 1) {
      message = (0,languageHandler._t)("%(count)s Messages deleted by %(name)s", {
        count: this.events.length,
        name: (sender === null || sender === void 0 ? void 0 : sender.name) || redactedBecauseUserId
      });
    } else {
      message = (0,languageHandler._t)("Message deleted by %(name)s", {
        name: (sender === null || sender === void 0 ? void 0 : sender.name) || redactedBecauseUserId
      });
    }
    return [/*#__PURE__*/react.createElement("li", {
      key: eventIds,
      className: "mx_EventListSummary",
      "data-scroll-tokens": eventIds,
      "data-layout": this.layout
    }, /*#__PURE__*/react.createElement("div", {
      className: "mx_TextualEvent"
    }, message))];

    // const isGrouped = true;
    // const panel = this.panel;
    // const ret = [];
    // const lastShownEvent = this.lastShownEvent;

    // if (
    //     panel.wantsDateSeparator(this.prevEvent, this.events[0].getDate())
    // ) {
    //     const ts = this.events[0].getTs();
    //     ret.push(
    //         <li key={ts + "~"}>
    //             <DateSeparator key={ts + "~"} ts={ts} />
    //         </li>,
    //     );
    // }

    // const key =
    //     "redactioneventlistsummary-" +
    //     (this.prevEvent ? this.events[0].getId() : "initial");

    // const senders = new Set<RoomMember>();
    // const room = panel.props.room;
    // let eventTiles = this.events
    //     .map((e, i) => {
    //         senders.add(room?.getMember(e.sender.userId) || e.sender);
    //         const prevEvent = i === 0 ? this.prevEvent : this.events[i - 1];
    //         return panel.getTilesForEvent(
    //             prevEvent,
    //             e,
    //             e === lastShownEvent,
    //             isGrouped,
    //             this.nextEvent,
    //             this.nextEventTile,
    //             "div",
    //         );
    //     })
    //     .reduce((a, b) => a.concat(b), []);

    // if (eventTiles.length === 0) {
    //     eventTiles = null;
    // }

    // const isOwnEvent =
    //     this.events[0]?.getSender() === MatrixClientPeg.get().getUserId()
    //         ? true
    //         : false;
    // const summaryEventAlign = isOwnEvent ? "right" : "left";

    // ret.push(
    //     <EventListSummary
    //         key={key}
    //         threshold={2}
    //         events={this.events}
    //         enableCollapse={false}
    //         onToggle={panel.onHeightChanged} // Update scroll state
    //         summaryMembers={Array.from(senders)}
    //         summaryText={_t("%(count)s messages deleted.", {
    //             count: eventTiles.length,
    //         })}
    //         sunmaryType="RoomMessageDeleted"
    //         layout={this.layout}
    //         summaryEventAlign={summaryEventAlign}
    //     >
    //         {eventTiles}
    //     </EventListSummary>,
    // );

    // if (this.readMarker) {
    //     ret.push(this.readMarker);
    // }

    // return ret;
  }

  getNewPrevEvent() {
    return this.events[this.events.length - 1];
  }
}
(0,defineProperty/* default */.Z)(RedactionGrouper, "canStartGroup", function (panel, ev) {
  return panel.shouldShowEvent(ev) && ev.isRedacted();
});
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/structures/groupers/DecryptionFailureGrouper.tsx








// Wrap decrypt message failure events in a ListSummary
class DecryptionFailureGrouper extends BaseGrouper {
  constructor(panel, ev, prevEvent, lastShownEvent, layout, nextEvent, nextEventTile) {
    super(panel, ev, prevEvent, lastShownEvent, layout, nextEvent, nextEventTile);
    this.events = [ev];
  }
  shouldGroup(ev) {
    if (ev.isRedacted()) {
      return false;
    }
    if (!ev.isDecryptionFailure()) {
      return false;
    }
    const createEvent = this.event;
    return createEvent.getSender() === ev.getSender();
  }
  add(ev) {
    this.events.push(ev);
  }
  getTiles() {
    var _this$events$;
    const ret = [];
    const panel = this.panel;
    const lastShownEvent = this.lastShownEvent;
    const ev = this.events[0];
    const isGrouped = this.events.length > 1;
    const key = "DecryptionFailureEventlistSummary-" + (this.prevEvent ? this.events[0].getId() : "initial");
    const isOwnEvent = ((_this$events$ = this.events[0]) === null || _this$events$ === void 0 ? void 0 : _this$events$.getSender()) === MatrixClientPeg/* MatrixClientPeg */.p.get().getUserId() ? true : false;
    const summaryEventAlign = isOwnEvent ? "right" : "left";
    let eventTiles = this.events.map((e, i) => {
      const prevEvent = i === 0 ? this.prevEvent : this.events[i - 1];
      const firstInGroup = i === 0;
      const lastInGroup = i === this.events.length - 1;
      return panel.getTilesForEvent(prevEvent, e, e === lastShownEvent, isGrouped, this.nextEvent, this.nextEventTile, "div", {
        firstInGroup,
        lastInGroup
      });
    }).reduce((a, b) => a.concat(b), []);
    if (eventTiles.length === 0) {
      eventTiles = null;
    }
    if (eventTiles.length === 1) {
      return /*#__PURE__*/react.createElement(react.Fragment, null, eventTiles[0], !panel.state.showBackupEncryptKey ? /*#__PURE__*/react.createElement("li", {
        className: "mx_RoomView_EventEncryptProcess_tip request_key mx_EventTile",
        "data-layout": panel.props.layout,
        "data-self": isOwnEvent
      }, /*#__PURE__*/react.createElement("img", {
        className: "encrypt_tip_icon",
        src: __webpack_require__(595448)
      }), /*#__PURE__*/react.createElement("div", {
        className: "encrypt_tip_content"
      }, /*#__PURE__*/react.createElement("span", null, "This message cannot be decrypted. Please try to request the key again."), /*#__PURE__*/react.createElement(elements_AccessibleButton/* default */.Z, {
        onClick: () => {
          panel.onRequestKeysClick(ev);
        }
      }, "Request key", " "))) : null);
    }
    ret.push( /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(elements_EventListSummary, {
      key: key,
      threshold: 2,
      events: this.events,
      onToggle: panel.onHeightChanged // Update scroll state
      ,
      summaryText: (0,languageHandler._t)("%(count)s messages", {
        count: eventTiles.length
      }),
      summaryEventAlign: summaryEventAlign,
      showFirstEvent: true,
      layout: this.layout,
      enableCollapse: false,
      sunmaryType: "EncryptMessage"
    }, eventTiles), !panel.state.showBackupEncryptKey ? /*#__PURE__*/react.createElement("li", {
      className: "mx_RoomView_EventEncryptProcess_tip request_key mx_EventTile",
      "data-self": isOwnEvent,
      "data-layout": panel.props.layout
    }, /*#__PURE__*/react.createElement("img", {
      className: "encrypt_tip_icon",
      src: __webpack_require__(595448)
    }), /*#__PURE__*/react.createElement("div", {
      className: "encrypt_tip_content"
    }, /*#__PURE__*/react.createElement("span", null, "This message cannot be decrypted. Please try to request the key again."), /*#__PURE__*/react.createElement(elements_AccessibleButton/* default */.Z, {
      onClick: () => {
        panel.onRequestKeysClick(ev);
      }
    }, "Request key", " "))) : null));
    return ret;
  }
  getNewPrevEvent() {
    return this.events[0];
  }
}
(0,defineProperty/* default */.Z)(DecryptionFailureGrouper, "canStartGroup", function (panel, ev) {
  return panel.shouldShowEvent(ev) && ev.isDecryptionFailure() && !ev.isRedacted();
});
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/structures/PinnedMsgBar.tsx + 8 modules
var PinnedMsgBar = __webpack_require__(832227);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/dialogs/ForwardDialog.tsx
var ForwardDialog = __webpack_require__(606510);
// EXTERNAL MODULE: ./node_modules/copy-to-clipboard/index.js
var copy_to_clipboard = __webpack_require__(820640);
var copy_to_clipboard_default = /*#__PURE__*/__webpack_require__.n(copy_to_clipboard);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/structures/SelectorPanel.tsx











const SelectorPanel = props => {
  const cli = (0,react.useContext)(contexts_MatrixClientContext/* default */.Z);
  const mxs = (0,react.useMemo)(() => {
    const res = props.selected.slice();
    if (res.length) {
      res.sort((a, b) => a.getTs() - b.getTs());
    }
    return res;
  }, [props.selected]);
  const getText = () => {
    if (!mxs) return;
    return mxs.reduce((a, mx, index) => {
      const {
        content,
        tag
      } = (0,PinnedMsgBar/* getContentOfMsg */.oG)(mx);
      const sender = (0,PinnedMsgBar/* getDisplayNameFromEvent */.kD)(mx, cli, true);
      a += `➤ ${sender} [${(0,DateUtils/* formatFullDate */.Tu)(new Date(mx.getTs()), false, false)}]\n`;
      if (tag) {
        a += `[${tag}] ${content}\n`;
      } else if (mx.getContent().msgtype === _types_event/* MsgType */.Zw.Card) {
        a += `[${content}] ${(0,PinnedMsgBar/* getContentOfCard */.US)(mx)}\n`;
      } else {
        a += `${content}\n`;
      }
      if (index === mxs.length - 1) {
        return a;
      }
      return a + "\n";
    }, `\n${(0,languageHandler._t)("Forward message")}\n\n`);
  };
  const showForwardDialog = type => {
    if (!mxs) return;
    (0,ForwardDialog/* showForwardDialogWithEvents */.aI)(mxs, type, props.onCancel);
  };
  const onRedactClick = () => {
    dist.SdModal.createDialog({
      title: (0,languageHandler._t)("Confirm Removal"),
      okText: (0,languageHandler._t)("Remove"),
      children: /*#__PURE__*/react.createElement("span", null, (0,languageHandler._t)("Are you sure you wish to remove this event?")),
      onOk: async close => {
        const cli = MatrixClientPeg/* MatrixClientPeg */.p.get();
        close === null || close === void 0 ? void 0 : close();
        mxs.forEach(mx => {
          var _props$room;
          cli.redactEvent((_props$room = props.room) === null || _props$room === void 0 ? void 0 : _props$room.roomId, mx.getId(), undefined);
        });
        props.onCancel();
      }
    });
  };
  return /*#__PURE__*/react.createElement("div", {
    className: "mx_selector_panel"
  }, /*#__PURE__*/react.createElement(dist.SdTooltip, {
    placement: "top",
    title: (0,languageHandler._t)("Close")
  }, /*#__PURE__*/react.createElement(dist.SdButton, {
    className: "mx_selector_panel_close",
    icon: "CloseOutlines",
    onClick: props.onCancel
  })), /*#__PURE__*/react.createElement("div", {
    className: "mx_selector_panel_info"
  }, mxs.length > 1 ? (0,languageHandler._t)("%(count)s messages selected", {
    count: mxs.length
  }) : (0,languageHandler._t)("%(count)s message selected", {
    count: mxs.length
  })), /*#__PURE__*/react.createElement("div", {
    className: "mx_selector_panel_button_group"
  }, /*#__PURE__*/react.createElement(dist.SdTooltip, {
    placement: "top",
    title: (0,languageHandler._t)("Copy")
  }, /*#__PURE__*/react.createElement(dist.SdButton, {
    icon: "CopyOutlines",
    onClick: () => {
      copy_to_clipboard_default()(getText(), {
        onCopy() {
          dist.SdMessage.success((0,languageHandler._t)("Copied to Clipboard"));
        },
        format: "text/plain"
      });
    }
  })), /*#__PURE__*/react.createElement(dist.SdTooltip, {
    placement: "top",
    title: (0,languageHandler._t)("One by One Forward")
  }, /*#__PURE__*/react.createElement(dist.SdButton, {
    icon: "ReplyOutlines",
    onClick: () => showForwardDialog("forward")
  })), /*#__PURE__*/react.createElement(dist.SdTooltip, {
    placement: "top",
    title: (0,languageHandler._t)("Combine Forward")
  }, /*#__PURE__*/react.createElement(dist.SdButton, {
    icon: "ReplymoreOutlines",
    onClick: () => showForwardDialog("forward_combine")
  })), /*#__PURE__*/react.createElement(dist.SdTooltip, {
    placement: "top",
    title: (0,languageHandler._t)("Delete")
  }, /*#__PURE__*/react.createElement(dist.SdButton, {
    className: "mx_selector_panel_delete",
    icon: "DeleteOutLines",
    onClick: onRedactClick
  }))));
};
/* harmony default export */ const structures_SelectorPanel = (SelectorPanel);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/structures/MessagePanel.tsx

var MessagePanel_dec, MessagePanel_class, MessagePanel_class2;
/*
Copyright 2016 - 2021 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

































const CONTINUATION_MAX_INTERVAL = 5 * 60 * 1000; // 5 minutes
const continuedTypes = [_types_event/* EventType */.tw.Sticker, _types_event/* EventType */.tw.RoomMessage];
const groupedEvents = [_types_event/* EventType */.tw.RoomMember, _types_event/* EventType */.tw.RoomThirdPartyInvite, _types_event/* EventType */.tw.RoomServerAcl, _types_event/* EventType */.tw.RoomPinnedEvents, _types_event/* EventType */.tw.RoomCustomizedEvents];

// check if there is a previous event and it has the same sender as this event
// and the types are the same/is in continuedTypes and the time between them is <= CONTINUATION_MAX_INTERVAL
function shouldFormContinuation(prevEvent, mxEvent, showHiddenEvents) {
  // sanity check inputs
  if (!prevEvent || !prevEvent.sender || !mxEvent.sender) return false;
  // check if within the max continuation period
  if (mxEvent.getTs() - prevEvent.getTs() > CONTINUATION_MAX_INTERVAL) return false;

  // As we summarise redactions, do not continue a redacted event onto a non-redacted one and vice-versa
  if (mxEvent.isRedacted() !== prevEvent.isRedacted()) return false;

  // Some events should appear as continuations from previous events of different types.
  if (mxEvent.getType() !== prevEvent.getType() && (!continuedTypes.includes(mxEvent.getType()) || !continuedTypes.includes(prevEvent.getType()))) return false;

  // Check if the sender is the same and hasn't changed their displayname/avatar between these events
  let prevSender, curSender;
  let prevContent = prevEvent.getContent();
  let curContent = mxEvent.getContent();
  if (prevEvent.isSaveMessage()) {
    prevSender = getSenderByContent(prevContent);
  } else {
    prevSender = prevEvent.sender;
  }
  if (mxEvent.isSaveMessage()) {
    curSender = getSenderByContent(curContent);
  } else {
    curSender = mxEvent.sender;
  }
  if (!prevSender || !curSender) return false;
  if (curSender.userId !== prevSender.userId || curSender.name !== prevSender.name || curSender.getMxcAvatarUrl() !== prevEvent.sender.getMxcAvatarUrl()) return false;

  // if we don't have tile for previous event then it was shown by showHiddenEvents and has no SenderProfile
  if (!haveTileForEvent(prevEvent, showHiddenEvents)) return false;
  return true;
}
function checkPositionInGroup(mxEvent, targetEvent, showHiddenEvents) {
  if (!targetEvent || !targetEvent.sender) return true;
  // if we don't have tile for previous event then it was shown by showHiddenEvents and has no SenderProfile
  if (!(0,EventTile/* haveTileForEvent */.K3)(targetEvent, showHiddenEvents)) return true;
  if (Math.abs(mxEvent.getTs() - targetEvent.getTs()) > CONTINUATION_MAX_INTERVAL) return true;
  if (mxEvent.isRedacted() !== targetEvent.isRedacted()) return true;
  if (mxEvent.getType() !== targetEvent.getType() && (!continuedTypes.includes(mxEvent.getType()) || !continuedTypes.includes(targetEvent.getType()))) {
    return true;
  }
  // Check if the sender is the same and hasn't changed their displayname/avatar between these events
  let prevSender, curSender;
  let prevContent = targetEvent.getContent();
  let curContent = mxEvent.getContent();
  if (targetEvent.isSaveMessage()) {
    prevSender = getSenderByContent(prevContent);
  } else {
    prevSender = targetEvent.sender;
  }
  if (mxEvent.isSaveMessage()) {
    curSender = getSenderByContent(curContent);
  } else {
    curSender = mxEvent.sender;
  }
  if (!prevSender || !curSender) return true;
  if (curSender.userId !== prevSender.userId) return true;
  return false;
}
function getSenderByContent(content) {
  var _content$save_message;
  const originRoomId = content === null || content === void 0 ? void 0 : (_content$save_message = content.save_message) === null || _content$save_message === void 0 ? void 0 : _content$save_message.room_id;
  const room = MatrixClientPeg/* MatrixClientPeg */.p.get().getRoom(originRoomId);
  const originUserId = content.save_message.sender;
  const sender = room === null || room === void 0 ? void 0 : room.getMember(originUserId);
  return sender;
}
// all the grouper classes that we use
let groupers = [CreationGrouper, MemberGrouper, RedactionGrouper, DecryptionFailureGrouper];

/* (almost) stateless UI component which builds the event tiles in the room timeline.
 */
let MessagePanel = (MessagePanel_dec = (0,replaceableComponent/* replaceableComponent */.U)("structures.MessagePanel"), MessagePanel_dec(MessagePanel_class = (MessagePanel_class2 = class MessagePanel extends react.Component {
  constructor(props, context) {
    var _this$props$room3, _this$props$room4;
    super(props, context);
    // opaque readreceipt info for each userId; used by ReadReceiptMarker
    // to manage its animations
    (0,defineProperty/* default */.Z)(this, "readReceiptMap", {});
    // Track read receipts by event ID. For each _shown_ event ID, we store
    // the list of read receipts to display:
    //   [
    //       {
    //           userId: string,
    //           member: RoomMember,
    //           ts: number,
    //       },
    //   ]
    // This is recomputed on each render. It's only stored on the component
    // for ease of passing the data around since it's computed in one pass
    // over all events.
    (0,defineProperty/* default */.Z)(this, "readReceiptsByEvent", {});
    // Track read receipts by user ID. For each user ID we've ever shown a
    // a read receipt for, we store an object:
    //   {
    //       lastShownEventId: string,
    //       receipt: {
    //           userId: string,
    //           member: RoomMember,
    //           ts: number,
    //       },
    //   }
    // so that we can always keep receipts displayed by reverting back to
    // the last shown event for that user ID when needed. This may feel like
    // it duplicates the receipt storage in the room, but at this layer, we
    // are tracking _shown_ event IDs, which the JS SDK knows nothing about.
    // This is recomputed on each render, using the data from the previous
    // render as our fallback for any user IDs we can't match a receipt to a
    // displayed event in the current render cycle.
    (0,defineProperty/* default */.Z)(this, "readReceiptsByUserId", {});
    (0,defineProperty/* default */.Z)(this, "showHiddenEventsInTimeline", void 0);
    (0,defineProperty/* default */.Z)(this, "isMounted", false);
    (0,defineProperty/* default */.Z)(this, "readMarkerNode", /*#__PURE__*/(0,react.createRef)());
    (0,defineProperty/* default */.Z)(this, "whoIsTyping", /*#__PURE__*/(0,react.createRef)());
    (0,defineProperty/* default */.Z)(this, "scrollPanel", /*#__PURE__*/(0,react.createRef)());
    (0,defineProperty/* default */.Z)(this, "showTypingNotificationsWatcherRef", void 0);
    (0,defineProperty/* default */.Z)(this, "eventNodes", void 0);
    // A map of <callId, CallEventGrouper>
    (0,defineProperty/* default */.Z)(this, "callEventGroupers", new Map());
    (0,defineProperty/* default */.Z)(this, "membersCount", 0);
    (0,defineProperty/* default */.Z)(this, "dispatcherRef", "");
    (0,defineProperty/* default */.Z)(this, "handleSelected", mx => {
      const current = this.state.currentSelected;
      if (current.includes(mx)) {
        current.splice(current.indexOf(mx), 1);
      } else {
        if (current.length >= 50) {
          // message.error("Exceeded the maximum selectable quantity");
          dist.SdMessage.error("Select up to 50 chat transcripts");
          return;
        }
        current.push(mx);
      }
      this.setState({
        currentSelected: [...current]
      });
    });
    (0,defineProperty/* default */.Z)(this, "onAction", payload => {
      switch (payload.action) {
        case actions/* Action */.a.TurnOnMultiSelection:
          if (payload.openSelectorPanel) {
            this.setState({
              currentSelected: payload.initialSelected,
              multiSelectorVisible: true
            });
          } else {
            this.setState({
              currentSelected: [],
              multiSelectorVisible: false
            });
          }
          break;
        case "DISPLAY_WEBSITE_LINK":
          this.setState({
            displayWebsiteLinkSetting: payload.checked
          });
          break;
      }
    });
    (0,defineProperty/* default */.Z)(this, "handleRoomEventEncryptProcessChange", process => {
      this.setState({
        RoomEventEncryptProcess: process
      });
    });
    (0,defineProperty/* default */.Z)(this, "calculateRoomMembersCount", (ev, state, member) => {
      var _this$props$room;
      if (!member || member.roomId === ((_this$props$room = this.props.room) === null || _this$props$room === void 0 ? void 0 : _this$props$room.roomId)) {
        var _this$props$room2;
        this.membersCount = ((_this$props$room2 = this.props.room) === null || _this$props$room2 === void 0 ? void 0 : _this$props$room2.getMembers().length) || 0;
      }
    });
    (0,defineProperty/* default */.Z)(this, "onShowTypingNotificationsChange", () => {
      this.setState({
        showTypingNotifications: SettingsStore/* default */.C.getValue("showTypingNotifications")
      });
    });
    (0,defineProperty/* default */.Z)(this, "isUnmounting", () => {
      return !this.isMounted;
    });
    (0,defineProperty/* default */.Z)(this, "collectGhostReadMarker", node => {
      if (node) {
        // now the element has appeared, change the style which will trigger the CSS transition
        requestAnimationFrame(() => {
          node.style.width = "10%";
          node.style.opacity = "0";
        });
      }
    });
    (0,defineProperty/* default */.Z)(this, "onGhostTransitionEnd", ev => {
      // we can now clean up the ghost element
      const finishedEventId = ev.target.dataset.eventid;
      this.setState({
        ghostReadMarkers: this.state.ghostReadMarkers.filter(eid => eid !== finishedEventId)
      });
    });
    (0,defineProperty/* default */.Z)(this, "collectEventNode", (eventId, node) => {
      var _node$ref;
      this.eventNodes[eventId] = node === null || node === void 0 ? void 0 : (_node$ref = node.ref) === null || _node$ref === void 0 ? void 0 : _node$ref.current;
    });
    // once dynamic content in the events load, make the scrollPanel check the
    // scroll offsets.
    (0,defineProperty/* default */.Z)(this, "onHeightChanged", () => {
      const scrollPanel = this.scrollPanel.current;
      if (scrollPanel) {
        scrollPanel.checkScroll();
      }
    });
    (0,defineProperty/* default */.Z)(this, "onTypingShown", () => {
      const scrollPanel = this.scrollPanel.current;
      // this will make the timeline grow, so checkScroll
      scrollPanel.checkScroll();
      if (scrollPanel && scrollPanel.getScrollState().stuckAtBottom) {
        scrollPanel.preventShrinking();
      }
    });
    (0,defineProperty/* default */.Z)(this, "onTypingHidden", () => {
      const scrollPanel = this.scrollPanel.current;
      if (scrollPanel) {
        // as hiding the typing notifications doesn't
        // update the scrollPanel, we tell it to apply
        // the shrinking prevention once the typing notifs are hidden
        scrollPanel.updatePreventShrinking();
        // order is important here as checkScroll will scroll down to
        // reveal added padding to balance the notifs disappearing.
        scrollPanel.checkScroll();
      }
    });
    (0,defineProperty/* default */.Z)(this, "onBackupEncryptKey", () => {
      const payload = {
        action: actions/* Action */.a.ViewUserSettings,
        initialTabId: UserSettingsDialog/* UserTab */.oX.RoomKeys,
        isShotCut: true
      };
      dispatcher/* default */.ZP.dispatch(payload);
    });
    (0,defineProperty/* default */.Z)(this, "onRequestKeysClick", ev => {
      MatrixClientPeg/* MatrixClientPeg */.p.get().cancelAndResendEventRoomKeyRequest(ev);
      dist.SdMessage.success((0,languageHandler._t)("Request key sent"));
    });
    (0,defineProperty/* default */.Z)(this, "renderEventEncryptProcess", () => {
      if (!this.state.isRoomEncrypted) return null;
      if (this.state.showBackupEncryptKey) {
        return /*#__PURE__*/react.createElement("li", {
          className: "mx_RoomView_EventEncryptProcess_tip",
          key: "renderEventEncryptProcess1"
        }, /*#__PURE__*/react.createElement("img", {
          className: "encrypt_tip_icon",
          src: __webpack_require__(298121)
        }), /*#__PURE__*/react.createElement("div", {
          className: "encrypt_tip_content"
        }, /*#__PURE__*/react.createElement("span", null, "Due to the destruction of the encryption key, the above message cannot be decrypted. In order to avoid the inability to decrypt new messages, please make sure to backup the encryption key."), /*#__PURE__*/react.createElement(elements_AccessibleButton/* default */.Z, {
          onClick: this.onBackupEncryptKey
        }, "Backup encryption key")));
      } else if (this.state.RoomEventEncryptProcess == browser_index/* EventEncryptProcess */.Yp.Start) {
        return /*#__PURE__*/react.createElement("li", {
          className: "mx_RoomView_EventEncryptProcess_tip",
          key: "renderEventEncryptProcess2"
        }, /*#__PURE__*/react.createElement("img", {
          className: "encrypt_tip_icon",
          src: __webpack_require__(816996)
        }), /*#__PURE__*/react.createElement("div", {
          className: "encrypt_tip_content"
        }, /*#__PURE__*/react.createElement("span", null, "The encryption key is on the way, please wait. It will be soon decrypted.")));
      }
      return null;
    });
    (0,defineProperty/* default */.Z)(this, "onCloseSelectorPanel", () => {
      dispatcher/* default */.ZP.dispatch({
        action: actions/* Action */.a.TurnOnMultiSelection,
        initialSelected: [],
        openSelectorPanel: false
      });
    });
    const displayLinksSetting = SettingsStore/* default */.C.getValue("displayWhiteListWebsiteLink");
    const client = MatrixClientPeg/* MatrixClientPeg */.p.get();
    const roomId = (_this$props$room3 = this.props.room) === null || _this$props$room3 === void 0 ? void 0 : _this$props$room3.roomId;
    this.state = {
      // previous positions the read marker has been in, so we can
      // display 'ghost' read markers that are animating away
      ghostReadMarkers: [],
      showTypingNotifications: SettingsStore/* default */.C.getValue("showTypingNotifications"),
      multiSelectorVisible: false,
      currentSelected: [],
      displayWebsiteLinkSetting: displayLinksSetting,
      showBackupEncryptKey: false,
      RoomEventEncryptProcess: null,
      isRoomEncrypted: roomId ? client.isRoomEncrypted(roomId) : false
    };

    // Cache hidden events setting on mount since Settings is expensive to
    // query, and we check this in a hot code path. This is also cached in
    // our RoomContext, however we still need a fallback for roomless MessagePanels.
    this.showHiddenEventsInTimeline = SettingsStore/* default */.C.getValue("showHiddenEventsInTimeline");
    this.showTypingNotificationsWatcherRef = SettingsStore/* default */.C.watchSetting("showTypingNotifications", null, this.onShowTypingNotificationsChange);
    const isRoomEncrypted = MatrixClientPeg/* MatrixClientPeg */.p.get().isRoomEncrypted((_this$props$room4 = this.props.room) === null || _this$props$room4 === void 0 ? void 0 : _this$props$room4.roomId);
    if (isRoomEncrypted) {
      MatrixClientPeg/* MatrixClientPeg */.p.get().exportRoomKeys().then(keys => {
        if ((keys === null || keys === void 0 ? void 0 : keys.length) === 0) {
          this.setState({
            showBackupEncryptKey: true
          });
        }
      });
    }
  }
  componentDidMount() {
    var _this$props, _this$props$room5;
    this.calculateRoomMembersCount();
    MatrixClientPeg/* MatrixClientPeg */.p.get().on("RoomState.members", this.calculateRoomMembersCount);
    (_this$props = this.props) === null || _this$props === void 0 ? void 0 : (_this$props$room5 = _this$props.room) === null || _this$props$room5 === void 0 ? void 0 : _this$props$room5.on("Room.eventEncryptProcessChange", this.handleRoomEventEncryptProcessChange);
    // if (SettingsStore.getValue("feature_thread")) {
    //     this.props.room?.getThreads().forEach(thread => thread.fetchReplyChain());
    // }
    this.isMounted = true;
    this.dispatcherRef = dispatcher/* default */.ZP.register(this.onAction);
  }
  componentWillUnmount() {
    var _this$props2, _this$props2$room;
    this.isMounted = false;
    MatrixClientPeg/* MatrixClientPeg */.p.get().off("RoomState.members", this.calculateRoomMembersCount);
    SettingsStore/* default */.C.unwatchSetting(this.showTypingNotificationsWatcherRef);
    if (this.dispatcherRef) {
      dispatcher/* default */.ZP.unregister(this.dispatcherRef);
    }
    (_this$props2 = this.props) === null || _this$props2 === void 0 ? void 0 : (_this$props2$room = _this$props2.room) === null || _this$props2$room === void 0 ? void 0 : _this$props2$room.off("Room.eventEncryptProcessChange", this.handleRoomEventEncryptProcessChange);
  }
  componentDidUpdate(prevProps, prevState) {
    if (prevProps.readMarkerVisible && this.props.readMarkerEventId !== prevProps.readMarkerEventId) {
      const ghostReadMarkers = this.state.ghostReadMarkers;
      ghostReadMarkers.push(prevProps.readMarkerEventId);
      this.setState({
        ghostReadMarkers
      });
    }
  }
  /* get the DOM node representing the given event */
  getNodeForEventId(eventId) {
    if (!this.eventNodes) {
      return undefined;
    }
    return this.eventNodes[eventId];
  }

  /* return true if the content is fully scrolled down right now; else false.
   */
  isAtBottom() {
    var _this$scrollPanel$cur;
    return (_this$scrollPanel$cur = this.scrollPanel.current) === null || _this$scrollPanel$cur === void 0 ? void 0 : _this$scrollPanel$cur.isAtBottom();
  }

  /* get the current scroll state. See ScrollPanel.getScrollState for
   * details.
   *
   * returns null if we are not mounted.
   */
  getScrollState() {
    var _this$scrollPanel$cur2, _this$scrollPanel$cur3;
    return (_this$scrollPanel$cur2 = (_this$scrollPanel$cur3 = this.scrollPanel.current) === null || _this$scrollPanel$cur3 === void 0 ? void 0 : _this$scrollPanel$cur3.getScrollState()) !== null && _this$scrollPanel$cur2 !== void 0 ? _this$scrollPanel$cur2 : null;
  }

  // returns one of:
  //
  //  null: there is no read marker
  //  -1: read marker is above the window
  //   0: read marker is within the window
  //  +1: read marker is below the window
  getReadMarkerPosition() {
    const readMarker = this.readMarkerNode.current;
    const messageWrapper = this.scrollPanel.current;
    if (!readMarker || !messageWrapper) {
      return null;
    }
    const wrapperRect = react_dom.findDOMNode(messageWrapper).getBoundingClientRect();
    const readMarkerRect = readMarker.getBoundingClientRect();

    // the read-marker pretends to have zero height when it is actually
    // two pixels high; +2 here to account for that.
    if (readMarkerRect.bottom + 2 < wrapperRect.top) {
      return -1;
    } else if (readMarkerRect.top < wrapperRect.bottom) {
      return 0;
    } else {
      return 1;
    }
  }

  /* jump to the top of the content.
   */
  scrollToTop() {
    if (this.scrollPanel.current) {
      this.scrollPanel.current.scrollToTop();
    }
  }

  /* jump to the bottom of the content.
   */
  scrollToBottom() {
    if (this.scrollPanel.current) {
      this.scrollPanel.current.scrollToBottom();
    }
  }

  /**
   * Page up/down.
   *
   * @param {number} mult: -1 to page up, +1 to page down
   */
  scrollRelative(mult) {
    if (this.scrollPanel.current) {
      this.scrollPanel.current.scrollRelative(mult);
    }
  }

  /**
   * Scroll up/down in response to a scroll key
   *
   * @param {KeyboardEvent} ev: the keyboard event to handle
   */
  handleScrollKey(ev) {
    if (this.scrollPanel.current) {
      this.scrollPanel.current.handleScrollKey(ev);
    }
  }

  /* jump to the given event id.
   *
   * offsetBase gives the reference point for the pixelOffset. 0 means the
   * top of the container, 1 means the bottom, and fractional values mean
   * somewhere in the middle. If omitted, it defaults to 0.
   *
   * pixelOffset gives the number of pixels *above* the offsetBase that the
   * node (specifically, the bottom of it) will be positioned. If omitted, it
   * defaults to 0.
   */
  scrollToEvent(eventId, pixelOffset, offsetBase) {
    if (this.scrollPanel.current) {
      this.scrollPanel.current.scrollToToken(eventId, pixelOffset, offsetBase);
    }
  }
  scrollToEventIfNeeded(eventId) {
    const node = this.eventNodes[eventId];
    if (node) {
      node.scrollIntoView({
        block: "nearest",
        behavior: "instant"
      });
    }
  }

  /* check the scroll state and send out pagination requests if necessary.
   */
  checkFillState() {
    if (this.scrollPanel.current) {
      this.scrollPanel.current.checkFillState();
    }
  }
  get showHiddenEvents() {
    var _this$context$showHid, _this$context;
    return (_this$context$showHid = (_this$context = this.context) === null || _this$context === void 0 ? void 0 : _this$context.showHiddenEventsInTimeline) !== null && _this$context$showHid !== void 0 ? _this$context$showHid : this.showHiddenEventsInTimeline;
  }

  // TODO: Implement granular (per-room) hide options
  shouldShowEvent(mxEv) {
    if (MatrixClientPeg/* MatrixClientPeg */.p.get().isUserIgnored(mxEv.getSender())) {
      return false; // ignored = no show (only happens if the ignore happens after an event was received)
    }

    if (this.showHiddenEvents) {
      return true;
    }
    if (!(0,EventTile/* haveTileForEvent */.K3)(mxEv, this.showHiddenEvents)) {
      return false; // no tile = no show
    }

    // Always show highlighted event
    if (this.props.highlightedEventId === mxEv.getId()) return true;

    // Checking if the message has a "parentEventId" as we do not
    // want to hide the root event of the thread
    if (mxEv.isThreadRelation && this.props.hideThreadedMessages && SettingsStore/* default */.C.getValue("feature_thread")) {
      return false;
    }
    return !(0,shouldHideEvent/* default */.Z)(mxEv, this.context);
  }
  readMarkerForEvent(eventId, isLastEvent) {
    const visible = !isLastEvent && this.props.readMarkerVisible;
    if (this.props.readMarkerEventId === eventId) {
      let hr;
      // if the read marker comes at the end of the timeline (except
      // for local echoes, which are excluded from RMs, because they
      // don't have useful event ids), we don't want to show it, but
      // we still want to create the <li/> for it so that the
      // algorithms which depend on its position on the screen aren't
      // confused.
      if (visible) {
        hr = /*#__PURE__*/react.createElement("hr", {
          className: "mx_RoomView_myReadMarker",
          style: {
            opacity: 1,
            width: "99%"
          }
        });
      }
      return /*#__PURE__*/react.createElement("li", {
        key: "readMarker_" + eventId,
        ref: this.readMarkerNode,
        className: "mx_RoomView_myReadMarker_text_container",
        "data-scroll-tokens": eventId
      }, visible ? /*#__PURE__*/react.createElement("span", {
        className: "mx_RoomView_myReadMarker"
      }, (0,languageHandler._t)("Unread Messages")) : null);
    } else if (this.state.ghostReadMarkers.includes(eventId)) {
      // We render 'ghost' read markers in the DOM while they
      // transition away. This allows the actual read marker
      // to be in the right place straight away without having
      // to wait for the transition to finish.
      // There are probably much simpler ways to do this transition,
      // possibly using react-transition-group which handles keeping
      // elements in the DOM whilst they transition out, although our
      // case is a little more complex because only some of the items
      // transition (ie. the read markers do but the event tiles do not)
      // and TransitionGroup requires that all its children are Transitions.
      const hr = /*#__PURE__*/react.createElement("hr", {
        className: "mx_RoomView_myReadMarker",
        ref: this.collectGhostReadMarker,
        onTransitionEnd: this.onGhostTransitionEnd,
        "data-eventid": eventId
      });

      // give it a key which depends on the event id. That will ensure that
      // we get a new DOM node (restarting the animation) when the ghost
      // moves to a different event.
      return /*#__PURE__*/react.createElement("li", {
        key: "_readuptoghost_" + eventId,
        className: "mx_RoomView_myReadMarker_line_container"
      }, hr);
    }
    return null;
  }
  getNextEventInfo(arr, i) {
    const nextEvent = i < arr.length - 1 ? arr[i + 1] : null;

    // The next event with tile is used to to determine the 'last successful' flag
    // when rendering the tile. The shouldShowEvent function is pretty quick at what
    // it does, so this should have no significant cost even when a room is used for
    // not-chat purposes.
    const nextTile = arr.slice(i + 1).find(e => this.shouldShowEvent(e));
    return {
      nextEvent,
      nextTile
    };
  }
  get roomHasPendingEdit() {
    return this.props.room && localStorage.getItem(`mx_edit_room_${this.props.room.roomId}`);
  }
  isJsonString(str) {
    try {
      JSON.parse(str);
    } catch (error) {
      return false;
    }
    return true;
  }
  getEventTiles() {
    this.eventNodes = {};
    let i;
    // first figure out which is the last event in the list which we're
    // actually going to show; this allows us to behave slightly
    // differently for the last event in the list. (eg show timestamp)
    //
    // we also need to figure out which is the last event we show which isn't
    // a local echo, to manage the read-marker.
    let lastShownEvent;
    let lastShownNonLocalEchoIndex = -1;
    const markMap = {};
    for (i = this.props.events.length - 1; i >= 0; i--) {
      const mxEv = this.props.events[i];
      if (mxEv.tagEventId && !markMap[mxEv.tagEventId]) {
        markMap[mxEv.tagEventId] = mxEv.getContent().msgtag;
      }
      if (!this.shouldShowEvent(mxEv)) {
        continue;
      }
      if (markMap[mxEv.getId()]) {
        mxEv.makeTag(markMap[mxEv.getId()]);
      }
    }
    for (i = this.props.events.length - 1; i >= 0; i--) {
      const mxEv = this.props.events[i];
      if (!this.shouldShowEvent(mxEv)) {
        continue;
      }
      if (lastShownEvent === undefined) {
        lastShownEvent = mxEv;
      }
      if (mxEv.status) {
        // this is a local echo
        continue;
      }
      lastShownNonLocalEchoIndex = i;
      break;
    }
    const ret = [];
    let prevEvent = null; // the last event we showed

    // Note: the EventTile might still render a "sent/sending receipt" independent of
    // this information. When not providing read receipt information, the tile is likely
    // to assume that sent receipts are to be shown more often.
    this.readReceiptsByEvent = {};
    if (this.props.showReadReceipts) {
      this.readReceiptsByEvent = this.getReadReceiptsByShownEvent();
    }
    let grouper = null;
    for (i = 0; i < this.props.events.length; i++) {
      var _mxEv$getType, _mxEv$getType2;
      const mxEv = this.props.events[i];
      const eventId = mxEv.getId();
      const last = mxEv === lastShownEvent;
      const {
        nextEvent,
        nextTile
      } = this.getNextEventInfo(this.props.events, i);
      if (((_mxEv$getType = mxEv.getType()) === null || _mxEv$getType === void 0 ? void 0 : _mxEv$getType.indexOf("m.call.")) === 0 || ((_mxEv$getType2 = mxEv.getType()) === null || _mxEv$getType2 === void 0 ? void 0 : _mxEv$getType2.indexOf("org.matrix.call.")) === 0) {
        const callId = mxEv.getContent().call_id;
        if (this.callEventGroupers.has(callId)) {
          this.callEventGroupers.get(callId).add(mxEv);
        } else {
          const callEventGrouper = new CallEventGrouper/* default */.ZP();
          callEventGrouper.add(mxEv);
          this.callEventGroupers.set(callId, callEventGrouper);
        }
      }
      if (grouper) {
        if (grouper.shouldGroup(mxEv)) {
          grouper.add(mxEv, this.showHiddenEvents);
          continue;
        } else {
          // not part of group, so get the group tiles, close the
          // group, and continue like a normal event
          const grouperTile = grouper.getTiles();
          if (grouperTile instanceof Array) {
            ret.push(...grouperTile);
          } else {
            ret.push(grouperTile);
          }
          prevEvent = grouper.getNewPrevEvent();
          grouper = null;
        }
      }
      for (const Grouper of groupers) {
        if (Grouper.canStartGroup(this, mxEv)) {
          grouper = new Grouper(this, mxEv, prevEvent, lastShownEvent, this.props.layout, nextEvent, nextTile);
        }
      }
      if (!grouper) {
        const wantTile = this.shouldShowEvent(mxEv);
        const isGrouped = false;
        if (wantTile) {
          // make sure we unpack the array returned by getTilesForEvent,
          // otherwise react will auto-generate keys and we will end up
          // replacing all of the DOM elements every time we paginate.
          ret.push(...this.getTilesForEvent(prevEvent, mxEv, last, isGrouped, nextEvent, nextTile));
          prevEvent = mxEv;
        }
        const readMarker = this.readMarkerForEvent(eventId, i >= lastShownNonLocalEchoIndex);
        if (readMarker) ret.push(readMarker);
      }
    }
    if (!this.props.editState && this.roomHasPendingEdit) {
      dispatcher/* default */.ZP.dispatch({
        action: "edit_event",
        event: this.props.room.findEventById(this.roomHasPendingEdit)
      });
    }
    if (grouper) {
      const grouperTile = grouper.getTiles();
      if (grouperTile instanceof Array) {
        ret.push(...grouperTile);
      } else {
        ret.push(grouperTile);
      }
    }
    return ret;
  }
  getTilesForEvent(prevEvent, mxEv, last = false, isGrouped = false, nextEvent, nextEventWithTile, elementAs, option) {
    const ret = [];
    const isEditing = this.props.editState && this.props.editState.getEvent().getId() === mxEv.getId();
    // local echoes have a fake date, which could even be yesterday. Treat them
    // as 'today' for the date separators.
    let ts1 = mxEv.getTs();
    let eventDate = mxEv.getDate();
    // if (mxEv.status) {
    //     eventDate = new Date();
    //     ts1 = eventDate.getTime();
    // }

    // do we need a date separator since the last event?
    const wantsDateSeparator = this.wantsDateSeparator(prevEvent, eventDate);
    if (wantsDateSeparator && !isGrouped) {
      const dateSeparator = /*#__PURE__*/react.createElement("li", {
        key: ts1,
        "data-event-id": mxEv === null || mxEv === void 0 ? void 0 : mxEv.getId(),
        "data-prev-event-id": prevEvent === null || prevEvent === void 0 ? void 0 : prevEvent.getId()
      }, /*#__PURE__*/react.createElement(DateSeparator["default"], {
        key: ts1,
        ts: ts1
      }));
      ret.push(dateSeparator);
    }
    let willWantDateSeparator = false;
    let lastInSection = true;
    if (nextEventWithTile) {
      willWantDateSeparator = this.wantsDateSeparator(mxEv, nextEventWithTile.getDate() || new Date());
      lastInSection = willWantDateSeparator || mxEv.getSender() !== nextEventWithTile.getSender();
    }

    // is this a continuation of the previous message?
    // const continuation =
    //     !wantsDateSeparator &&
    //     shouldFormContinuation(prevEvent, mxEv, this.showHiddenEvents);
    const eventId = mxEv.getId();
    const highlight = eventId === this.props.highlightedEventId;
    const readReceipts = this.readReceiptsByEvent[eventId];
    let isLastSuccessful = false;
    const isSentState = s => !s || s === "sent";
    const isSent = isSentState(mxEv.getAssociatedStatus());
    const hasNextEvent = nextEvent && this.shouldShowEvent(nextEvent);
    if (!hasNextEvent && isSent) {
      isLastSuccessful = true;
    } else if (hasNextEvent && isSent && !isSentState(nextEvent.getAssociatedStatus())) {
      isLastSuccessful = true;
    }

    // This is a bit nuanced, but if our next event is hidden but a future event is not
    // hidden then we're not the last successful.
    if (nextEventWithTile && nextEventWithTile !== nextEvent && isSentState(nextEventWithTile.getAssociatedStatus())) {
      isLastSuccessful = false;
    }

    // We only want to consider "last successful" if the event is sent by us, otherwise of course
    // it's successful: we received it.
    isLastSuccessful = isLastSuccessful && mxEv.getSender() === MatrixClientPeg/* MatrixClientPeg */.p.get().getUserId();
    const callEventGrouper = this.callEventGroupers.get(mxEv.getContent().call_id);
    let firstInGroup, lastInGroup;
    if (isGrouped) {
      firstInGroup = option === null || option === void 0 ? void 0 : option.firstInGroup;
      lastInGroup = option === null || option === void 0 ? void 0 : option.lastInGroup;
    } else {
      firstInGroup = checkPositionInGroup(mxEv, prevEvent, this.showHiddenEvents);
      lastInGroup = checkPositionInGroup(mxEv, nextEvent, this.showHiddenEvents);
    }
    const msgtype = mxEv.getContent().msgtype;
    const classes = classnames_default()({
      "mx-first-in-group": firstInGroup,
      "mx-last-in-group": lastInGroup,
      "mx-has-appendix": lastInGroup && EventTile/* MessageInGroup */.bU[msgtype]
    });
    // use txnId as key if available so that we don't remount during sending
    ret.push( /*#__PURE__*/react.createElement(TileErrorBoundary["default"], {
      key: mxEv.getTxnId() || eventId,
      mxEvent: mxEv
    }, /*#__PURE__*/react.createElement(EventTile/* default */.ZP, {
      className: classes,
      as: elementAs !== null && elementAs !== void 0 ? elementAs : "li",
      ref: this.collectEventNode.bind(this, eventId),
      alwaysShowTimestamps: this.props.alwaysShowTimestamps,
      mxEvent: mxEv,
      continuation: !lastInGroup,
      isRedacted: mxEv.isRedacted(),
      replacingEventId: mxEv.replacingEventId(),
      editState: isEditing && this.props.editState,
      onHeightChanged: this.onHeightChanged,
      readReceipts: readReceipts,
      readReceiptMap: this.readReceiptMap,
      showUrlPreview: this.props.showUrlPreview,
      checkUnmounting: this.isUnmounting,
      eventSendStatus: mxEv.getAssociatedStatus(),
      tileShape: this.props.tileShape,
      isTwelveHour: this.props.isTwelveHour,
      permalinkCreator: this.props.permalinkCreator,
      last: last,
      lastInSection: lastInSection,
      lastSuccessful: isLastSuccessful,
      isSelectedEvent: highlight,
      getRelationsForEvent: this.props.getRelationsForEvent,
      showReactions: this.props.showReactions,
      layout: this.props.layout,
      enableFlair: this.props.enableFlair,
      showReadReceipts: this.props.showReadReceipts,
      callEventGrouper: callEventGrouper
      // hideSender={this.props.room.getMembers().length <= 2 && this.props.layout !== Layout.Group}
      ,
      onSelected: this.state.multiSelectorVisible ? this.handleSelected : void 0,
      inMultiSelected: this.state.currentSelected.includes(mxEv),
      displayWebsiteLinkSetting: this.state.displayWebsiteLinkSetting,
      firstInGroup: firstInGroup,
      lastInGroup: lastInGroup
    })));
    return ret;
  }
  wantsDateSeparator(prevEvent, nextEventDate) {
    if (prevEvent == null) {
      // first event in the panel: depends if we could back-paginate from
      // here.
      return !this.props.suppressFirstDateSeparator;
    }
    return (0,DateUtils/* wantsDateSeparator */.JC)(prevEvent.getDate(), nextEventDate);
  }

  // Get a list of read receipts that should be shown next to this event
  // Receipts are objects which have a 'userId', 'roomMember' and 'ts'.
  getReadReceiptsForEvent(event) {
    const myUserId = MatrixClientPeg/* MatrixClientPeg */.p.get().credentials.userId;

    // get list of read receipts, sorted most recent first
    const {
      room
    } = this.props;
    if (!room) {
      return null;
    }
    const receipts = [];
    room.getReceiptsForEvent(event).forEach(r => {
      if (!r.userId || r.type !== "m.read" || r.userId === myUserId) {
        return; // ignore non-read receipts and receipts from self.
      }

      if (MatrixClientPeg/* MatrixClientPeg */.p.get().isUserIgnored(r.userId)) {
        return; // ignore ignored users
      }

      const member = room.getMember(r.userId);
      receipts.push({
        userId: r.userId,
        roomMember: member,
        ts: r.data ? r.data.ts : 0
      });
    });
    return receipts;
  }

  // Get an object that maps from event ID to a list of read receipts that
  // should be shown next to that event. If a hidden event has read receipts,
  // they are folded into the receipts of the last shown event.
  getReadReceiptsByShownEvent() {
    const receiptsByEvent = {};
    const receiptsByUserId = {};
    let lastShownEventId;
    for (const event of this.props.events) {
      if (this.shouldShowEvent(event)) {
        lastShownEventId = event.getId();
      }
      if (!lastShownEventId) {
        continue;
      }
      const existingReceipts = receiptsByEvent[lastShownEventId] || [];
      const newReceipts = this.getReadReceiptsForEvent(event);
      receiptsByEvent[lastShownEventId] = existingReceipts.concat(newReceipts);

      // Record these receipts along with their last shown event ID for
      // each associated user ID.
      for (const receipt of newReceipts) {
        receiptsByUserId[receipt.userId] = {
          lastShownEventId,
          receipt
        };
      }
    }

    // It's possible in some cases (for example, when a read receipt
    // advances before we have paginated in the new event that it's marking
    // received) that we can temporarily not have a matching event for
    // someone which had one in the last. By looking through our previous
    // mapping of receipts by user ID, we can cover recover any receipts
    // that would have been lost by using the same event ID from last time.
    for (const userId in this.readReceiptsByUserId) {
      if (receiptsByUserId[userId]) {
        continue;
      }
      const {
        lastShownEventId,
        receipt
      } = this.readReceiptsByUserId[userId];
      const existingReceipts = receiptsByEvent[lastShownEventId] || [];
      receiptsByEvent[lastShownEventId] = existingReceipts.concat(receipt);
      receiptsByUserId[userId] = {
        lastShownEventId,
        receipt
      };
    }
    this.readReceiptsByUserId = receiptsByUserId;

    // After grouping receipts by shown events, do another pass to sort each
    // receipt list.
    for (const eventId in receiptsByEvent) {
      receiptsByEvent[eventId].sort((r1, r2) => {
        return r2.ts - r1.ts;
      });
    }
    return receiptsByEvent;
  }
  updateTimelineMinHeight() {
    const scrollPanel = this.scrollPanel.current;
    if (scrollPanel) {
      const isAtBottom = scrollPanel.isAtBottom();
      const whoIsTyping = this.whoIsTyping.current;
      const isTypingVisible = whoIsTyping && whoIsTyping.isVisible();
      // when messages get added to the timeline,
      // but somebody else is still typing,
      // update the min-height, so once the last
      // person stops typing, no jumping occurs
      if (isAtBottom && isTypingVisible) {
        scrollPanel.preventShrinking();
      }
    }
  }
  onTimelineReset() {
    const scrollPanel = this.scrollPanel.current;
    if (scrollPanel) {
      scrollPanel.clearPreventShrinking();
    }
  }
  render() {
    let topSpinner;
    let bottomSpinner;
    if (this.props.backPaginating) {
      topSpinner = /*#__PURE__*/react.createElement("li", {
        key: "_topSpinner"
      }, /*#__PURE__*/react.createElement(elements_Spinner/* default */.Z, null));
    }
    if (this.props.forwardPaginating) {
      bottomSpinner = /*#__PURE__*/react.createElement("li", {
        key: "_bottomSpinner"
      }, /*#__PURE__*/react.createElement(elements_Spinner/* default */.Z, null));
    }
    const style = this.props.hidden ? {
      display: "none"
    } : {};
    let whoIsTyping;
    if (this.props.room && !this.props.tileShape && this.state.showTypingNotifications) {
      whoIsTyping = /*#__PURE__*/react.createElement(WhoIsTypingTile/* default */.Z, {
        key: "WhoIsTypingTile",
        room: this.props.room,
        onShown: this.onTypingShown,
        onHidden: this.onTypingHidden,
        ref: this.whoIsTyping
      });
    }
    let ircResizer = null;
    if (this.props.layout == Layout/* Layout */.A.IRC) {
      ircResizer = /*#__PURE__*/react.createElement(IRCTimelineProfileResizer, {
        key: "IRCTimelineProfileResizer",
        minWidth: 20,
        maxWidth: 600,
        roomId: this.props.room ? this.props.room.roomId : null
      });
    }
    return /*#__PURE__*/react.createElement(ErrorBoundary/* default */.Z, null, /*#__PURE__*/react.createElement(ScrollPanel/* default */.Z, {
      ref: this.scrollPanel,
      className: classnames_default()(this.props.className, {
        mx_RoomView_messagePanel_onSelect: this.state.multiSelectorVisible
      }),
      onScroll: this.props.onScroll,
      onUserScroll: this.props.onUserScroll,
      onFillRequest: this.props.onFillRequest,
      onUnfillRequest: this.props.onUnfillRequest,
      style: style,
      stickyBottom: this.props.stickyBottom,
      resizeNotifier: this.props.resizeNotifier,
      fixedChildren: ircResizer
    }, topSpinner, this.getEventTiles(), whoIsTyping, this.renderEventEncryptProcess(), bottomSpinner), this.state.multiSelectorVisible ? /*#__PURE__*/react.createElement(structures_SelectorPanel, {
      selected: this.state.currentSelected,
      onCancel: this.onCloseSelectorPanel,
      room: this.props.room
    }) : null);
  }
}, (0,defineProperty/* default */.Z)(MessagePanel_class2, "contextType", contexts_RoomContext/* default */.Z), MessagePanel_class2)) || MessagePanel_class);

// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/dialogs/ErrorDialog.tsx
var ErrorDialog = __webpack_require__(705636);
// EXTERNAL MODULE: ./node_modules/lodash-es/debounce.js
var debounce = __webpack_require__(453434);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/notifications/RoomNotificationStateStore.ts + 3 modules
var RoomNotificationStateStore = __webpack_require__(16033);
// EXTERNAL MODULE: ./node_modules/firebase/analytics/dist/esm/index.esm.js + 1 modules
var index_esm = __webpack_require__(472133);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/firebase_analytics.ts + 3 modules
var firebase_analytics = __webpack_require__(937139);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/utils/commonPointParams.ts
var commonPointParams = __webpack_require__(970698);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/structures/TimelinePanel.tsx

var TimelinePanel_dec, TimelinePanel_class, TimelinePanel_class2;
function TimelinePanel_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function TimelinePanel_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? TimelinePanel_ownKeys(Object(t), !0).forEach(function (r) { (0,defineProperty/* default */.Z)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : TimelinePanel_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
/*
Copyright 2016 - 2021 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/





























const PAGINATE_SIZE = 20;
const INITIAL_SIZE = 20;
const READ_RECEIPT_INTERVAL_MS = 500;
const READ_MARKER_DEBOUNCE_MS = 200;
const DEBUG = false;
let debuglog = function (...s) {};
if (DEBUG) {
  // using bind means that we get to keep useful line numbers in the console
  debuglog = console.log.bind(console);
}
/*
 * Component which shows the event timeline in a room view.
 *
 * Also responsible for handling and sending read receipts.
 */
let TimelinePanel = (TimelinePanel_dec = (0,replaceableComponent/* replaceableComponent */.U)("structures.TimelinePanel"), TimelinePanel_dec(TimelinePanel_class = (TimelinePanel_class2 = class TimelinePanel extends react.Component {
  constructor(props, context) {
    super(props, context);
    (0,defineProperty/* default */.Z)(this, "lastRRSentEventId", undefined);
    (0,defineProperty/* default */.Z)(this, "lastRMSentEventId", undefined);
    (0,defineProperty/* default */.Z)(this, "messagePanel", /*#__PURE__*/(0,react.createRef)());
    (0,defineProperty/* default */.Z)(this, "dispatcherRef", void 0);
    (0,defineProperty/* default */.Z)(this, "timelineWindow", void 0);
    (0,defineProperty/* default */.Z)(this, "unmounted", false);
    (0,defineProperty/* default */.Z)(this, "readReceiptActivityTimer", void 0);
    (0,defineProperty/* default */.Z)(this, "readMarkerActivityTimer", void 0);
    (0,defineProperty/* default */.Z)(this, "onMessageListUnfillRequest", (backwards, scrollToken) => {
      // If backwards, unpaginate from the back (i.e. the start of the timeline)
      const dir = backwards ? event_timeline/* EventTimeline */.G.BACKWARDS : event_timeline/* EventTimeline */.G.FORWARDS;
      debuglog("TimelinePanel: unpaginating events in direction", dir);

      // All tiles are inserted by MessagePanel to have a scrollToken === eventId, and
      // this particular event should be the first or last to be unpaginated.
      const eventId = scrollToken;
      const marker = this.state.events.findIndex(ev => {
        return ev.getId() === eventId;
      });
      const count = backwards ? marker + 1 : this.state.events.length - marker;
      if (count > 0) {
        debuglog("TimelinePanel: Unpaginating", count, "in direction", dir);
        this.timelineWindow.unpaginate(count, backwards);
        const {
          events,
          liveEvents,
          firstVisibleEventIndex
        } = this.getEvents();
        const newState = {
          events,
          liveEvents,
          firstVisibleEventIndex
        };

        // We can now paginate in the unpaginated direction
        if (backwards) {
          newState.canBackPaginate = true;
        } else {
          newState.canForwardPaginate = true;
        }
        this.setState(newState);
      }
    });
    (0,defineProperty/* default */.Z)(this, "onPaginationRequest", (timelineWindow, direction, size) => {
      if (this.props.onPaginationRequest) {
        return this.props.onPaginationRequest(timelineWindow, direction, size);
      } else {
        return timelineWindow.paginate(direction, size);
      }
    });
    // set off a pagination request.
    (0,defineProperty/* default */.Z)(this, "onMessageListFillRequest", backwards => {
      if (!this.shouldPaginate()) return Promise.resolve(false);
      const dir = backwards ? event_timeline/* EventTimeline */.G.BACKWARDS : event_timeline/* EventTimeline */.G.FORWARDS;
      const canPaginateKey = backwards ? "canBackPaginate" : "canForwardPaginate";
      const paginatingKey = backwards ? "backPaginating" : "forwardPaginating";
      if (!this.state[canPaginateKey]) {
        debuglog("TimelinePanel: have given up", dir, "paginating this timeline");
        return Promise.resolve(false);
      }
      if (!this.timelineWindow.canPaginate(dir)) {
        debuglog("TimelinePanel: can't", dir, "paginate any further");
        this.setState({
          [canPaginateKey]: false
        });
        return Promise.resolve(false);
      }
      if (backwards && this.state.firstVisibleEventIndex !== 0) {
        debuglog("TimelinePanel: won't", dir, "paginate past first visible event");
        return Promise.resolve(false);
      }
      debuglog("TimelinePanel: Initiating paginate; backwards:" + backwards);
      this.setState({
        [paginatingKey]: true
      });
      return this.onPaginationRequest(this.timelineWindow, dir, PAGINATE_SIZE).then(r => {
        if (this.unmounted) {
          return;
        }
        debuglog("TimelinePanel: paginate complete backwards:" + backwards + "; success:" + r);
        const {
          events,
          liveEvents,
          firstVisibleEventIndex
        } = this.getEvents();
        const newState = {
          [paginatingKey]: false,
          [canPaginateKey]: r,
          events,
          liveEvents,
          firstVisibleEventIndex
        };

        // moving the window in this direction may mean that we can now
        // paginate in the other where we previously could not.
        const otherDirection = backwards ? event_timeline/* EventTimeline */.G.FORWARDS : event_timeline/* EventTimeline */.G.BACKWARDS;
        const canPaginateOtherWayKey = backwards ? "canForwardPaginate" : "canBackPaginate";
        if (!this.state[canPaginateOtherWayKey] && this.timelineWindow.canPaginate(otherDirection)) {
          debuglog("TimelinePanel: can now", otherDirection, "paginate again");
          newState[canPaginateOtherWayKey] = true;
        }

        // Don't resolve until the setState has completed: we need to let
        // the component update before we consider the pagination completed,
        // otherwise we'll end up paginating in all the history the js-sdk
        // has in memory because we never gave the component a chance to scroll
        // itself into the right place
        return new Promise(resolve => {
          this.setState(newState, () => {
            // we can continue paginating in the given direction if:
            // - timelineWindow.paginate says we can
            // - we're paginating forwards, or we won't be trying to
            //   paginate backwards past the first visible event
            resolve(r && (!backwards || firstVisibleEventIndex === 0));
          });
        });
      });
    });
    (0,defineProperty/* default */.Z)(this, "onMessageListScroll", e => {
      if (this.props.onScroll) {
        this.props.onScroll(e);
      }
      if (this.props.manageReadMarkers) {
        this.doManageReadMarkers();
      }
    });
    /*
     * Debounced function to manage read markers because we don't need to
     * do this on every tiny scroll update. It also sets state which causes
     * a component update, which can in turn reset the scroll position, so
     * it's important we allow the browser to scroll a bit before running this
     * (hence trailing edge only and debounce rather than throttle because
     * we really only need to update this once the user has finished scrolling,
     * not periodically while they scroll).
     */
    (0,defineProperty/* default */.Z)(this, "doManageReadMarkers", (0,debounce/* default */.Z)(() => {
      var _this$readMarkerActiv;
      const rmPosition = this.getReadMarkerPosition();
      // we hide the read marker when it first comes onto the screen, but if
      // it goes back off the top of the screen (presumably because the user
      // clicks on the 'jump to bottom' button), we need to re-enable it.
      if (rmPosition < 0) {
        this.setState({
          readMarkerVisible: true
        });
      }

      // if read marker position goes between 0 and -1/1,
      // (and user is active), switch timeout
      const timeout = this.readMarkerTimeout(rmPosition);
      // NO-OP when timeout already has set to the given value
      (_this$readMarkerActiv = this.readMarkerActivityTimer) === null || _this$readMarkerActiv === void 0 ? void 0 : _this$readMarkerActiv.changeTimeout(timeout);
    }, READ_MARKER_DEBOUNCE_MS, {
      leading: false,
      trailing: true
    }));
    (0,defineProperty/* default */.Z)(this, "onAction", payload => {
      switch (payload.action) {
        case "ignore_state_changed":
          this.forceUpdate();
          break;
      }
    });
    (0,defineProperty/* default */.Z)(this, "onRoomTimeline", (ev, room, toStartOfTimeline, removed, data) => {
      // ignore events for other timeline sets
      if (data.timeline.getTimelineSet() !== this.props.timelineSet) return;

      // ignore anything but real-time updates at the end of the room:
      // updates from pagination will happen when the paginate completes.
      if (toStartOfTimeline || !data || !data.liveEvent) return;
      if (!this.messagePanel.current) return;
      if (!this.messagePanel.current.getScrollState().stuckAtBottom) {
        // we won't load this event now, because we don't want to push any
        // events off the other end of the timeline. But we need to note
        // that we can now paginate.
        this.setState({
          canForwardPaginate: true
        });
        return;
      }

      // tell the timeline window to try to advance itself, but not to make
      // an http request to do so.
      //
      // we deliberately avoid going via the ScrollPanel for this call - the
      // ScrollPanel might already have an active pagination promise, which
      // will fail, but would stop us passing the pagination request to the
      // timeline window.
      //
      // see https://github.com/vector-im/vector-web/issues/1035

      this.timelineWindow.paginate(event_timeline/* EventTimeline */.G.FORWARDS, 1, false).then(() => {
        if (this.unmounted) {
          return;
        }
        const {
          events,
          liveEvents,
          firstVisibleEventIndex
        } = this.getEvents();
        const lastLiveEvent = liveEvents[liveEvents.length - 1];
        const updatedState = {
          events,
          liveEvents,
          firstVisibleEventIndex
        };
        let callRMUpdated;
        if (this.props.manageReadMarkers) {
          // when a new event arrives when the user is not watching the
          // window, but the window is in its auto-scroll mode, make sure the
          // read marker is visible.
          //
          // We ignore events we have sent ourselves; we don't want to see the
          // read-marker when a remote echo of an event we have just sent takes
          // more than the timeout on userActiveRecently.
          //
          const myUserId = MatrixClientPeg/* MatrixClientPeg */.p.get().credentials.userId;
          callRMUpdated = false;
          if (ev.getSender() !== myUserId && !UserActivity/* default */.Z.sharedInstance().userActiveRecently()) {
            updatedState.readMarkerVisible = true;
          } else if (lastLiveEvent && this.getReadMarkerPosition() === 0) {
            // we know we're stuckAtBottom, so we can advance the RM
            // immediately, to save a later render cycle

            this.setReadMarker(lastLiveEvent.getId(), lastLiveEvent.getTs(), true);
            updatedState.readMarkerVisible = false;
            updatedState.readMarkerEventId = lastLiveEvent.getId();
            callRMUpdated = true;
          }
        }
        this.setState(updatedState, () => {
          var _this$messagePanel$cu;
          (_this$messagePanel$cu = this.messagePanel.current) === null || _this$messagePanel$cu === void 0 ? void 0 : _this$messagePanel$cu.updateTimelineMinHeight();
          if (callRMUpdated) {
            this.props.onReadMarkerUpdated();
          }
        });
      });
    });
    (0,defineProperty/* default */.Z)(this, "onRoomTimelineReset", (room, timelineSet) => {
      if (timelineSet !== this.props.timelineSet) return;
      if (this.messagePanel.current && this.messagePanel.current.isAtBottom()) {
        this.loadTimeline();
      }
    });
    (0,defineProperty/* default */.Z)(this, "canResetTimeline", () => {
      var _this$messagePanel;
      return (_this$messagePanel = this.messagePanel) === null || _this$messagePanel === void 0 ? void 0 : _this$messagePanel.current.isAtBottom();
    });
    (0,defineProperty/* default */.Z)(this, "onRoomRedaction", (ev, room) => {
      if (this.unmounted) return;

      // ignore events for other rooms
      if (room !== this.props.timelineSet.room) return;

      // we could skip an update if the event isn't in our timeline,
      // but that's probably an early optimisation.
      this.forceUpdate();
    });
    (0,defineProperty/* default */.Z)(this, "onEventReplaced", (replacedEvent, room) => {
      if (this.unmounted) return;

      // ignore events for other rooms
      if (room !== this.props.timelineSet.room) return;

      // we could skip an update if the event isn't in our timeline,
      // but that's probably an early optimisation.
      this.forceUpdate();
    });
    (0,defineProperty/* default */.Z)(this, "onRoomReceipt", (ev, room) => {
      if (this.unmounted) return;

      // ignore events for other rooms
      if (room !== this.props.timelineSet.room) return;
      this.forceUpdate();
    });
    (0,defineProperty/* default */.Z)(this, "onLocalEchoUpdated", (ev, room, oldEventId) => {
      if (this.unmounted) return;

      // ignore events for other rooms
      if (room !== this.props.timelineSet.room) return;
      this.reloadEvents();
    });
    (0,defineProperty/* default */.Z)(this, "onAccountData", (ev, room) => {
      if (this.unmounted) return;

      // ignore events for other rooms
      if (room !== this.props.timelineSet.room) return;
      if (ev.getType() !== _types_event/* EventType */.tw.FullyRead) return;

      // XXX: roomReadMarkerTsMap not updated here so it is now inconsistent. Replace
      // this mechanism of determining where the RM is relative to the view-port with
      // one supported by the server (the client needs more than an event ID).
      this.setState({
        readMarkerEventId: ev.getContent().event_id
      }, this.props.onReadMarkerUpdated);
    });
    (0,defineProperty/* default */.Z)(this, "onEventDecrypted", ev => {
      // Can be null for the notification timeline, etc.
      if (!this.props.timelineSet.room) return;

      // Need to update as we don't display event tiles for events that
      // haven't yet been decrypted. The event will have just been updated
      // in place so we just need to re-render.
      // TODO: We should restrict this to only events in our timeline,
      // but possibly the event tile itself should just update when this
      // happens to save us re-rendering the whole timeline.
      if (ev.getRoomId() === this.props.timelineSet.room.roomId) {
        this.forceUpdate();
      }
    });
    (0,defineProperty/* default */.Z)(this, "onSync", (clientSyncState, prevState, data) => {
      console.log("clientSyncState", clientSyncState);
      this.setState({
        clientSyncState
      });
    });
    (0,defineProperty/* default */.Z)(this, "sendReadReceipt", () => {
      if (SettingsStore/* default */.C.getValue("lowBandwidth")) return;
      if (!this.messagePanel.current) return;
      if (!this.props.manageReadReceipts) return;
      // This happens on user_activity_end which is delayed, and it's
      // very possible have logged out within that timeframe, so check
      // we still have a client.
      const cli = MatrixClientPeg/* MatrixClientPeg */.p.get();
      // if no client or client is guest don't send RR or RM
      if (!cli || cli.isGuest()) return;
      let shouldSendRR = true;
      const currentRREventId = this.getCurrentReadReceipt(true);
      const currentRREventIndex = this.indexForEventId(currentRREventId);
      // We want to avoid sending out read receipts when we are looking at
      // events in the past which are before the latest RR.
      //
      // For now, let's apply a heuristic: if (a) the event corresponding to
      // the latest RR (either from the server, or sent by ourselves) doesn't
      // appear in our timeline, and (b) we could forward-paginate the event
      // timeline, then don't send any more RRs.
      //
      // This isn't watertight, as we could be looking at a section of
      // timeline which is *after* the latest RR (so we should actually send
      // RRs) - but that is a bit of a niche case. It will sort itself out when
      // the user eventually hits the live timeline.
      //
      if (currentRREventId && currentRREventIndex === null && this.timelineWindow.canPaginate(event_timeline/* EventTimeline */.G.FORWARDS)) {
        shouldSendRR = false;
      }
      const lastReadEventIndex = this.getLastDisplayedEventIndex({
        ignoreOwn: true
      });
      if (lastReadEventIndex === null) {
        shouldSendRR = false;
      }
      let lastReadEvent = this.state.events[lastReadEventIndex];
      shouldSendRR = shouldSendRR &&
      // Only send a RR if the last read event is ahead in the timeline relative to
      // the current RR event.
      lastReadEventIndex > currentRREventIndex &&
      // Only send a RR if the last RR set != the one we would send
      this.lastRRSentEventId != lastReadEvent.getId();

      // Only send a RM if the last RM sent != the one we would send
      const shouldSendRM = this.lastRMSentEventId != this.state.readMarkerEventId;

      // we also remember the last read receipt we sent to avoid spamming the
      // same one at the server repeatedly
      if (shouldSendRR || shouldSendRM) {
        if (shouldSendRR) {
          this.lastRRSentEventId = lastReadEvent.getId();
        } else {
          lastReadEvent = null;
        }
        this.lastRMSentEventId = this.state.readMarkerEventId;
        const roomId = this.props.timelineSet.room.roomId;
        const hiddenRR = SettingsStore/* default */.C.getValue("feature_hidden_read_receipts", roomId);
        debuglog("TimelinePanel: Sending Read Markers for ", this.props.timelineSet.room.roomId, "rm", this.state.readMarkerEventId, lastReadEvent ? "rr " + lastReadEvent.getId() : "", " hidden:" + hiddenRR);
        RoomNotificationStateStore/* RoomNotificationStateStore */.v.instance.getRoomState(this.props.timelineSet.room).clearUnRead();
        (0,index_esm/* logEvent */.Kz)(firebase_analytics/* analytics */.c, "read_message", TimelinePanel_objectSpread(TimelinePanel_objectSpread({}, (0,commonPointParams/* getCommonPointParams */.I)()), {}, {
          room_id: roomId.split(":")[0]
        }));
        MatrixClientPeg/* MatrixClientPeg */.p.get().setRoomReadMarkers(roomId, this.state.readMarkerEventId, lastReadEvent,
        // Could be null, in which case no RR is sent
        {
          hidden: hiddenRR
        }).catch(e => {
          // /read_markers API is not implemented on this HS, fallback to just RR
          if (e.errcode === "M_UNRECOGNIZED" && lastReadEvent) {
            return MatrixClientPeg/* MatrixClientPeg */.p.get().sendReadReceipt(lastReadEvent, {}).catch(e => {
              console.error(e);
              this.lastRRSentEventId = undefined;
            });
          } else {
            console.error(e);
          }
          // it failed, so allow retries next time the user is active
          this.lastRRSentEventId = undefined;
          this.lastRMSentEventId = undefined;
        });

        // do a quick-reset of our unreadNotificationCount to avoid having
        // to wait from the remote echo from the homeserver.
        // we only do this if we're right at the end, because we're just assuming
        // that sending an RR for the latest message will set our notif counter
        // to zero: it may not do this if we send an RR for somewhere before the end.
        if (this.isAtEndOfLiveTimeline()) {
          this.props.timelineSet.room.setUnreadNotificationCount(room/* NotificationCountType */.mf.Total, 0);
          this.props.timelineSet.room.setUnreadNotificationCount(room/* NotificationCountType */.mf.Highlight, 0);
          dispatcher/* default */.ZP.dispatch({
            action: "on_room_read",
            roomId: this.props.timelineSet.room.roomId
          });
        }
      }
    });
    // if the read marker is on the screen, we can now assume we've caught up to the end
    // of the screen, so move the marker down to the bottom of the screen.
    (0,defineProperty/* default */.Z)(this, "updateReadMarker", () => {
      if (!this.props.manageReadMarkers) return;
      if (this.getReadMarkerPosition() === 1) {
        // the read marker is at an event below the viewport,
        // we don't want to rewind it.
        return;
      }
      // move the RM to *after* the message at the bottom of the screen. This
      // avoids a problem whereby we never advance the RM if there is a huge
      // message which doesn't fit on the screen.
      const lastDisplayedIndex = this.getLastDisplayedEventIndex({
        allowPartial: true
      });
      if (lastDisplayedIndex === null) {
        return;
      }
      const lastDisplayedEvent = this.state.events[lastDisplayedIndex];
      this.setReadMarker(lastDisplayedEvent.getId(), lastDisplayedEvent.getTs());

      // the read-marker should become invisible, so that if the user scrolls
      // down, they don't see it.
      if (this.state.readMarkerVisible) {
        this.setState({
          readMarkerVisible: false
        });
      }

      // Send the updated read marker (along with read receipt) to the server
      this.sendReadReceipt();
    });
    /* jump down to the bottom of this room, where new events are arriving
     */
    (0,defineProperty/* default */.Z)(this, "jumpToLiveTimeline", () => {
      // if we can't forward-paginate the existing timeline, then there
      // is no point reloading it - just jump straight to the bottom.
      //
      // Otherwise, reload the timeline rather than trying to paginate
      // through all of space-time.
      if (this.timelineWindow.canPaginate(event_timeline/* EventTimeline */.G.FORWARDS)) {
        this.loadTimeline();
      } else {
        var _this$messagePanel$cu2;
        (_this$messagePanel$cu2 = this.messagePanel.current) === null || _this$messagePanel$cu2 === void 0 ? void 0 : _this$messagePanel$cu2.scrollToBottom();
      }
    });
    (0,defineProperty/* default */.Z)(this, "scrollToEventIfNeeded", eventId => {
      var _this$messagePanel$cu3;
      (_this$messagePanel$cu3 = this.messagePanel.current) === null || _this$messagePanel$cu3 === void 0 ? void 0 : _this$messagePanel$cu3.scrollToEventIfNeeded(eventId);
    });
    /* scroll to show the read-up-to marker. We put it 1/3 of the way down
     * the container.
     */
    (0,defineProperty/* default */.Z)(this, "jumpToReadMarker", () => {
      if (!this.props.manageReadMarkers) return;
      if (!this.messagePanel.current) return;
      if (!this.state.readMarkerEventId) return;

      // we may not have loaded the event corresponding to the read-marker
      // into the timelineWindow. In that case, attempts to scroll to it
      // will fail.
      //
      // a quick way to figure out if we've loaded the relevant event is
      // simply to check if the messagepanel knows where the read-marker is.
      const ret = this.messagePanel.current.getReadMarkerPosition();
      if (ret !== null) {
        // The messagepanel knows where the RM is, so we must have loaded
        // the relevant event.
        this.messagePanel.current.scrollToEvent(this.state.readMarkerEventId, 0, 1 / 3);
        return;
      }

      // Looks like we haven't loaded the event corresponding to the read-marker.
      // As with jumpToLiveTimeline, we want to reload the timeline around the
      // read-marker.
      this.loadTimeline(this.state.readMarkerEventId, 0, 1 / 3);
    });
    /* update the read-up-to marker to match the read receipt
     */
    (0,defineProperty/* default */.Z)(this, "forgetReadMarker", () => {
      if (!this.props.manageReadMarkers) return;
      const rmId = this.getCurrentReadReceipt();

      // see if we know the timestamp for the rr event
      const tl = this.props.timelineSet.getTimelineForEvent(rmId);
      let rmTs;
      if (tl) {
        const event = tl.getEvents().find(e => {
          return e.getId() == rmId;
        });
        if (event) {
          rmTs = event.getTs();
        }
      }
      this.setReadMarker(rmId, rmTs);
    });
    /* return true if the content is fully scrolled down and we are
     * at the end of the live timeline.
     */
    (0,defineProperty/* default */.Z)(this, "isAtEndOfLiveTimeline", () => {
      var _this$messagePanel$cu4;
      return ((_this$messagePanel$cu4 = this.messagePanel.current) === null || _this$messagePanel$cu4 === void 0 ? void 0 : _this$messagePanel$cu4.isAtBottom()) && this.timelineWindow && !this.timelineWindow.canPaginate(event_timeline/* EventTimeline */.G.FORWARDS);
    });
    /* get the current scroll state. See ScrollPanel.getScrollState for
     * details.
     *
     * returns null if we are not mounted.
     */
    (0,defineProperty/* default */.Z)(this, "getScrollState", () => {
      if (!this.messagePanel.current) {
        return null;
      }
      return this.messagePanel.current.getScrollState();
    });
    // returns one of:
    //
    //  null: there is no read marker
    //  -1: read marker is above the window
    //   0: read marker is visible
    //  +1: read marker is below the window
    (0,defineProperty/* default */.Z)(this, "getReadMarkerPosition", () => {
      if (!this.props.manageReadMarkers) return null;
      if (!this.messagePanel.current) return null;
      const ret = this.messagePanel.current.getReadMarkerPosition();
      if (ret !== null) {
        return ret;
      }

      // the messagePanel doesn't know where the read marker is.
      // if we know the timestamp of the read marker, make a guess based on that.
      const rmTs = TimelinePanel.roomReadMarkerTsMap[this.props.timelineSet.room.roomId];
      if (rmTs && this.state.events.length > 0) {
        if (rmTs < this.state.events[0].getTs()) {
          return -1;
        } else {
          return 1;
        }
      }
      return null;
    });
    (0,defineProperty/* default */.Z)(this, "canJumpToReadMarker", () => {
      // 1. Do not show jump bar if neither the RM nor the RR are set.
      // 3. We want to show the bar if the read-marker is off the top of the screen.
      // 4. Also, if pos === null, the event might not be paginated - show the unread bar
      const pos = this.getReadMarkerPosition();
      const ret = this.state.readMarkerEventId !== null && (
      // 1.
      pos < 0 || pos === null); // 3., 4.
      return ret;
    });
    /*
     * called by the parent component when PageUp/Down/etc is pressed.
     *
     * We pass it down to the scroll panel.
     */
    (0,defineProperty/* default */.Z)(this, "handleScrollKey", ev => {
      if (!this.messagePanel.current) {
        return;
      }

      // jump to the live timeline on ctrl-end, rather than the end of the
      // timeline window.
      if (ev.ctrlKey && !ev.shiftKey && !ev.altKey && !ev.metaKey && ev.key === Keyboard/* Key */.sr.END) {
        this.jumpToLiveTimeline();
      } else {
        this.messagePanel.current.handleScrollKey(ev);
      }
    });
    (0,defineProperty/* default */.Z)(this, "getRelationsForEvent", (eventId, relationType, eventType) => this.props.timelineSet.getRelationsForEvent(eventId, relationType, eventType));
    debuglog("TimelinePanel: mounting");
    // XXX: we could track RM per TimelineSet rather than per Room.
    // but for now we just do it per room for simplicity.
    let initialReadMarker = null;
    if (this.props.manageReadMarkers) {
      // const readmarker =
      //     this.props.timelineSet.room.getAccountData("m.fully_read");
      // if (readmarker) {
      //     initialReadMarker = readmarker.getContent().event_id;
      // } else {
      //     initialReadMarker = this.getCurrentReadReceipt();
      // }
      const {
        room
      } = context;
      const events = room.getLiveTimeline().getEvents();
      const event = events[events.length - 1];
      if (event) {
        initialReadMarker = event.getId();
      }
    }
    this.state = {
      events: [],
      liveEvents: [],
      timelineLoading: true,
      firstVisibleEventIndex: 0,
      canBackPaginate: false,
      canForwardPaginate: false,
      readMarkerVisible: true,
      readMarkerEventId: initialReadMarker,
      backPaginating: false,
      forwardPaginating: false,
      clientSyncState: MatrixClientPeg/* MatrixClientPeg */.p.get().getSyncState(),
      isTwelveHour: SettingsStore/* default */.C.getValue("showTwelveHourTimestamps"),
      alwaysShowTimestamps: SettingsStore/* default */.C.getValue("alwaysShowTimestamps"),
      readMarkerInViewThresholdMs: SettingsStore/* default */.C.getValue("readMarkerInViewThresholdMs"),
      readMarkerOutOfViewThresholdMs: SettingsStore/* default */.C.getValue("readMarkerOutOfViewThresholdMs")
    };
    this.dispatcherRef = dispatcher/* default */.ZP.register(this.onAction);
    const _cli = MatrixClientPeg/* MatrixClientPeg */.p.get();
    _cli.on("Room.timeline", this.onRoomTimeline);
    _cli.on("Room.timelineReset", this.onRoomTimelineReset);
    _cli.on("Room.redaction", this.onRoomRedaction);
    // same event handler as Room.redaction as for both we just do forceUpdate
    _cli.on("Room.redactionCancelled", this.onRoomRedaction);
    _cli.on("Room.receipt", this.onRoomReceipt);
    _cli.on("Room.localEchoUpdated", this.onLocalEchoUpdated);
    _cli.on("Room.accountData", this.onAccountData);
    _cli.on("Event.decrypted", this.onEventDecrypted);
    _cli.on("Event.replaced", this.onEventReplaced);
    _cli.on("sync", this.onSync);
  }

  // TODO: [REACT-WARNING] Move into constructor
  // eslint-disable-next-line
  UNSAFE_componentWillMount() {
    if (this.props.manageReadReceipts) {
      this.updateReadReceiptOnUserActivity();
    }
    if (this.props.manageReadMarkers) {
      this.updateReadMarkerOnUserActivity();
    }
    this.initTimeline(this.props);
    // this.saveMessage2Loacl(this.timelineWindow.getEvents());
  }

  // TODO: [REACT-WARNING] Replace with appropriate lifecycle event
  // eslint-disable-next-line
  UNSAFE_componentWillReceiveProps(newProps) {
    if (newProps.timelineSet !== this.props.timelineSet) {
      // throw new Error("changing timelineSet on a TimelinePanel is not supported");

      // regrettably, this does happen; in particular, when joining a
      // room with /join. In that case, there are two Rooms in
      // circulation - one which is created by the MatrixClient.joinRoom
      // call and used to create the RoomView, and a second which is
      // created by the sync loop once the room comes back down the /sync
      // pipe. Once the latter happens, our room is replaced with the new one.
      //
      // for now, just warn about this. But we're going to end up paginating
      // both rooms separately, and it's all bad.
      console.warn("Replacing timelineSet on a TimelinePanel - confusion may ensue");
    }
    const differentEventId = newProps.eventId != this.props.eventId;
    const differentHighlightedEventId = newProps.highlightedEventId != this.props.highlightedEventId;
    if (differentEventId || differentHighlightedEventId) {
      console.log("TimelinePanel switching to eventId " + newProps.eventId + " (was " + this.props.eventId + ")");
      return this.initTimeline(newProps);
    }
  }
  componentWillUnmount() {
    // set a boolean to say we've been unmounted, which any pending
    // promises can use to throw away their results.
    //
    // (We could use isMounted, but facebook have deprecated that.)
    this.unmounted = true;
    if (this.readReceiptActivityTimer) {
      this.readReceiptActivityTimer.abort();
      this.readReceiptActivityTimer = null;
    }
    if (this.readMarkerActivityTimer) {
      this.readMarkerActivityTimer.abort();
      this.readMarkerActivityTimer = null;
    }
    dispatcher/* default */.ZP.unregister(this.dispatcherRef);
    const client = MatrixClientPeg/* MatrixClientPeg */.p.get();
    if (client) {
      client.removeListener("Room.timeline", this.onRoomTimeline);
      client.removeListener("Room.timelineReset", this.onRoomTimelineReset);
      client.removeListener("Room.redaction", this.onRoomRedaction);
      client.removeListener("Room.redactionCancelled", this.onRoomRedaction);
      client.removeListener("Room.receipt", this.onRoomReceipt);
      client.removeListener("Room.localEchoUpdated", this.onLocalEchoUpdated);
      client.removeListener("Room.accountData", this.onAccountData);
      client.removeListener("Event.decrypted", this.onEventDecrypted);
      client.removeListener("Event.replaced", this.onEventReplaced);
      client.removeListener("sync", this.onSync);
    }
  }
  readMarkerTimeout(readMarkerPosition) {
    var _this$context$readMar, _this$context, _this$context$readMar2, _this$context2;
    return readMarkerPosition === 0 ? (_this$context$readMar = (_this$context = this.context) === null || _this$context === void 0 ? void 0 : _this$context.readMarkerInViewThresholdMs) !== null && _this$context$readMar !== void 0 ? _this$context$readMar : this.state.readMarkerInViewThresholdMs : (_this$context$readMar2 = (_this$context2 = this.context) === null || _this$context2 === void 0 ? void 0 : _this$context2.readMarkerOutOfViewThresholdMs) !== null && _this$context$readMar2 !== void 0 ? _this$context$readMar2 : this.state.readMarkerOutOfViewThresholdMs;
  }
  async updateReadMarkerOnUserActivity() {
    const initialTimeout = this.readMarkerTimeout(this.getReadMarkerPosition());
    this.readMarkerActivityTimer = new Timer/* default */.Z(initialTimeout);
    while (this.readMarkerActivityTimer) {
      //unset on unmount
      UserActivity/* default */.Z.sharedInstance().timeWhileActiveRecently(this.readMarkerActivityTimer);
      try {
        await this.readMarkerActivityTimer.finished();
      } catch (e) {
        continue; /* aborted */
      }
      // outside of try/catch to not swallow errors
      this.updateReadMarker();
    }
  }
  async updateReadReceiptOnUserActivity() {
    this.readReceiptActivityTimer = new Timer/* default */.Z(READ_RECEIPT_INTERVAL_MS);
    while (this.readReceiptActivityTimer) {
      //unset on unmount
      UserActivity/* default */.Z.sharedInstance().timeWhileActiveNow(this.readReceiptActivityTimer);
      try {
        await this.readReceiptActivityTimer.finished();
      } catch (e) {
        continue; /* aborted */
      }
      // outside of try/catch to not swallow errors
      this.sendReadReceipt();
    }
  }
  // advance the read marker past any events we sent ourselves.
  advanceReadMarkerPastMyEvents() {
    if (!this.props.manageReadMarkers) return;

    // we call `timelineWindow.getEvents()` rather than using
    // `this.state.liveEvents`, because React batches the update to the
    // latter, so it may not have been updated yet.
    const events = this.timelineWindow.getEvents();

    // first find where the current RM is
    let i;
    for (i = 0; i < events.length; i++) {
      if (events[i].getId() == this.state.readMarkerEventId) {
        break;
      }
    }
    if (i >= events.length) {
      return;
    }

    // now think about advancing it
    const myUserId = MatrixClientPeg/* MatrixClientPeg */.p.get().credentials.userId;
    for (i++; i < events.length; i++) {
      const ev = events[i];
      if (ev.getSender() !== myUserId) {
        break;
      }
    }
    // i is now the first unread message which we didn't send ourselves.
    i--;
    const ev = events[i];
    this.setReadMarker(ev.getId(), ev.getTs());
  }
  initTimeline(props) {
    const initialEvent = props.eventId;
    const pixelOffset = props.eventPixelOffset;

    // if a pixelOffset is given, it is relative to the bottom of the
    // container. If not, put the event in the middle of the container.
    let offsetBase = 1;
    if (pixelOffset == null) {
      offsetBase = 0.5;
    }
    return this.loadTimeline(initialEvent, pixelOffset, offsetBase);
  }

  /**
   * (re)-load the event timeline, and initialise the scroll state, centered
   * around the given event.
   *
   * @param {string?}  eventId the event to focus on. If undefined, will
   *    scroll to the bottom of the room.
   *
   * @param {number?} pixelOffset   offset to position the given event at
   *    (pixels from the offsetBase). If omitted, defaults to 0.
   *
   * @param {number?} offsetBase the reference point for the pixelOffset. 0
   *     means the top of the container, 1 means the bottom, and fractional
   *     values mean somewhere in the middle. If omitted, it defaults to 0.
   */
  loadTimeline(eventId, pixelOffset, offsetBase) {
    this.timelineWindow = new timeline_window/* TimelineWindow */.e(MatrixClientPeg/* MatrixClientPeg */.p.get(), this.props.timelineSet, {
      windowLimit: this.props.timelineCap
    });
    const onLoaded = () => {
      if (this.unmounted) return;

      // clear the timeline min-height when
      // (re)loading the timeline
      if (this.messagePanel.current) {
        this.messagePanel.current.onTimelineReset();
      }
      this.reloadEvents();

      // If we switched away from the room while there were pending
      // outgoing events, the read-marker will be before those events.
      // We need to skip over any which have subsequently been sent.
      this.advanceReadMarkerPastMyEvents();
      this.setState({
        canBackPaginate: this.timelineWindow.canPaginate(event_timeline/* EventTimeline */.G.BACKWARDS),
        canForwardPaginate: this.timelineWindow.canPaginate(event_timeline/* EventTimeline */.G.FORWARDS),
        timelineLoading: false
      }, () => {
        // initialise the scroll state of the message panel
        if (!this.messagePanel.current) {
          // this shouldn't happen - we know we're mounted because
          // we're in a setState callback, and we know
          // timelineLoading is now false, so render() should have
          // mounted the message panel.
          console.log("can't initialise scroll state because " + "messagePanel didn't load");
          return;
        }
        if (eventId) {
          this.messagePanel.current.scrollToEvent(eventId, pixelOffset, offsetBase);
        } else {
          this.messagePanel.current.scrollToBottom();
        }
        if (this.props.sendReadReceiptOnLoad) {
          this.sendReadReceipt();
        }
      });
    };
    const onError = error => {
      if (this.unmounted) return;
      this.setState({
        timelineLoading: false
      });
      console.error(`Error loading timeline panel at ${eventId}: ${error}`);
      let onFinished;

      // if we were given an event ID, then when the user closes the
      // dialog, let's jump to the end of the timeline. If we weren't,
      // something has gone badly wrong and rather than causing a loop of
      // undismissable dialogs, let's just give up.
      if (eventId) {
        onFinished = () => {
          // go via the dispatcher so that the URL is updated
          dispatcher/* default */.ZP.dispatch({
            action: "view_room",
            room_id: this.props.timelineSet.room.roomId
          });
        };
      }
      let message;
      if (error.errcode == "M_FORBIDDEN") {
        message = (0,languageHandler._t)("Tried to load a specific point in this room's timeline, but you " + "do not have permission to view the message in question.");
      } else {
        message = (0,languageHandler._t)("Tried to load a specific point in this room's timeline, but was " + "unable to find it.");
      }
      Modal/* default */.Z.createTrackedDialog("Failed to load timeline position", "", ErrorDialog/* default */.Z, {
        title: (0,languageHandler._t)("Failed to load timeline position"),
        description: message,
        onFinished: onFinished
      });
    };

    // if we already have the event in question, TimelineWindow.load
    // returns a resolved promise.
    //
    // In this situation, we don't really want to defer the update of the
    // state to the next event loop, because it makes room-switching feel
    // quite slow. So we detect that situation and shortcut straight to
    // calling _reloadEvents and updating the state.

    const timeline = this.props.timelineSet.getTimelineForEvent(eventId);
    if (timeline) {
      // This is a hot-path optimization by skipping a promise tick
      // by repeating a no-op sync branch in TimelineSet.getTimelineForEvent & MatrixClient.getEventTimeline
      this.timelineWindow.load(eventId, INITIAL_SIZE); // in this branch this method will happen in sync time
      onLoaded();
    } else {
      const prom = this.timelineWindow.load(eventId, INITIAL_SIZE);
      this.setState({
        events: [],
        liveEvents: [],
        canBackPaginate: false,
        canForwardPaginate: false,
        timelineLoading: true
      });
      prom.then(onLoaded, onError);
    }
  }

  // handle the completion of a timeline load or localEchoUpdate, by
  // reloading the events from the timelinewindow and pending event list into
  // the state.
  reloadEvents() {
    // we might have switched rooms since the load started - just bin
    // the results if so.
    if (this.unmounted) return;
    this.setState(this.getEvents());
  }

  // Force refresh the timeline before threads support pending events
  refreshTimeline() {
    this.loadTimeline();
    this.reloadEvents();
  }

  // get the list of events from the timeline window and the pending event list
  getEvents() {
    const events = this.timelineWindow.getEvents();
    let filterEvents = [];
    if (this.props.tileShape === EventTile/* TileShape */.GO.ImageGrid) {
      for (let i = 0; i < events.length; i++) {
        const event = events[i];
        const content = event.getContent();
        if (content.msgtype === _types_event/* MsgType */.Zw.Image || content.msgtype === _types_event/* MsgType */.Zw.Video) {
          filterEvents.push(event);
        }
      }
    } else if (this.props.tileShape === EventTile/* TileShape */.GO.FileGrid) {
      for (let i = 0; i < events.length; i++) {
        const event = events[i];
        const content = event.getContent();
        if (content.msgtype === _types_event/* MsgType */.Zw.File) {
          filterEvents.push(event);
        }
      }
    } else {
      filterEvents = events;
    }
    // `arrayFastClone` performs a shallow copy of the array
    // we want the last event to be decrypted first but displayed last
    // `reverse` is destructive and unfortunately mutates the "events" array
    (0,arrays/* arrayFastClone */.iP)(filterEvents).reverse().forEach(event => {
      const client = MatrixClientPeg/* MatrixClientPeg */.p.get();
      // why here?
      client.decryptEventIfNeeded(event);
    });
    const firstVisibleEventIndex = this.checkForPreJoinUISI(filterEvents);

    // Hold onto the live events separately. The read receipt and read marker
    // should use this list, so that they don't advance into pending events.
    const liveEvents = [...filterEvents];

    // if we're at the end of the live timeline, append the pending events
    if (!this.timelineWindow.canPaginate(event_timeline/* EventTimeline */.G.FORWARDS)) {
      filterEvents.push(...this.props.timelineSet.getPendingEvents());
    }
    if (this.props.sortEventType) {
      filterEvents.sort((a, b) => {
        if (this.props.sortEventType == "DOWN") {
          return b.getTs() - a.getTs();
        } else if (this.props.sortEventType == "UP") {
          return a.getTs() - b.getTs();
        }
      });
    }
    return {
      events: filterEvents,
      liveEvents,
      firstVisibleEventIndex
    };
  }
  saveMessage2Loacl(events) {
    const len = events.length;
    const cli = MatrixClientPeg/* MatrixClientPeg */.p.get();
    try {
      for (let i = 0; i < len; i++) {
        const event = events[i];
        cli.opfsStore.addMessage({
          roomId: event.event.room_id,
          content: event.event.content.body,
          sender: event.event.sender,
          eventId: event.event.event_id,
          originServerTs: event.event.origin_server_ts,
          event
        });
      }
    } catch (err) {
      console.log(err);
    }
  }

  /**
   * Check for undecryptable messages that were sent while the user was not in
   * the room.
   *
   * @param {Array<MatrixEvent>} events The timeline events to check
   *
   * @return {Number} The index within `events` of the event after the most recent
   * undecryptable event that was sent while the user was not in the room.  If no
   * such events were found, then it returns 0.
   */
  checkForPreJoinUISI(events) {
    const room = this.props.timelineSet.room;
    if (events.length === 0 || !room || !MatrixClientPeg/* MatrixClientPeg */.p.get().isRoomEncrypted(room.roomId)) {
      return 0;
    }
    const userId = MatrixClientPeg/* MatrixClientPeg */.p.get().credentials.userId;

    // get the user's membership at the last event by getting the timeline
    // that the event belongs to, and traversing the timeline looking for
    // that event, while keeping track of the user's membership
    let i;
    let userMembership = "leave";
    for (i = events.length - 1; i >= 0; i--) {
      const timeline = room.getTimelineForEvent(events[i].getId());
      if (!timeline) {
        // Somehow, it seems to be possible for live events to not have
        // a timeline, even though that should not happen. :(
        // https://github.com/vector-im/element-web/issues/12120
        console.warn(`Event ${events[i].getId()} in room ${room.roomId} is live, ` + `but it does not have a timeline`);
        continue;
      }
      const userMembershipEvent = timeline.getState(event_timeline/* EventTimeline */.G.FORWARDS).getMember(userId);
      userMembership = userMembershipEvent ? userMembershipEvent.membership : "leave";
      const timelineEvents = timeline.getEvents();
      for (let j = timelineEvents.length - 1; j >= 0; j--) {
        const event = timelineEvents[j];
        if (event.getId() === events[i].getId()) {
          break;
        } else if (event.getStateKey() === userId && event.getType() === "m.room.member") {
          const prevContent = event.getPrevContent();
          userMembership = prevContent.membership || "leave";
        }
      }
      break;
    }

    // now go through the rest of the events and find the first undecryptable
    // one that was sent when the user wasn't in the room
    for (; i >= 0; i--) {
      const event = events[i];
      if (event.getStateKey() === userId && event.getType() === "m.room.member") {
        const prevContent = event.getPrevContent();
        userMembership = prevContent.membership || "leave";
      } else if (userMembership === "leave" && (event.isDecryptionFailure() || event.isBeingDecrypted())) {
        // reached an undecryptable message when the user wasn't in
        // the room -- don't try to load any more
        // Note: for now, we assume that events that are being decrypted are
        // not decryptable
        return i + 1;
      }
    }
    return 0;
  }
  indexForEventId(evId) {
    for (let i = 0; i < this.state.events.length; ++i) {
      if (evId == this.state.events[i].getId()) {
        return i;
      }
    }
    return null;
  }
  getLastDisplayedEventIndex(opts = {}) {
    const ignoreOwn = opts.ignoreOwn || false;
    const allowPartial = opts.allowPartial || false;
    const messagePanel = this.messagePanel.current;
    if (!messagePanel) return null;
    const messagePanelNode = react_dom.findDOMNode(messagePanel);
    if (!messagePanelNode) return null; // sometimes this happens for fresh rooms/post-sync
    const wrapperRect = messagePanelNode.getBoundingClientRect();
    const myUserId = MatrixClientPeg/* MatrixClientPeg */.p.get().credentials.userId;
    const isNodeInView = node => {
      if (node) {
        const boundingRect = node.getBoundingClientRect();
        if (allowPartial && boundingRect.top < wrapperRect.bottom || !allowPartial && boundingRect.bottom < wrapperRect.bottom) {
          return true;
        }
      }
      return false;
    };

    // We keep track of how many of the adjacent events didn't have a tile
    // but should have the read receipt moved past them, so
    // we can include those once we find the last displayed (visible) event.
    // The counter is not started for events we don't want
    // to send a read receipt for (our own events, local echos).
    let adjacentInvisibleEventCount = 0;
    // Use `liveEvents` here because we don't want the read marker or read
    // receipt to advance into pending events.
    for (let i = this.state.liveEvents.length - 1; i >= 0; --i) {
      var _this$context3;
      const ev = this.state.liveEvents[i];
      const node = messagePanel.getNodeForEventId(ev.getId());
      const isInView = isNodeInView(node);

      // when we've reached the first visible event, and the previous
      // events were all invisible (with the first one not being ignored),
      // return the index of the first invisible event.
      if (isInView && adjacentInvisibleEventCount !== 0) {
        return i + adjacentInvisibleEventCount;
      }
      if (node && !isInView) {
        // has node but not in view, so reset adjacent invisible events
        adjacentInvisibleEventCount = 0;
      }
      const shouldIgnore = !!ev.status ||
      // local echo
      ignoreOwn && ev.getSender() === myUserId; // own message
      const isWithoutTile = !(0,EventTile/* haveTileForEvent */.K3)(ev, (_this$context3 = this.context) === null || _this$context3 === void 0 ? void 0 : _this$context3.showHiddenEventsInTimeline) || (0,shouldHideEvent/* default */.Z)(ev, this.context);
      if (isWithoutTile || !node) {
        // don't start counting if the event should be ignored,
        // but continue counting if we were already so the offset
        // to the previous invisble event that didn't need to be ignored
        // doesn't get messed up
        if (!shouldIgnore || shouldIgnore && adjacentInvisibleEventCount !== 0) {
          ++adjacentInvisibleEventCount;
        }
        continue;
      }
      if (shouldIgnore) {
        continue;
      }
      if (isInView) {
        return i;
      }
    }
    return null;
  }

  /**
   * Get the id of the event corresponding to our user's latest read-receipt.
   *
   * @param {Boolean} ignoreSynthesized If true, return only receipts that
   *                                    have been sent by the server, not
   *                                    implicit ones generated by the JS
   *                                    SDK.
   * @return {String} the event ID
   */
  getCurrentReadReceipt(ignoreSynthesized = false) {
    const client = MatrixClientPeg/* MatrixClientPeg */.p.get();
    // the client can be null on logout
    if (client == null) {
      return null;
    }
    const myUserId = client.credentials.userId;
    return this.props.timelineSet.room.getEventReadUpTo(myUserId, ignoreSynthesized);
  }
  setReadMarker(eventId, eventTs, inhibitSetState = false) {
    const roomId = this.props.timelineSet.room.roomId;

    // don't update the state (and cause a re-render) if there is
    // no change to the RM.
    if (eventId === this.state.readMarkerEventId) {
      return;
    }

    // in order to later figure out if the read marker is
    // above or below the visible timeline, we stash the timestamp.
    TimelinePanel.roomReadMarkerTsMap[roomId] = eventTs;
    if (inhibitSetState) {
      return;
    }

    // Do the local echo of the RM
    // run the render cycle before calling the callback, so that
    // getReadMarkerPosition() returns the right thing.
    this.setState({
      readMarkerEventId: eventId
    }, this.props.onReadMarkerUpdated);
  }
  shouldPaginate() {
    // don't try to paginate while events in the timeline are
    // still being decrypted. We don't render events while they're
    // being decrypted, so they don't take up space in the timeline.
    // This means we can pull quite a lot of events into the timeline
    // and end up trying to render a lot of events.
    return !this.state.events.some(e => {
      return e.isBeingDecrypted();
    });
  }
  render() {
    var _this$context$showTwe, _this$context4, _ref, _this$props$alwaysSho, _this$context5;
    // just show a spinner while the timeline loads.
    //
    // put it in a div of the right class (mx_RoomView_messagePanel) so
    // that the order in the roomview flexbox is correct, and
    // mx_RoomView_messageListWrapper to position the inner div in the
    // right place.
    //
    // Note that the click-on-search-result functionality relies on the
    // fact that the messagePanel is hidden while the timeline reloads,
    // but that the RoomHeader (complete with search term) continues to
    // exist.
    if (this.state.timelineLoading) {
      return /*#__PURE__*/react.createElement("div", {
        className: "mx_RoomView_messagePanelSpinner"
      }, /*#__PURE__*/react.createElement(elements_Spinner/* default */.Z, null));
    }
    if (this.state.events.length == 0 && !this.state.canBackPaginate && this.props.empty) {
      return /*#__PURE__*/react.createElement("div", {
        className: this.props.className + " mx_RoomView_messageListWrapper"
      }, /*#__PURE__*/react.createElement("div", {
        className: "mx_RoomView_empty"
      }, this.props.empty));
    }

    // give the messagepanel a stickybottom if we're at the end of the
    // live timeline, so that the arrival of new events triggers a
    // scroll.
    //
    // Make sure that stickyBottom is *false* if we can paginate
    // forwards, otherwise if somebody hits the bottom of the loaded
    // events when viewing historical messages, we get stuck in a loop
    // of paginating our way through the entire history of the room.
    const stickyBottom = !this.timelineWindow.canPaginate(event_timeline/* EventTimeline */.G.FORWARDS);

    // If the state is PREPARED or CATCHUP, we're still waiting for the js-sdk to sync with
    // the HS and fetch the latest events, so we are effectively forward paginating.
    const forwardPaginating = this.state.forwardPaginating || ["PREPARED", "CATCHUP"].includes(this.state.clientSyncState);
    const events = this.state.firstVisibleEventIndex ? this.state.events.slice(this.state.firstVisibleEventIndex) : this.state.events;
    return /*#__PURE__*/react.createElement(MessagePanel, {
      ref: this.messagePanel,
      room: this.props.timelineSet.room,
      permalinkCreator: this.props.permalinkCreator,
      hidden: this.props.hidden,
      backPaginating: this.state.backPaginating,
      forwardPaginating: forwardPaginating,
      events: events,
      highlightedEventId: this.props.highlightedEventId,
      readMarkerEventId: this.state.readMarkerEventId,
      readMarkerVisible: this.state.readMarkerVisible,
      suppressFirstDateSeparator: this.state.canBackPaginate,
      showUrlPreview: this.props.showUrlPreview,
      showReadReceipts: this.props.showReadReceipts,
      ourUserId: MatrixClientPeg/* MatrixClientPeg */.p.get().credentials.userId,
      stickyBottom: stickyBottom,
      onScroll: this.onMessageListScroll,
      onUserScroll: this.props.onUserScroll,
      onFillRequest: this.onMessageListFillRequest,
      onUnfillRequest: this.onMessageListUnfillRequest,
      isTwelveHour: (_this$context$showTwe = (_this$context4 = this.context) === null || _this$context4 === void 0 ? void 0 : _this$context4.showTwelveHourTimestamps) !== null && _this$context$showTwe !== void 0 ? _this$context$showTwe : this.state.isTwelveHour,
      alwaysShowTimestamps: (_ref = (_this$props$alwaysSho = this.props.alwaysShowTimestamps) !== null && _this$props$alwaysSho !== void 0 ? _this$props$alwaysSho : (_this$context5 = this.context) === null || _this$context5 === void 0 ? void 0 : _this$context5.alwaysShowTimestamps) !== null && _ref !== void 0 ? _ref : this.state.alwaysShowTimestamps,
      className: this.props.className,
      tileShape: this.props.tileShape,
      resizeNotifier: this.props.resizeNotifier,
      getRelationsForEvent: this.getRelationsForEvent,
      editState: this.props.editState,
      showReactions: this.props.showReactions,
      layout: this.props.layout,
      enableFlair: SettingsStore/* default */.C.getValue(UIFeature/* UIFeature */.H.Flair),
      hideThreadedMessages: this.props.hideThreadedMessages,
      canBackPaginate: this.state.canBackPaginate
    });
  }
}, (0,defineProperty/* default */.Z)(TimelinePanel_class2, "contextType", contexts_RoomContext/* default */.Z), (0,defineProperty/* default */.Z)(TimelinePanel_class2, "roomReadMarkerTsMap", {}), (0,defineProperty/* default */.Z)(TimelinePanel_class2, "defaultProps", {
  // By default, disable the timelineCap in favour of unpaginating based on
  // event tile heights. (See _unpaginateEvents)
  timelineCap: Number.MAX_VALUE,
  className: "mx_RoomView_messagePanel",
  sendReadReceiptOnLoad: true,
  hideThreadedMessages: true
}), TimelinePanel_class2)) || TimelinePanel_class);
/* harmony default export */ const structures_TimelinePanel = (TimelinePanel);

/***/ }),

/***/ 249135:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  n: () => (/* binding */ DisplayPosition),
  Z: () => (/* binding */ space_home_DappButtons)
});

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(667294);
// EXTERNAL MODULE: ./node_modules/classnames/index.js
var classnames = __webpack_require__(294184);
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/MatrixClientPeg.ts + 3 modules
var MatrixClientPeg = __webpack_require__(933393);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/elements/AccessibleButton.tsx
var AccessibleButton = __webpack_require__(805035);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/dispatcher/actions.ts
var actions = __webpack_require__(473627);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/RightPanelStorePhases.ts
var RightPanelStorePhases = __webpack_require__(274057);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/dispatcher/dispatcher.ts
var dispatcher = __webpack_require__(245539);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/languageHandler.tsx
var languageHandler = __webpack_require__(867614);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/elements/Spinner.tsx
var Spinner = __webpack_require__(641542);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/RoomViewStore.tsx
var RoomViewStore = __webpack_require__(144332);
// EXTERNAL MODULE: ./node_modules/lodash-es/get.js
var get = __webpack_require__(216423);
// EXTERNAL MODULE: ./node_modules/lodash-es/isPlainObject.js
var isPlainObject = __webpack_require__(437514);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/lib/constants.ts
var constants = __webpack_require__(877294);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/snapshot/SnapshotButtonView.tsx









const SnapshotButton = ({
  roomId,
  style = {},
  className
}) => {
  var _client$getRoom$getPa;
  const client = MatrixClientPeg/* MatrixClientPeg */.p.get();
  const userId = client.getUserId();
  const squadId = ((_client$getRoom$getPa = client.getRoom(roomId).getParentRoom()) === null || _client$getRoom$getPa === void 0 ? void 0 : _client$getRoom$getPa.roomId) || roomId;
  const [spaceId, setSpaceId] = (0,react.useState)("");
  const [loading, setLoading] = (0,react.useState)(true);
  (0,react.useEffect)(() => {
    let didCancel = false;
    client.getBindedSnapshotSpace(squadId).then(res => {
      if ((0,isPlainObject/* default */.Z)(res) && !didCancel) {
        setSpaceId(res.id);
      }
    }).catch(() => {
      setSpaceId("");
    }).finally(() => setLoading(false));
    return () => {
      didCancel = true;
    };
  }, []);
  return /*#__PURE__*/react.createElement(AccessibleButton/* default */.Z, {
    key: "vote",
    className: className,
    disabled: loading,
    kind: "primary",
    style: style,
    onClick: () => {
      if (spaceId) {
        dispatcher/* default */.ZP.dispatch({
          action: actions/* Action */.a.SetRightPanelPhase,
          phase: RightPanelStorePhases/* RightPanelPhases */.q4.IframeWidget,
          refireParams: {
            params: {
              src: `${constants/* VOTE_URL */.lH}/#/${spaceId || ""}?roomId=${squadId}&userId=${userId}`,
              title: "Snapshot"
            }
          }
        });
      }
    }
  }, /*#__PURE__*/react.createElement("div", null, "Snapshot"));
};
/* harmony default export */ const SnapshotButtonView = (SnapshotButton);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/lib/util.ts
var util = __webpack_require__(25654);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/settings/SettingsStore.ts + 9 modules
var SettingsStore = __webpack_require__(571879);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/structures/space_home/DappButtons.tsx














let DisplayPosition = /*#__PURE__*/function (DisplayPosition) {
  DisplayPosition["SQUAD_HOME"] = "squad_home";
  DisplayPosition["SQUAD_HOME_ADMIN"] = "squad_home_admin";
  DisplayPosition["CHAT_BOX_L1"] = "chat_box_l1";
  DisplayPosition["CHAT_BOX_L2"] = "chat_box_l2";
  DisplayPosition["DISCOVER"] = "discover";
  return DisplayPosition;
}({});
const DappButtons = props => {
  const [loading, setLoading] = (0,react.useState)(false);
  // DESC: 优化，第一层由外部组件传入
  const [items, setItems] = (0,react.useState)(props.items || []);
  const notShowLinxAuthNameList = ["Money Gun", "Transfer"];
  (0,react.useEffect)(() => {
    const fetchDapps = async () => {
      setLoading(true);
      const client = MatrixClientPeg/* MatrixClientPeg */.p.get();
      const roomId = RoomViewStore/* default */.Z.getRoomId();
      const room = MatrixClientPeg/* MatrixClientPeg */.p.get().getRoom(roomId);
      const roomType = await room.getRoomType();
      let dappRoomType;
      if (["squad", "room"].includes(roomType)) {
        dappRoomType = "squad_chat";
      } else if (roomType === "dm") {
        dappRoomType = "trusted_private_chat";
      } else {
        dappRoomType = "group_chat";
      }
      // TODO: 容错处理， 非L1、L2，不需要传roomType
      if (![DisplayPosition.CHAT_BOX_L1, DisplayPosition.CHAT_BOX_L2].includes(props.displayPosition)) {
        dappRoomType = undefined;
      }
      try {
        const result = await MatrixClientPeg/* MatrixClientPeg */.p.getDapps(props.displayPosition);
        console.log("fetch dapps:", {
          result
        });
        setItems(result);
      } catch (error) {
        setItems([]);
        console.error("fetch dapp list failed", error, props);
      } finally {
        setLoading(false);
      }
    };
    if (props.items) {
      if (props.displayPosition === DisplayPosition.CHAT_BOX_L2) fetchDapps();
    } else fetchDapps();
  }, [props.terminal, props.displayPosition]);
  const getQuery = (context, params) => {
    return params.reduce((arr, cur) => {
      const {
        context: key,
        args
      } = cur;
      arr.push(`${args}=${(0,get/* default */.Z)(context, key, "")}`);
      return arr;
    }, []).join("&");
  };
  if (loading && props.loading) {
    return /*#__PURE__*/react.createElement(Spinner/* default */.Z, null);
  }
  return /*#__PURE__*/react.createElement(react.Fragment, null, items.map(item => {
    const style = {};
    if (item.app_logo) {
      style["--avatar"] = `url(${item.grayscale || item.app_logo})`;
    }
    if (item.app_name.toLowerCase() === "snapshot") {
      var _props$context, _props$context2;
      return /*#__PURE__*/react.createElement(SnapshotButtonView, {
        key: item.app_name,
        roomId: ((_props$context = props.context) === null || _props$context === void 0 ? void 0 : _props$context.roomId) || ((_props$context2 = props.context) === null || _props$context2 === void 0 ? void 0 : _props$context2.squadId),
        style: style,
        className: classnames_default()("mx_DApp_buttons", props.className, props.layout)
      });
    } else {
      return /*#__PURE__*/react.createElement(AccessibleButton/* default */.Z, {
        key: item.app_url,
        kind: "primary",
        className: classnames_default()("mx_DApp_buttons", props.className, props.layout),
        title: (0,languageHandler._t)(item.app_name),
        style: style,
        onClick: () => {
          const theme = SettingsStore/* default */.C.getValue("theme") === "light" ? "light" : "dark";
          const themeQuery = `&theme=${theme}`;
          const query = (0,util/* isString */.HD)(item.route_params) ? item.route_params + themeQuery : getQuery(props.context, item.route_params || []) + themeQuery;
          dispatcher/* default */.ZP.dispatch({
            action: actions/* Action */.a.SetRightPanelPhase,
            phase: RightPanelStorePhases/* RightPanelPhases */.q4.IframeWidget,
            refireParams: {
              params: {
                src: getSrc(item.app_url, query),
                title: item.app_name,
                needHiddenLinxAuth: notShowLinxAuthNameList.includes(item.app_name)
              }
            }
          });
        }
      }, /*#__PURE__*/react.createElement("div", null, (0,languageHandler._t)(item.app_name)));
    }
  }));
};
DappButtons.defaultProps = {
  terminal: "web",
  layout: "horizontal"
};
/* harmony default export */ const space_home_DappButtons = (DappButtons);
const getSrc = (url, query) => {
  if (url.indexOf("?") > -1) {
    return `${url}&${query}`;
  }
  return `${url}?${query}`;
};

/***/ }),

/***/ 135605:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(667294);
/* harmony import */ var dayjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(727484);
/* harmony import */ var dayjs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(dayjs__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var sendingme_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(602271);
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(294184);
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _MatrixClientPeg__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(933393);
/* harmony import */ var _components_Split__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(583282);






const AncCardInfo = props => {
  const {
    mxEvent,
    type,
    className
  } = props;
  const roomId = mxEvent.event.room_id;
  const room = _MatrixClientPeg__WEBPACK_IMPORTED_MODULE_4__/* .MatrixClientPeg */ .p.get().getRoom(roomId);
  const ts = mxEvent.getTs();
  let iconName = "PinOutlines";
  let typeColor = "#B57BFB";
  let typeName = "Pinned";
  if (type === "NOTICE") {
    iconName = "NoticeOutlines";
    typeColor = "#FC774B";
    typeName = "Notice";
  } else if (type === "AMA") {
    iconName = "WaveOutlines";
    typeName = "AMA";
  }
  const wrapperClass = classnames__WEBPACK_IMPORTED_MODULE_3___default()({
    "mx_squadHomePage_ancCard_info": true,
    "text-tertiary": true,
    "inline-block": true,
    "wb-keep-all": true
  }, className);
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: wrapperClass
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
    style: {
      textTransform: "capitalize",
      fontWeight: 500,
      color: typeColor
    },
    className: "inline-block"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(sendingme_ui__WEBPACK_IMPORTED_MODULE_2__.SdIcon, {
    icon: iconName,
    style: {
      marginRight: "4px"
    }
  }), typeName), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components_Split__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z, {
    className: "px-12 inline-block"
  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", null, room.name), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components_Split__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z, {
    className: "px-12 inline-block"
  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", null, dayjs__WEBPACK_IMPORTED_MODULE_1___default()(ts).format("MMM DD, YYYY HH:mm")));
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AncCardInfo);

/***/ }),

/***/ 583282:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(294184);
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(667294);


function Split(props) {
  const {
    className
  } = props;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("span", {
    className: classnames__WEBPACK_IMPORTED_MODULE_0___default()("mx_squadHomePage_split", className)
  }, "|");
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Split);

/***/ }),

/***/ 807065:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A4: () => (/* binding */ getRooms),
/* harmony export */   ZP: () => (/* binding */ useAnnouncements)
/* harmony export */ });
/* unused harmony exports getAmaEventEntries, getMsgEventEntries */
/* harmony import */ var matrix_js_sdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(407637);
/* harmony import */ var matrix_js_sdk_src_types_event__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(907977);
/* harmony import */ var _MatrixClientPeg__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(933393);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(479697);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(325614);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(727961);
/* harmony import */ var _utils_PinningUtils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(53050);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(667294);






function useAnnouncements(room) {
  const cli = _MatrixClientPeg__WEBPACK_IMPORTED_MODULE_2__/* .MatrixClientPeg */ .p.get();
  const ref = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)([]);
  const [mxEvents, setMxEvents] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)();
  const [pinnedMap, setPinnedMap] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)();
  const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(true);
  let rooms = getRooms(room);
  const amaEventEntries = getAmaEventEntries(rooms);
  const ancEventEntries = getAncEventEntries(rooms);
  const msgEventEntries = getMsgEventEntries(rooms, ancEventEntries, amaEventEntries);
  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {
    const eventEntries = [...amaEventEntries, ...msgEventEntries, ...ancEventEntries];
    const isDiff = ref.current.length !== eventEntries.length || !(0,lodash_es__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)((0,lodash_es__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(ref.current, eventEntries, "eventId"));
    if (isDiff) {
      ref.current = eventEntries;
      setLoading(true);
      const pinnedMap = new Map();
      msgEventEntries.forEach(item => pinnedMap.set(item.eventId, "MSG"));
      amaEventEntries.forEach(item => pinnedMap.set(item.eventId, "AMA"));
      ancEventEntries.forEach(item => pinnedMap.set(item.eventId, "NOTICE"));
      const promises = ref.current.map(async ({
        room,
        eventId
      }) => {
        var _timelineSet$getTimel;
        const timelineSet = room.getUnfilteredTimelineSet();
        const localEvent = timelineSet === null || timelineSet === void 0 ? void 0 : (_timelineSet$getTimel = timelineSet.getTimelineForEvent(eventId)) === null || _timelineSet$getTimel === void 0 ? void 0 : _timelineSet$getTimel.getEvents().find(e => e.getId() === eventId);
        if (localEvent) {
          if (localEvent.isEncrypted()) {
            await cli.decryptEventIfNeeded(localEvent);
          }
          return localEvent;
        }
        try {
          const evJson = await cli.fetchRoomEvent(room.roomId, eventId);
          const event = new matrix_js_sdk__WEBPACK_IMPORTED_MODULE_0__/* .MatrixEvent */ .dC(evJson);
          if (event.isEncrypted()) {
            await cli.decryptEventIfNeeded(event); // TODO await?
          }

          if (event && _utils_PinningUtils__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z.isPinnable(event)) {
            return event;
          }
        } catch (err) {
          console.error("Error looking up pinned event " + eventId + " in room " + room.roomId);
          console.error(err);
        }
        return null;
      });
      setLoading(false);
      setMxEvents(promises);
      setPinnedMap(pinnedMap);
    } else {
      setLoading(false);
    }
  }, [amaEventEntries, msgEventEntries]);
  return {
    loading,
    mxEvents,
    pinnedMap
  };
}
const getRooms = room => {
  const cli = _MatrixClientPeg__WEBPACK_IMPORTED_MODULE_2__/* .MatrixClientPeg */ .p.get();
  let rooms = [];
  if (room.isSpaceRoom()) {
    const events = room.currentState.getStateEvents(matrix_js_sdk_src_types_event__WEBPACK_IMPORTED_MODULE_1__/* .EventType */ .tw.SpaceChild);
    rooms = events.map(ev => ev.getStateKey()).map(id => cli.getRoom(id)).filter(Boolean).filter(room => room.getMyMembership() === "join");
  } else {
    rooms = [room];
  }
  return rooms;
};
const getAmaEventEntries = rooms => {
  const amaEventEntries = rooms.map(room => ({
    room,
    content: room.getPinnedActivityEventContent()
  })).map(({
    room,
    content
  }) => ({
    room,
    eventId: content.pinned
  })).filter(({
    eventId
  }) => !!eventId);
  return amaEventEntries;
};
const getMsgEventEntries = (rooms, ancEvs, amaEvs) => {
  const flattenMsgEventEntries = (0,lodash_es__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(rooms.map(room => {
    var _room$currentState$ge, _room$currentState$ge2;
    const eventIds = (_room$currentState$ge = room.currentState.getStateEvents(matrix_js_sdk_src_types_event__WEBPACK_IMPORTED_MODULE_1__/* .EventType */ .tw.RoomPinnedEvents, "")) === null || _room$currentState$ge === void 0 ? void 0 : (_room$currentState$ge2 = _room$currentState$ge.getContent()) === null || _room$currentState$ge2 === void 0 ? void 0 : _room$currentState$ge2.pinned;
    return eventIds === null || eventIds === void 0 ? void 0 : eventIds.map(id => ({
      room,
      eventId: id
    }));
  }));
  const excludeAncAndAmaEnries = flattenMsgEventEntries.filter(Boolean).filter(flattenEv => {
    const {
      eventId
    } = flattenEv;
    if (ancEvs.find(ancEv => ancEv.eventId === eventId) || amaEvs.find(amaEv => amaEv.eventId === eventId)) {
      return false;
    }
    return true;
  });
  const msgEventEntries = excludeAncAndAmaEnries.filter(Boolean).filter(({
    eventId
  }) => !!eventId);
  return msgEventEntries;
};
const getAncEventEntries = rooms => {
  const ancEventEntries = rooms.map(room => {
    const ev = room.currentState.getStateEvents(matrix_js_sdk_src_types_event__WEBPACK_IMPORTED_MODULE_1__/* .EventType */ .tw.RoomAnnouncement, "");
    if (ev) {
      return {
        room,
        eventId: ev.getId()
      };
    }
    return null;
  }).filter(Boolean);
  return ancEventEntries;
};

/***/ }),

/***/ 224424:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(667294);
/* harmony import */ var sendingme_ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(602271);
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(294184);
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var matrix_js_sdk_src_types_event__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(907977);
/* harmony import */ var _MatrixClientPeg__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(933393);
/* harmony import */ var _languageHandler__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(867614);
/* harmony import */ var _PinnedMsgBar__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(832227);
/* harmony import */ var _components_AncCardInfo__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(135605);








const LiveGif = __webpack_require__(996344);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(function Announcement(props) {
  const {
    pinnedMap,
    mxEvent,
    space,
    direction = "horizontal"
  } = props;
  const [preview, setPreview] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)();
  const ts = mxEvent.getTs();
  const evId = mxEvent.getId();
  const cli = _MatrixClientPeg__WEBPACK_IMPORTED_MODULE_4__/* .MatrixClientPeg */ .p.get();
  const type = pinnedMap.get(evId);
  let html = "";
  let img = "";
  let fileList;
  if (type === "NOTICE") {
    var _html$match;
    const content = mxEvent.getContent();
    const {
      content: _html,
      file_list
    } = content.announcement;
    html = content.announcement.content.replace(/<hr.*?>/g, "").replace(/<br.*?>/g, "").replace(/<\/(ul|li|p|ol)/g, "</div").replace(/<(ul|li|p|ol)/g, "<div").replaceAll("<div></div>", "");
    img = (_html$match = html.match(/<img.*?\/?>/g)) === null || _html$match === void 0 ? void 0 : _html$match[0];
    html = html.replace(/<img.*?>/g, "");
    fileList = file_list;
  } else {
    const {
      content
    } = mxEvent.getEffectiveEvent();
    if (content.msgtype === matrix_js_sdk_src_types_event__WEBPACK_IMPORTED_MODULE_3__/* .MsgType */ .Zw.Image) {
      img = `<img src=${content.url} />`;
    }
  }
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    if (type === "AMA" && !mxEvent.isDecryptionFailure()) {
      const {
        content
      } = mxEvent.getEffectiveEvent();
      const link = content.body;
      cli.getUrlPreview(link, ts).then(res => {
        setPreview(res);
      });
    }
  }, [type]);
  const handleClick = () => {
    props.onClick && props.onClick();
  };
  const renderNoticeWrapper = () => {
    var _fileList, _fileList2;
    const bodyClass = classnames__WEBPACK_IMPORTED_MODULE_2___default()({
      flex: direction === "horizontal",
      "flex-gap-12": true,
      "justify-start": true,
      "text-16": true,
      "flex-col-reverse": direction === "vertical",
      "cursor-pointer": true
    });
    const imgContainerClass = classnames__WEBPACK_IMPORTED_MODULE_2___default()({
      mx_AnnouncImg_150: true
    });
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: bodyClass,
      onClick: () => handleClick()
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: imgContainerClass,
      dangerouslySetInnerHTML: {
        __html: img
      }
    }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "flex-col flex-gap-12"
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      dangerouslySetInnerHTML: {
        __html: html
      }
    }), !!((_fileList = fileList) !== null && _fileList !== void 0 && _fileList.length) && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", null, (_fileList2 = fileList) === null || _fileList2 === void 0 ? void 0 : _fileList2.map(item => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      key: item.id,
      className: "flex flex-gap-6 items-center justify-start"
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(sendingme_ui__WEBPACK_IMPORTED_MODULE_1__.SdIcon, {
      icon: "FileOutlines",
      className: "p-12 rounded-6",
      style: {
        backgroundColor: "#dddfec",
        color: "#000"
      }
    }), item.file_name)))));
  };
  const renderAmaWrapper = () => {
    if (!preview) return null;
    const title = preview["og:title"];
    const hostName = preview["og:host:name"];
    const participantAvatar = preview["og:participant:avatar[]"];
    const participantCount = preview["og:participant:count"];
    const bodyClass = classnames__WEBPACK_IMPORTED_MODULE_2___default()({
      flex: direction === "horizontal",
      "flex-gap-12": true,
      "justify-start": true,
      "text-16": true,
      "flex-col-reverse": direction === "vertical",
      "mx_AMAWidget_card": true,
      "cursor-pointer": true
    });
    const imageClass = classnames__WEBPACK_IMPORTED_MODULE_2___default()("mx_AMAWidget_card_bottom flex items-center justify-center rounded-12", {
      "mx_AMAWidget_card_bottom_vertical": direction === "vertical",
      "p-10": direction === "vertical"
    });
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: bodyClass,
      onClick: () => handleClick()
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: imageClass
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "text-center"
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("img", {
      className: "image-size-20 mb-4",
      src: LiveGif
    }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "ama_tag"
    }, "AMA"))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "flex-col"
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "mb-6 fw-500"
    }, title), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "mb-6"
    }, `Host: ${hostName}`), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", null, (0,_languageHandler__WEBPACK_IMPORTED_MODULE_5__._t)("%(count)s listened", {
      count: participantCount !== null && participantCount !== void 0 ? participantCount : participantAvatar.length
    }))));
  };
  const renderMsgWrapper = () => {
    const content = (0,_PinnedMsgBar__WEBPACK_IMPORTED_MODULE_6__/* .getContentOfMsg */ .oG)(mxEvent);
    const bodyClass = classnames__WEBPACK_IMPORTED_MODULE_2___default()({
      "cursor-pointer": true
    });
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: bodyClass,
      onClick: () => handleClick()
    }, content === null || content === void 0 ? void 0 : content.content);
  };
  const renderContent = () => {
    let render = null;
    switch (type) {
      case "AMA":
        render = renderAmaWrapper();
        break;
      case "NOTICE":
        render = renderNoticeWrapper();
        break;
      case "MSG":
        render = renderMsgWrapper();
        break;
      default:
        break;
    }
    return render;
  };
  const renderBottom = () => {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components_AncCardInfo__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z, {
      type: type,
      mxEvent: mxEvent
    });
  };
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "mx_squadHomePage_ancCard flex-col flex-gap-8 text-14"
  }, renderContent(), renderBottom());
}));

/***/ }),

/***/ 971616:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(667294);
/* harmony import */ var sendingme_ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(602271);


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(function TwitterEmbed(props) {
  const theme = document.documentElement.getAttribute("data-theme");
  const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);
  const createTimeline = screenName => {
    return () => {
      window.twttr.ready(() => {
        window.twttr.widgets.createTimeline({
          sourceType: "profile",
          screenName
        }, document.getElementById("x-embed-container-" + screenName), {
          height: window.innerHeight - 62,
          chrome: "transparent",
          tweetLimit: 3,
          theme: theme !== null && theme !== void 0 && theme.includes("dark") ? "dark" : "light"
        }).finally(() => {
          setLoading(false);
        });
      });
    };
  };
  const createTweet = tweetId => {
    return () => {
      window.twttr.ready(() => {
        window.twttr.widgets.createTweet(tweetId, document.getElementById("x-embed-container-" + tweetId), {
          theme: theme !== null && theme !== void 0 && theme.includes("dark") ? "dark" : "light"
        }).finally(() => {
          setLoading(false);
        });
      });
    };
  };
  const id = props.tweetId || props.sourceName;
  const create = props.tweetId ? createTweet(props.tweetId) : createTimeline(props.sourceName);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    if (!document.getElementById("mx_squadHomePage_twitter_script")) {
      const script = document.createElement("script");
      script.src = "https://platform.twitter.com/widgets.js";
      script.id = "mx_squadHomePage_twitter_script";
      script.onload = () => {
        create();
      };
      document.head.appendChild(script);
    } else if (window.twttr) {
      create();
    }
  }, []);
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", null, loading && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(sendingme_ui__WEBPACK_IMPORTED_MODULE_1__.SdSkeleton, {
    avatar: true,
    active: true,
    paragraph: {
      rows: 3
    },
    style: {
      padding: "0px 20px"
    }
  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    id: "x-embed-container-" + id
  }));
}));

/***/ }),

/***/ 508380:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   u: () => (/* binding */ HomeButton)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(992619);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(667294);
/* harmony import */ var _dispatcher_dispatcher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(245539);
/* harmony import */ var _dispatcher_actions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(473627);
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(294184);
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var sendingme_ui__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(602271);

const _excluded = ["title", "children", "secondary"];





const HomeButton = ({
  tag
}) => {
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(sendingme_ui__WEBPACK_IMPORTED_MODULE_4__.SdButton, {
    icon: "LeftOutlines",
    className: "mx_HomeButton",
    onClick: () => {
      _dispatcher_dispatcher__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .ZP.dispatch({
        action: _dispatcher_actions__WEBPACK_IMPORTED_MODULE_2__/* .Action */ .a.HideRoomPanel,
        tag
      });
      // if (!["DApps", "Explore"].includes(tag)) {
      //     dis.dispatch({
      //         action: Action.HideRoomPanel,
      //         tag,
      //     });
      // }
      _dispatcher_dispatcher__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .ZP.dispatch({
        action: _dispatcher_actions__WEBPACK_IMPORTED_MODULE_2__/* .Action */ .a.HideRightPanel,
        tag
      });
    }
  })
  // <button
  //     className="mx_HomeButton"
  //     onClick={() => {
  //         dis.dispatch({
  //             action: Action.HideRoomPanel,
  //             tag,
  //         });
  //         // if (!["DApps", "Explore"].includes(tag)) {
  //         //     dis.dispatch({
  //         //         action: Action.HideRoomPanel,
  //         //         tag,
  //         //     });
  //         // }
  //         dis.dispatch({
  //             action: Action.HideRightPanel,
  //             tag,
  //         });
  //     }}
  // />
  ;
};

/**
 * RoomHeader H5 header 组件
 *
 * | homeButton | title ---------- | secondary |
 *  ```jsx
 * <RoomHeaderH5
 *      title={your title}
 *      secondary={
 *          <button xxx/>
 *      }
 * />
 *  ```
 * @param props
 * @returns
 */
const RoomHeaderH5 = props => {
  const {
      title,
      children,
      secondary
    } = props,
    rest = (0,_babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(props, _excluded);
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: classnames__WEBPACK_IMPORTED_MODULE_3___default()("mx_RoomHeader_h5", {
      mx_RoomHeader_Recommendations: title == "Recommendations"
    })
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(HomeButton, rest), children, title, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    style: {
      flex: 1
    }
  }), secondary);
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RoomHeaderH5);

/***/ }),

/***/ 529015:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (/* binding */ ConfirmDeleteFriendDialog)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(225259);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(667294);
/* harmony import */ var _languageHandler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(867614);
/* harmony import */ var _utils_replaceableComponent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(90287);
/* harmony import */ var _BaseDialog__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(308043);
/* harmony import */ var _elements_AccessibleButton__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(805035);
/* harmony import */ var _MatrixClientPeg__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(933393);
/* harmony import */ var _stores_ContactStore__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(476979);
/* harmony import */ var _dispatcher_dispatcher__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(245539);
/* harmony import */ var _actions_RoomListActions__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(612358);
/* harmony import */ var _stores_room_list_models__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(103619);
/* harmony import */ var _ActiveRoomObserver__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(759347);
/* harmony import */ var sendingme_ui__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(602271);
/* harmony import */ var _utils_room_getRoomScene__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(827337);

var _dec, _class;
/*
Copyright 2017 Michael Telatynski <7t3chguy@gmail.com>
Copyright 2020, 2021 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/














let ConfirmDeleteFriendDialog = (_dec = (0,_utils_replaceableComponent__WEBPACK_IMPORTED_MODULE_2__/* .replaceableComponent */ .U)("views.dialogs.ConfirmDialog"), _dec(_class = class ConfirmDeleteFriendDialog extends react__WEBPACK_IMPORTED_MODULE_0__.Component {
  constructor(...args) {
    super(...args);
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z)(this, "onOk", () => {
      _MatrixClientPeg__WEBPACK_IMPORTED_MODULE_5__/* .MatrixClientPeg */ .p.get().removeFriend(this.props.userId).then(res => {
        if (!(res !== null && res !== void 0 && res.ok)) {
          sendingme_ui__WEBPACK_IMPORTED_MODULE_11__.SdMessage.error("Remove Friend failed.");
        } else {
          let friendList = _stores_ContactStore__WEBPACK_IMPORTED_MODULE_6__["default"].instance.friends;
          friendList = friendList.filter(item => item.userId !== this.props.userId);
          _stores_ContactStore__WEBPACK_IMPORTED_MODULE_6__["default"].instance.friends = friendList;
          _stores_ContactStore__WEBPACK_IMPORTED_MODULE_6__["default"].instance.emit(_stores_ContactStore__WEBPACK_IMPORTED_MODULE_6__/* .FRIEND_UPDATE_EVENT */ .rG);
          // delete exist dmroom
          const dmRooms = _MatrixClientPeg__WEBPACK_IMPORTED_MODULE_5__/* .MatrixClientPeg */ .p.get().getDmRoomByUserId(this.props.userId);
          dmRooms.forEach(room => {
            if (!(0,_utils_room_getRoomScene__WEBPACK_IMPORTED_MODULE_12__/* .isWorkRoom */ .PI)(room)) {
              var _room$getParentRoom;
              _dispatcher_dispatcher__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .ZP.dispatch(_actions_RoomListActions__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z.tagRoom(_MatrixClientPeg__WEBPACK_IMPORTED_MODULE_5__/* .MatrixClientPeg */ .p.get(), room, null, _stores_room_list_models__WEBPACK_IMPORTED_MODULE_9__/* .DefaultTagID */ .lL.Invisible, undefined, 0));
              window.localStorage.removeItem(`mx_space_context_${(_room$getParentRoom = room.getParentRoom()) === null || _room$getParentRoom === void 0 ? void 0 : _room$getParentRoom.roomId}`);
              if (_ActiveRoomObserver__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z.activeRoomId === room.roomId) {
                window.localStorage.removeItem("mx_space_context_HOME_SPACE");
                window.localStorage.removeItem("mx_last_room_id");
                _dispatcher_dispatcher__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .ZP.dispatch({
                  action: "view_home_page"
                });
              }
            }
          });
        }
      });
      this.onCancel();
    });
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z)(this, "onCancel", () => {
      this.props.onFinished(false);
    });
  }
  render() {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_BaseDialog__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z, {
      className: "mx_ConfirmDialog",
      onFinished: this.props.onFinished,
      title: (0,_languageHandler__WEBPACK_IMPORTED_MODULE_1__._t)("Delete Friend"),
      hasCancel: false,
      fixedWidth: true
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "mx_ConfirmDialog_des"
    }, (0,_languageHandler__WEBPACK_IMPORTED_MODULE_1__._t)("Delete the friend relationship with %(name)s and delete the chat history", {
      name: this.props.name || this.props.walletAddress
    })), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "mx_ConfirmDialog_buttons"
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_elements_AccessibleButton__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z, {
      kind: "secondary",
      onClick: this.onCancel
    }, " ", (0,_languageHandler__WEBPACK_IMPORTED_MODULE_1__._t)("Cancel"), " "), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_elements_AccessibleButton__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z, {
      kind: "danger",
      onClick: this.onOk
    }, " ", (0,_languageHandler__WEBPACK_IMPORTED_MODULE_1__._t)("Delete"), " ")));
  }
}) || _class);


/***/ }),

/***/ 523677:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (/* binding */ ConfirmRedactDialog)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(667294);
/* harmony import */ var _languageHandler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(867614);
/* harmony import */ var _utils_replaceableComponent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(90287);
/* harmony import */ var _TextInputDialog__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(968222);
var _dec, _class;
/*
Copyright 2017 Vector Creations Ltd

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/





/*
 * A dialog for confirming a redaction.
 */
let ConfirmRedactDialog = (_dec = (0,_utils_replaceableComponent__WEBPACK_IMPORTED_MODULE_2__/* .replaceableComponent */ .U)("views.dialogs.ConfirmRedactDialog"), _dec(_class = class ConfirmRedactDialog extends react__WEBPACK_IMPORTED_MODULE_0__.Component {
  render() {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_TextInputDialog__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z, {
      onFinished: this.props.onFinished,
      title: (0,_languageHandler__WEBPACK_IMPORTED_MODULE_1__._t)("Confirm Removal"),
      description: (0,_languageHandler__WEBPACK_IMPORTED_MODULE_1__._t)("Are you sure you wish to remove this event?"),
      placeholder: (0,_languageHandler__WEBPACK_IMPORTED_MODULE_1__._t)("Reason (optional)"),
      focus: true,
      button: (0,_languageHandler__WEBPACK_IMPORTED_MODULE_1__._t)("Remove"),
      showInput: false
    });
  }
}) || _class);


/***/ }),

/***/ 659148:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (/* binding */ RoomUpgradeDialog)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(225259);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(667294);
/* harmony import */ var _Modal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(241648);
/* harmony import */ var _languageHandler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(867614);
/* harmony import */ var _utils_replaceableComponent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(90287);
/* harmony import */ var _utils_RoomUpgrade__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(336876);
/* harmony import */ var _BaseDialog__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(308043);
/* harmony import */ var _ErrorDialog__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(705636);
/* harmony import */ var _elements_DialogButtons__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(804821);
/* harmony import */ var _elements_Spinner__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(641542);

var _dec, _class;
/*
Copyright 2018 - 2021 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/










let RoomUpgradeDialog = (_dec = (0,_utils_replaceableComponent__WEBPACK_IMPORTED_MODULE_3__/* .replaceableComponent */ .U)("views.dialogs.RoomUpgradeDialog"), _dec(_class = class RoomUpgradeDialog extends react__WEBPACK_IMPORTED_MODULE_0__.Component {
  constructor(...args) {
    super(...args);
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)(this, "targetVersion", void 0);
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)(this, "state", {
      busy: true
    });
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)(this, "onCancelClick", () => {
      this.props.onFinished(false);
    });
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)(this, "onUpgradeClick", () => {
      this.setState({
        busy: true
      });
      (0,_utils_RoomUpgrade__WEBPACK_IMPORTED_MODULE_4__/* .upgradeRoom */ .U)(this.props.room, this.targetVersion, false, false).then(() => {
        this.props.onFinished(true);
      }).catch(err => {
        _Modal__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z.createTrackedDialog('Failed to upgrade room', '', _ErrorDialog__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z, {
          title: (0,_languageHandler__WEBPACK_IMPORTED_MODULE_2__._t)("Failed to upgrade room"),
          description: err && err.message ? err.message : (0,_languageHandler__WEBPACK_IMPORTED_MODULE_2__._t)("The room upgrade could not be completed")
        });
      }).finally(() => {
        this.setState({
          busy: false
        });
      });
    });
  }
  async componentDidMount() {
    const recommended = await this.props.room.getRecommendedVersion();
    this.targetVersion = recommended.version;
    this.setState({
      busy: false
    });
  }
  render() {
    let buttons;
    if (this.state.busy) {
      buttons = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_elements_Spinner__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z, null);
    } else {
      buttons = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_elements_DialogButtons__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z, {
        primaryButton: (0,_languageHandler__WEBPACK_IMPORTED_MODULE_2__._t)('Upgrade this room to version %(version)s', {
          version: this.targetVersion
        }),
        primaryButtonClass: "danger",
        hasCancel: true,
        onPrimaryButtonClick: this.onUpgradeClick,
        onCancel: this.onCancelClick
      });
    }
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_BaseDialog__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z, {
      className: "mx_RoomUpgradeDialog",
      onFinished: this.props.onFinished,
      title: (0,_languageHandler__WEBPACK_IMPORTED_MODULE_2__._t)("Upgrade Room Version"),
      contentId: "mx_Dialog_content",
      hasCancel: true
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("p", null, (0,_languageHandler__WEBPACK_IMPORTED_MODULE_2__._t)("Upgrading this room requires closing down the current " + "instance of the room and creating a new room in its place. " + "To give room members the best possible experience, we will:")), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("ol", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("li", null, (0,_languageHandler__WEBPACK_IMPORTED_MODULE_2__._t)("Create a new room with the same name, description and avatar")), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("li", null, (0,_languageHandler__WEBPACK_IMPORTED_MODULE_2__._t)("Update any local room aliases to point to the new room")), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("li", null, (0,_languageHandler__WEBPACK_IMPORTED_MODULE_2__._t)("Stop users from speaking in the old version of the room, " + "and post a message advising users to move to the new room")), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("li", null, (0,_languageHandler__WEBPACK_IMPORTED_MODULE_2__._t)("Put a link back to the old room at the start of the new room " + "so people can see old messages"))), buttons);
  }
}) || _class);


/***/ }),

/***/ 566334:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(166644);
/* harmony import */ var _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(992619);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(667294);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(898697);
/* harmony import */ var _avatars_MemberAvatar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6156);
/* harmony import */ var _languageHandler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(867614);
/* harmony import */ var _utils_DMRoomMap__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(332506);
/* harmony import */ var _elements_TextWithTooltip__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(852240);
/* harmony import */ var _hooks_useRoomMembers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(573266);
/* harmony import */ var _contexts_MatrixClientContext__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(311878);
/* harmony import */ var sendingme_ui__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(602271);


const _excluded = ["room", "onlyKnownUsers", "numShown", "showOurselves", "size"];
/*
Copyright 2021 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/










const DEFAULT_NUM_FACES = 5;
const isKnownMember = member => {
  var _DMRoomMap$shared$get;
  return !!((_DMRoomMap$shared$get = _utils_DMRoomMap__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z.shared().getDMRoomsForUserId(member.userId)) !== null && _DMRoomMap$shared$get !== void 0 && _DMRoomMap$shared$get.length);
};
const FacePile = _ref => {
  var _members;
  let {
      room,
      onlyKnownUsers = true,
      numShown = DEFAULT_NUM_FACES,
      showOurselves = false,
      size
    } = _ref,
    props = (0,_babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(_ref, _excluded);
  const cli = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(_contexts_MatrixClientContext__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z);
  let members = props.members || (0,_hooks_useRoomMembers__WEBPACK_IMPORTED_MODULE_5__/* .useRoomMembers */ .B)(room);
  const memberCount = ((_members = members) === null || _members === void 0 ? void 0 : _members.length) || (0,_hooks_useRoomMembers__WEBPACK_IMPORTED_MODULE_5__/* .useRoomMemberCount */ .$)(room);
  // sort users with an explicit avatar first
  const iteratees = [member => !!member.getMxcAvatarUrl()];
  if (onlyKnownUsers) {
    members = members.filter(isKnownMember);
  } else {
    // sort known users first
    iteratees.unshift(member => isKnownMember(member));
  }

  // exclude ourselves from the shown members list
  const shownMembers = (0,lodash_es__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)(members.filter(m => showOurselves || m.userId !== cli.getUserId()), iteratees).slice(0, numShown);
  if (shownMembers.length < 1) return null;

  // We reverse the order of the shown faces in CSS to simplify their visual overlap,
  // reverse members in tooltip order to make the order between the two match up.
  const commaSeparatedMembers = shownMembers.map(m => m.rawDisplayName).reverse().join(", ");
  let tooltip;
  if (props.onClick) {
    tooltip = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "mx_Tooltip_title"
    }, (0,_languageHandler__WEBPACK_IMPORTED_MODULE_2__._t)("View all %(count)s members", {
      count: memberCount
    })), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "mx_Tooltip_sub"
    }, (0,_languageHandler__WEBPACK_IMPORTED_MODULE_2__._t)("Including %(commaSeparatedMembers)s", {
      commaSeparatedMembers
    })));
  } else {
    var _members2;
    tooltip = (0,_languageHandler__WEBPACK_IMPORTED_MODULE_2__._t)("%(count)s members including %(commaSeparatedMembers)s", {
      count: ((_members2 = members) === null || _members2 === void 0 ? void 0 : _members2.length) || room.getRoomMemberCount(),
      commaSeparatedMembers
    });
  }
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", (0,_babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z)({}, props, {
    className: "mx_FacePile"
  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_elements_TextWithTooltip__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z, {
    class: "mx_FacePile_faces",
    tooltip: tooltip
  }, members.length > numShown ?
  /*#__PURE__*/
  // <span className="mx_FacePile_face mx_FacePile_more" />
  react__WEBPACK_IMPORTED_MODULE_0__.createElement(sendingme_ui__WEBPACK_IMPORTED_MODULE_7__.SdIcon, {
    icon: "MoreOutlines",
    className: "mx_FacePile_face mx_FacePile_more"
  }) : null, shownMembers.map(m => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_avatars_MemberAvatar__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z, {
    key: m.userId,
    member: m,
    size: 24,
    className: "mx_FacePile_face"
  }))), onlyKnownUsers && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
    className: "mx_FacePile_summary"
  }, (0,_languageHandler__WEBPACK_IMPORTED_MODULE_2__._t)("%(count)s people you know have already joined", {
    count: members.length
  })));
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FacePile);

/***/ }),

/***/ 461951:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Z: () => (/* binding */ components_NotificationDrawer)
});

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(667294);
// EXTERNAL MODULE: ./node_modules/classnames/index.js
var classnames = __webpack_require__(294184);
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/inbox/def.ts
var def = __webpack_require__(842456);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/hooks/inbox/useLeftPanelState.tsx
var useLeftPanelState = __webpack_require__(685070);
// EXTERNAL MODULE: ./node_modules/antd/lib/index.js
var lib = __webpack_require__(769215);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/elements/AccessibleButton.tsx
var AccessibleButton = __webpack_require__(805035);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/dispatcher/dispatcher.ts
var dispatcher = __webpack_require__(245539);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/LeftPanelStore.ts
var LeftPanelStore = __webpack_require__(290884);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/right_panel/BaseCard.tsx
var BaseCard = __webpack_require__(554219);
// EXTERNAL MODULE: ./node_modules/@ant-design/icons/lib/index.js
var icons_lib = __webpack_require__(639389);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/languageHandler.tsx
var languageHandler = __webpack_require__(867614);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/inbox/components/InstanceContent.tsx









const InstanceContent = ({
  data,
  showBack,
  onBack,
  onClose
}) => {
  var _data$app_info, _data$app_info2, _data$app_info3, _data$app_info4;
  const handleClick = () => {
    dispatcher/* default */.ZP.dispatch({
      action: LeftPanelStore/* CHANGE_LEFT_PANEL_UI_STATE */.Us,
      target: LeftPanelStore/* INBOX_NOTIFICATION */.mB,
      value: {
        openPanel: true,
        instanceId: "",
        type: def/* NotificationDrawerType */.M.DISPLAY_INSTANCE_NOTIFICATION,
        data
      }
    });
  };
  const handleSettingClick = () => {
    dispatcher/* default */.ZP.dispatch({
      action: LeftPanelStore/* CHANGE_LEFT_PANEL_UI_STATE */.Us,
      target: LeftPanelStore/* INBOX_NOTIFICATION */.mB,
      value: {
        openPanel: true,
        instanceId: "",
        type: def/* NotificationDrawerType */.M.DIsPLAY_NOTIFICATION_SETTING,
        data
      }
    });
  };
  const handleClose = () => {
    onClose === null || onClose === void 0 ? void 0 : onClose();
    dispatcher/* default */.ZP.dispatch({
      action: LeftPanelStore/* CHANGE_LEFT_PANEL_UI_STATE */.Us,
      target: LeftPanelStore/* INBOX_NOTIFICATION */.mB,
      value: {
        openPanel: false,
        instanceId: "",
        type: ""
      }
    });
  };
  if (!data) {
    return null;
  }
  return /*#__PURE__*/react.createElement(BaseCard/* default */.C, {
    className: "mx_instance_drawer_content"
    // header={data.app_info?.app_name}
    ,
    header: /*#__PURE__*/react.createElement("div", {
      className: "mx_instance_drawer_content_header"
    }, showBack && /*#__PURE__*/react.createElement("div", {
      className: "mx_instance_drawer_content_header_action",
      onClick: onBack
    }, /*#__PURE__*/react.createElement(icons_lib.LeftCircleFilled, {
      size: 14
    })), /*#__PURE__*/react.createElement("h1", null, (_data$app_info = data.app_info) === null || _data$app_info === void 0 ? void 0 : _data$app_info.app_name), /*#__PURE__*/react.createElement("div", {
      style: {
        flex: "1"
      }
    }), /*#__PURE__*/react.createElement("div", {
      className: "mx_instance_drawer_content_header_action",
      onClick: handleClose
    }, /*#__PURE__*/react.createElement(icons_lib.CloseCircleFilled, {
      size: 14
    })))
    // onClose={handleClose}
    ,
    footer: /*#__PURE__*/react.createElement("div", {
      className: "mx_notification_drawer_footer"
    }, /*#__PURE__*/react.createElement(AccessibleButton/* default */.Z, {
      element: "button",
      className: "mx_instance_drawer_content_action",
      onClick: handleClick
    }, (0,languageHandler._t)("Notifications")), /*#__PURE__*/react.createElement(AccessibleButton/* default */.Z, {
      element: "button",
      className: "mx_instance_drawer_content_action",
      onClick: handleSettingClick
    }, (0,languageHandler._t)("Setting")))
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_instance_drawer_content_body"
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_instance_drawer_content_avatar"
  }, /*#__PURE__*/react.createElement(lib.Avatar, {
    size: 280,
    src: (_data$app_info2 = data.app_info) === null || _data$app_info2 === void 0 ? void 0 : _data$app_info2.app_logo,
    shape: "square"
  })), /*#__PURE__*/react.createElement("h1", {
    className: "mx_instance_drawer_content_title"
  }, (_data$app_info3 = data.app_info) === null || _data$app_info3 === void 0 ? void 0 : _data$app_info3.app_name), /*#__PURE__*/react.createElement("p", null, (_data$app_info4 = data.app_info) === null || _data$app_info4 === void 0 ? void 0 : _data$app_info4.app_desc)));
};
/* harmony default export */ const components_InstanceContent = (InstanceContent);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/node_modules/@babel/runtime/helpers/esm/defineProperty.js
var defineProperty = __webpack_require__(225259);
// EXTERNAL MODULE: ./node_modules/moment/moment.js
var moment = __webpack_require__(730381);
var moment_default = /*#__PURE__*/__webpack_require__.n(moment);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/MatrixClientPeg.ts + 3 modules
var MatrixClientPeg = __webpack_require__(933393);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/inbox/hooks/useInstanceList.tsx


const useInstanceList = props => {
  const [data, setDataState] = (0,react.useState)([]);
  const [isFinished, setIsFinishedState] = (0,react.useState)(false);
  const [isLoading, setIsLoadingState] = (0,react.useState)(false);
  const isLoadRef = (0,react.useRef)(false);
  const fetchedData = async ({
    limit = 5,
    offset = 0
  }) => {
    try {
      var _MatrixClientPeg$get, _MatrixClientPeg$get$;
      setIsLoadingState(true);
      isLoadRef.current = true;
      const {
        data
      } = await ((_MatrixClientPeg$get = MatrixClientPeg/* MatrixClientPeg */.p.get()) === null || _MatrixClientPeg$get === void 0 ? void 0 : (_MatrixClientPeg$get$ = _MatrixClientPeg$get.getNotificationInstanceList) === null || _MatrixClientPeg$get$ === void 0 ? void 0 : _MatrixClientPeg$get$.call(_MatrixClientPeg$get, {
        offset: offset,
        limit: limit
      }));
      if (data.length < props.limit) {
        setIsFinishedState(true);
      }
      setDataState(prev => [...prev, ...data]);
    } catch (error) {
      console.log({
        error
      });
    } finally {
      isLoadRef.current = false;
      setIsLoadingState(false);
    }
  };
  (0,react.useEffect)(() => {
    if (props && !isLoadRef.current) {
      fetchedData(props);
    }
  }, [props]);
  return (0,react.useMemo)(() => {
    return {
      data,
      isLoading,
      isFinished,
      fetchedData
    };
  }, [data, isLoading, isFinished, fetchedData]);
};
/* harmony default export */ const hooks_useInstanceList = (useInstanceList);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/inbox/hooks/useInfinity.tsx
var useInfinity = __webpack_require__(56235);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/elements/Spinner.tsx
var Spinner = __webpack_require__(641542);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/inbox/components/InstanceLists.tsx

function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0,defineProperty/* default */.Z)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }











const DEFAULT_LIMIT = 5;
const InstanceLists = ({
  showBack,
  onBack,
  onClose
}) => {
  const [query, setQueryState] = (0,react.useState)({
    offset: 0,
    limit: DEFAULT_LIMIT
  });
  const {
    data,
    isLoading,
    isFinished
  } = hooks_useInstanceList(query);
  const handleClick = item => {
    dispatcher/* default */.ZP.dispatch({
      action: LeftPanelStore/* CHANGE_LEFT_PANEL_UI_STATE */.Us,
      target: LeftPanelStore/* INBOX_NOTIFICATION */.mB,
      value: {
        openPanel: true,
        instanceId: "",
        type: def/* NotificationDrawerType */.M.DISPLAY_INSTANCE_NOTIFICATION,
        data: item
      }
    });
  };
  const handleClose = () => {
    dispatcher/* default */.ZP.dispatch({
      action: LeftPanelStore/* CHANGE_LEFT_PANEL_UI_STATE */.Us,
      target: LeftPanelStore/* INBOX_NOTIFICATION */.mB,
      value: {
        openPanel: false,
        instanceId: "",
        type: ""
      }
    });
    onClose === null || onClose === void 0 ? void 0 : onClose();
  };
  const fetchMoreData = (0,react.useCallback)(() => {
    if (isLoading) {
      return;
    }
    setQueryState(prev => _objectSpread(_objectSpread({}, prev), {}, {
      offset: prev.offset + DEFAULT_LIMIT
    }));
  }, [isLoading]);
  const {
    setTargetState
  } = (0,useInfinity/* default */.Z)(fetchMoreData);
  return /*#__PURE__*/react.createElement(BaseCard/* default */.C, {
    withoutScrollContainer: true,
    className: "mx_instance_drawer_content",
    header: /*#__PURE__*/react.createElement("div", {
      className: "mx_instance_drawer_content_header"
    }, showBack && /*#__PURE__*/react.createElement("div", {
      className: "mx_instance_drawer_content_header_action",
      onClick: onBack
    }, /*#__PURE__*/react.createElement(icons_lib.LeftCircleFilled, {
      size: 14
    })), /*#__PURE__*/react.createElement("h1", null, "Notification"), /*#__PURE__*/react.createElement("div", {
      style: {
        flex: "1"
      }
    }), /*#__PURE__*/react.createElement("div", {
      className: "mx_instance_drawer_content_header_action",
      onClick: handleClose
    }, /*#__PURE__*/react.createElement(icons_lib.CloseCircleFilled, {
      size: 14
    })))
    // header={"Notification"}
    // onClose={handleClose}
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_instance_list_content"
  }, data.map(item => {
    var _item$app_info, _item$app_info2, _item$notice_info;
    const ts = new Date(item.send_time_ms);
    return /*#__PURE__*/react.createElement("div", {
      className: "mx_instance_list_item",
      key: item.notice_id,
      onClick: () => handleClick(item)
    }, /*#__PURE__*/react.createElement(lib.Avatar, {
      shape: "square",
      className: "mx_instance_list_item_avatar",
      src: (_item$app_info = item.app_info) === null || _item$app_info === void 0 ? void 0 : _item$app_info.app_logo,
      size: 38
    }), /*#__PURE__*/react.createElement("div", {
      className: "mx_instance_list_item_body"
    }, /*#__PURE__*/react.createElement("h1", null, (_item$app_info2 = item.app_info) === null || _item$app_info2 === void 0 ? void 0 : _item$app_info2.app_name), /*#__PURE__*/react.createElement("p", null, (_item$notice_info = item.notice_info) === null || _item$notice_info === void 0 ? void 0 : _item$notice_info.title)), /*#__PURE__*/react.createElement("div", {
      className: "mx_instance_list_item_secondary"
    }, /*#__PURE__*/react.createElement("span", null, moment_default()(item.send_time_ms).format("HH:mm"))));
  }), !isFinished && /*#__PURE__*/react.createElement("div", {
    ref: setTargetState
  }, isLoading && /*#__PURE__*/react.createElement(Spinner/* default */.Z, null)), /*#__PURE__*/react.createElement("div", {
    style: {
      height: "24px"
    }
  })));
};
/* harmony default export */ const components_InstanceLists = (InstanceLists);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/inbox/hooks/useCommonNotify.tsx
var useCommonNotify = __webpack_require__(493095);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/inbox/components/NotificationItem.tsx + 1 modules
var NotificationItem = __webpack_require__(323874);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/inbox/components/InstanceNotifications.tsx

function InstanceNotifications_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function InstanceNotifications_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? InstanceNotifications_ownKeys(Object(t), !0).forEach(function (r) { (0,defineProperty/* default */.Z)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : InstanceNotifications_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }










const InstanceNotifications_DEFAULT_LIMIT = 5;
const InstanceNotifications = /*#__PURE__*/(0,react.memo)(({
  data,
  showBack,
  onBack,
  onClose
}) => {
  var _data$app_info, _data$app_info2;
  const [query, setQueryState] = (0,react.useState)({
    offset: 0,
    limit: InstanceNotifications_DEFAULT_LIMIT,
    client_id: (data === null || data === void 0 ? void 0 : (_data$app_info = data.app_info) === null || _data$app_info === void 0 ? void 0 : _data$app_info.client_id) || ""
  });
  const {
    data: notificationLists,
    isLoading,
    isFinished
  } = (0,useCommonNotify/* default */.Z)(query);
  const handleBack = () => {
    onBack === null || onBack === void 0 ? void 0 : onBack();
  };
  const handleClose = () => {
    onClose === null || onClose === void 0 ? void 0 : onClose();
    dispatcher/* default */.ZP.dispatch({
      action: LeftPanelStore/* CHANGE_LEFT_PANEL_UI_STATE */.Us,
      target: LeftPanelStore/* INBOX_NOTIFICATION */.mB,
      value: {
        openPanel: false,
        instanceId: "",
        type: ""
      }
    });
  };
  const handleFetchMore = (0,react.useCallback)(() => {
    if (isLoading) {
      return;
    }
    setQueryState(prev => InstanceNotifications_objectSpread(InstanceNotifications_objectSpread({}, prev), {}, {
      offset: prev.offset + InstanceNotifications_DEFAULT_LIMIT
    }));
  }, [isLoading]);
  const {
    setTargetState
  } = (0,useInfinity/* default */.Z)(handleFetchMore);
  if (!data) {
    return null;
  }
  return /*#__PURE__*/react.createElement(BaseCard/* default */.C, {
    className: "mx_instance_drawer_content",
    header: /*#__PURE__*/react.createElement("div", {
      className: "mx_instance_drawer_content_header"
    }, showBack && /*#__PURE__*/react.createElement("div", {
      className: "mx_instance_drawer_content_header_action",
      onClick: handleBack
    }, /*#__PURE__*/react.createElement(icons_lib.LeftCircleFilled, {
      size: 14
    })), /*#__PURE__*/react.createElement("h1", null, (_data$app_info2 = data.app_info) === null || _data$app_info2 === void 0 ? void 0 : _data$app_info2.app_name), /*#__PURE__*/react.createElement("div", {
      style: {
        flex: "1"
      }
    }), /*#__PURE__*/react.createElement("div", {
      className: "mx_instance_drawer_content_header_action",
      onClick: handleClose
    }, /*#__PURE__*/react.createElement(icons_lib.CloseCircleFilled, {
      size: 14
    })))
  }, notificationLists.map(item => /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(NotificationItem/* default */.Z, {
    key: item.notice_id,
    data: item
  }), /*#__PURE__*/react.createElement(lib.Divider, null))), !isFinished && /*#__PURE__*/react.createElement("div", {
    ref: setTargetState
  }, isLoading && /*#__PURE__*/react.createElement(Spinner/* default */.Z, null)), /*#__PURE__*/react.createElement("div", {
    style: {
      height: "24px"
    }
  }));
});
/* harmony default export */ const components_InstanceNotifications = (InstanceNotifications);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/inbox/components/NotificationDetail.tsx





const NotificationDetail = ({
  data,
  showBack,
  onBack,
  onClose
}) => {
  var _data$app_info, _data$notice_info, _data$notice_info2, _data$notice_info3, _data$notice_info4;
  const handleClose = () => {
    dispatcher/* default */.ZP.dispatch({
      action: LeftPanelStore/* CHANGE_LEFT_PANEL_UI_STATE */.Us,
      target: LeftPanelStore/* INBOX_NOTIFICATION */.mB,
      value: {
        openPanel: false,
        instanceId: "",
        type: ""
      }
    });
    onClose === null || onClose === void 0 ? void 0 : onClose();
  };
  if (!data) {
    return null;
  }
  return /*#__PURE__*/react.createElement(BaseCard/* default */.C, {
    className: "mx_notification_detail_drawer_content"
    // header={data.app_info?.app_name}
    ,
    header: /*#__PURE__*/react.createElement("div", {
      className: "mx_instance_drawer_content_header"
    }, showBack && /*#__PURE__*/react.createElement("div", {
      className: "mx_instance_drawer_content_header_action",
      onClick: onBack
    }, /*#__PURE__*/react.createElement(icons_lib.LeftCircleFilled, {
      size: 14
    })), /*#__PURE__*/react.createElement("h1", null, (_data$app_info = data.app_info) === null || _data$app_info === void 0 ? void 0 : _data$app_info.app_name), /*#__PURE__*/react.createElement("div", {
      style: {
        flex: "1"
      }
    }), /*#__PURE__*/react.createElement("div", {
      className: "mx_instance_drawer_content_header_action",
      onClick: handleClose
    }, /*#__PURE__*/react.createElement(icons_lib.CloseCircleFilled, {
      size: 14
    })))
    // onClose={handleClose}
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_notification_detail_drawer_content_body"
  }, /*#__PURE__*/react.createElement("h1", {
    className: "mx_notification_detail_drawer_content_body_title"
  }, data === null || data === void 0 ? void 0 : (_data$notice_info = data.notice_info) === null || _data$notice_info === void 0 ? void 0 : _data$notice_info.title), (data === null || data === void 0 ? void 0 : (_data$notice_info2 = data.notice_info) === null || _data$notice_info2 === void 0 ? void 0 : _data$notice_info2.image) && /*#__PURE__*/react.createElement("div", {
    className: "mx_notification_detail_drawer_content_body_img"
  }, /*#__PURE__*/react.createElement("img", {
    src: data === null || data === void 0 ? void 0 : (_data$notice_info3 = data.notice_info) === null || _data$notice_info3 === void 0 ? void 0 : _data$notice_info3.image
  })), /*#__PURE__*/react.createElement("div", {
    className: "mx_notification_detail_drawer_content_body_desc",
    dangerouslySetInnerHTML: {
      __html: data === null || data === void 0 ? void 0 : (_data$notice_info4 = data.notice_info) === null || _data$notice_info4 === void 0 ? void 0 : _data$notice_info4.description
    }
  })));
};
/* harmony default export */ const components_NotificationDetail = (NotificationDetail);
// EXTERNAL MODULE: ./node_modules/ahooks/lib/index.js
var ahooks_lib = __webpack_require__(924737);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/local-echo/EchoChamber.ts + 5 modules
var EchoChamber = __webpack_require__(932955);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/RoomNotifs.js
var RoomNotifs = __webpack_require__(349340);
// EXTERNAL MODULE: ./node_modules/sendingme-ui/dist/index.js
var dist = __webpack_require__(602271);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/inbox/components/InstanceSetting.tsx

function InstanceSetting_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function InstanceSetting_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? InstanceSetting_ownKeys(Object(t), !0).forEach(function (r) { (0,defineProperty/* default */.Z)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : InstanceSetting_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }












const onMuteClick = (roomProps, type) => {
  if (MatrixClientPeg/* MatrixClientPeg */.p.get().isGuest()) {
    return;
  }
  roomProps.notificationVolume = type;
};

/**
 * notification subscribe setting component
 *
 * @param param0
 * @returns { JSX.Element } - react node
 */
const InstanceSetting = ({
  data,
  showBack,
  onBack,
  onClose
}) => {
  const cli = MatrixClientPeg/* MatrixClientPeg */.p.get();
  const {
    data: clientSettingState,
    error,
    loading: isSubscribeLoadingState,
    refresh
  } = (0,ahooks_lib.useRequest)(() => {
    var _data$app_info;
    return cli.getClientNotificationSettingState(data === null || data === void 0 ? void 0 : (_data$app_info = data.app_info) === null || _data$app_info === void 0 ? void 0 : _data$app_info.client_id);
  });
  const {
    is_subscribe,
    room_id
  } = (clientSettingState === null || clientSettingState === void 0 ? void 0 : clientSettingState.data) || {};
  const isUserSubscribe = is_subscribe === 1;
  const currentRoom = room_id ? cli.getRoom(room_id) : null;
  const roomProps = currentRoom ? EchoChamber/* EchoChamber */.P.forRoom(currentRoom) : null;
  const isMute = (roomProps === null || roomProps === void 0 ? void 0 : roomProps.notificationVolume) === RoomNotifs/* MUTE */.Q2;
  const [loadingState, setLoadingStateState] = (0,react.useState)({
    isAddActionLoading: false,
    isPushActionLoading: false
  });
  const handleClose = () => {
    dispatcher/* default */.ZP.dispatch({
      action: LeftPanelStore/* CHANGE_LEFT_PANEL_UI_STATE */.Us,
      target: LeftPanelStore/* INBOX_NOTIFICATION */.mB,
      value: {
        openPanel: false,
        instanceId: "",
        type: ""
      }
    });
    onClose === null || onClose === void 0 ? void 0 : onClose();
  };
  const handleSubscribeChanged = async isSubscribe => {
    try {
      var _MatrixClientPeg$getC, _data$app_info2;
      setLoadingStateState(prev => InstanceSetting_objectSpread(InstanceSetting_objectSpread({}, prev), {}, {
        isAddActionLoading: true
      }));
      const homeServer = (_MatrixClientPeg$getC = MatrixClientPeg/* MatrixClientPeg */.p.getCredentials()) === null || _MatrixClientPeg$getC === void 0 ? void 0 : _MatrixClientPeg$getC.homeserverUrl;
      const params = {
        client_id: data === null || data === void 0 ? void 0 : (_data$app_info2 = data.app_info) === null || _data$app_info2 === void 0 ? void 0 : _data$app_info2.client_id,
        sdn_hs_url: homeServer
      };
      const request = isSubscribe ? cli.addNotificationToConversation(params) : cli.removeNotificationFromConversation(params);
      await request;
      dist.SdMessage.success((0,languageHandler._t)("Successful"));
      if (!isSubscribe && LeftPanelStore/* default */.ZP.instance.getState().selected !== LeftPanelStore/* INBOX_TAB */.J9) {
        // if user cancel subscribe, clear some data
        dispatcher/* default */.ZP.dispatch({
          action: "view_home_page"
        });
        dispatcher/* default */.ZP.dispatch({
          action: LeftPanelStore/* CHANGE_LEFT_PANEL_UI_STATE */.Us,
          target: LeftPanelStore/* INBOX_NOTIFICATION */.mB,
          value: {
            openPanel: false,
            instanceId: "",
            type: null,
            data: null
          }
        });
      }
    } catch (error) {
      dist.SdMessage.error((0,languageHandler._t)("Failed"));
    } finally {
      setLoadingStateState(prev => InstanceSetting_objectSpread(InstanceSetting_objectSpread({}, prev), {}, {
        isAddActionLoading: false
      }));
      refresh();
    }
  };
  const handlePushChanged = async needPush => {
    try {
      setLoadingStateState(prev => InstanceSetting_objectSpread(InstanceSetting_objectSpread({}, prev), {}, {
        isPushActionLoading: true
      }));
      const result = await onMuteClick(roomProps, isMute ? RoomNotifs/* ALL_MESSAGES_LOUD */.ei : RoomNotifs/* MUTE */.Q2);
      dist.SdMessage.success((0,languageHandler._t)("Successful"));
    } catch (error) {
      dist.SdMessage.success((0,languageHandler._t)("Failed"));
    } finally {
      setLoadingStateState(prev => InstanceSetting_objectSpread(InstanceSetting_objectSpread({}, prev), {}, {
        isPushActionLoading: false
      }));
    }
  };

  // if (!data || error) {
  //     return null;
  // }

  return /*#__PURE__*/react.createElement(BaseCard/* default */.C, {
    className: "mx_instance_drawer_setting",
    header: /*#__PURE__*/react.createElement("div", {
      className: "mx_instance_drawer_content_header"
    }, showBack && /*#__PURE__*/react.createElement("div", {
      className: "mx_instance_drawer_content_header_action",
      onClick: onBack
    }, /*#__PURE__*/react.createElement(icons_lib.LeftCircleFilled, {
      size: 14
    })), /*#__PURE__*/react.createElement("div", {
      style: {
        flex: "1"
      }
    }), /*#__PURE__*/react.createElement("div", {
      className: "mx_instance_drawer_content_header_action",
      onClick: handleClose
    }, /*#__PURE__*/react.createElement(icons_lib.CloseCircleFilled, {
      size: 14
    })))
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_instance_drawer_setting_content"
  }, /*#__PURE__*/react.createElement("ul", null, /*#__PURE__*/react.createElement("li", {
    className: ""
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_instance_drawer_setting_content_row1"
  }, /*#__PURE__*/react.createElement("h5", null, (0,languageHandler._t)("Add to Conversation")), /*#__PURE__*/react.createElement(lib.Switch, {
    loading: loadingState.isAddActionLoading || isSubscribeLoadingState,
    checked: isUserSubscribe,
    onChange: handleSubscribeChanged,
    disabled: loadingState.isAddActionLoading || isSubscribeLoadingState
  })), /*#__PURE__*/react.createElement("div", {
    className: "mx_instance_drawer_setting_content_row2"
  }, /*#__PURE__*/react.createElement("p", null, (0,languageHandler._t)("Show this notification in conversation list")))), /*#__PURE__*/react.createElement("li", {
    className: ""
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_instance_drawer_setting_content_row1"
  }, /*#__PURE__*/react.createElement("h5", null, (0,languageHandler._t)("Push Notification")), /*#__PURE__*/react.createElement(lib.Switch, {
    loading: loadingState.isPushActionLoading || isSubscribeLoadingState,
    checked: !isMute,
    onChange: handlePushChanged,
    disabled: loadingState.isPushActionLoading || isSubscribeLoadingState
  })), /*#__PURE__*/react.createElement("div", {
    className: "mx_instance_drawer_setting_content_row2"
  }, /*#__PURE__*/react.createElement("p", null, (0,languageHandler._t)("You will be alerted when there are new notifications")))))));
};
/* harmony default export */ const components_InstanceSetting = (InstanceSetting);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/structures/IframeWidget.tsx + 7 modules
var IframeWidget = __webpack_require__(731400);
// EXTERNAL MODULE: ./node_modules/lodash-es/isEqual.js
var isEqual = __webpack_require__(250576);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/inbox/components/NotificationDrawer.tsx











const NotificationDrawer = ({
  onClose
}) => {
  const state = (0,useLeftPanelState/* useInboxNotificationState */.L8)();
  const [noticeStack, setNoticeStackState] = (0,react.useState)([]);
  const handleClean = () => {
    setNoticeStackState([]);
    onClose === null || onClose === void 0 ? void 0 : onClose();
  };
  const handleBackEvent = () => {
    setNoticeStackState(prevState => {
      prevState.pop();
      return [...prevState];
    });
  };
  (0,react.useEffect)(() => {
    if (state !== null && state !== void 0 && state.openPanel) {
      setNoticeStackState(prevState => {
        var _prevState, _prevState2;
        if ((0,isEqual/* default */.Z)((_prevState = prevState[prevState.length - 1]) === null || _prevState === void 0 ? void 0 : _prevState.type, state === null || state === void 0 ? void 0 : state.type) && (0,isEqual/* default */.Z)((_prevState2 = prevState[prevState.length - 1]) === null || _prevState2 === void 0 ? void 0 : _prevState2.data, state === null || state === void 0 ? void 0 : state.data)) {
          return prevState;
        } else {
          return [...prevState, {
            type: state === null || state === void 0 ? void 0 : state.type,
            data: state === null || state === void 0 ? void 0 : state.data
          }];
        }
      });
    } else {
      setNoticeStackState([]);
    }
  }, [state]);
  const content = (0,react.useMemo)(() => {
    const currentNotice = noticeStack[noticeStack.length - 1];
    const showBackState = noticeStack.length > 1;
    switch (currentNotice === null || currentNotice === void 0 ? void 0 : currentNotice.type) {
      case def/* NotificationDrawerType */.M.DISPLAY_INSTANCE:
        {
          return /*#__PURE__*/react.createElement(components_InstanceContent, {
            showBack: showBackState,
            data: (currentNotice === null || currentNotice === void 0 ? void 0 : currentNotice.data) || null,
            onBack: handleBackEvent,
            onClose: onClose
          });
        }
      case def/* NotificationDrawerType */.M.DISPLAY_INSTANCE_LIST:
        {
          return /*#__PURE__*/react.createElement(components_InstanceLists, {
            showBack: showBackState,
            onBack: handleBackEvent,
            onClose: onClose
          });
        }
      case def/* NotificationDrawerType */.M.DISPLAY_INSTANCE_NOTIFICATION:
        {
          return /*#__PURE__*/react.createElement(components_InstanceNotifications, {
            showBack: showBackState,
            data: (currentNotice === null || currentNotice === void 0 ? void 0 : currentNotice.data) || null,
            onBack: handleBackEvent,
            onClose: onClose
          });
        }
      case def/* NotificationDrawerType */.M.DISPLAY_NOTIFICATION_DETAIL:
        {
          return /*#__PURE__*/react.createElement(components_NotificationDetail, {
            showBack: showBackState,
            data: (currentNotice === null || currentNotice === void 0 ? void 0 : currentNotice.data) || null,
            onBack: handleBackEvent,
            onClose: onClose
          });
        }
      case def/* NotificationDrawerType */.M.DIsPLAY_NOTIFICATION_SETTING:
        {
          return /*#__PURE__*/react.createElement(components_InstanceSetting, {
            showBack: showBackState,
            data: (currentNotice === null || currentNotice === void 0 ? void 0 : currentNotice.data) || null,
            onBack: handleBackEvent,
            onClose: onClose
          });
        }
      case def/* NotificationDrawerType */.M.DISPLAY_WHITE_LIST_LINK:
        {
          const url = currentNotice.data.url;
          if (!url) {
            return null;
          }
          return /*#__PURE__*/react.createElement(IframeWidget/* default */.Z, {
            src: url,
            onClose: handleClean
          });
        }
      default:
        {
          return null;
        }
    }
  }, [noticeStack]);
  if (!Boolean(noticeStack.length)) {
    return null;
  }
  return /*#__PURE__*/react.createElement("aside", {
    className: classnames_default()("mx_RightPanel", "dark-panel", "mx_notification_drawer")
  }, content);
};
/* harmony default export */ const components_NotificationDrawer = (NotificationDrawer);

/***/ }),

/***/ 493095:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(667294);
/* harmony import */ var _MatrixClientPeg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(933393);
/* harmony import */ var _def__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(842456);



const useCommonNotifyList = props => {
  const [data, setDataState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => JSON.parse(localStorage.getItem(`${_def__WEBPACK_IMPORTED_MODULE_2__/* .FIRST_FRAME_LIST_OF_NOTIFY */ .G}${props.client_id}`)) || []);
  const [isFinished, setIsFinishedState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);
  const [isLoading, setIsLoadingState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);
  const fetchedData = async ({
    limit,
    offset,
    client_id
  }) => {
    try {
      var _MatrixClientPeg$get;
      setIsLoadingState(true);
      const {
        data
      } = await ((_MatrixClientPeg$get = _MatrixClientPeg__WEBPACK_IMPORTED_MODULE_1__/* .MatrixClientPeg */ .p.get()) === null || _MatrixClientPeg$get === void 0 ? void 0 : _MatrixClientPeg$get.getCommonNotifyList({
        limit,
        offset,
        client_id
      }));
      if (data.length < props.limit) {
        setIsFinishedState(true);
      }
      if (offset === 0) {
        // is first frame
        localStorage.setItem(`${_def__WEBPACK_IMPORTED_MODULE_2__/* .FIRST_FRAME_LIST_OF_NOTIFY */ .G}${client_id}`, JSON.stringify(data));
      }
      setDataState(prev => offset === 0 ? data : [...prev, ...data]);
    } catch (error) {
      console.log({
        error
      });
    } finally {
      setIsLoadingState(false);
    }
  };
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    if (props && !isLoading) {
      fetchedData(props);
    }
  }, [props]);
  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    return {
      data,
      isLoading,
      isFinished,
      fetchedData
    };
  }, [data, isLoading, isFinished, fetchedData]);
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (useCommonNotifyList);

/***/ }),

/***/ 56235:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(667294);

const useInfinityScroll = callback => {
  const [target, setTargetState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);
  const observerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    if (!(target instanceof HTMLElement)) {
      return;
    }
    const options = {
      root: null,
      rootMargin: "0px",
      threshold: 0.5
    };
    const handleIntersection = entries => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          callback(entry);
        }
      });
    };
    observerRef.current = new IntersectionObserver(handleIntersection, options);
    observerRef.current.observe(target);
    return () => {
      if (observerRef.current) {
        observerRef.current.disconnect();
      }
    };
  }, [target, callback]);
  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({
    setTargetState
  }), []);
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (useInfinityScroll);

/***/ }),

/***/ 964586:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DateSeparator)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(667294);
/* harmony import */ var _languageHandler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(867614);
/* harmony import */ var _DateUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(466556);
/*
Copyright 2018 Michael Telatynski <7t3chguy@gmail.com>
Copyright 2015 - 2021 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/




function getDaysArray() {
  return [(0,_languageHandler__WEBPACK_IMPORTED_MODULE_1__._t)('Sunday'), (0,_languageHandler__WEBPACK_IMPORTED_MODULE_1__._t)('Monday'), (0,_languageHandler__WEBPACK_IMPORTED_MODULE_1__._t)('Tuesday'), (0,_languageHandler__WEBPACK_IMPORTED_MODULE_1__._t)('Wednesday'), (0,_languageHandler__WEBPACK_IMPORTED_MODULE_1__._t)('Thursday'), (0,_languageHandler__WEBPACK_IMPORTED_MODULE_1__._t)('Friday'), (0,_languageHandler__WEBPACK_IMPORTED_MODULE_1__._t)('Saturday')];
}
class DateSeparator extends react__WEBPACK_IMPORTED_MODULE_0__.Component {
  getLabel() {
    const date = new Date(this.props.ts);
    const today = new Date();
    const yesterday = new Date();
    const days = getDaysArray();
    yesterday.setDate(today.getDate() - 1);
    if (date.toDateString() === today.toDateString()) {
      return (0,_languageHandler__WEBPACK_IMPORTED_MODULE_1__._t)('Today');
    } else if (date.toDateString() === yesterday.toDateString()) {
      return (0,_languageHandler__WEBPACK_IMPORTED_MODULE_1__._t)('Yesterday');
    } else if (today.getTime() - date.getTime() < 6 * 24 * 60 * 60 * 1000) {
      return days[date.getDay()];
    } else {
      return (0,_DateUtils__WEBPACK_IMPORTED_MODULE_2__/* .formatFullDateNoTime */ .D5)(date);
    }
  }
  render() {
    // ARIA treats <hr/>s as separators, here we abuse them slightly so manually treat this entire thing as one
    // tab-index=-1 to allow it to be focusable but do not add tab stop for it, primarily for screen readers
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("h2", {
      className: "mx_DateSeparator",
      role: "separator",
      tabIndex: -1
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("hr", {
      role: "none"
    }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", null, this.getLabel()), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("hr", {
      role: "none"
    }));
  }
}

/***/ }),

/***/ 920355:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(667294);
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(294184);
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_1__);
/*
Copyright 2020 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/



const EventTileBubble = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(({
  className,
  title,
  subtitle,
  children,
  titlePrefix
}, ref) => {
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: classnames__WEBPACK_IMPORTED_MODULE_1___default()("mx_EventTileBubble", className),
    ref: ref
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "mx_EventTileBubble_title"
  }, titlePrefix, title), subtitle && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "mx_EventTileBubble_subtitle"
  }, subtitle), children);
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (EventTileBubble);

/***/ }),

/***/ 667311:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TileErrorBoundary)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(225259);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(667294);
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(294184);
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _languageHandler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(867614);
/* harmony import */ var _Modal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(241648);
/* harmony import */ var _SdkConfig__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(374312);
/* harmony import */ var _utils_replaceableComponent__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(90287);
/* harmony import */ var _dialogs_BugReportDialog__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(758795);

var _dec, _class;
/*
Copyright 2020 - 2021 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/








let TileErrorBoundary = (_dec = (0,_utils_replaceableComponent__WEBPACK_IMPORTED_MODULE_5__/* .replaceableComponent */ .U)("views.messages.TileErrorBoundary"), _dec(_class = class TileErrorBoundary extends react__WEBPACK_IMPORTED_MODULE_0__.Component {
  constructor(props) {
    super(props);
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(this, "onBugReport", () => {
      _Modal__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z.createTrackedDialog('Bug Report Dialog', '', _dialogs_BugReportDialog__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z, {
        label: 'react-soft-crash-tile',
        error: this.state.error
      });
    });
    this.state = {
      error: null
    };
  }
  static getDerivedStateFromError(error) {
    // Side effects are not permitted here, so we only update the state so
    // that the next render shows an error message.
    return {
      error
    };
  }
  render() {
    if (this.state.error) {
      const {
        mxEvent
      } = this.props;
      const classes = {
        mx_EventTile: true,
        mx_EventTile_info: true,
        mx_EventTile_content: true,
        mx_EventTile_tileError: true
      };
      let submitLogsButton;
      if (_SdkConfig__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z.get().bug_report_endpoint_url) {
        submitLogsButton = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("a", {
          onClick: this.onBugReport,
          href: "#"
        }, (0,_languageHandler__WEBPACK_IMPORTED_MODULE_2__._t)("Submit logs"));
      }
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
        className: classnames__WEBPACK_IMPORTED_MODULE_1___default()(classes)
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
        className: "mx_EventTile_line"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", null, (0,_languageHandler__WEBPACK_IMPORTED_MODULE_2__._t)("Can't load this message"), mxEvent && ` (${mxEvent.getType()})`, submitLogsButton)));
    }
    return this.props.children;
  }
}) || _class);


/***/ }),

/***/ 822172:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MFilePinnedBody)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(667294);
/* harmony import */ var _languageHandler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(867614);


class MFilePinnedBody extends react__WEBPACK_IMPORTED_MODULE_0__.Component {
  get content() {
    return this.props.mxEvent.getContent();
  }
  get fileName() {
    return this.content.body && this.content.body.length > 0 ? this.content.body : (0,_languageHandler__WEBPACK_IMPORTED_MODULE_1__._t)("Attachment");
  }
  render() {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "mx_MPinnedBody"
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "mx_MPinnedBody_info"
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "mx_MPinnedBody_sender"
    }, (0,_languageHandler__WEBPACK_IMPORTED_MODULE_1__._t)("Pinned Message"), " #", this.props.pindedIndex + 1), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "mx_MPinnedBody_content"
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("img", {
      className: "mx_MPinnedBody_icon",
      src: __webpack_require__(533769),
      alt: ""
    }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
      className: "mx_MPinnedBody_text"
    }, this.fileName))));
  }
}

/***/ }),

/***/ 527750:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MImagePinnedBody)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(225259);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(667294);
/* harmony import */ var _MImageBody__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(910749);
/* harmony import */ var matrix_js_sdk_src_types_event__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(907977);
/* harmony import */ var _languageHandler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(867614);

/*
Copyright 2020-2021 Tulir Asokan <tulir@maunium.net>

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/





const FORCED_IMAGE_HEIGHT = 40;
class MImagePinnedBody extends _MImageBody__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor(...args) {
    super(...args);
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, "onClick", ev => {
      ev.preventDefault();
    });
  }
  wrapImage(contentUrl, children) {
    return children;
  }
  render() {
    var _content$info;
    if (this.state.error !== null) {
      return super.render();
    }
    const content = this.props.mxEvent.getContent();
    const msgtype = content.msgtype;
    const contentUrl = this.getContentUrl();
    const thumbnail = this.messageContent(contentUrl, this.getThumbUrl(), content, FORCED_IMAGE_HEIGHT);
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "mx_MPinnedBody"
    }, thumbnail, msgtype === matrix_js_sdk_src_types_event__WEBPACK_IMPORTED_MODULE_2__/* .MsgType */ .Zw.Image || msgtype === matrix_js_sdk_src_types_event__WEBPACK_IMPORTED_MODULE_2__/* .MsgType */ .Zw.Video ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "mx_MPinnedBody_info"
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "mx_MPinnedBody_sender"
    }, (0,_languageHandler__WEBPACK_IMPORTED_MODULE_3__._t)("Pinned Message"), " #", this.props.pindedIndex + 1), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "mx_MPinnedBody_filename"
    }, msgtype === matrix_js_sdk_src_types_event__WEBPACK_IMPORTED_MODULE_2__/* .MsgType */ .Zw.Image ? "Photo" : msgtype === matrix_js_sdk_src_types_event__WEBPACK_IMPORTED_MODULE_2__/* .MsgType */ .Zw.Video ? "Video" : null)) : null, msgtype === matrix_js_sdk_src_types_event__WEBPACK_IMPORTED_MODULE_2__/* .MsgType */ .Zw.Sticker ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "mx_MPinnedBody_info"
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "mx_MPinnedBody_sender"
    }, (0,_languageHandler__WEBPACK_IMPORTED_MODULE_3__._t)("Pinned Message"), " #", this.props.pindedIndex + 1), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "mx_MPinnedBody_content"
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
      className: "mx_MPinnedBody_icon"
    }, (_content$info = content.info) === null || _content$info === void 0 ? void 0 : _content$info.emoji), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
      className: "mx_MPinnedBody_text"
    }, "Sticker"))) : null);
  }
}

/***/ }),

/***/ 144957:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MVoicePinnedBody)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(667294);
/* harmony import */ var _languageHandler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(867614);
/* harmony import */ var matrix_js_sdk_src_types_event__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(907977);
/* harmony import */ var _utils_FormattingUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(960882);
/* harmony import */ var _HtmlUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(714813);
/* harmony import */ var _elements_ReplyThread__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(980531);






class MVoicePinnedBody extends react__WEBPACK_IMPORTED_MODULE_0__.Component {
  get content() {
    return this.props.mxEvent.getContent();
  }
  get eventType() {
    return this.props.mxEvent.getType();
  }
  getMessageContetnt() {
    const {
      mxEvent
    } = this.props;
    const {
      body,
      format,
      formatted_body: formattedBody
    } = this.content;
    let content = body;
    let icon = "";
    let tag = "";
    if (mxEvent.getWireContent()["m.forward"]) {
      tag = `[${(0,_languageHandler__WEBPACK_IMPORTED_MODULE_1__._t)("Forward message")}]`;
      content = "";
    }
    if (this.eventType === matrix_js_sdk_src_types_event__WEBPACK_IMPORTED_MODULE_2__/* .EventType */ .tw.PollStart || this.eventType === matrix_js_sdk_src_types_event__WEBPACK_IMPORTED_MODULE_2__/* .EventType */ .tw.PollEnd) {
      var _this$content$this$ev;
      tag = (0,_languageHandler__WEBPACK_IMPORTED_MODULE_1__._t)("Poll");
      content = ((_this$content$this$ev = this.content[this.eventType]) === null || _this$content$this$ev === void 0 ? void 0 : _this$content$this$ev.question["m.text"]) || "";
      icon = "📊";
    }
    if (this.eventType === matrix_js_sdk_src_types_event__WEBPACK_IMPORTED_MODULE_2__/* .EventType */ .tw.RoomAnnouncement) {
      var _mxEvent$getContent$a;
      tag = `[${(0,_languageHandler__WEBPACK_IMPORTED_MODULE_1__._t)("Room Notice")}]`;
      content = (0,_utils_FormattingUtils__WEBPACK_IMPORTED_MODULE_3__/* .parseHtmlString */ .PS)((_mxEvent$getContent$a = mxEvent.getContent()["announcement"]) === null || _mxEvent$getContent$a === void 0 ? void 0 : _mxEvent$getContent$a.content) || "";
      icon = "📢";
    }
    const mRelatesTo = mxEvent.getWireContent()["m.relates_to"];
    if (mRelatesTo && mRelatesTo["m.in_reply_to"]) {
      tag = `[${(0,_languageHandler__WEBPACK_IMPORTED_MODULE_1__._t)("Reply")}]`;
      const hasHtml = format === "org.matrix.custom.html" && formattedBody;
      if (hasHtml) {
        content = (0,_HtmlUtils__WEBPACK_IMPORTED_MODULE_4__/* .getHtmlText */ .JS)((_elements_ReplyThread__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z.stripHTMLReply(formattedBody) || "").trim());
      } else {
        content = (_elements_ReplyThread__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z.stripPlainReply(content) || "").trim();
      }
      if (!content) {
        content = "";
      }
    }
    return {
      tag,
      icon,
      content
    };
  }
  render() {
    const {
      tag,
      content,
      icon
    } = this.getMessageContetnt();
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "mx_MPinnedBody"
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "mx_MPinnedBody_info"
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "mx_MPinnedBody_sender"
    }, (0,_languageHandler__WEBPACK_IMPORTED_MODULE_1__._t)("Pinned Message"), " #", this.props.pindedIndex + 1), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "mx_MPinnedBody_content"
    }, icon ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
      className: "mx_MPinnedBody_icon mx_MTextPinnedBody_icon"
    }, icon) : null, tag ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
      className: "mx_MPinnedBody_text mx_MPinnedBody_tag"
    }, tag) : null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
      className: "mx_MPinnedBody_text"
    }, content))));
  }
}

/***/ }),

/***/ 356326:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MVoicePinnedBody)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(667294);
/* harmony import */ var _languageHandler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(867614);


class MVoicePinnedBody extends react__WEBPACK_IMPORTED_MODULE_0__.Component {
  render() {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "mx_MPinnedBody"
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "mx_MPinnedBody_info"
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "mx_MPinnedBody_sender"
    }, (0,_languageHandler__WEBPACK_IMPORTED_MODULE_1__._t)("Pinned Message"), " #", this.props.pindedIndex + 1), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "mx_MPinnedBody_content"
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("img", {
      className: "mx_MPinnedBody_icon",
      src: __webpack_require__(615775),
      alt: ""
    }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
      className: "mx_MPinnedBody_text"
    }, (0,_languageHandler__WEBPACK_IMPORTED_MODULE_1__._t)("Voice")))));
  }
}

/***/ }),

/***/ 241358:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(166644);
/* harmony import */ var _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(992619);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(667294);
/* harmony import */ var _right_panel_BaseCard__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(554219);
/* harmony import */ var _languageHandler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(867614);
/* harmony import */ var _elements_AccessibleButton__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(805035);
/* harmony import */ var _hiseas_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(989638);
/* harmony import */ var _elements_Spinner__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(641542);
/* harmony import */ var _dispatcher_dispatcher__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(245539);
/* harmony import */ var _dispatcher_actions__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(473627);
/* harmony import */ var _stores_LeftPanelStore__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(290884);
/* harmony import */ var _hooks_useDispatcher__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(694284);
/* harmony import */ var _TokenGatedRequirement__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(872607);
/* harmony import */ var _stores_ExploreStore__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(512892);
/* harmony import */ var _stores_ActivityStore__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(182445);
/* harmony import */ var _spaces_ActivityCard__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(161732);
/* harmony import */ var _stores_RightPanelStorePhases__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(274057);
/* harmony import */ var _stores_SpaceStore__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(387579);
/* harmony import */ var _contexts_MatrixClientContext__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(311878);
/* harmony import */ var _icons_IconOfficial__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(65246);
/* harmony import */ var _avatars_OverLapMembersAvatar__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(486011);


const _excluded = ["detail", "recommendEvent", "isOfficial", "refresh", "from"];



















const Squad = _ref => {
  let {
      detail,
      recommendEvent,
      isOfficial,
      refresh,
      from = ''
    } = _ref,
    props = (0,_babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_19__/* ["default"] */ .Z)(_ref, _excluded);
  const cli = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(_contexts_MatrixClientContext__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z);
  const [btnTag, setBtnTag] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(-1); // 0 can-join; 1 cannot-join; 2 joined; 3 joining; -1 origin
  const [data, setData] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});
  const [activity, setActivity] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});
  const id = detail.id;
  const {
    name,
    urls,
    desc,
    member,
    members,
    avatar,
    alias,
    bg,
    auth,
    joinRules,
    joinAdvance,
    joinParams
  } = detail.bg ? detail : data;
  const room = cli === null || cli === void 0 ? void 0 : cli.getRoom(id);
  (0,_hooks_useDispatcher__WEBPACK_IMPORTED_MODULE_9__/* .useDispatcher */ .P)(_dispatcher_dispatcher__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .ZP, payload => {
    if (payload.action === _dispatcher_actions__WEBPACK_IMPORTED_MODULE_7__/* .Action */ .a.JoinRoomReady && payload.roomId === id) {
      onJoinButtonClicked(2);
    } else if (payload.action === "after_leave_room" && payload.room_id === id) {
      setBtnTag(-1);
      refresh && refresh();
    }
  });
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    if (name) {
      return;
    }
    _stores_ExploreStore__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .Z.instance.fetchSquadDetail(id).then(res => {
      setData(res);
    });
  }, []);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    if (recommendEvent !== null && recommendEvent !== void 0 && recommendEvent.id) {
      return;
    }
    _stores_ActivityStore__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .Z.instance.fetchRecent(id).then(res => {
      var _res$data;
      if ((res === null || res === void 0 ? void 0 : (_res$data = res.data) === null || _res$data === void 0 ? void 0 : _res$data.length) > 0) {
        setActivity(res.data[0]);
      }
    });
  }, []);
  if (!detail.id || !name) {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_elements_Spinner__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z, null);
  }
  let btnState = btnTag;
  if (btnState === -1) {
    if (!!_stores_LeftPanelStore__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .ZP.instance.getState().spaces.find(item => item.roomId === id) || joinRules === "token.access") {
      btnState = 2;
    } else if (auth !== "public") {
      btnState = 1;
    } else {
      btnState = 0;
    }
  }
  const header = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "mx_IframeWidget_header"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "mx_IframeWidget_header_title"
  }, (0,_languageHandler__WEBPACK_IMPORTED_MODULE_2__._t)("Squad")));
  const event = activity !== null && activity !== void 0 && activity.id ? activity : recommendEvent;
  const onJoinButtonClicked = (state, count = 0) => {
    if (state === 2) {
      // location.href = `${location.origin}/#/room/${alias || id}`;
      const space = _stores_SpaceStore__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .ZP.instance.getSpace(id);
      // if (!space) {
      //     count < 100 && setTimeout(() => onJoinButtonClicked(2, ++count), 800);
      //     return;
      // }
      if (space) {
        setTimeout(() => {
          _stores_SpaceStore__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .ZP.instance.setActiveSpace(space);
          _dispatcher_dispatcher__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .ZP.dispatch({
            action: "view_room",
            room_id: alias || id,
            params: {
              from
            }
          }, true);
          _dispatcher_dispatcher__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .ZP.dispatch({
            action: _dispatcher_actions__WEBPACK_IMPORTED_MODULE_7__/* .Action */ .a.ShowRoomPanel
          });
          (event === null || event === void 0 ? void 0 : event.id) && _dispatcher_dispatcher__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .ZP.dispatch({
            action: _dispatcher_actions__WEBPACK_IMPORTED_MODULE_7__/* .Action */ .a.SetRightPanelPhase,
            phase: _stores_RightPanelStorePhases__WEBPACK_IMPORTED_MODULE_14__/* .RightPanelPhases */ .q4.IframeWidget,
            refireParams: {
              params: {
                src: event.url,
                title: "Soshow"
              }
            }
          });
        }, 200);
        return;
      }
    }
    setBtnTag(3);
    const signUrl = "";
    _dispatcher_dispatcher__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .ZP.dispatch({
      action: _dispatcher_actions__WEBPACK_IMPORTED_MODULE_7__/* .Action */ .a.JoinRoom,
      roomId: id,
      outsideRoom: true,
      opts: {
        inviteSignUrl: signUrl
      },
      _type: "unknown",
      // TODO: instrumentation
      inviteSender: ""
    });
    _dispatcher_dispatcher__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .ZP.dispatch({
      action: "view_room",
      room_id: id,
      params: {
        from
      }
    });
  };
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_right_panel_BaseCard__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .C, {
    header: header,
    className: "mx_WidgetCard",
    onClose: props.onClose,
    withoutScrollContainer: true
  }, !name ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_elements_Spinner__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z, null) : /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "mx_IframeWidget_container squad_detail"
  }, bg || avatar ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("img", {
    className: "explore_item_bg",
    src: bg || avatar
  }) : /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_hiseas_react__WEBPACK_IMPORTED_MODULE_4__.CombineAvatar, {
    width: 390,
    height: 138,
    avatars: urls || [],
    className: "explore_item_bg explore_item_bg_combine"
  }), !bg && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "explore_item_bg_mask"
  }), avatar ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("img", {
    src: avatar,
    className: "explore_item_avatar"
  }) : /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_hiseas_react__WEBPACK_IMPORTED_MODULE_4__.CombineAvatar, {
    width: 68,
    height: 68,
    avatars: urls || [],
    className: "explore_item_avatar"
  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "explore_item_name_wrap"
  }, isOfficial && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_icons_IconOfficial__WEBPACK_IMPORTED_MODULE_17__/* ["default"] */ .Z, null), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
    className: "explore_item_name"
  }, name)), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "explore_item_taginfo"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", null, member, " members"), joinRules ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", null, joinRules.charAt(0).toUpperCase() + joinRules.slice(1)) : null), members ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_avatars_OverLapMembersAvatar__WEBPACK_IMPORTED_MODULE_18__/* .OverLapMembersAvatar */ .l, {
    members: members,
    avatarSize: 26
  }) : null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "explore_operate"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_elements_AccessibleButton__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z, {
    kind: "primary",
    onClick: () => onJoinButtonClicked(btnState),
    className: "explore_item_btn",
    disabled: btnState !== 0 && btnState !== 2
  }, btnState === 1 && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "explore_item_btn_icon"
  }), event !== null && event !== void 0 && event.id ? (0,_languageHandler__WEBPACK_IMPORTED_MODULE_2__._t)(["Join And Listen", "Unable to join", "Enter And Listen", "Joining squad …"][btnState]) : (0,_languageHandler__WEBPACK_IMPORTED_MODULE_2__._t)(["Join", "Unable to join", "Enter", "Joining squad …"][btnState]))), event !== null && event !== void 0 && event.id ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "explore_item_desc_wrap"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "explore_item_desc_label"
  }, (0,_languageHandler__WEBPACK_IMPORTED_MODULE_2__._t)(recommendEvent ? "Event" : "Recent Event")), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_spaces_ActivityCard__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, (0,_babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_20__/* ["default"] */ .Z)({
    key: event.id
  }, event, {
    disClickable: true,
    disableOpt: true
  }))) : null, joinParams && joinParams.requirements.length > 0 && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "explore_item_desc_wrap"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "explore_item_desc_label"
  }, (0,_languageHandler__WEBPACK_IMPORTED_MODULE_2__._t)("Token Gated")), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "mx_TokenGated_joinparams"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_TokenGatedRequirement__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z, {
    joinparams: joinParams,
    joinadvance: joinAdvance,
    from: "homePage"
  }))), desc && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "explore_item_desc_wrap"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "explore_item_desc_label"
  }, (0,_languageHandler__WEBPACK_IMPORTED_MODULE_2__._t)("Description")), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "explore_item_desc"
  }, desc))));
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Squad);

/***/ }),

/***/ 872607:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   o: () => (/* binding */ TokenGatedSdmCardDescription)
/* harmony export */ });
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(294184);
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(667294);
/* harmony import */ var _languageHandler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(867614);
/* harmony import */ var _stores_AccessTokenStore__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(295640);
/* harmony import */ var _MatrixClientPeg__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(933393);
/* harmony import */ var matrix_js_sdk_src_types_event__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(907977);
/* harmony import */ var matrix_js_sdk_src_types_partials__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(85047);







const TokenGatedRequirement = tokenGatedProps => {
  var _joinparams$requireme;
  const {
    joinadvance,
    joinparams,
    from,
    shortTitle
  } = tokenGatedProps;
  const getOperate = item => {
    let operate = null;
    // TODO: token_pass 是 去 Mint
    if (!(joinparams !== null && joinparams !== void 0 && joinparams.qualified) && !item.check) {
      if (!_stores_AccessTokenStore__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z.isNFT(item.requiredToken.type)) {
        operate = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("a", {
          target: "_blank",
          href: "https://app.1inch.io/"
        }, "Swap");
      } else if (!_stores_AccessTokenStore__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z.isPOAP(item.requiredToken.type)) {
        operate = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("a", {
          target: "_blank",
          href: "https://collections.poap.xyz/"
        }, "Swap");
      } else {
        operate = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("a", {
          target: "_blank",
          href: `https://opensea.io/assets/ethereum/${item.requiredToken.address}`
        }, "Buy Now");
      }
    }
    return operate;
  };
  function renderAmount(item) {
    var _item$owned;
    const itemNoNFT = !item.check && _stores_AccessTokenStore__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z.isNFT(item.requiredToken.type);
    const itemNoPOAP = !item.check && _stores_AccessTokenStore__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z.isPOAP(item.requiredToken.type);
    if (itemNoPOAP) {
      return (0,_languageHandler__WEBPACK_IMPORTED_MODULE_2__._t)("No POAP");
    } else if (itemNoNFT) {
      return (0,_languageHandler__WEBPACK_IMPORTED_MODULE_2__._t)("No NFT");
    }
    return `${(_item$owned = item.owned) !== null && _item$owned !== void 0 ? _item$owned : 0} / ${item.requiredAmount}`;
  }
  const renderExploreMatchItem = item => {
    if (joinparams !== null && joinparams !== void 0 && joinparams.qualified) {
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("span", {
        className: "mx_TokenGate_checked_item_amount"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
        className: "mx_TokenGate_checked_item_Qualified"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("img", {
        src: __webpack_require__(792540)
      })));
    } else if (item.check) {
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("span", {
        className: "mx_TokenGate_checked_item_amount"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
        className: "mx_TokenGate_checked_item_Qualified"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("img", {
        src: __webpack_require__(792540)
      })));
    } else {
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("span", {
        className: "mx_TokenGate_checked_item_amount"
      }, renderAmount(item));
    }
  };
  function renderHeader() {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
      className: "explore_match_title"
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
      className: "explore_match_title_left"
    }, shortTitle ? `Match ${joinparams === null || joinparams === void 0 ? void 0 : joinparams.logic.toLowerCase()}` : `Match ${joinparams === null || joinparams === void 0 ? void 0 : joinparams.logic.toLowerCase()} of the following requirements`), typeof joinparams.qualified === 'boolean' && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
      className: classnames__WEBPACK_IMPORTED_MODULE_0___default()("explore_match_title_right", {
        "explore_match_title_right_green": joinparams.qualified,
        "explore_match_title_right_red": !joinparams.qualified
      })
    }, joinparams.qualified ? (0,_languageHandler__WEBPACK_IMPORTED_MODULE_2__._t)("Access Granted") : (0,_languageHandler__WEBPACK_IMPORTED_MODULE_2__._t)("Access Denied")));
  }

  /* Squad Homepage margin-bottom 100px */
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
    className: classnames__WEBPACK_IMPORTED_MODULE_0___default()("mx_MatchRequirement explore_match_container", {
      mx_MatchRequirement_bottom: from === "homePage"
    })
  }, joinparams && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
    className: "explore_match_wrapper"
  }, renderHeader(), joinparams === null || joinparams === void 0 ? void 0 : (_joinparams$requireme = joinparams.requirements) === null || _joinparams$requireme === void 0 ? void 0 : _joinparams$requireme.map((item, index) => {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
      className: "explore_match_item_wrapper",
      key: index
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
      className: "explore_match_item explore_match_info"
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
      className: "match_item_avatar"
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("img", {
      src: item.requiredToken.logo || "https://static.alchemyapi.io/images/assets/3717.png"
    })), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
      className: "match_item_info"
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
      className: "match_item_info_name"
    }, !_stores_AccessTokenStore__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z.isNFT(item.requiredToken.type) ? `${item.requiredAmount}` : "", " ", item.requiredToken.name), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
      className: "match_item_info_tag"
    }, _stores_AccessTokenStore__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z.isPOAP(item.requiredToken.type) ? "" : item === null || item === void 0 ? void 0 : item.chain))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
      className: "explore_match_item mx_TokenGate_checked_error"
    }, renderExploreMatchItem(item)), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
      className: "explore_match_item explore_match_operate"
    }, getOperate(item)));
  })), joinadvance && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
    className: "mx_TokenGated_advance"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
    className: "explore_match_title"
  }, "Match advance requirement"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
    className: "mx_TokenGated_advance_wrapper"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
    className: "mx_TokenGated_advance_info"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
    className: "match_item_avatar"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("img", {
    src: __webpack_require__(750929)
  })), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
    className: "match_item_info"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
    className: "match_item_info_name"
  }, joinadvance === null || joinadvance === void 0 ? void 0 : joinadvance.rule_name))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
    className: "mx_TokenGated_advance_error"
  }, !(joinadvance !== null && joinadvance !== void 0 && joinadvance.qualified) && "Not Match"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
    className: "mx_TokenGated_advance_operate"
  }))));
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TokenGatedRequirement);
const TokenGatedSdmCardDescription = props => {
  const {
    description,
    type,
    link
  } = props;
  const [isTokenGated, setIsTokenGated] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);
  const getQueryString = name => {
    var _link$split$;
    if (!link) return;
    const map = new Map();
    (_link$split$ = link.split("?")[1]) === null || _link$split$ === void 0 ? void 0 : _link$split$.split("&").map(i => {
      const key = i.split("=")[0];
      const value = i.split("=")[1];
      map.set(key, value);
    });
    return map.get(name);
  };
  react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {
    getSquadInfo();
  }, [link, type]);
  async function getSquadInfo() {
    var _room$currentState, _room$currentState$ge;
    const squadId = getQueryString("squad");
    if (type !== "squad" || !squadId) {
      setIsTokenGated(false);
      return false;
    }
    ;
    const room = _MatrixClientPeg__WEBPACK_IMPORTED_MODULE_4__/* .MatrixClientPeg */ .p.get().getRoom(squadId);
    const tokenGatedRuleContent = room === null || room === void 0 ? void 0 : (_room$currentState = room.currentState) === null || _room$currentState === void 0 ? void 0 : (_room$currentState$ge = _room$currentState.getStateEvents(matrix_js_sdk_src_types_event__WEBPACK_IMPORTED_MODULE_5__/* .EventType */ .tw.RoomJoinRules, "")) === null || _room$currentState$ge === void 0 ? void 0 : _room$currentState$ge.getContent();
    if ((tokenGatedRuleContent === null || tokenGatedRuleContent === void 0 ? void 0 : tokenGatedRuleContent.join_rule) === matrix_js_sdk_src_types_partials__WEBPACK_IMPORTED_MODULE_6__/* .JoinRule */ .iE.Token) {
      setIsTokenGated(true);
      return true;
    }
    const spaceInfo = await _MatrixClientPeg__WEBPACK_IMPORTED_MODULE_4__/* .MatrixClientPeg */ .p.get().getSdnSquadInfo(squadId);
    if ((spaceInfo === null || spaceInfo === void 0 ? void 0 : spaceInfo.join_rules) === matrix_js_sdk_src_types_partials__WEBPACK_IMPORTED_MODULE_6__/* .JoinRule */ .iE.Token) {
      setIsTokenGated(true);
      return true;
    }
    setIsTokenGated(false);
  }
  if (isTokenGated) {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
      className: classnames__WEBPACK_IMPORTED_MODULE_0___default()("mx_SdmCard_description", "mx_SdmCard_description_tokenGated")
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", null, description), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", null, (0,_languageHandler__WEBPACK_IMPORTED_MODULE_2__._t)("Token gating")));
  }
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
    className: "mx_SdmCard_description"
  }, description);
};

/***/ }),

/***/ 746487:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(667294);
/* harmony import */ var _stores_ExploreStore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(512892);
/* harmony import */ var _panelcontent_Squad__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(241358);




const CommonSider = ({
  children,
  className
}) => {
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("aside", {
    className: `mx_RightPanel dark-panel ${className || ""}`
  }, children);
};
const ExploreSider = props => {
  const {
    clientId,
    onClose
  } = props;
  const [detail, setDetail] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});
  const squad = detail.name ? detail : _stores_ExploreStore__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z.instance.getSquads().find(item => item.id === clientId);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    if (squad !== null && squad !== void 0 && squad.name) {
      return;
    }
    _stores_ExploreStore__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z.instance.fetchSquadDetail(clientId).then(res => {
      setDetail(res);
    });
  }, [clientId]);
  const refresh = () => {
    _stores_ExploreStore__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z.instance.fetchSquadDetail(clientId).then(res => {
      setDetail(res);
    });
  };
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(CommonSider, {
    className: "mx_explore_container"
  }, !(squad !== null && squad !== void 0 && squad.id) ? null : /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_panelcontent_Squad__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z, {
    detail: squad,
    key: squad === null || squad === void 0 ? void 0 : squad.id,
    onClose: onClose,
    refresh: refresh,
    isOfficial: squad.isOfficial
  }));
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ExploreSider);

/***/ }),

/***/ 289791:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(225259);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(667294);
/* harmony import */ var matrix_js_sdk__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(407637);
/* harmony import */ var _MatrixClientPeg__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(933393);
/* harmony import */ var _stores_ContactStore__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(476979);
/* harmony import */ var _languageHandler__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(867614);
/* harmony import */ var _stores_RightPanelStorePhases__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(274057);
/* harmony import */ var _BaseCard__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(554219);
/* harmony import */ var _dispatcher_dispatcher__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(245539);
/* harmony import */ var _dispatcher_actions__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(473627);
/* harmony import */ var _firebase_analytics__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(937139);
/* harmony import */ var _stores_WalletStore__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(644764);
/* harmony import */ var _utils_commonPointParams__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(970698);
/* harmony import */ var _SdkConfig__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(374312);
/* harmony import */ var _Modal__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(241648);
/* harmony import */ var sendingme_ui__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(602271);
/* harmony import */ var matrix_js_sdk_src_types_partials__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(85047);
/* harmony import */ var matrix_js_sdk_src_models_room_member__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(69694);
/* harmony import */ var _Avatar__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(161992);
/* harmony import */ var _elements_RoomTopic__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(756810);
/* harmony import */ var _elements_FacePile__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(566334);
/* harmony import */ var _utils_token__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(732094);
/* harmony import */ var _hooks_useDispatcher__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(694284);
/* harmony import */ var _views_dialogs_ErrorDialog__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(705636);
/* harmony import */ var _views_avatars_RoomAvatar__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(139319);
/* harmony import */ var _stores_ExploreStore__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(512892);
/* harmony import */ var _stores_SpaceStore__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(387579);
/* harmony import */ var _stores_ApproveStore__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(107541);
/* harmony import */ var _views_panelcontent_TokenGatedRequirement__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(872607);
/* harmony import */ var _structures_SpaceRoomView__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(102420);
/* harmony import */ var _structures_LinkWallet__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(103041);
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(294184);
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_30___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_30__);
/* harmony import */ var _res_img_inviteGroupBg_png__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(661407);
/* harmony import */ var _res_img_inviteGroupBg_png__WEBPACK_IMPORTED_MODULE_31___default = /*#__PURE__*/__webpack_require__.n(_res_img_inviteGroupBg_png__WEBPACK_IMPORTED_MODULE_31__);
/* harmony import */ var matrix_js_sdk_src_types_room__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(445706);
/* harmony import */ var _stores_LeftPanelStore__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(290884);

function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }


































const InvIteGroupPanel = props => {
  var _room, _roomInfo$space, _roomInfo$space2, _roomInfo$space3, _ContactStore$instanc2;
  const {
    roomId,
    isLink
  } = props;
  let {
    room
  } = props;
  const client = _MatrixClientPeg__WEBPACK_IMPORTED_MODULE_3__/* .MatrixClientPeg */ .p.get();
  const currentUserId = _MatrixClientPeg__WEBPACK_IMPORTED_MODULE_3__/* .MatrixClientPeg */ .p.get().getUserId();
  const newRoom = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {
    if (!roomId) return;
    return new matrix_js_sdk__WEBPACK_IMPORTED_MODULE_2__/* .Room */ .du(roomId, client, currentUserId);
  }, [roomId]);
  room = (_room = room) !== null && _room !== void 0 ? _room : newRoom;
  const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);
  const [visibleType, setVisibleType] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(matrix_js_sdk_src_types_partials__WEBPACK_IMPORTED_MODULE_16__/* .Visibility */ .EE.Public);
  const [members, setMembers] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);
  const [roomInfo, setRoomInfo] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)();
  const [busy, setBusy] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);
  const [rejecting, setRejecting] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);
  const [detailToken, setDetailToken] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);
  const [detailTokenData, setDetailTokenData] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);
  const [walletList, setWalletList] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);
  const myMembership = (0,_structures_SpaceRoomView__WEBPACK_IMPORTED_MODULE_28__/* .useMyRoomMembership */ .qr)(room);
  const [showLinkWallet, setShowLinkWallet] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);
  const [approveApplied, setApproveApplied] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({
    status: false,
    msg: ""
  });
  const [isSpaceApprove, setIsSpaceApprove] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(myMembership !== "invite" && myMembership !== "join" && !!(roomInfo !== null && roomInfo !== void 0 && (_roomInfo$space = roomInfo.space) !== null && _roomInfo$space !== void 0 && _roomInfo$space.room_id) && !_stores_SpaceStore__WEBPACK_IMPORTED_MODULE_25__/* ["default"] */ .ZP.instance.getSpace(roomInfo === null || roomInfo === void 0 ? void 0 : (_roomInfo$space2 = roomInfo.space) === null || _roomInfo$space2 === void 0 ? void 0 : _roomInfo$space2.room_id) && (roomInfo === null || roomInfo === void 0 ? void 0 : (_roomInfo$space3 = roomInfo.space) === null || _roomInfo$space3 === void 0 ? void 0 : _roomInfo$space3.join_rules) === matrix_js_sdk_src_types_partials__WEBPACK_IMPORTED_MODULE_16__/* .JoinRule */ .iE.Approve);
  const WHITE_LIST_PERMISSION = _SdkConfig__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z.get("WHITE_LIST_PERMISSION");
  (0,_hooks_useDispatcher__WEBPACK_IMPORTED_MODULE_21__/* .useDispatcher */ .P)(_dispatcher_dispatcher__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .ZP, payload => {
    var _room2;
    if (payload.action === _dispatcher_actions__WEBPACK_IMPORTED_MODULE_9__/* .Action */ .a.JoinRoomError && payload.roomId === (((_room2 = room) === null || _room2 === void 0 ? void 0 : _room2.roomId) || roomId)) {
      setBusy(false); // stop the spinner, join failed
      if (payload.err.qualified !== undefined) {
        setDetailToken(true);
        setDetailTokenData(payload.err);
      } else if (payload.err.privateApply) {
        // setPrivateApply(true);
      }
    }
    if (payload.action === "token_qualified_error") {
      setBusy(false);
    }
  });
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {
    if (isLink) {
      setLoading(true);
    }
    Promise.all([client.getSdnSquadInfo$$(roomId || room.roomId), client.getRoomDetail(roomId || room.roomId)]).then(([shareRes, baseRes]) => {
      setMembers((shareRes === null || shareRes === void 0 ? void 0 : shareRes.members) || []);
      if (shareRes !== null && shareRes !== void 0 && shareRes.join_rules) {
        var _shareRes$members;
        setRoomInfo(_objectSpread(_objectSpread({}, shareRes), {}, {
          memberCount: (_shareRes$members = shareRes.members) === null || _shareRes$members === void 0 ? void 0 : _shareRes$members.length
        }));
      } else {
        const item = _stores_ExploreStore__WEBPACK_IMPORTED_MODULE_24__/* ["default"] */ .Z.resolveItem(baseRes);
        const data = {
          room_id: item.id,
          roomId: item.id,
          name: item.name,
          background: item.bg,
          avatar: item.avatar,
          join_rules: item.auth,
          public: item.auth === "Public",
          topic: item.desc,
          urls: item.urls,
          type: item.type,
          space: item.space,
          memberCount: item.member,
          joinParams: item.joinParams,
          joinAdvance: item.joinAdvance
        };
        setRoomInfo(data);
      }
    }).finally(() => {
      setLoading(false);
    });
  }, [room, roomId, isLink]);
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {
    var _room3;
    if (!room && !roomId) return;
    client.getRoomDirectoryVisibility(((_room3 = room) === null || _room3 === void 0 ? void 0 : _room3.roomId) || roomId).then(result => {
      const visibility = result.visibility === "public" ? matrix_js_sdk_src_types_partials__WEBPACK_IMPORTED_MODULE_16__/* .Visibility */ .EE.Public : matrix_js_sdk_src_types_partials__WEBPACK_IMPORTED_MODULE_16__/* .Visibility */ .EE.Private;
      setVisibleType(visibility);
    });
  }, [room, roomId]);
  const roomMembers = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {
    return members.map(m => {
      const newMember = new matrix_js_sdk_src_models_room_member__WEBPACK_IMPORTED_MODULE_17__/* .RoomMember */ .T(room.roomId, m.user_id);
      newMember.setRawDisplayName(m.displayname);
      newMember.name = m.displayname;
      newMember.setCustomerRoomMemberAvatar(m.avatar_url);
      return newMember;
    });
  }, [members]);
  const bannerUrl = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {
    if (roomInfo !== null && roomInfo !== void 0 && roomInfo.background) {
      return roomInfo.background;
    }
    if (!room.getParentRoom()) {
      return (0,_Avatar__WEBPACK_IMPORTED_MODULE_18__/* .bannerUrlForRoom */ .ot)(room, 960, 540, "scale");
    }
    return '';
  }, [room, roomInfo]);
  const avatar = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {
    if (roomInfo !== null && roomInfo !== void 0 && roomInfo.avatar) {
      return roomInfo.avatar;
    }
    return (0,_Avatar__WEBPACK_IMPORTED_MODULE_18__/* .avatarUrlForRoom */ .Eh)(room, 80, 80, "crop");
  }, [room, roomInfo]);
  const description = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {
    const currentTopic = (0,_elements_RoomTopic__WEBPACK_IMPORTED_MODULE_19__/* .getTopic */ .B)(room);
    return currentTopic;
  }, [room]);
  const roomType = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {
    var _room4, _room5;
    const isChannel = (roomInfo === null || roomInfo === void 0 ? void 0 : roomInfo.room_type) === matrix_js_sdk_src_types_room__WEBPACK_IMPORTED_MODULE_32__/* .RoomServerType */ .O.SPACE_CHAT;
    const isGroup = ((_room4 = room) === null || _room4 === void 0 ? void 0 : _room4.isGroup()) || (roomInfo === null || roomInfo === void 0 ? void 0 : roomInfo.room_type) === matrix_js_sdk_src_types_room__WEBPACK_IMPORTED_MODULE_32__/* .RoomServerType */ .O.GROUP;
    const isSpace = ((_room5 = room) === null || _room5 === void 0 ? void 0 : _room5.isSpaceRoom()) || (roomInfo === null || roomInfo === void 0 ? void 0 : roomInfo.room_type) === matrix_js_sdk_src_types_room__WEBPACK_IMPORTED_MODULE_32__/* .RoomServerType */ .O["m.space"];
    // If room does not exist in the props of a component, then the type of room in this component is group.
    // so squad takes precedence over group.
    if (isSpace) {
      return "Squad";
    }
    if (isChannel) {
      return "Channel";
    }
    if (isGroup) {
      return "Group";
    }
    return "Channel";
  }, [room, roomInfo]);
  const sender = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {
    var _ContactStore$instanc, _inviteMember$events$;
    const friends = (_ContactStore$instanc = _stores_ContactStore__WEBPACK_IMPORTED_MODULE_4__["default"].instance) === null || _ContactStore$instanc === void 0 ? void 0 : _ContactStore$instanc.friends;
    const inviteMember = room.getMembers().find(member => member.userId === currentUserId && member.membership === "invite");
    const inviteSender = inviteMember === null || inviteMember === void 0 ? void 0 : (_inviteMember$events$ = inviteMember.events.member) === null || _inviteMember$events$ === void 0 ? void 0 : _inviteMember$events$.getSender();
    const senderUser = friends.find(i => i.userId === inviteSender);
    return senderUser;
  }, [room, (_ContactStore$instanc2 = _stores_ContactStore__WEBPACK_IMPORTED_MODULE_4__["default"].instance) === null || _ContactStore$instanc2 === void 0 ? void 0 : _ContactStore$instanc2.friends]);
  const isTokenGating = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {
    return roomInfo && roomInfo.join_rules === matrix_js_sdk_src_types_partials__WEBPACK_IMPORTED_MODULE_16__/* .JoinRule */ .iE.Token;
  }, [roomInfo]);
  const isMaxWallet = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {
    return walletList.length >= 10;
  }, [walletList]);
  const isApproveRule = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {
    var _room6;
    const joinRules = (roomInfo === null || roomInfo === void 0 ? void 0 : roomInfo.join_rules) || ((_room6 = room) === null || _room6 === void 0 ? void 0 : _room6.getJoinRule());
    return myMembership !== "invite" && joinRules === matrix_js_sdk_src_types_partials__WEBPACK_IMPORTED_MODULE_16__/* .JoinRule */ .iE.Approve;
  }, [roomInfo, myMembership]);
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {
    if (roomInfo && isTokenGating) {
      checkTokenGatedPermission();
    }
  }, [roomInfo, isTokenGating]);
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {
    if (roomInfo) {
      const refresh = () => {
        var _roomInfo$space4, _roomInfo$space5, _roomInfo$space6;
        const next = myMembership !== "invite" && myMembership !== "join" && !!(roomInfo !== null && roomInfo !== void 0 && (_roomInfo$space4 = roomInfo.space) !== null && _roomInfo$space4 !== void 0 && _roomInfo$space4.room_id) && !_stores_SpaceStore__WEBPACK_IMPORTED_MODULE_25__/* ["default"] */ .ZP.instance.getSpace(roomInfo === null || roomInfo === void 0 ? void 0 : (_roomInfo$space5 = roomInfo.space) === null || _roomInfo$space5 === void 0 ? void 0 : _roomInfo$space5.room_id) && (roomInfo === null || roomInfo === void 0 ? void 0 : (_roomInfo$space6 = roomInfo.space) === null || _roomInfo$space6 === void 0 ? void 0 : _roomInfo$space6.join_rules) === matrix_js_sdk_src_types_partials__WEBPACK_IMPORTED_MODULE_16__/* .JoinRule */ .iE.Approve;
        setIsSpaceApprove(next);
        if (isSpaceApprove && !next) {
          setApproveApplied({
            status: false,
            msg: ""
          });
        }
      };
      setTimeout(refresh, 400);
      _stores_SpaceStore__WEBPACK_IMPORTED_MODULE_25__/* ["default"] */ .ZP.instance.on(_stores_SpaceStore__WEBPACK_IMPORTED_MODULE_25__/* .UPDATE_TOP_LEVEL_SPACES */ .Ue, refresh);
      return () => {
        _stores_SpaceStore__WEBPACK_IMPORTED_MODULE_25__/* ["default"] */ .ZP.instance.off(_stores_SpaceStore__WEBPACK_IMPORTED_MODULE_25__/* .UPDATE_TOP_LEVEL_SPACES */ .Ue, refresh);
      };
    }
  }, [myMembership, roomInfo]);
  const getWalletList = async () => {
    const userId = client.getUserId();
    const walletListResult = await _stores_WalletStore__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .ZP.instance.getWalletList(userId, true);
    if (walletListResult.data) {
      setWalletList(walletListResult.data || []);
    }
  };
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {
    if (isTokenGating) {
      getWalletList();
    }
  }, [isTokenGating]);
  const checkTokenGatedPermission = async () => {
    const sendObj = {
      join_rule: roomInfo === null || roomInfo === void 0 ? void 0 : roomInfo.join_rules,
      join_params: roomInfo === null || roomInfo === void 0 ? void 0 : roomInfo.join_params
    };
    const res = await client.checkTokenGated(sendObj);
    if ((res === null || res === void 0 ? void 0 : res.qualified) !== undefined) {
      setDetailToken(true);
      setDetailTokenData(res === null || res === void 0 ? void 0 : res.content);
    }
  };
  const onSuccess = roomId => {
    console.log('trigger onSuccess');
    if (roomId) {
      var _props$onClose;
      const room = client.getRoom(roomId);
      if (room !== null && room !== void 0 && room.isSpaceRoom() || room !== null && room !== void 0 && room.getParentRoom()) {
        client.pointReport({
          action_type: "join_squad",
          room_id: room.isSpaceRoom() ? roomId : room.getParentRoom().roomId
        });
      }
      setBusy(false);
      sendingme_ui__WEBPACK_IMPORTED_MODULE_15__.SdMessage.success((0,_languageHandler__WEBPACK_IMPORTED_MODULE_5__._t)("Joined successfully."));
      props === null || props === void 0 ? void 0 : (_props$onClose = props.onClose) === null || _props$onClose === void 0 ? void 0 : _props$onClose.call(props);
      _dispatcher_dispatcher__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .ZP.dispatch({
        action: "view_room",
        room_id: roomId
      }, true);
      _dispatcher_dispatcher__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .ZP.dispatch({
        action: _dispatcher_actions__WEBPACK_IMPORTED_MODULE_9__/* .Action */ .a.ShowRoomPanel
      });
    }
  };
  const onFailed = error => {
    var _props$onClose2;
    console.log('trigger onFailed');
    sendingme_ui__WEBPACK_IMPORTED_MODULE_15__.SdMessage.error(error);
    console.error(error);
    room.isJoining = false;
    props === null || props === void 0 ? void 0 : (_props$onClose2 = props.onClose) === null || _props$onClose2 === void 0 ? void 0 : _props$onClose2.call(props);
  };
  const onfinish = () => {
    console.log('trigger onfinish');
    setBusy(false);
  };
  function onJoinButtonClicked(roomId, outsideRoom, inviteSender, squadId) {
    //done firebase : room_invite_accept
    (0,_firebase_analytics__WEBPACK_IMPORTED_MODULE_10__/* .logEvent */ .K)(_firebase_analytics__WEBPACK_IMPORTED_MODULE_10__/* .analytics */ .c, "room_invite_accept", _objectSpread(_objectSpread({}, (0,_utils_commonPointParams__WEBPACK_IMPORTED_MODULE_12__/* .getCommonPointParams */ .I)()), {}, {
      room_id: room.roomId.split(":")[0],
      invite_user_id: inviteSender || "unknown",
      invite_room_id: room.roomId.split(":")[0]
    }));
    return Promise.resolve().then(() => {
      const signUrl = "";
      const id = (outsideRoom ? roomId : "") || room.roomId;
      _dispatcher_dispatcher__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .ZP.dispatch({
        action: _dispatcher_actions__WEBPACK_IMPORTED_MODULE_9__/* .Action */ .a.JoinRoom,
        roomId: id,
        outsideRoom,
        opts: {
          inviteSignUrl: signUrl,
          squadId
        },
        _type: "unknown",
        // TODO: instrumentation
        inviteSender: inviteSender,
        onSuccess: () => onSuccess(id),
        onFailed,
        onfinish,
        from: 'inviteGroupPanel'
      });
      return Promise.resolve({
        roomId: id
      });
    });
  }
  const onApproveApply = () => {
    var _room7;
    if (approveApplied.status) {
      return;
    }
    _stores_ApproveStore__WEBPACK_IMPORTED_MODULE_26__/* ["default"] */ .Z.applyApprove(roomInfo.room_id || ((_room7 = room) === null || _room7 === void 0 ? void 0 : _room7.roomId)).then(res => {
      if (res.httpStatus === 400) {
        sendingme_ui__WEBPACK_IMPORTED_MODULE_15__.SdMessage.error(res.data);
      }
      if (!(res !== null && res !== void 0 && res.httpStatus)) {
        sendingme_ui__WEBPACK_IMPORTED_MODULE_15__.SdMessage.success((0,_languageHandler__WEBPACK_IMPORTED_MODULE_5__._t)("Apply Successfully!"));
      }
      setApproveApplied({
        status: true,
        msg: (res === null || res === void 0 ? void 0 : res.data) || ""
      });
    });
  };

  // for remove 0x
  const transferAddress = address => {
    if (/^0x(.*)/.test(address)) {
      return address.substring(2);
    }
    return address;
  };
  function handleJoin() {
    var _room8, _room8$currentState$g, _room9, _room9$getMember, _room9$getMember$even, _room$getParentRoom;
    debugger;
    // const owner = room.getOwner()
    const creator = ((_room8 = room) === null || _room8 === void 0 ? void 0 : (_room8$currentState$g = _room8.currentState.getStateEvents("m.room.create", "")) === null || _room8$currentState$g === void 0 ? void 0 : _room8$currentState$g.getContent()["creator"]) || '';
    const senderAddress = transferAddress(sender === null || sender === void 0 ? void 0 : sender.walletAddress);
    const isOwnerInvite = creator === null || creator === void 0 ? void 0 : creator.includes(senderAddress);
    if ((roomInfo === null || roomInfo === void 0 ? void 0 : roomInfo.join_rules) === matrix_js_sdk_src_types_partials__WEBPACK_IMPORTED_MODULE_16__/* .JoinRule */ .iE.Approve && !isOwnerInvite) {
      var _props$onClose3;
      onApproveApply();
      props === null || props === void 0 ? void 0 : (_props$onClose3 = props.onClose) === null || _props$onClose3 === void 0 ? void 0 : _props$onClose3.call(props);
      return;
    }
    setBusy(true);
    room.isJoining = true;
    onJoinButtonClicked(room.roomId, true, (_room9 = room) === null || _room9 === void 0 ? void 0 : (_room9$getMember = _room9.getMember(client.getUserId())) === null || _room9$getMember === void 0 ? void 0 : (_room9$getMember$even = _room9$getMember.events.member) === null || _room9$getMember$even === void 0 ? void 0 : _room9$getMember$even.getSender(), (_room$getParentRoom = room.getParentRoom()) === null || _room$getParentRoom === void 0 ? void 0 : _room$getParentRoom.roomId);
  }
  const onRejectButtonClicked = inviteSender => {
    if (isApproveRule) {
      var _props$onClose4;
      props === null || props === void 0 ? void 0 : (_props$onClose4 = props.onClose) === null || _props$onClose4 === void 0 ? void 0 : _props$onClose4.call(props);
      return;
    }
    setRejecting(true);
    //done firebase : room_invite_reject
    (0,_firebase_analytics__WEBPACK_IMPORTED_MODULE_10__/* .logEvent */ .K)(_firebase_analytics__WEBPACK_IMPORTED_MODULE_10__/* .analytics */ .c, "room_invite_reject", _objectSpread(_objectSpread({}, (0,_utils_commonPointParams__WEBPACK_IMPORTED_MODULE_12__/* .getCommonPointParams */ .I)()), {}, {
      invite_user_id: inviteSender || "unknown",
      room_id: room.roomId.split(":")[0]
    }));
    return room.client.leave(room.roomId).then(() => {
      // done firebase : room_invite_reject_success
      (0,_firebase_analytics__WEBPACK_IMPORTED_MODULE_10__/* .logEvent */ .K)(_firebase_analytics__WEBPACK_IMPORTED_MODULE_10__/* .analytics */ .c, "room_invite_reject_success", _objectSpread(_objectSpread({}, (0,_utils_commonPointParams__WEBPACK_IMPORTED_MODULE_12__/* .getCommonPointParams */ .I)()), {}, {
        invite_user_id: inviteSender || "unknown",
        room_id: room.roomId.split(":")[0]
      }));
      _dispatcher_dispatcher__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .ZP.dispatch({
        action: "view_home_page"
      });
      _stores_LeftPanelStore__WEBPACK_IMPORTED_MODULE_33__/* ["default"] */ .ZP.instance.updateSelected(_stores_LeftPanelStore__WEBPACK_IMPORTED_MODULE_33__/* .HOME_TAB */ .e9);
      setRejecting(false);
    }, error => {
      const msg1 = (0,_languageHandler__WEBPACK_IMPORTED_MODULE_5__._t)("Oops! Something went wrong with the server. Please try again later.");
      const msg2 = (0,_languageHandler__WEBPACK_IMPORTED_MODULE_5__._t)("Oops! Your request is invalid. Please try again.");
      const msg = (error === null || error === void 0 ? void 0 : error.status) === 403 ? msg2 : msg1;
      _Modal__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z.createTrackedDialog("Failed to reject invite", "", _views_dialogs_ErrorDialog__WEBPACK_IMPORTED_MODULE_22__/* ["default"] */ .Z, {
        title: (0,_languageHandler__WEBPACK_IMPORTED_MODULE_5__._t)("Failed to reject invite"),
        description: msg,
        onFinished: () => {
          setRejecting(false);
        }
      });

      // done firebase : room_invite_reject_failed
      (0,_firebase_analytics__WEBPACK_IMPORTED_MODULE_10__/* .logEvent */ .K)(_firebase_analytics__WEBPACK_IMPORTED_MODULE_10__/* .analytics */ .c, "room_invite_reject_failed", _objectSpread(_objectSpread({}, (0,_utils_commonPointParams__WEBPACK_IMPORTED_MODULE_12__/* .getCommonPointParams */ .I)()), {}, {
        invite_user_id: inviteSender || "unknown",
        room_id: room.roomId.split(":")[0]
      }));
    }).finally(() => {
      setRejecting(false);
    });
  };
  const getPreviousPhase = () => {
    let previousPhase = null;
    if (props.room) {
      var _props$room;
      previousPhase = (_props$room = props.room) !== null && _props$room !== void 0 && _props$room.hasSpaceParent() ? _stores_RightPanelStorePhases__WEBPACK_IMPORTED_MODULE_6__/* .RightPanelPhases */ .q4.RoomMemberList : _stores_RightPanelStorePhases__WEBPACK_IMPORTED_MODULE_6__/* .RightPanelPhases */ .q4.SpaceMemberList;
    }
    return previousPhase;
  };
  const renderTokenGatedArea = () => {
    // roomInfo?.join_rules === JoinRule.Approve ||
    if (!isTokenGating) return null;
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
      className: "card_child_area card_token_gated_area"
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
      className: "mx_TokenGated_joinparams",
      style: {
        padding: "0px"
      }
    }, detailToken ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(_views_panelcontent_TokenGatedRequirement__WEBPACK_IMPORTED_MODULE_27__/* ["default"] */ .Z, {
      joinparams: detailTokenData === null || detailTokenData === void 0 ? void 0 : detailTokenData.join_params,
      joinadvance: detailTokenData === null || detailTokenData === void 0 ? void 0 : detailTokenData.join_advance,
      shortTitle: true
    }) : /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(_views_panelcontent_TokenGatedRequirement__WEBPACK_IMPORTED_MODULE_27__/* ["default"] */ .Z, {
      joinparams: roomInfo === null || roomInfo === void 0 ? void 0 : roomInfo.join_params,
      joinadvance: roomInfo === null || roomInfo === void 0 ? void 0 : roomInfo.join_advance,
      shortTitle: true
    })));
  };
  const renderWalletSection = () => {
    if (isApproveRule || isMaxWallet || !isTokenGating) return null;
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
      className: "card_child_area card_wallett_section"
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
      className: "mx_walletSection_operation"
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
      onClick: () => setShowLinkWallet(true)
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("img", {
      src: __webpack_require__(570560)
    }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("span", null, (0,_languageHandler__WEBPACK_IMPORTED_MODULE_5__._t)("Link another wallet")))));
  };
  const renderBannerArea = () => {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
      className: "card_top_cover_area"
    }, bannerUrl ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("img", {
      className: "cover_banner",
      src: bannerUrl
    }) :
    /*#__PURE__*/
    // <div className="cover_banner cover_banner_empty" />
    react__WEBPACK_IMPORTED_MODULE_1__.createElement("img", {
      className: "cover_banner",
      src: (_res_img_inviteGroupBg_png__WEBPACK_IMPORTED_MODULE_31___default())
    }));
  };
  const renderCardAvatarArea = () => {
    var _room10;
    const name = (roomInfo === null || roomInfo === void 0 ? void 0 : roomInfo.name) || ((_room10 = room) === null || _room10 === void 0 ? void 0 : _room10.name);
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
      className: classnames__WEBPACK_IMPORTED_MODULE_30___default()({
        "card_top_avatar_area": true,
        // "card_top_avatar_area_center": roomType === "Group",
        "card_top_avatar_area_center": true
      })
    }, avatar ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("img", {
      className: "cover_avatar",
      src: avatar
    }) : /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
      className: "cover_avatar"
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(_views_avatars_RoomAvatar__WEBPACK_IMPORTED_MODULE_23__/* ["default"] */ .Z, {
      name: name,
      room: room,
      size: 70,
      viewAvatarOnClick: true,
      style: {
        borderWidth: "unset",
        borderRadius: "50%"
      }
    })));
  };
  const renderCardInfoArea = () => {
    var _room11;
    const name = (roomInfo === null || roomInfo === void 0 ? void 0 : roomInfo.name) || ((_room11 = room) === null || _room11 === void 0 ? void 0 : _room11.name);
    const isPrivate = visibleType === matrix_js_sdk_src_types_partials__WEBPACK_IMPORTED_MODULE_16__/* .Visibility */ .EE.Private;
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
      className: classnames__WEBPACK_IMPORTED_MODULE_30___default()({
        "card_child_area": true,
        "card_info_area": true,
        // "card_info_area_center": roomType === "Group",
        "card_info_area_center": true
      })
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
      className: "info_name"
    }, name), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
      className: "info_others"
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", null, (0,_languageHandler__WEBPACK_IMPORTED_MODULE_5__._t)(roomType)), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", null, "|"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", null, `${members.length} members`), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", null, "|"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", null, isPrivate ? "Private" : "Public")), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
      className: "info_member_area"
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(_elements_FacePile__WEBPACK_IMPORTED_MODULE_20__/* ["default"] */ .Z, {
      room: room,
      onlyKnownUsers: false,
      numShown: 7,
      members: roomMembers,
      showOurselves: true,
      size: 26
    })));
  };
  const renderDescriptionArea = () => {
    if (!description) return;
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
      className: "card_child_area card_description_area"
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
      className: "description_title"
    }, (0,_languageHandler__WEBPACK_IMPORTED_MODULE_5__._t)("Description")), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
      className: "description_detail"
    }, description));
  };
  const renderLinkWalletCard = () => {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
      className: "mx_SpacePreview_wallet_wrapper"
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(_structures_LinkWallet__WEBPACK_IMPORTED_MODULE_29__/* ["default"] */ .ZP, {
      step: _structures_LinkWallet__WEBPACK_IMPORTED_MODULE_29__/* .WalletStep */ .Ww.LINK_WALLET,
      closeElement: /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("span", {
        className: "mx_LinkWallet_header_close",
        onClick: () => setShowLinkWallet(false)
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("img", {
        src: __webpack_require__(101727)
      })),
      onClose: () => setShowLinkWallet(false)
    }));
  };
  const renderCardContent = () => {
    if (loading) {
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(sendingme_ui__WEBPACK_IMPORTED_MODULE_15__.SdSkeleton.SimpleList, {
        rows: 5,
        style: {
          padding: 16
        }
      });
    }
    if (showLinkWallet) {
      return renderLinkWalletCard();
    }
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, renderBannerArea(), renderCardAvatarArea(), renderCardInfoArea(), renderDescriptionArea(), renderTokenGatedArea(), renderWalletSection());
  };
  const renderFooter = () => {
    var _detailTokenData$join;
    if (loading) return null;
    if (showLinkWallet) return null;
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
      className: "invite_card_footer_area"
    }, sender && !isLink && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
      className: "footer_invite_user"
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(sendingme_ui__WEBPACK_IMPORTED_MODULE_15__.SdAvatar, {
      className: "user_avatar",
      name: sender.displayName,
      id: sender.userId,
      src: sender === null || sender === void 0 ? void 0 : sender.avatarUrl,
      size: 28,
      type: "round"
    }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
      className: "user_name",
      title: sender === null || sender === void 0 ? void 0 : sender.displayName
    }, (0,_utils_token__WEBPACK_IMPORTED_MODULE_34__/* .formatWallet */ .Tl)(sender === null || sender === void 0 ? void 0 : sender.displayName)), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
      className: "user_wallet",
      title: sender === null || sender === void 0 ? void 0 : sender.walletAddress
    }, "(", (0,_utils_token__WEBPACK_IMPORTED_MODULE_34__/* .formatWallet */ .Tl)(sender === null || sender === void 0 ? void 0 : sender.walletAddress), ")"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
      className: "user_text"
    }, (0,_languageHandler__WEBPACK_IMPORTED_MODULE_5__._t)("invited you"))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
      className: "footer_button_area"
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(sendingme_ui__WEBPACK_IMPORTED_MODULE_15__.SdButton, {
      className: "reject_botton",
      onClick: () => onRejectButtonClicked(sender === null || sender === void 0 ? void 0 : sender.userId),
      type: "associate",
      size: "large",
      disabled: rejecting,
      loading: rejecting
    }, (0,_languageHandler__WEBPACK_IMPORTED_MODULE_5__._t)(isApproveRule ? "Close" : "Reject")), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(sendingme_ui__WEBPACK_IMPORTED_MODULE_15__.SdButton, {
      className: "join_botton",
      onClick: handleJoin,
      type: "primary",
      size: "large",
      disabled: busy || detailTokenData && !(detailTokenData !== null && detailTokenData !== void 0 && (_detailTokenData$join = detailTokenData.join_params) !== null && _detailTokenData$join !== void 0 && _detailTokenData$join.qualified),
      loading: busy
    }, (0,_languageHandler__WEBPACK_IMPORTED_MODULE_5__._t)(isApproveRule ? "Apply" : "Join"))));
  };
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(_BaseCard__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .C, {
    className: "mx_invite_room_right_panel",
    onClose: props.onClose,
    onBack: null,
    previousPhase: getPreviousPhase(),
    footer: renderFooter()
  }, renderCardContent()));
};
InvIteGroupPanel.defaultProps = {
  width: 200,
  height: 200
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (InvIteGroupPanel);

/***/ }),

/***/ 128370:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Z: () => (/* binding */ SeaUserProfile_SeaUserProfile),
  o: () => (/* binding */ iconStyle)
});

// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/node_modules/@babel/runtime/helpers/esm/defineProperty.js
var defineProperty = __webpack_require__(225259);
// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(667294);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/right_panel/BaseCard.tsx
var BaseCard = __webpack_require__(554219);
// EXTERNAL MODULE: ./node_modules/sendingme-ui/dist/index.js
var dist = __webpack_require__(602271);
// EXTERNAL MODULE: ./node_modules/matrix-js-sdk/src/browser-index.js
var browser_index = __webpack_require__(407637);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/customisations/Media.ts + 1 modules
var Media = __webpack_require__(834208);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/MatrixClientPeg.ts + 3 modules
var MatrixClientPeg = __webpack_require__(933393);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/dispatcher/actions.ts
var actions = __webpack_require__(473627);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/RightPanelStorePhases.ts
var RightPanelStorePhases = __webpack_require__(274057);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/lib/constants.ts
var constants = __webpack_require__(877294);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/dispatcher/dispatcher.ts
var dispatcher = __webpack_require__(245539);
// EXTERNAL MODULE: ./node_modules/@sdm/react/dist/index.js
var react_dist = __webpack_require__(654384);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/utils/commonPointParams.ts
var commonPointParams = __webpack_require__(970698);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/firebase_analytics.ts + 3 modules
var firebase_analytics = __webpack_require__(937139);
// EXTERNAL MODULE: ./node_modules/matrix-js-sdk/src/@types/user.ts
var _types_user = __webpack_require__(650540);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/ContactStore.ts + 1 modules
var ContactStore = __webpack_require__(476979);
// EXTERNAL MODULE: ./node_modules/antd/lib/index.js
var lib = __webpack_require__(769215);
// EXTERNAL MODULE: ./node_modules/classnames/index.js
var classnames = __webpack_require__(294184);
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/SdkConfig.ts
var SdkConfig = __webpack_require__(374312);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/right_panel/SeaUserProfile/UserInfo.tsx








const UserInfo = props => {
  var _props$tokens, _props$tokens2, _props$nfts, _props$poaps;
  const WHITE_LIST_PERMISSION = SdkConfig/* default */.Z.get("WHITE_LIST_PERMISSION");
  const {
    user,
    userId,
    avatar
  } = props;
  const isBot = (SdkConfig/* default */.Z.get("bot") || []).includes(userId);
  const [businessCard, setBusinessCard] = (0,react.useState)(null);
  (0,react.useEffect)(() => {
    const getBusinessCard = async () => {
      const businessCardInfo = await MatrixClientPeg/* MatrixClientPeg */.p.get().getBusinessCard(userId);
      const result = (businessCardInfo === null || businessCardInfo === void 0 ? void 0 : businessCardInfo.result) || null;
      setBusinessCard(result);
    };
    getBusinessCard();
  }, [userId]);
  const renderMarks = () => {
    const tags = renderAssetTagArea(props);
    if (!tags && !props.feedNode) return null;
    return /*#__PURE__*/react.createElement("div", {
      className: "mx_UserProfile_marks"
    }, tags, props.feedNode ? props.feedNode : null);
  };
  return /*#__PURE__*/react.createElement("div", {
    className: "mx_UserProfile_userinfo"
  }, renderMarks(), businessCard && WHITE_LIST_PERMISSION ? BusinessCard({
    businessCard,
    avatar
  }) : null, props.contactRelation ? props.contactRelation : null, (user === null || user === void 0 ? void 0 : user.signature) && /*#__PURE__*/react.createElement("div", {
    className: "mx_UserProfile_about_me"
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_UserProfile_card_title"
  }, "Bio"), /*#__PURE__*/react.createElement("div", {
    className: "mx_UserProfile_card_content"
  }, isBot && /*#__PURE__*/react.createElement("div", {
    className: "bot_title"
  }, /*#__PURE__*/react.createElement("span", {
    className: "bot_title_tag"
  }, "Bot")), user === null || user === void 0 ? void 0 : user.signature)), /*#__PURE__*/react.createElement("div", {
    className: "mx_UserProfile_asset"
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_UserProfile_card_title"
  }, "Asset"), (_props$tokens = props.tokens) !== null && _props$tokens !== void 0 && _props$tokens.length || props.netWorth || props.nftWorth || props.tokenWorth ? /*#__PURE__*/react.createElement("div", {
    className: "mx_UserProfile_card_content"
  }, /*#__PURE__*/react.createElement("div", null, props.netWorth ? /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(lib.Row, null, /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement("div", {
    className: "mx_UserProfile_asset_item_title"
  }, "Net worth"), /*#__PURE__*/react.createElement("div", {
    className: "net_worth"
  }, "$", props.netWorth.value), props.netWorth.limit ? /*#__PURE__*/react.createElement("div", {
    className: `mx_UserProfile_value ${getCompareString(props.netWorth.rate)}`
  }, props.netWorth.rate.toFixed(2), "% ($", props.netWorth.limit.toFixed(2), ")") : null)), /*#__PURE__*/react.createElement(lib.Divider, null)) : null, props.tokenWorth || props.nftWorth ? /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(lib.Row, null, props.tokenWorth ? /*#__PURE__*/react.createElement(lib.Col, {
    span: 12
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_UserProfile_asset_item_title"
  }, "Tokens worth"), /*#__PURE__*/react.createElement("div", {
    className: "tokens_worth"
  }, "$", props.tokenWorth.value), props.tokenWorth.limit ? /*#__PURE__*/react.createElement("div", {
    className: `mx_UserProfile_value ${getCompareString(props.tokenWorth.rate)}`
  }, props.tokenWorth.rate.toFixed(2), "% ($", props.tokenWorth.limit.toFixed(2), ")") : null) : null, props.nftWorth ? /*#__PURE__*/react.createElement(lib.Col, {
    span: 12
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_UserProfile_asset_item_title"
  }, "NFTS worth"), /*#__PURE__*/react.createElement("div", {
    className: "nfts_worth"
  }, "$", props.nftWorth.value), props.nftWorth.limit ? /*#__PURE__*/react.createElement("div", {
    className: `mx_UserProfile_value ${getCompareString(props.nftWorth.rate)}`
  }, props.nftWorth.rate.toFixed(2), "% ($", props.nftWorth.limit.toFixed(2), ")") : null) : null)) : null, (_props$tokens2 = props.tokens) !== null && _props$tokens2 !== void 0 && _props$tokens2.length ? /*#__PURE__*/react.createElement("div", {
    className: "mx_UserProfile_token_avatar"
  }, (props.tokens || []).slice(0, 5).map(token => {
    return /*#__PURE__*/react.createElement(lib.Avatar, {
      className: "token_avatar",
      src: token,
      size: 24,
      key: token
    });
  })) : null)) : null, /*#__PURE__*/react.createElement("div", {
    className: "mx_UserProfile_card_content"
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_UserProfile_nft_summary"
  }, /*#__PURE__*/react.createElement(lib.Row, null, /*#__PURE__*/react.createElement(lib.Col, {
    span: 12
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_UserProfile_asset_item_title"
  }, "Collections"), /*#__PURE__*/react.createElement("div", {
    className: "collections_count"
  }, props.collectionsCount || 0)), /*#__PURE__*/react.createElement(lib.Col, {
    span: 12
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_UserProfile_asset_item_title"
  }, "NFTS"), /*#__PURE__*/react.createElement("div", {
    className: "nfts_count"
  }, props.nftsCount || 0))), (_props$nfts = props.nfts) !== null && _props$nfts !== void 0 && _props$nfts.length ? /*#__PURE__*/react.createElement("div", {
    className: "nft_avatar_group"
  }, props.nfts.slice(0, 6).map(nft => {
    return /*#__PURE__*/react.createElement("div", {
      className: "nft_avatar",
      onClick: () => {
        if (props.onClickNft) {
          props.onClickNft(nft);
        }
      }
    }, /*#__PURE__*/react.createElement(lib.Avatar, {
      size: 44,
      shape: "square",
      src: nft.imageUrl,
      key: `${nft.contractAddress}_${nft.tokenId}`
    }));
  })) : null)), props.poaps && ((_props$poaps = props.poaps) === null || _props$poaps === void 0 ? void 0 : _props$poaps.length) > 0 ? /*#__PURE__*/react.createElement("div", {
    className: "mx_UserProfile_card_content"
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_UserProfile_card_title"
  }, "POAPs (", props.poaps.length, ")"), /*#__PURE__*/react.createElement("div", {
    className: "mx_UserProfile_card_poaps"
  }, props.poaps.slice(0, 5).map(poap => {
    return /*#__PURE__*/react.createElement("div", {
      className: "mx_UserProfile_card_poaps_icon"
    }, /*#__PURE__*/react.createElement("img", {
      src: poap.imageUrl,
      alt: poap.name
    }));
  }))) : null, props.hasMoreAssets ? /*#__PURE__*/react.createElement("div", {
    className: "mx_UserProfile_card_content for_assets",
    onClick: props.onMoreAssets
  }, /*#__PURE__*/react.createElement("div", {
    className: "more_assets"
  }, "More Assets")) : null));
};
const getCompareString = v => {
  if (!v) {
    return '';
  }
  if (v > 0) {
    return 'green';
  }
  if (v < 0) {
    return 'red';
  }
  return 'gray';
};
function renderTag(assetTag) {
  let tag = null;
  let level = null;
  let type = null;
  switch (assetTag) {
    case 'asset_level_3':
      tag = '$>1000';
      level = 3;
      type = 'asset';
      break;
    case 'asset_level_2':
      tag = '$>10000';
      level = 2;
      type = 'asset';
      break;
    case 'asset_level_1':
      tag = 'Whale';
      level = 1;
      type = 'asset';
      break;
    case 'nft_level_1':
      tag = 'Blue chip';
      level = 1;
      type = 'nft';
      break;
    default:
      break;
  }
  if (!level) return null;
  return /*#__PURE__*/react.createElement("div", {
    className: classnames_default()({
      asset_tag: true,
      [`asset_tag_type_${type}`]: type,
      [`asset_tag_level_${type}_${level}`]: level
    })
  }, tag);
}
function renderAssetTagArea(props) {
  var _props$assetsTags, _props$assetsTags2;
  if (!(props !== null && props !== void 0 && props.assetsTags)) return null;
  if ((props === null || props === void 0 ? void 0 : (_props$assetsTags = props.assetsTags) === null || _props$assetsTags === void 0 ? void 0 : _props$assetsTags.length) === 0) return null;
  return /*#__PURE__*/react.createElement("div", {
    className: "mx_UserProfile_card_assetTagArea"
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_UserProfile_marks_label"
  }, "Tags"), /*#__PURE__*/react.createElement("div", {
    className: "mx_UserProfil_asset_tags"
  }, (_props$assetsTags2 = props.assetsTags) === null || _props$assetsTags2 === void 0 ? void 0 : _props$assetsTags2.map(renderTag)));
}
const getCardBackImg = layoutType => {
  switch (layoutType) {
    case '1':
      return 'https://businesscard.socialswap.com/image/icon/card_image_1_0.png';
    case '3':
      return 'https://businesscard.socialswap.com/image/icon/card_image_2_0.png';
    case '5':
      return 'https://businesscard.socialswap.com/image/icon/card_image_3_0.png';
    case '7':
      return 'https://businesscard.socialswap.com/image/icon/card_image_4_0.png';
    default:
      return null;
  }
};
const BusinessCard = props => {
  const {
    businessCard,
    avatar
  } = props;
  if (!businessCard) return null;
  const {
    layoutType,
    name,
    title,
    company,
    cardIndustries,
    profilePic
  } = businessCard;
  const tags = cardIndustries ? cardIndustries.slice(0, 2) : [];
  const onClickBusinessCard = () => {
    const businessCardHost = SdkConfig/* default */.Z.get().dapp.business_card;
    const url = `${businessCardHost}/detail?st=sdn&from=profile&id=${businessCard.cardNo}`;
    dispatcher/* default */.ZP.dispatch({
      action: actions/* Action */.a.SetRightPanelPhase,
      phase: RightPanelStorePhases/* RightPanelPhases */.q4.IframeWidget,
      refireParams: {
        params: {
          src: url,
          title: "Business Card"
        }
      }
    });
  };
  return /*#__PURE__*/react.createElement("div", {
    className: "mx_BusinessCard_cardbox",
    onClick: onClickBusinessCard
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_BusinessCard_cardbox--content"
  }, /*#__PURE__*/react.createElement("div", {
    className: "item",
    style: {
      backgroundImage: `url(${getCardBackImg(layoutType)})`
    }
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_BusinessCard_content"
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_BusinessCard--avatar"
  }, avatar ? /*#__PURE__*/react.createElement("div", {
    className: "mx_BusinessCard--avatar_box"
  }, /*#__PURE__*/react.createElement("img", {
    src: profilePic ? profilePic : avatar,
    alt: ""
  })) : null), /*#__PURE__*/react.createElement("div", {
    className: "mx_BusinessCard_info"
  }, /*#__PURE__*/react.createElement("p", {
    className: "mx_BusinessCard_info--name"
  }, name), /*#__PURE__*/react.createElement("p", {
    className: "mx_BusinessCard_info--job"
  }, title), /*#__PURE__*/react.createElement("p", {
    className: "mx_BusinessCard_info--company"
  }, /*#__PURE__*/react.createElement("span", {
    className: "mx_BusinessCard_info--company--icon"
  }), /*#__PURE__*/react.createElement("span", null, company)))), /*#__PURE__*/react.createElement("div", {
    className: "mx_BusinessCard_tag"
  }, tags.map(tag => {
    return /*#__PURE__*/react.createElement("p", {
      key: tag.id
    }, tag.industry);
  }), cardIndustries.length > 2 ? /*#__PURE__*/react.createElement("p", {
    className: "mx_BusinessCard_tag_more"
  }, "...") : null))));
};
/* harmony default export */ const SeaUserProfile_UserInfo = (UserInfo);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/WalletStore.ts
var WalletStore = __webpack_require__(644764);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/OpenseaStore.ts
var OpenseaStore = __webpack_require__(683043);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/lib/util.ts
var util = __webpack_require__(25654);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/structures/FilePanel.tsx
var FilePanel = __webpack_require__(617691);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/languageHandler.tsx
var languageHandler = __webpack_require__(867614);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/local-echo/EchoChamber.ts + 5 modules
var EchoChamber = __webpack_require__(932955);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/RoomNotifs.js
var RoomNotifs = __webpack_require__(349340);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/elements/AccessibleButton.tsx
var AccessibleButton = __webpack_require__(805035);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/dialogs/ForwardDialog.tsx
var ForwardDialog = __webpack_require__(606510);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/utils/permalinks/Permalinks.ts
var Permalinks = __webpack_require__(954105);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/Modal.tsx + 1 modules
var Modal = __webpack_require__(241648);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/dialogs/ConfirmDeleteFriendDialog.tsx
var ConfirmDeleteFriendDialog = __webpack_require__(529015);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/contexts/MatrixClientContext.ts
var MatrixClientContext = __webpack_require__(311878);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/right_panel/userProfile/useUserProfileTabList.ts



const useUserProfileTabList = targetId => {
  const cli = (0,react.useContext)(MatrixClientContext/* default */.Z);
  const [groupLists, setGroupsState] = (0,react.useState)([]);
  const [squadLists, setSquadsState] = (0,react.useState)([]);
  const getRooms = () => {
    const allRooms = cli.getRooms();
    const userId = cli.getUserId();
    const childRooms = [];
    const squadsBoth = [];
    const roomsBoth = [];
    allRooms.forEach(item => {
      if (item.isDmRoom()) {
        return;
      }
      const isMeMember = item.getMember(userId);
      const isTargetMember = item.getMember(targetId);
      if (!isMeMember || isMeMember.membership !== "join" || !isTargetMember || isTargetMember.membership !== "join") {
        return;
      }
      if (item.hasSpaceParent()) {
        childRooms.push(item);
      }
      if (item.isSpaceRoom()) {
        squadsBoth.push({
          roomId: item.currentState.roomId,
          timeline: item.timeline,
          childRooms: item.getVisibleChildRooms().map(inner => ({
            roomId: inner.currentState.roomId,
            timeline: inner.timeline
          }))
        });
      }
      if (item.isGroup()) {
        roomsBoth.push({
          roomId: item.currentState.roomId,
          timeline: item.timeline
        });
      }
    });
    return {
      squadsBoth,
      roomsBoth
    };
  };
  const handleSort = ({
    roomsBoth,
    squadsBoth
  }) => {
    try {
      const myWorker = new Worker(URL.createObjectURL(new Blob([`
                            self.onmessage = function(event) {
                                const postData = JSON.parse(event.data)
                                const { squadsBoth, roomsBoth, targetId } = postData || {};

                                if(!targetId) {
                                    self.postMessage({
                                        spaceRooms: [],
                                        groups: [],
                                    });
                                    return;
                                }

                                const group1 = []
                                const group2 = []

                                roomsBoth.forEach((element) => {
                                    const msgEventLines =  element.timeline.filter(item => {
                                        const currentItem = 'decrypted' in item ? item.decrypted : item;

                                        const isMessage = currentItem.type === 'm.room.message';

                                        return isMessage;
                                    });

                                    const ghostTimeline = msgEventLines.filter(item => {
                                        const currentItem = 'decrypted' in item ? item.decrypted : item;

                                        const isSender = currentItem?.sender === (targetId);
                                        return isSender;
                                    });

                                    if(Boolean(ghostTimeline.length)) {
                                        const lastItem = ghostTimeline[ghostTimeline.length - 1];
                                        let timestamp = 0;
                                        if(lastItem) {
                                            timestamp = 'decrypted' in lastItem ? lastItem?.decrypted?.origin_server_ts : lastItem?.origin_server_ts;
                                        }

                                        group1.push({
                                            ...element,
                                            timeline: ghostTimeline,
                                            timestamp,
                                        })
                                    } else {
                                        const lastItem = msgEventLines[msgEventLines.length - 1];
                                        let timestamp = 0;
                                        if(lastItem) {
                                            timestamp = 'decrypted' in lastItem ? lastItem?.decrypted?.origin_server_ts : lastItem?.origin_server_ts;
                                        }

                                        group2.push({
                                            ...element,
                                            timeline: msgEventLines,
                                            timestamp,
                                        })
                                    };
                                });

                                group1.sort((a, b) => b.timestamp - a.timestamp);
                                group2.sort((a, b) => b.timestamp - a.timestamp);

                                const groupResult = [...group1, ...group2]

                                // console.log('groupResult', groupResult)

                                const squadResult = squadsBoth.map((element) => {
                                    const ghostTimeline = element.childRooms.flatMap(innerRooms => {
                                        const innerResult = innerRooms.timeline.filter(childItem => {
                                            const currentItem = 'decrypted' in childItem ? childItem.decrypted : childItem;

                                            const isSender = currentItem?.sender === (targetId);
                                            const isMessage = currentItem?.type === 'm.room.message';
                                            return isSender && isMessage;
                                        });

                                        const lastItem = innerResult[innerResult.length - 1];
                                        let timestamp = 0;
                                        // let room_id = element.roomId
                                        let room_id = ''

                                        if(lastItem) {
                                            timestamp = 'decrypted' in lastItem ? lastItem?.decrypted?.origin_server_ts : lastItem?.origin_server_ts;
                                            room_id = 'decrypted' in lastItem ? lastItem?.decrypted?.room_id : lastItem?.room_id;
                                        }

                                        return {
                                            timeline: innerResult,
                                            timestamp,
                                            room_id,
                                        }

                                    }).sort((a, b) => b.timestamp - a.timestamp);

                                    return {
                                        ...element,
                                        channelId: ghostTimeline[0]?.room_id,
                                        timeline: ghostTimeline[0],
                                        timestamp: ghostTimeline[0]?.timestamp

                                    }
                                }).sort((a, b) => b.timestamp - a.timestamp);

                                const result = {
                                    spaceRooms: squadResult,
                                    groups: groupResult,
                                };

                                self.postMessage(result);
                            };`], {
        type: "application/javascript"
      })));
      myWorker.postMessage(JSON.stringify({
        squadsBoth,
        roomsBoth,
        targetId
      }));
      myWorker.onmessage = function (event) {
        const {
          spaceRooms = [],
          groups = []
        } = event.data || {};
        console.log("from child thread :", {
          spaceRooms,
          groups
        });
        setGroupsState(groups.map(item => cli.getRoom(item.roomId)));
        setSquadsState(spaceRooms.map(item => ({
          room: cli.getRoom(item.roomId),
          channel: cli.getRoom(item.channelId)
        })));
      };
      myWorker.onerror = function (err) {
        console.log(err, "-----worker");
      };
    } catch (error) {
      console.log("error", error);
    }
  };
  (0,react.useEffect)(() => {
    const {
      squadsBoth,
      roomsBoth
    } = getRooms();
    handleSort({
      roomsBoth,
      squadsBoth
    });
  }, [targetId]);
  return {
    groupLists,
    squadLists
  };
};
/* harmony default export */ const userProfile_useUserProfileTabList = (useUserProfileTabList);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/LeftPanelStore.ts
var LeftPanelStore = __webpack_require__(290884);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/right_panel/UserInfo.tsx + 4 modules
var right_panel_UserInfo = __webpack_require__(931363);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/SpaceStore.tsx + 2 modules
var SpaceStore = __webpack_require__(387579);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/context_menus/IconizedContextMenu.tsx
var IconizedContextMenu = __webpack_require__(882385);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/avatars/RoomAvatar.tsx
var RoomAvatar = __webpack_require__(139319);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/elements/RoomName.tsx
var RoomName = __webpack_require__(75865);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/res/img/empty-cover/empty-data.svg
var empty_data = __webpack_require__(211856);
var empty_data_default = /*#__PURE__*/__webpack_require__.n(empty_data);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/right_panel/SeaUserProfile/RoomList.tsx









class RoomList extends react.Component {
  constructor(props) {
    super(props);
    (0,defineProperty/* default */.Z)(this, "onTileClick", room => {
      dispatcher/* default */.ZP.dispatch({
        action: "view_room",
        show_room_tile: true,
        // make sure the room is visible in the list
        room_id: room.roomId
      });
    });
    (0,defineProperty/* default */.Z)(this, "onSpaceClick", space => {
      SpaceStore/* default */.ZP.instance.setActiveSpace(space);
    });
  }
  render() {
    const {
      roomType,
      rooms
    } = this.props;
    if (rooms.length === 0) return /*#__PURE__*/react.createElement(dist.SdEmpty, {
      image: /*#__PURE__*/react.createElement("img", {
        src: (empty_data_default()),
        alt: ""
      }),
      description: (0,languageHandler._t)("No data available.")
    });
    return /*#__PURE__*/react.createElement("div", {
      className: "mx_UserProfile_RoomContainer"
    }, roomType === "group" ? /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("div", {
      className: "mx_UserProfile_RoomContainer_title"
    }, "Mutual Groups"), rooms.map(room => {
      return /*#__PURE__*/react.createElement("div", {
        className: "mx_UserProfile_RoomItem",
        onClick: () => this.onTileClick(room)
      }, /*#__PURE__*/react.createElement(RoomAvatar/* default */.Z, {
        room: room,
        size: "middle"
      }), /*#__PURE__*/react.createElement("div", {
        className: "mx_UserProfile_RoomItem_name"
      }, /*#__PURE__*/react.createElement(RoomName/* default */.Z, {
        room: room
      })));
    })) : /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("div", {
      className: "mx_UserProfile_RoomContainer_title"
    }, "Mutual Squads"), rooms.map(item => {
      const {
        room,
        channel
      } = item;
      return /*#__PURE__*/react.createElement("div", {
        className: "mx_UserProfile_RoomItem",
        onClick: () => this.onSpaceClick(room)
      }, /*#__PURE__*/react.createElement(RoomAvatar/* default */.Z, {
        room: room,
        size: "middle"
      }), /*#__PURE__*/react.createElement("div", {
        className: "mx_UserProfile_RoomItem_name"
      }, /*#__PURE__*/react.createElement(RoomName/* default */.Z, {
        room: room
      }), /*#__PURE__*/react.createElement("span", null, channel === null || channel === void 0 ? void 0 : channel.name)));
    })));
  }
}
/* harmony default export */ const SeaUserProfile_RoomList = ((/* unused pure expression or super */ null && (RoomList)));
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/rooms/EventTile.tsx + 7 modules
var EventTile = __webpack_require__(585340);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/utils/strings.ts
var strings = __webpack_require__(653848);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/right_panel/SeaUserProfile/SeaUserProfile.tsx

function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0,defineProperty/* default */.Z)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }





































var ProfileScene = /*#__PURE__*/function (ProfileScene) {
  ProfileScene["UserInfo"] = "user_info";
  ProfileScene["Media"] = "media";
  ProfileScene["File"] = "file";
  ProfileScene["Group"] = "group";
  ProfileScene["Squad"] = "squad";
  return ProfileScene;
}(ProfileScene || {});
const iconStyle = {
  width: "24px",
  height: "24px",
  borderRadius: "50%"
};
const toNumber = v => {
  if (!v) {
    return 0;
  }
  return +v.replace(/,/g, "");
};
const ContactRelation = ({
  data,
  member
}) => {
  var _member$events, _member$events$member, _data$data, _data$data$username, _data$data2, _ref, _data$data$avatar_url, _data$data3, _data$data5;
  const content = member === null || member === void 0 ? void 0 : (_member$events = member.events) === null || _member$events === void 0 ? void 0 : (_member$events$member = _member$events.member) === null || _member$events$member === void 0 ? void 0 : _member$events$member.getContent();
  const [teleName, setTeleName] = (0,react.useState)(data === null || data === void 0 ? void 0 : (_data$data = data.data) === null || _data$data === void 0 ? void 0 : _data$data.telegrame_userName);
  const sdnName = (_data$data$username = data === null || data === void 0 ? void 0 : (_data$data2 = data.data) === null || _data$data2 === void 0 ? void 0 : _data$data2.username) !== null && _data$data$username !== void 0 ? _data$data$username : content === null || content === void 0 ? void 0 : content.displayname;
  const avatarUrl = (_ref = (_data$data$avatar_url = data === null || data === void 0 ? void 0 : (_data$data3 = data.data) === null || _data$data3 === void 0 ? void 0 : _data$data3.avatar_url) !== null && _data$data$avatar_url !== void 0 ? _data$data$avatar_url : content === null || content === void 0 ? void 0 : content.avatar_url) !== null && _ref !== void 0 ? _ref : __webpack_require__(178327);
  const [loading, setLoading] = (0,react.useState)(false);
  (0,react.useEffect)(() => {
    var _data$data4;
    if (!(data !== null && data !== void 0 && (_data$data4 = data.data) !== null && _data$data4 !== void 0 && _data$data4.user_id) && member !== null && member !== void 0 && member.userId) {
      const cli = MatrixClientPeg/* MatrixClientPeg */.p.get();
      setLoading(true);
      cli.checkTelegramStatus(member.userId).then(res => {
        if (res !== null && res !== void 0 && res.username) {
          var _res$username;
          setTeleName((_res$username = res.username) !== null && _res$username !== void 0 ? _res$username : res.telegram_id);
        }
      }).finally(() => {
        setLoading(false);
      });
    }
  }, [data === null || data === void 0 ? void 0 : (_data$data5 = data.data) === null || _data$data5 === void 0 ? void 0 : _data$data5.user_id, member === null || member === void 0 ? void 0 : member.userId]);
  if (loading) {
    return /*#__PURE__*/react.createElement("div", {
      className: "mx_UserProfile_Relation_wrap_skeleton"
    }, /*#__PURE__*/react.createElement(dist.SdSkeleton.SimpleList, {
      cols: 1,
      rows: 1,
      active: true
    }));
  }
  if (teleName) {
    return /*#__PURE__*/react.createElement("div", {
      className: "mx_UserProfile_Relation_wrap"
    }, /*#__PURE__*/react.createElement("div", {
      className: "mx_UserProfile_Relation_twitter"
    }, /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement("img", {
      src: avatarUrl
    }), /*#__PURE__*/react.createElement("div", {
      className: "mx_UserProfile_Relation_Social_icon"
    })), /*#__PURE__*/react.createElement("div", {
      className: "mx_UserProfile_Relation_desc"
    }, /*#__PURE__*/react.createElement("span", {
      className: "mx_UserProfile_Relation_title"
    }, sdnName), /*#__PURE__*/react.createElement("span", null, teleName))));
  }
  return null;
};
const SeaUserProfile = props => {
  var _RemarkStore$get$getR, _props$room, _props$recommendation, _props$recommendation2, _props$recommendation3, _props$recommendation4, _props$room3;
  const {
    outerWalletAddress,
    userId,
    room,
    user,
    dmRoom
  } = props;
  // if (props.showAssetMore) {
  //     return <Spinner />;
  // }
  const {
    joined,
    type
  } = props.recommendation || {};
  const simpleInfo = !joined && type === "transaction";
  const headerRef = (0,react.useRef)();
  const contentRef = (0,react.useRef)();
  const [displayName, setDisplayName] = (0,react.useState)(null);
  const [profile, setProfile] = (0,react.useState)({
    walletAddress: (user === null || user === void 0 ? void 0 : user.getWalletAddress()) || ""
  });
  const [avatarUrl, setAvatarUrl] = (0,react.useState)(null);
  const [currentNft, setCurrentNft] = (0,react.useState)();
  const [remarkName, setRemarkName] = (0,react.useState)((_RemarkStore$get$getR = browser_index/* RemarkStore */.Tq.get().getRemarkMap()[userId]) === null || _RemarkStore$get$getR === void 0 ? void 0 : _RemarkStore$get$getR.name);
  const [userShip, setUserShip] = (0,react.useState)([_types_user/* UserShip */.J.Stranger]);
  const [position, setPosition] = (0,react.useState)(null);
  const [walletList, setWalletList] = (0,react.useState)([]);
  const [assetsTags, setAssetsTags] = (0,react.useState)();
  const [asset, setAsset] = (0,react.useState)();
  const [nfts, setNfts] = (0,react.useState)();
  const [poaps, setPoaps] = (0,react.useState)();
  const [options, setOptions] = (0,react.useState)([]);
  const [isMute, setVolume] = (0,react.useState)(false);
  const [diff, setDiff] = (0,react.useState)({
    netWorth: {
      limit: 0,
      rate: 0
    },
    tokenWorth: {
      limit: 0,
      rate: 0
    },
    nftWorth: {
      limit: 0,
      rate: 0
    }
  });
  const [multiAddress, setMultiAddress] = (0,react.useState)("");
  const [beIgnore, setBeIgnore] = (0,react.useState)(false);
  const [friendRequestOpt, setFriendRequestOpt] = (0,react.useState)({
    friendRequestItem: null,
    state: 0,
    self: false
  });
  const [footer, setFooter] = (0,react.useState)();
  const [isIgnored, setIsIgnored] = (0,react.useState)(MatrixClientPeg/* MatrixClientPeg */.p.get().getIgnoredUsers().includes(userId));
  // const [isCollapse, setIsCollapse] = useState(false);
  const {
    groupLists,
    squadLists
  } = userProfile_useUserProfileTabList(userId);
  const ens = user === null || user === void 0 ? void 0 : user.ens;
  const member = props.recommendation ? null : (_props$room = props.room) === null || _props$room === void 0 ? void 0 : _props$room.getMember(userId);
  const rawDisplayName = ((_props$recommendation = props.recommendation) === null || _props$recommendation === void 0 ? void 0 : (_props$recommendation2 = _props$recommendation.data) === null || _props$recommendation2 === void 0 ? void 0 : _props$recommendation2.display_name) || (user === null || user === void 0 ? void 0 : user.rawDisplayName) || displayName;
  let avatar = (0,react.useMemo)(() => {
    let avatarUrl;
    const mxcAvatarUrl = member === null || member === void 0 ? void 0 : member.getMxcAvatarUrl();
    if (mxcAvatarUrl) {
      try {
        const media = (0,Media/* mediaFromMxc */.TS)(mxcAvatarUrl);
        avatarUrl = media.srcHttp;
      } catch (error) {
        console.error(error);
      }
    } else {
      try {
        if (user !== null && user !== void 0 && user.avatarUrl) {
          const media = (0,Media/* mediaFromMxc */.TS)(user === null || user === void 0 ? void 0 : user.avatarUrl);
          avatarUrl = media.srcHttp;
        }
      } catch (error) {
        console.error(error);
      }
    }
    return avatarUrl;
  }, [props === null || props === void 0 ? void 0 : props.size, props === null || props === void 0 ? void 0 : props.resizeMethod, props === null || props === void 0 ? void 0 : props.size, user === null || user === void 0 ? void 0 : user.avatarUrl, member]);
  (0,react.useEffect)(() => {
    var _RemarkStore$get$getR2;
    const friendRequestList = ContactStore["default"].instance.friendRequestList;
    let state, self, friendRequestItem;
    for (let i = 0; i < friendRequestList.length; i++) {
      if (friendRequestList[i].contact_id === userId) {
        friendRequestItem = _objectSpread({}, friendRequestList[i]);
        state = friendRequestList[i].state;
        self = friendRequestList[i].self;
      }
    }
    setFriendRequestOpt({
      friendRequestItem,
      state,
      self
    });
    setRemarkName((_RemarkStore$get$getR2 = browser_index/* RemarkStore */.Tq.get().getRemarkMap()[userId]) === null || _RemarkStore$get$getR2 === void 0 ? void 0 : _RemarkStore$get$getR2.name);
  }, [userId]);
  (0,react.useEffect)(() => {
    let unmount = false;
    if (!profile.walletAddress || !(user !== null && user !== void 0 && user.signature)) {
      MatrixClientPeg/* MatrixClientPeg */.p.get().getProfileInfo(userId).then(res => {
        !unmount && setProfile({
          walletAddress: res.wallet_address
        });
        user === null || user === void 0 ? void 0 : user.setWalletAddress(res.wallet_address);
        setAvatarUrl(res.avatar_url);
        setDisplayName(res.displayname);
        if (res.nft_avatar) {
          setCurrentNft(res.nft_avatar);
        }
        if (res.signature) {
          user.setSignature(res.signature);
        }
      });
    }
    if (userId) {
      const client = MatrixClientPeg/* MatrixClientPeg */.p.get();
      client.getUserAssetsTags(userId).then(res => {
        setAssetsTags(res || []);
      });
    }
    return () => {
      unmount = true;
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [userId]);
  (0,react.useEffect)(() => {
    const initEvent = async () => {
      const userShip = ContactStore["default"].instance.getUserShip(userId);
      setUserShip(userShip);
    };
    ContactStore["default"].instance.on(ContactStore/* FRIEND_UPDATE_EVENT */.rG, initEvent);
    initEvent();
    return () => {
      ContactStore["default"].instance.off(ContactStore/* CONTACT_UPDATE_EVENT */.RX, initEvent);
      ContactStore["default"].instance.off(ContactStore/* FRIEND_UPDATE_EVENT */.rG, initEvent);
    };
  }, [userId]);
  (0,react.useEffect)(() => {
    const getMultiWallets = async () => {
      try {
        const walletListResult = await WalletStore/* default */.ZP.instance.getWalletList(userId);
        setWalletList((walletListResult === null || walletListResult === void 0 ? void 0 : walletListResult.data) || []);
      } catch (error) {
        setWalletList([]);
      }
    };
    getMultiWallets();
    setAvatarUrl(null);
  }, [userId]);
  (0,react.useEffect)(() => {
    let unmount = false;
    const getOpenseaNFTs = async address => {
      try {
        var _assetsOfOwner$value, _assetsOfOwner$value$, _nfts$value;
        const [assetsOfOwner, nfts] = await Promise.allSettled([OpenseaStore/* default */.Z.instance.getAssetsByOwner(address), OpenseaStore/* default */.Z.instance.getNftsByOwner(address)]);
        if (assetsOfOwner.status === "fulfilled" && (_assetsOfOwner$value = assetsOfOwner.value) !== null && _assetsOfOwner$value !== void 0 && (_assetsOfOwner$value$ = _assetsOfOwner$value.assets) !== null && _assetsOfOwner$value$ !== void 0 && _assetsOfOwner$value$[0] && !unmount) {
          const [current, prev] = assetsOfOwner.value.assets;
          setAsset(current);
          if (prev) {
            setDiff(diff => {
              diff.netWorth.limit = toNumber(prev.net_worth) - toNumber(current.net_worth);
              diff.netWorth.rate = diff.netWorth.limit / toNumber(current.net_worth) * 100;
              diff.nftWorth.limit = toNumber(prev.metrics.est_holding_value_usd) - toNumber(current.metrics.est_holding_value_usd);
              diff.nftWorth.rate = diff.netWorth.limit / toNumber(current.metrics.est_holding_value_usd) * 100;
              diff.tokenWorth.limit = toNumber(prev.tokens_worth) - toNumber(current.tokens_worth);
              diff.tokenWorth.rate = diff.tokenWorth.limit / toNumber(current.tokens_worth) * 100;
              return _objectSpread({}, diff);
            });
          }
        }
        if (nfts.status === "fulfilled" && (_nfts$value = nfts.value) !== null && _nfts$value !== void 0 && _nfts$value.nfts && !unmount) {
          // eslint-disable-next-line @typescript-eslint/naming-convention, camelcase
          setNfts(nfts.value.nfts);
        }
      } catch (error) {
        console.error(error);
        setAsset(null);
      }
    };
    if (profile.walletAddress) {
      getOpenseaNFTs(profile.walletAddress);
    }
    return () => {
      unmount = true;
    };
  }, [userId, profile.walletAddress]);

  // get poaps list
  (0,react.useEffect)(() => {
    const getPoApsList = async () => {
      const client = MatrixClientPeg/* MatrixClientPeg */.p.get();
      client.getPoAps(profile.walletAddress).then(res => {
        const poap_list = res.poap_list;
        setPoaps(poap_list);
      });
    };
    if (profile.walletAddress) {
      getPoApsList();
    }
  }, [userId, profile.walletAddress]);

  // get beignorelist
  (0,react.useEffect)(() => {
    const client = MatrixClientPeg/* MatrixClientPeg */.p.get();
    client.getBeIgnoreList({
      [userId]: ""
    }).then(res => {
      if (res !== null && res !== void 0 && res[userId]) {
        const beIgnore = res[userId];
        setBeIgnore(beIgnore);
      } else {
        setBeIgnore(false);
      }
    }).catch(err => {
      setBeIgnore(false);
    });
  }, []);
  (0,react.useEffect)(() => {
    const address = options.filter(item => item.checked).map(item => item.value).join(",") || "";
    setMultiAddress(address);
  }, [options]);
  (0,react.useEffect)(() => {
    const displayname = localStorage.getItem("mx_profile_displayname") || "";
    const localWalletAddress = localStorage.getItem("mx_profile_wallet_address") || "";
    const setDefaultCheck = currentWalletAddress => {
      if (!outerWalletAddress) return true;
      return outerWalletAddress === currentWalletAddress;
    };
    const options = [{
      checked: setDefaultCheck(localWalletAddress),
      value: localWalletAddress,
      id: localWalletAddress,
      type: "owner",
      label: /*#__PURE__*/react.createElement("div", {
        className: "item_label"
      }, /*#__PURE__*/react.createElement("img", {
        style: iconStyle,
        src: avatar
      }), /*#__PURE__*/react.createElement("div", {
        className: "mx_item_label_wallet_info"
      }, /*#__PURE__*/react.createElement("div", null, displayname), /*#__PURE__*/react.createElement("div", null, (0,util/* shortStr */.lS)(localWalletAddress))))
    }, ...walletList.map(item => ({
      checked: setDefaultCheck(item.wallet_address),
      value: item.wallet_address,
      id: item.wallet_address,
      type: item.verify_source,
      label: /*#__PURE__*/react.createElement("div", {
        className: "item_label"
      }, /*#__PURE__*/react.createElement("img", {
        style: iconStyle,
        src: item === null || item === void 0 ? void 0 : item.verify_source_logo
      }), /*#__PURE__*/react.createElement("div", {
        className: "mx_item_label_wallet_info"
      }, /*#__PURE__*/react.createElement("div", null, item.wallet_name), /*#__PURE__*/react.createElement("div", null, (0,util/* shortStr */.lS)(item.wallet_address))))
    }))];
    setOptions(options);
  }, [walletList, outerWalletAddress]);
  (0,react.useEffect)(() => {
    if (props.showAssetMore && asset) {
      const client = MatrixClientPeg/* MatrixClientPeg */.p.get();
      profile.walletAddress = client.getUser(client.getUserId()).getWalletAddress();
      showAssetMore();
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [props.showAssetMore, asset]);
  const roomProps = (0,react.useMemo)(() => {
    if (props.dmRoom && props.room === props.dmRoom) {
      return EchoChamber/* EchoChamber */.P.forRoom(props.room);
    }
    return null;
  }, [props.dmRoom]);
  (0,react.useEffect)(() => {
    if (props.dmRoom && props.room === props.dmRoom) {
      const isMute = (roomProps === null || roomProps === void 0 ? void 0 : roomProps.notificationVolume) === RoomNotifs/* MUTE */.Q2;
      setVolume(isMute);
    }
  }, [props.dmRoom]);

  // init profile footer
  (0,react.useEffect)(() => {
    var _props$room2;
    let footer = null;
    if (props.showFooter && userId !== ((_props$room2 = props.room) === null || _props$room2 === void 0 ? void 0 : _props$room2.myUserId)) {
      if (friendRequestOpt && friendRequestOpt.state === ContactStore/* FriendRequestState */.Rj.RequestSent && !friendRequestOpt.self) {
        footer = /*#__PURE__*/react.createElement("div", {
          className: "mx_profile_footer_buttons"
        }, /*#__PURE__*/react.createElement(AccessibleButton/* default */.Z, {
          kind: "secondary",
          onClick: handleFriendsReject
        }, (0,languageHandler._t)("Reject")), /*#__PURE__*/react.createElement(AccessibleButton/* default */.Z, {
          kind: "primary",
          onClick: handleFriendsAccept
        }, (0,languageHandler._t)("Accept")));
      } else if (userShip.includes(_types_user/* UserShip */.J.Stranger)) {
        footer = /*#__PURE__*/react.createElement(react.Fragment, null, !beIgnore ? /*#__PURE__*/react.createElement("div", {
          className: "mx_profile_footer_buttons"
        }, /*#__PURE__*/react.createElement("div", {
          className: "mx_profile_footer_ignore",
          onClick: onIgnoreToggle
        }, /*#__PURE__*/react.createElement("p", {
          className: "mx_RoomTile_iconIgnore"
        }), /*#__PURE__*/react.createElement("p", null, isIgnored ? (0,languageHandler._t)("Unblock") : (0,languageHandler._t)("Block"))), /*#__PURE__*/react.createElement(AccessibleButton/* default */.Z, {
          disabled: friendRequestOpt.state === ContactStore/* FriendRequestState */.Rj.RequestSent,
          kind: friendRequestOpt.state === ContactStore/* FriendRequestState */.Rj.RequestSent ? "secondary" : "primary",
          onClick: addFriend
        }, (0,languageHandler._t)("Friend request"))) : /*#__PURE__*/react.createElement("div", {
          className: "mx_profile_footer_buttons"
        }, /*#__PURE__*/react.createElement(AccessibleButton/* default */.Z, {
          disabled: true,
          kind: "secondary",
          onClick: null
        }, (0,languageHandler._t)("Decline Request"))));
      } else if (userShip.includes(_types_user/* UserShip */.J.Colleague) && !userShip.includes(_types_user/* UserShip */.J.Friend)) {
        footer = /*#__PURE__*/react.createElement(react.Fragment, null, !beIgnore ? /*#__PURE__*/react.createElement("div", {
          className: "mx_profile_footer_buttons"
        }, /*#__PURE__*/react.createElement(AccessibleButton/* default */.Z, {
          disabled: friendRequestOpt.state === ContactStore/* FriendRequestState */.Rj.RequestSent,
          kind: friendRequestOpt.state === ContactStore/* FriendRequestState */.Rj.RequestSent ? "secondary" : "primary",
          onClick: addFriend
        }, (0,languageHandler._t)("Friend request"))) : null);
      }
    }
    setFooter(footer);
  }, [userShip, beIgnore, isIgnored, friendRequestOpt.state]);
  const handleFriendsReject = () => {
    const requestItem = friendRequestOpt.friendRequestItem;
    if (!(requestItem !== null && requestItem !== void 0 && requestItem.id)) return;
    MatrixClientPeg/* MatrixClientPeg */.p.get().rejectFriendsRequest(requestItem.id).then(res => {
      if (!res.ok) {
        dist.SdMessage.error(res.reason);
      } else {
        dist.SdMessage.success("Rejected");
        requestItem.state = ContactStore/* FriendRequestState */.Rj.Rejected;
        friendRequestOpt.state = ContactStore/* FriendRequestState */.Rj.Rejected;
        ContactStore["default"].instance.updateFriendRequest({
          [requestItem.contact_id]: requestItem
        });
        setFriendRequestOpt(_objectSpread({}, friendRequestOpt));
      }
    });
  };
  const handleFriendsAccept = () => {
    const requestItem = friendRequestOpt.friendRequestItem;
    if (!(requestItem !== null && requestItem !== void 0 && requestItem.id)) return;
    MatrixClientPeg/* MatrixClientPeg */.p.get().acceptFriendsRequest(requestItem.id).then(res => {
      if (!res.ok) {
        dist.SdMessage.error(res.reason);
      } else {
        dist.SdMessage.success("Accepted");
        setFriendRequestOpt(prev => _objectSpread(_objectSpread({}, prev), {}, {
          friendRequestItem: _objectSpread(_objectSpread({}, prev.friendRequestItem), {}, {
            state: ContactStore/* FriendRequestState */.Rj.Approved
          }),
          state: ContactStore/* FriendRequestState */.Rj.Approved
        }));
        requestItem.state = ContactStore/* FriendRequestState */.Rj.Approved;
        friendRequestOpt.state = ContactStore/* FriendRequestState */.Rj.Approved;
        ContactStore["default"].instance.updateFriendList({
          action: ContactStore/* UpdateFriendsAction */.uM.ADD,
          data: [{
            userId: requestItem.contact_id,
            displayName: requestItem.displayname,
            avatarUrl: requestItem.avatar_url,
            walletAddress: requestItem.displayname
          }]
        });
        ContactStore["default"].instance.updateFriendRequest({
          [requestItem.contact_id]: requestItem
        });
      }
    });
  };
  const onIgnoreToggle = () => {
    const cli = MatrixClientPeg/* MatrixClientPeg */.p.get();
    const ignoredUsers = cli.getIgnoredUsers();
    if (isIgnored) {
      const index = ignoredUsers.indexOf(userId);
      if (index !== -1) ignoredUsers.splice(index, 1);
    } else {
      ignoredUsers.push(userId);
    }
    setIsIgnored(!isIgnored);
    cli.setIgnoredUsers(ignoredUsers);
  };
  const removeFriend = async () => {
    setPosition(null);
    if (userId) {
      Modal/* default */.Z.createTrackedDialog("", "", ConfirmDeleteFriendDialog/* default */.Z, {
        userId: userId,
        walletAddress: profile.walletAddress,
        name: member === null || member === void 0 ? void 0 : member.name
      });
    }
  };
  const addFriend = () => {
    dispatcher/* default */.ZP.dispatch({
      action: "view_add_friend_apply",
      applyFriendsInfo: {
        userId: userId,
        room: props.room
      }
    });
  };
  const onShareUserLink = () => {
    var _creds;
    setPosition(null);
    (0,ForwardDialog/* showForwardDialogWithContent */.H2)({
      msgtype: userId === MatrixClientPeg/* MatrixClientPeg */.p.get().getUserId() ? "me" : "user",
      body: (0,Permalinks/* shareUserPermalink */.G3)(userId)
    }, "share");
    let creds;
    try {
      creds = JSON.parse(localStorage.getItem("mx_Homeserver_Creds"));
    } catch {}
    const avatar = member.getMxcAvatarUrl();
    MatrixClientPeg/* MatrixClientPeg */.p.get().updateSdnUserToSdm({
      user_id: member.userId,
      display_name: member.rawDisplayName,
      wallet_address: member.walletAddress,
      avatar: avatar ? `${avatar}?access_token=${(_creds = creds) === null || _creds === void 0 ? void 0 : _creds.accessToken}` : "",
      ens: !!member.ens,
      source: "web"
    });
  };
  const onMessage = async () => {
    const client = MatrixClientPeg/* MatrixClientPeg */.p.get();
    const dmRooms = client.getDmRoomByUserId(userId);
    const lastRoom = dmRooms[dmRooms.length - 1];
    if (lastRoom) {
      dispatcher/* default */.ZP.dispatch({
        action: "view_room",
        room_id: lastRoom.roomId,
        should_peek: false,
        joining: false
      });
      LeftPanelStore/* default */.ZP.instance.updateSelected(LeftPanelStore/* HOME_TAB */.e9, true);
      dispatcher/* default */.ZP.dispatch({
        action: actions/* Action */.a.ShowRoomPanel
      });
    } else {
      var _room$getParentRoom;
      await (0,right_panel_UserInfo/* openDMForUser */.Oz)({
        userId,
        squadId: room !== null && room !== void 0 && room.isSpaceRoom() ? room.roomId : room !== null && room !== void 0 && room.hasSpaceParent() ? (_room$getParentRoom = room.getParentRoom()) === null || _room$getParentRoom === void 0 ? void 0 : _room$getParentRoom.roomId : "",
        isJump: true,
        showRoomTile: false,
        directMessage: true
      });
      if (userShip.includes(_types_user/* UserShip */.J.Colleague)) {
        SpaceStore/* default */.ZP.instance.setActiveSpace(null);
        setTimeout(() => {
          LeftPanelStore/* default */.ZP.instance.updateSelected(LeftPanelStore/* WORK_HOME_TAB */.Jv);
        }, 200);
      }
    }
  };
  const onUserProfileAvatar = () => {
    if (currentNft) {
      const nft = currentNft;
      dispatcher/* default */.ZP.dispatch({
        action: actions/* Action */.a.SetRightPanelPhase,
        phase: RightPanelStorePhases/* RightPanelPhases */.q4.IframeWidget,
        refireParams: {
          params: {
            src: `${constants/* FAV_HOST_URL */.AU}/nft/${nft.contract_address}/${nft.token_id}`,
            title: "NFT Profile"
          }
        }
      });
    }
  };
  const showAssetMore = () => {
    dispatcher/* default */.ZP.dispatch({
      action: actions/* Action */.a.SetRightPanelPhase,
      phase: RightPanelStorePhases/* RightPanelPhases */.q4.AssetsMore,
      refireParams: {
        member: user,
        params: _objectSpread(_objectSpread({}, asset), {}, {
          walletAddress: props.showOtherAssetMore ? user.walletAddress : profile.walletAddress,
          assetDefaultTab: props === null || props === void 0 ? void 0 : props.assetDefaultTab,
          network: props === null || props === void 0 ? void 0 : props.network,
          options: props.showOtherAssetMore ? [] : options,
          multiAddress: props.showOtherAssetMore ? user.walletAddress : multiAddress,
          userId
        })
      }
    });
  };
  const onRemarkNameSubmit = remarkName => {
    // done firebase : contact_edit_remark_name
    (0,firebase_analytics/* logEvent */.K)(firebase_analytics/* analytics */.c, "contact_edit_remark_name", _objectSpread(_objectSpread({}, (0,commonPointParams/* getCommonPointParams */.I)()), {}, {
      contact_id: userId,
      remark_name: remarkName
    }));
    return browser_index/* RemarkStore */.Tq.get().setUserRemarkMap(userId, {
      name: remarkName
    }).then(() => {
      // done firebase : contact_edit_remark_name_success
      (0,firebase_analytics/* logEvent */.K)(firebase_analytics/* analytics */.c, "contact_edit_remark_name_success", _objectSpread(_objectSpread({}, (0,commonPointParams/* getCommonPointParams */.I)()), {}, {
        contact_id: userId,
        remark_name: remarkName
      }));
      setRemarkName(remarkName);
    }, err => {
      // done firebase : contact_edit_remark_name_failed
      (0,firebase_analytics/* logEvent */.K)(firebase_analytics/* analytics */.c, "contact_edit_remark_name_failed", _objectSpread(_objectSpread({}, (0,commonPointParams/* getCommonPointParams */.I)()), {}, {
        contact_id: userId,
        remark_name: remarkName,
        error_code: err.httpStatus || err.errcode || 0,
        error_reason: err.name || err.message || err.stack
      }));
    });
  };
  const onRoomInviteClick = room => {
    // TODO: move user limit in `showRoomInviteDialog` into here
    dispatcher/* defaultDispatcher */.ec.dispatch({
      action: "view_invite",
      roomId: room.roomId
    });
  };
  const onMuteClick = (roomProps, type) => {
    if (MatrixClientPeg/* MatrixClientPeg */.p.get().isGuest()) return;
    roomProps.notificationVolume = type;
  };
  const getPreviousPhase = () => {
    let previousPhase = null;
    if (props.room && !props.room.isDmRoom()) {
      // previousPhase = props.room?.hasSpaceParent()
      //     ? RightPanelPhases.RoomMemberList
      //     : RightPanelPhases.SpaceMemberList;
      previousPhase = RightPanelStorePhases/* RightPanelPhases */.q4.RoomSummary;
    }
    return previousPhase;
  };
  const handleTabsChange = () => {
    const headerHeight = headerRef.current.offsetHeight;
    contentRef.current.style.minHeight = headerRef.current.parentElement.offsetHeight + "px";
    headerRef.current.parentElement.scrollTo({
      behavior: "smooth",
      top: headerHeight + 15
    });
  };

  // const handleScroll = (event) => {
  //     console.log(event.currentTarget.scrollTop)
  //     if (event.currentTarget.scrollTop > 20) {
  //         contentRef.current.style.minHeight = headerRef.current.parentElement.parentElement.offsetHeight + "px";
  //         setIsCollapse(true)
  //     } else {
  //         contentRef.current.style.minHeight = "";
  //         setIsCollapse(false);
  //     }
  // }

  const handleEdit = () => {
    if (MatrixClientPeg/* MatrixClientPeg */.p.get().isGuest()) return;
    dispatcher/* defaultDispatcher */.ec.dispatch({
      action: actions/* Action */.a.SetRightPanelPhase,
      phase: RightPanelStorePhases/* RightPanelPhases */.q4.EditRemark,
      refireParams: {
        member
      }
    });
  };
  const handleNameCopy = async e => {
    e.preventDefault();
    const successful = await (0,strings/* copyPlaintext */.RO)(rawDisplayName);
    successful ? dist.SdMessage.success((0,languageHandler._t)("Copied to clipboard")) : dist.SdMessage.success((0,languageHandler._t)("Failed to copy"));
  };
  const handleAddressCopy = async e => {
    e.preventDefault();
    const successful = await (0,strings/* copyPlaintext */.RO)(profile.walletAddress);
    successful ? dist.SdMessage.success((0,languageHandler._t)("Copied to clipboard")) : dist.SdMessage.success((0,languageHandler._t)("Failed to copy"));
  };
  const contactRelation = userId === MatrixClientPeg/* MatrixClientPeg */.p.get().getUserId() || userShip.includes(_types_user/* UserShip */.J.Stranger) ? null : /*#__PURE__*/react.createElement(ContactRelation, {
    data: props.recommendation,
    member: member
  });
  const profileTabs = (0,react.useMemo)(() => {
    var _asset$assets;
    let tabs = [{
      key: ProfileScene.UserInfo,
      label: "User Info",
      children: /*#__PURE__*/react.createElement(SeaUserProfile_UserInfo, {
        userId: userId,
        contactRelation: contactRelation,
        feedNode: props.feedNode,
        user: user,
        assetsTags: assetsTags,
        tokens: asset === null || asset === void 0 ? void 0 : (_asset$assets = asset.assets) === null || _asset$assets === void 0 ? void 0 : _asset$assets.flatMap(({
          displayProps
        }) => displayProps.images),
        netWorth: (asset === null || asset === void 0 ? void 0 : asset.net_worth) && _objectSpread({
          value: asset.net_worth
        }, diff.netWorth),
        nftWorth: (asset === null || asset === void 0 ? void 0 : asset.metrics.est_holding_value_usd) && _objectSpread({
          value: asset.metrics.est_holding_value_usd
        }, diff.nftWorth),
        tokenWorth: (asset === null || asset === void 0 ? void 0 : asset.tokens_worth) && _objectSpread({
          value: asset.tokens_worth
        }, diff.tokenWorth),
        collectionsCount: asset === null || asset === void 0 ? void 0 : asset.metrics.collection_num,
        nftsCount: asset === null || asset === void 0 ? void 0 : asset.metrics.nft_num,
        poaps: (poaps || []).map(poap => {
          return {
            tokenId: poap.token_id,
            name: poap.event.name,
            imageUrl: poap.event.image_url,
            eventUrl: poap.event.event_url,
            startDate: poap.event.start_date
          };
        }),
        hasMoreAssets: userShip.includes(_types_user/* UserShip */.J.Friend) || userShip.includes(_types_user/* UserShip */.J.Colleague),
        onMoreAssets: showAssetMore
      })
    }];
    if (userShip.includes(_types_user/* UserShip */.J.Friend) || userShip.includes(_types_user/* UserShip */.J.Colleague)) {
      tabs.push(...[{
        key: ProfileScene.Media,
        label: "Media",
        children: /*#__PURE__*/react.createElement(FilePanel/* default */.Z, {
          roomId: dmRoom === null || dmRoom === void 0 ? void 0 : dmRoom.roomId,
          resizeNotifier: props.resizeNotifier,
          tileShape: EventTile/* TileShape */.GO.ImageGrid
        })
      }, {
        key: ProfileScene.File,
        label: "File",
        children: /*#__PURE__*/react.createElement(FilePanel/* default */.Z, {
          roomId: dmRoom === null || dmRoom === void 0 ? void 0 : dmRoom.roomId,
          resizeNotifier: props.resizeNotifier
        })
      }, {
        key: ProfileScene.Group,
        label: "Group",
        children: /*#__PURE__*/react.createElement(RoomList, {
          rooms: groupLists,
          roomType: "group"
        })
      }, {
        key: ProfileScene.Squad,
        label: "Squad",
        children: /*#__PURE__*/react.createElement(RoomList, {
          rooms: squadLists,
          roomType: "squad"
        })
      }]);
    }
    return tabs;
  }, [userShip, userId, groupLists, squadLists, dmRoom === null || dmRoom === void 0 ? void 0 : dmRoom.roomId]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(BaseCard/* default */.C, {
    className: classnames_default()({
      mx_UserProfile: true,
      "is-collapse": true
    }),
    onClose: props.onClose,
    header: /*#__PURE__*/react.createElement("span", {
      className: "mx_UserProfile_title"
    }, "User Info"),
    previousPhase: getPreviousPhase(),
    footer: footer
    // onScroll={handleScroll}
    ,
    onEdit: handleEdit
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_UserProfile_header",
    ref: headerRef
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_UserProfile_avatar_container"
  }, /*#__PURE__*/react.createElement(dist.SdAvatar, {
    src: ((_props$recommendation3 = props.recommendation) === null || _props$recommendation3 === void 0 ? void 0 : (_props$recommendation4 = _props$recommendation3.data) === null || _props$recommendation4 === void 0 ? void 0 : _props$recommendation4.avatar_url) || avatarUrl || avatar,
    name: (remarkName === null || remarkName === void 0 ? void 0 : remarkName.trim()) || (rawDisplayName === null || rawDisplayName === void 0 ? void 0 : rawDisplayName.trim()),
    id: userId,
    size: props.size
    // fontSize={210}
    ,
    className: "mx_UserProfile_avatar",
    onClick: onUserProfileAvatar
  }), /*#__PURE__*/react.createElement("div", {
    className: "mx_UserProfile_avatar_info"
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_UserProfile_note_name"
  }, remarkName ? remarkName : rawDisplayName), /*#__PURE__*/react.createElement("div", {
    className: "mx_UserProfile_info_expand"
  }, remarkName ? /*#__PURE__*/react.createElement("div", {
    className: classnames_default()({
      mx_UserProfile_info_expand_item: true,
      mx_UserProfile_user_name: true,
      mx_UserProfile_user_name_ens: ens
    })
  }, ens ? /*#__PURE__*/react.createElement(react_dist.Text, null, rawDisplayName) : /*#__PURE__*/react.createElement("span", null, rawDisplayName), /*#__PURE__*/react.createElement(dist.SdTooltip, {
    placement: "top",
    title: "Copy"
  }, /*#__PURE__*/react.createElement(dist.SdIcon, {
    icon: "CopyOutlines",
    onClick: handleNameCopy
  }))) : null, profile.walletAddress ? /*#__PURE__*/react.createElement("div", {
    className: "mx_UserProfile_info_expand_item mx_UserProfile_wallet_address"
  }, /*#__PURE__*/react.createElement("span", null, profile.walletAddress.substring(0, 6), "...", profile.walletAddress.substr(profile.walletAddress.length - 4)), /*#__PURE__*/react.createElement(dist.SdTooltip, {
    placement: "top",
    title: "Copy"
  }, /*#__PURE__*/react.createElement(dist.SdIcon, {
    icon: "CopyOutlines",
    onClick: handleAddressCopy
  }))) : null))), (userShip !== null && userShip !== void 0 && userShip.includes(_types_user/* UserShip */.J.Friend) || userShip !== null && userShip !== void 0 && userShip.includes(_types_user/* UserShip */.J.Colleague)) && userId !== ((_props$room3 = props.room) === null || _props$room3 === void 0 ? void 0 : _props$room3.myUserId) ? /*#__PURE__*/react.createElement("div", {
    className: "mx_UserProfile_button_group"
  }, props.room && props.room.isDmRoom() ? null : /*#__PURE__*/react.createElement(dist.SdButton, {
    type: "associate",
    icon: "MessageOutlined",
    size: "large",
    onClick: onMessage
  }, "Message"), props.dmRoom && props.room === props.dmRoom ? /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(dist.SdButton, {
    type: "associate",
    icon: "AdduserOutlines",
    size: "large",
    className: "mx_RoomSummaryCard_actionButton",
    onClick: () => onRoomInviteClick(props.room)
  }, (0,languageHandler._t)("Invite")), /*#__PURE__*/react.createElement(dist.SdButton, {
    type: "associate",
    icon: isMute ? "MuteOutlines" : "NoticeOutlines",
    size: "large",
    className: "mx_RoomSummaryCard_actionButton",
    onClick: () => {
      onMuteClick(roomProps, isMute ? RoomNotifs/* ALL_MESSAGES_LOUD */.ei : RoomNotifs/* MUTE */.Q2);
      setVolume(!isMute);
    }
  }, (0,languageHandler._t)(isMute ? "Off" : "On"))) : null, /*#__PURE__*/react.createElement(dist.SdButton, {
    type: "associate",
    icon: "MoreOutlines",
    size: "large",
    onClick: e => {
      const {
        left,
        top
      } = e.target.getBoundingClientRect();
      setPosition({
        left,
        top
      });
    }
  }, "More")) : null), /*#__PURE__*/react.createElement("div", {
    className: "mx_UserProfile_content",
    ref: contentRef
  }, /*#__PURE__*/react.createElement(dist.SdTabs, {
    defaultActiveKey: ProfileScene.UserInfo,
    items: profileTabs,
    animated: true,
    tabBarGutter: 0,
    onChange: handleTabsChange
  }))), position ? /*#__PURE__*/react.createElement(IconizedContextMenu/* default */.ZP, {
    left: position.left - 210,
    top: position.top,
    onFinished: () => setPosition(null),
    className: "mx_RoomTile_contextMenu"
  }, userShip.includes(_types_user/* UserShip */.J.Stranger) && !isIgnored ? null : /*#__PURE__*/react.createElement(IconizedContextMenu/* IconizedContextMenuOptionList */.I2, null, /*#__PURE__*/react.createElement(IconizedContextMenu/* IconizedContextMenuOption */.$k, null, /*#__PURE__*/react.createElement(IconizedContextMenu/* IconizedContextMenuItem */.XH, {
    onClick: onShareUserLink,
    label: userShip.includes(_types_user/* UserShip */.J.Friend) ? (0,languageHandler._t)("Share Friend") : (0,languageHandler._t)("Share to"),
    iconClassName: "mx_RoomTile_iconShare"
  }))), /*#__PURE__*/react.createElement(IconizedContextMenu/* IconizedContextMenuOptionList */.I2
  // red={!isIgnored}
  // green={isIgnored}
  , null, /*#__PURE__*/react.createElement(IconizedContextMenu/* IconizedContextMenuOption */.$k, null, /*#__PURE__*/react.createElement(IconizedContextMenu/* IconizedContextMenuItem */.XH, {
    onClick: onIgnoreToggle,
    label: isIgnored ? (0,languageHandler._t)("Unblock") : (0,languageHandler._t)("Block"),
    iconClassName: "mx_RoomTile_iconIgnore"
  }))), userShip.includes(_types_user/* UserShip */.J.Friend) ? /*#__PURE__*/react.createElement(IconizedContextMenu/* IconizedContextMenuOptionList */.I2, {
    red: true
  }, /*#__PURE__*/react.createElement(IconizedContextMenu/* IconizedContextMenuOption */.$k, null, /*#__PURE__*/react.createElement(IconizedContextMenu/* IconizedContextMenuItem */.XH, {
    onClick: removeFriend,
    label: (0,languageHandler._t)("Delete Friend"),
    iconClassName: "mx_RoomTile_iconDelete"
  }))) : null) : null);
};
SeaUserProfile.defaultProps = {
  size: 120
};
/* harmony default export */ const SeaUserProfile_SeaUserProfile = (SeaUserProfile);

/***/ }),

/***/ 934735:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  m: () => (/* binding */ REGEX_EMOTICON),
  Z: () => (/* binding */ BasicMessageEditor)
});

// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/node_modules/@babel/runtime/helpers/esm/defineProperty.js
var defineProperty = __webpack_require__(225259);
// EXTERNAL MODULE: ./node_modules/classnames/index.js
var classnames = __webpack_require__(294184);
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);
// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(667294);
// EXTERNAL MODULE: ./node_modules/emojibase-regex/emoticon.js
var emoticon = __webpack_require__(615619);
var emoticon_default = /*#__PURE__*/__webpack_require__.n(emoticon);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/editor/history.ts

/*
Copyright 2019 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

const MAX_STEP_LENGTH = 10;
class HistoryManager {
  constructor() {
    (0,defineProperty/* default */.Z)(this, "stack", []);
    (0,defineProperty/* default */.Z)(this, "newlyTypedCharCount", 0);
    (0,defineProperty/* default */.Z)(this, "currentIndex", -1);
    (0,defineProperty/* default */.Z)(this, "changedSinceLastPush", false);
    (0,defineProperty/* default */.Z)(this, "lastCaret", null);
    (0,defineProperty/* default */.Z)(this, "nonWordBoundarySinceLastPush", false);
    (0,defineProperty/* default */.Z)(this, "addedSinceLastPush", false);
    (0,defineProperty/* default */.Z)(this, "removedSinceLastPush", false);
  }
  clear() {
    this.stack = [];
    this.newlyTypedCharCount = 0;
    this.currentIndex = -1;
    this.changedSinceLastPush = false;
    this.lastCaret = null;
    this.nonWordBoundarySinceLastPush = false;
    this.addedSinceLastPush = false;
    this.removedSinceLastPush = false;
  }
  shouldPush(inputType, diff) {
    // right now we can only push a step after
    // the input has been applied to the model,
    // so we can't push the state before something happened.
    // not ideal but changing this would be harder to fit cleanly into
    // the editor model.
    const isNonBulkInput = inputType === "insertText" || inputType === "deleteContentForward" || inputType === "deleteContentBackward";
    if (diff && isNonBulkInput) {
      if (diff.added) {
        this.addedSinceLastPush = true;
      }
      if (diff.removed) {
        this.removedSinceLastPush = true;
      }
      // as long as you've only been adding or removing since the last push
      if (this.addedSinceLastPush !== this.removedSinceLastPush) {
        // add steps by word boundary, up to MAX_STEP_LENGTH characters
        const str = diff.added ? diff.added : diff.removed;
        const isWordBoundary = str === " " || str === "\t" || str === "\n";
        if (this.nonWordBoundarySinceLastPush && isWordBoundary) {
          return true;
        }
        if (!isWordBoundary) {
          this.nonWordBoundarySinceLastPush = true;
        }
        this.newlyTypedCharCount += str.length;
        return this.newlyTypedCharCount > MAX_STEP_LENGTH;
      } else {
        // if starting to remove while adding before, or the opposite, push
        return true;
      }
    } else {
      // bulk input (paste, ...) should be pushed every time
      return true;
    }
  }
  pushState(model, caret) {
    // remove all steps after current step
    while (this.currentIndex < this.stack.length - 1) {
      this.stack.pop();
    }
    const parts = model.serializeParts();
    this.stack.push({
      parts,
      caret
    });
    this.currentIndex = this.stack.length - 1;
    this.lastCaret = null;
    this.changedSinceLastPush = false;
    this.newlyTypedCharCount = 0;
    this.nonWordBoundarySinceLastPush = false;
    this.addedSinceLastPush = false;
    this.removedSinceLastPush = false;
  }

  // needs to persist parts and caret position
  tryPush(model, caret, inputType, diff) {
    // ignore state restoration echos.
    // these respect the inputType values of the input event,
    // but are actually passed in from MessageEditor calling model.reset()
    // in the keydown event handler.
    if (inputType === "historyUndo" || inputType === "historyRedo") {
      return false;
    }
    const shouldPush = this.shouldPush(inputType, diff);
    if (shouldPush) {
      this.pushState(model, caret);
    } else {
      this.lastCaret = caret;
      this.changedSinceLastPush = true;
    }
    return shouldPush;
  }
  ensureLastChangesPushed(model) {
    if (this.changedSinceLastPush) {
      this.pushState(model, this.lastCaret);
    }
  }
  canUndo() {
    return this.currentIndex >= 1 || this.changedSinceLastPush;
  }
  canRedo() {
    return this.currentIndex < this.stack.length - 1;
  }

  // returns state that should be applied to model
  undo(model) {
    if (this.canUndo()) {
      this.ensureLastChangesPushed(model);
      this.currentIndex -= 1;
      return this.stack[this.currentIndex];
    }
  }

  // returns state that should be applied to model
  redo() {
    if (this.canRedo()) {
      this.changedSinceLastPush = false;
      this.currentIndex += 1;
      return this.stack[this.currentIndex];
    }
  }
}
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/editor/render.ts
var render = __webpack_require__(91021);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/editor/range.ts
var range = __webpack_require__(123245);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/editor/parts.ts + 1 modules
var editor_parts = __webpack_require__(887403);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/editor/caret.ts
/*
Copyright 2019 New Vector Ltd
Copyright 2019 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/




function setSelection(editor, model, selection) {
  if (selection instanceof range/* default */.Z) {
    setDocumentRangeSelection(editor, model, selection);
  } else {
    setCaretPosition(editor, model, selection);
  }
}
function setDocumentRangeSelection(editor, model, range) {
  const sel = document.getSelection();
  sel.removeAllRanges();
  const selectionRange = document.createRange();
  const start = getNodeAndOffsetForPosition(editor, model, range.start);
  selectionRange.setStart(start.node, start.offset);
  const end = getNodeAndOffsetForPosition(editor, model, range.end);
  selectionRange.setEnd(end.node, end.offset);
  sel.addRange(selectionRange);
}
function setCaretPosition(editor, model, caretPosition) {
  const range = document.createRange();
  const {
    node,
    offset
  } = getNodeAndOffsetForPosition(editor, model, caretPosition);
  range.setStart(node, offset);
  range.collapse(true);
  const sel = document.getSelection();
  if (sel.rangeCount === 1) {
    const existingRange = sel.getRangeAt(0);
    if (existingRange.startContainer === range.startContainer && existingRange.startOffset === range.startOffset && existingRange.collapsed === range.collapsed) {
      // If the selection matches, it's important to leave it alone.
      // Recreating the selection state in at least Chrome can cause
      // strange side effects, like touch bar flickering on every key.
      // See https://github.com/vector-im/element-web/issues/9299
      return;
    }
  }
  sel.removeAllRanges();
  sel.addRange(range);
}
function getNodeAndOffsetForPosition(editor, model, position) {
  const {
    offset,
    lineIndex,
    nodeIndex
  } = getLineAndNodePosition(model, position);
  const lineNode = editor.childNodes[lineIndex];
  let focusNode;
  // empty line with just a <br>
  if (nodeIndex === -1) {
    focusNode = lineNode;
  } else {
    focusNode = lineNode.childNodes[nodeIndex];
    // make sure we have a text node
    if (focusNode.nodeType === Node.ELEMENT_NODE && focusNode.firstChild) {
      focusNode = focusNode.firstChild;
    }
  }
  return {
    node: focusNode,
    offset
  };
}
function getLineAndNodePosition(model, caretPosition) {
  const {
    parts
  } = model;
  const partIndex = caretPosition.index;
  const lineResult = findNodeInLineForPart(parts, partIndex);
  const {
    lineIndex
  } = lineResult;
  let {
    nodeIndex
  } = lineResult;
  let {
    offset
  } = caretPosition;
  // we're at an empty line between a newline part
  // and another newline part or end/start of parts.
  // set offset to 0 so it gets set to the <br> inside the line container
  if (nodeIndex === -1) {
    offset = 0;
  } else {
    // move caret out of uneditable part (into caret node, or empty line br) if needed
    ({
      nodeIndex,
      offset
    } = moveOutOfUneditablePart(parts, partIndex, nodeIndex, offset));
  }
  return {
    lineIndex,
    nodeIndex,
    offset
  };
}
function findNodeInLineForPart(parts, partIndex) {
  let lineIndex = 0;
  let nodeIndex = -1;
  let prevPart = null;
  // go through to parts up till (and including) the index
  // to find newline parts
  for (let i = 0; i <= partIndex; ++i) {
    const part = parts[i];
    if (part.type === editor_parts/* Type */.Dy.Newline) {
      lineIndex += 1;
      nodeIndex = -1;
      prevPart = null;
    } else {
      nodeIndex += 1;
      if ((0,render/* needsCaretNodeBefore */.PM)(part, prevPart)) {
        nodeIndex += 1;
      }
      // only jump over caret node if we're not at our destination node already,
      // as we'll assume in moveOutOfUneditablePart that nodeIndex
      // refers to the node  corresponding to the part,
      // and not an adjacent caret node
      if (i < partIndex) {
        const nextPart = parts[i + 1];
        const isLastOfLine = !nextPart || nextPart.type === editor_parts/* Type */.Dy.Newline;
        if ((0,render/* needsCaretNodeAfter */.xP)(part, isLastOfLine)) {
          nodeIndex += 1;
        }
      }
      prevPart = part;
    }
  }
  return {
    lineIndex,
    nodeIndex
  };
}
function moveOutOfUneditablePart(parts, partIndex, nodeIndex, offset) {
  // move caret before or after uneditable part
  const part = parts[partIndex];
  if (part && !part.canEdit) {
    if (offset === 0) {
      nodeIndex -= 1;
      const prevPart = parts[partIndex - 1];
      // if the previous node is a caret node, it's empty
      // so the offset can stay at 0
      // only when it's not, we need to set the offset
      // at the end of the node
      if (!(0,render/* needsCaretNodeBefore */.PM)(part, prevPart)) {
        offset = prevPart.text.length;
      }
    } else {
      nodeIndex += 1;
      offset = 0;
    }
  }
  return {
    nodeIndex,
    offset
  };
}
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/editor/operations.ts
/*
Copyright 2019 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/



/**
 * Some common queries and transformations on the editor model
 */

function replaceRangeAndExpandSelection(range, newParts) {
  const {
    model
  } = range;
  model.transform(() => {
    const oldLen = range.length;
    const addedLen = range.replace(newParts);
    const firstOffset = range.start.asOffset(model);
    const lastOffset = firstOffset.add(oldLen + addedLen);
    return model.startRange(firstOffset.asPosition(model), lastOffset.asPosition(model));
  });
}
function replaceRangeAndMoveCaret(range, newParts) {
  const {
    model
  } = range;
  model.transform(() => {
    const oldLen = range.length;
    const addedLen = range.replace(newParts);
    const firstOffset = range.start.asOffset(model);
    const lastOffset = firstOffset.add(oldLen + addedLen);
    return lastOffset.asPosition(model);
  });
}
function rangeStartsAtBeginningOfLine(range) {
  const {
    model
  } = range;
  const startsWithPartial = range.start.offset !== 0;
  const isFirstPart = range.start.index === 0;
  const previousIsNewline = !isFirstPart && model.parts[range.start.index - 1].type === editor_parts/* Type */.Dy.Newline;
  return !startsWithPartial && (isFirstPart || previousIsNewline);
}
function rangeEndsAtEndOfLine(range) {
  const {
    model
  } = range;
  const lastPart = model.parts[range.end.index];
  const endsWithPartial = range.end.offset !== lastPart.text.length;
  const isLastPart = range.end.index === model.parts.length - 1;
  const nextIsNewline = !isLastPart && model.parts[range.end.index + 1].type === editor_parts/* Type */.Dy.Newline;
  return !endsWithPartial && (isLastPart || nextIsNewline);
}
function formatRangeAsQuote(range) {
  const {
    model,
    parts
  } = range;
  const {
    partCreator
  } = model;
  for (let i = 0; i < parts.length; ++i) {
    const part = parts[i];
    if (part.type === editor_parts/* Type */.Dy.Newline) {
      parts.splice(i + 1, 0, partCreator.plain("> "));
    }
  }
  parts.unshift(partCreator.plain("> "));
  if (!rangeStartsAtBeginningOfLine(range)) {
    parts.unshift(partCreator.newline());
  }
  if (!rangeEndsAtEndOfLine(range)) {
    parts.push(partCreator.newline());
  }
  parts.push(partCreator.newline());
  replaceRangeAndExpandSelection(range, parts);
}
function formatRangeAsCode(range) {
  const {
    model,
    parts
  } = range;
  const {
    partCreator
  } = model;
  const needsBlock = parts.some(p => p.type === editor_parts/* Type */.Dy.Newline);
  if (needsBlock) {
    parts.unshift(partCreator.plain("```"), partCreator.newline());
    if (!rangeStartsAtBeginningOfLine(range)) {
      parts.unshift(partCreator.newline());
    }
    parts.push(partCreator.newline(), partCreator.plain("```"));
    if (!rangeEndsAtEndOfLine(range)) {
      parts.push(partCreator.newline());
    }
  } else {
    parts.unshift(partCreator.plain("`"));
    parts.push(partCreator.plain("`"));
  }
  replaceRangeAndExpandSelection(range, parts);
}

// parts helper methods
const isBlank = part => !part.text || !/\S/.test(part.text);
const isNL = part => part.type === editor_parts/* Type */.Dy.Newline;
function toggleInlineFormat(range, prefix, suffix = prefix) {
  const {
    model,
    parts
  } = range;
  const {
    partCreator
  } = model;

  // compute paragraph [start, end] indexes
  const paragraphIndexes = [];
  let startIndex = 0;
  // start at i=2 because we look at i and up to two parts behind to detect paragraph breaks at their end
  for (let i = 2; i < parts.length; i++) {
    // paragraph breaks can be denoted in a multitude of ways,
    // - 2 newline parts in sequence
    // - newline part, plain(<empty or just spaces>), newline part

    // bump startIndex onto the first non-blank after the paragraph ending
    if (isBlank(parts[i - 2]) && isNL(parts[i - 1]) && !isNL(parts[i]) && !isBlank(parts[i])) {
      startIndex = i;
    }

    // if at a paragraph break, store the indexes of the paragraph
    if (isNL(parts[i - 1]) && isNL(parts[i])) {
      paragraphIndexes.push([startIndex, i - 1]);
      startIndex = i + 1;
    } else if (isNL(parts[i - 2]) && isBlank(parts[i - 1]) && isNL(parts[i])) {
      paragraphIndexes.push([startIndex, i - 2]);
      startIndex = i + 1;
    }
  }
  const lastNonEmptyPart = parts.map(isBlank).lastIndexOf(false);
  // If we have not yet included the final paragraph then add it now
  if (startIndex <= lastNonEmptyPart) {
    paragraphIndexes.push([startIndex, lastNonEmptyPart + 1]);
  }

  // keep track of how many things we have inserted as an offset:=0
  let offset = 0;
  paragraphIndexes.forEach(([startIdx, endIdx]) => {
    // for each paragraph apply the same rule
    const base = startIdx + offset;
    const index = endIdx + offset;
    const isFormatted = index - base > 0 && parts[base].text.startsWith(prefix) && parts[index - 1].text.endsWith(suffix);
    if (isFormatted) {
      // remove prefix and suffix
      const partWithoutPrefix = parts[base].serialize();
      partWithoutPrefix.text = partWithoutPrefix.text.substr(prefix.length);
      parts[base] = partCreator.deserializePart(partWithoutPrefix);
      const partWithoutSuffix = parts[index - 1].serialize();
      const suffixPartText = partWithoutSuffix.text;
      partWithoutSuffix.text = suffixPartText.substring(0, suffixPartText.length - suffix.length);
      parts[index - 1] = partCreator.deserializePart(partWithoutSuffix);
    } else {
      parts.splice(index, 0, partCreator.plain(suffix)); // splice in the later one first to not change offset
      parts.splice(base, 0, partCreator.plain(prefix));
      offset += 2; // offset index to account for the two items we just spliced in
    }
  });

  replaceRangeAndExpandSelection(range, parts);
}
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/editor/dom.ts
var dom = __webpack_require__(980680);
// EXTERNAL MODULE: ./node_modules/lodash-es/flatMap.js
var flatMap = __webpack_require__(216805);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/settings/SettingsStore.ts + 9 modules
var SettingsStore = __webpack_require__(571879);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/languageHandler.tsx
var languageHandler = __webpack_require__(867614);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/autocomplete/AutocompleteProvider.tsx

/*
Copyright 2016 Aviral Dasgupta
Copyright 2017 Vector Creations Ltd
Copyright 2017, 2018 New Vector Ltd

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

class AutocompleteProvider {
  constructor(commandRegex, forcedCommandRegex) {
    (0,defineProperty/* default */.Z)(this, "commandRegex", void 0);
    (0,defineProperty/* default */.Z)(this, "forcedCommandRegex", void 0);
    if (commandRegex) {
      if (!commandRegex.global) {
        throw new Error('commandRegex must have global flag set');
      }
      this.commandRegex = commandRegex;
    }
    if (forcedCommandRegex) {
      if (!forcedCommandRegex.global) {
        throw new Error('forcedCommandRegex must have global flag set');
      }
      this.forcedCommandRegex = forcedCommandRegex;
    }
  }
  destroy() {
    // stub
  }

  /**
   * Of the matched commands in the query, returns the first that contains or is contained by the selection, or null.
   * @param {string} query The query string
   * @param {ISelectionRange} selection Selection to search
   * @param {boolean} force True if the user is forcing completion
   * @return {object} { command, range } where both objects fields are null if no match
   */
  getCurrentCommand(query, selection, force = false) {
    let commandRegex = this.commandRegex;
    if (force && this.shouldForceComplete()) {
      commandRegex = this.forcedCommandRegex || /\S+/g;
    }
    if (!commandRegex) {
      return null;
    }
    commandRegex.lastIndex = 0;
    let match;
    while ((match = commandRegex.exec(query)) !== null) {
      const start = match.index;
      const end = start + match[0].length;
      if (selection.start <= end && selection.end >= start) {
        return {
          command: match,
          range: {
            start,
            end
          }
        };
      }
    }
    return {
      command: null,
      range: {
        start: -1,
        end: -1
      }
    };
  }
  // Whether we should provide completions even if triggered forcefully, without a sigil.
  shouldForceComplete() {
    return false;
  }
}
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/autocomplete/QueryMatcher.ts
var QueryMatcher = __webpack_require__(745590);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/node_modules/@babel/runtime/helpers/esm/extends.js
var esm_extends = __webpack_require__(166644);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js + 1 modules
var objectWithoutProperties = __webpack_require__(992619);
// EXTERNAL MODULE: ./node_modules/lodash-es/isString.js
var isString = __webpack_require__(636378);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/autocomplete/Components.tsx


const _excluded = ["title", "subtitle", "className"],
  _excluded2 = ["title", "subtitle", "className", "children", "highlight"];
/*
Copyright 2016 Aviral Dasgupta

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/





/* These were earlier stateless functional components but had to be converted
since we need to use refs/findDOMNode to access the underlying DOM node to focus the correct completion,
something that is not entirely possible with stateless functional components. One could
presumably wrap them in a <div> before rendering but I think this is the better way to do it.
 */

const TextualCompletion = /*#__PURE__*/(0,react.forwardRef)((props, ref) => {
  const {
      title,
      subtitle,
      className
    } = props,
    restProps = (0,objectWithoutProperties/* default */.Z)(props, _excluded);
  return /*#__PURE__*/react.createElement("div", (0,esm_extends/* default */.Z)({}, restProps, {
    className: classnames_default()("mx_Autocomplete_Completion_block", className),
    role: "option",
    ref: ref
  }), /*#__PURE__*/react.createElement("span", {
    className: "mx_Autocomplete_Completion_title"
  }, title), /*#__PURE__*/react.createElement("span", {
    className: "mx_Autocomplete_Completion_subtitle"
  }, subtitle));
});
const PillCompletion = /*#__PURE__*/(0,react.forwardRef)((props, ref) => {
  const {
      title,
      subtitle,
      className,
      children,
      highlight
    } = props,
    restProps = (0,objectWithoutProperties/* default */.Z)(props, _excluded2);
  const showHighlight = highlight && (0,isString/* default */.Z)(title) && title.includes(highlight);
  return /*#__PURE__*/react.createElement("div", (0,esm_extends/* default */.Z)({}, restProps, {
    className: classnames_default()("mx_Autocomplete_Completion_pill", className),
    role: "option",
    ref: ref
  }), children, showHighlight ? /*#__PURE__*/react.createElement("span", {
    className: "mx_Autocomplete_Completion_highlight"
  }, highlight) : null, /*#__PURE__*/react.createElement("span", {
    className: "mx_Autocomplete_Completion_title"
  }, showHighlight ? title.replace(highlight || "", "") : title), /*#__PURE__*/react.createElement("span", {
    className: "mx_Autocomplete_Completion_subtitle"
  }, subtitle));
});
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/SlashCommands.tsx + 3 modules
var SlashCommands = __webpack_require__(662316);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/autocomplete/CommandProvider.tsx

/*
Copyright 2016 Aviral Dasgupta
Copyright 2017 Vector Creations Ltd
Copyright 2017 New Vector Ltd
Copyright 2018 Michael Telatynski <7t3chguy@gmail.com>

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/







const COMMAND_RE = /(^\/\w*)(?: .*)?/g;
const hiddenCommands = ['transfer', 'nick', 'myroomnick', 'roomavatar', 'myroomavatar', 'myavatar', 'invite', 'join', 'part', 'ignore', 'unignore', 'query', 'msg', 'upgraderoom', 'topic', 'roomname', 'kick', 'ban', 'unban', 'op', 'deop', 'addwidget', 'devtools', 'verify', 'discardsession', 'help', 'whois', 'rageshake'];
class CommandProvider extends AutocompleteProvider {
  constructor() {
    super(COMMAND_RE);
    (0,defineProperty/* default */.Z)(this, "matcher", void 0);
    this.matcher = new QueryMatcher/* default */.Z(SlashCommands/* Commands */.Gh, {
      keys: ['command', 'args', 'description'],
      funcs: [({
        aliases
      }) => aliases.join(" ")] // aliases
    });
  }

  async getCompletions(query, selection, force, limit = -1) {
    const {
      command,
      range
    } = this.getCurrentCommand(query, selection);
    if (!command) return [];
    let matches = [];
    // check if the full match differs from the first word (i.e. returns false if the command has args)
    if (command[0] !== command[1]) {
      // The input looks like a command with arguments, perform exact match
      const name = command[1].substr(1); // strip leading `/`
      if (SlashCommands/* CommandMap */.QQ.has(name) && SlashCommands/* CommandMap */.QQ.get(name).isEnabled()) {
        // some commands, namely `me` don't suit having the usage shown whilst typing their arguments
        if (SlashCommands/* CommandMap */.QQ.get(name).hideCompletionAfterSpace) return [];
        matches = [SlashCommands/* CommandMap */.QQ.get(name)];
      }
    } else {
      if (query === '/') {
        // If they have just entered `/` show everything
        // We exclude the limit on purpose to have a comprehensive list
        matches = SlashCommands/* Commands */.Gh.filter(command => !hiddenCommands.includes(command.command));
      } else {
        // otherwise fuzzy match against all of the fields
        matches = this.matcher.match(command[1], limit).filter(command => !hiddenCommands.includes(command.command));
      }
    }
    return matches.filter(cmd => cmd.isEnabled()).map(result => {
      let completion = result.getCommand() + ' ';
      const usedAlias = result.aliases.find(alias => `/${alias}` === command[1]);
      // If the command (or an alias) is the same as the one they entered, we don't want to discard their arguments
      if (usedAlias || result.getCommand() === command[1]) {
        completion = command[0];
      }
      return {
        completion,
        type: "command",
        component: /*#__PURE__*/react.createElement(TextualCompletion, {
          title: `/${usedAlias || result.command}`,
          subtitle: result.args,
          description: (0,languageHandler._t)(result.description)
        }),
        range
      };
    });
  }
  getName() {
    return '*️⃣ ' + (0,languageHandler._t)('Commands');
  }
  renderCompletions(completions) {
    return /*#__PURE__*/react.createElement("div", {
      className: "mx_Autocomplete_Completion_container_pill",
      role: "presentation",
      "aria-label": (0,languageHandler._t)("Command Autocomplete")
    }, completions);
  }
}
// EXTERNAL MODULE: ./node_modules/lodash-es/sortBy.js
var sortBy = __webpack_require__(898697);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/MatrixClientPeg.ts + 3 modules
var MatrixClientPeg = __webpack_require__(933393);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/utils/permalinks/Permalinks.ts
var Permalinks = __webpack_require__(954105);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/avatars/MemberAvatar.tsx
var MemberAvatar = __webpack_require__(6156);
// EXTERNAL MODULE: ./node_modules/matrix-js-sdk/src/@types/event.ts
var _types_event = __webpack_require__(907977);
// EXTERNAL MODULE: ./node_modules/matrix-js-sdk/src/@types/partials.ts
var partials = __webpack_require__(85047);
// EXTERNAL MODULE: ./node_modules/matrix-js-sdk/src/browser-index.js
var browser_index = __webpack_require__(407637);
// EXTERNAL MODULE: ./node_modules/rc-virtual-list/lib/index.js
var lib = __webpack_require__(727032);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/utils/room/getRoomScene.ts
var getRoomScene = __webpack_require__(827337);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/autocomplete/UserProvider.tsx

/*
Copyright 2016 Aviral Dasgupta
Copyright 2017 Vector Creations Ltd
Copyright 2017, 2018 New Vector Ltd
Copyright 2018 Michael Telatynski <7t3chguy@gmail.com>

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/















const USER_REGEX = /@\S*/g;

// used when you hit 'tab' - we allow some separator chars at the beginning
// to allow you to tab-complete /mat into /(matthew)
const FORCED_USER_REGEX = /[^/,:; \t\n]\S*/g;
var CountMemberType = /*#__PURE__*/function (CountMemberType) {
  CountMemberType["UNLEAVE"] = "unleave";
  CountMemberType["JOIN"] = "join";
  return CountMemberType;
}(CountMemberType || {});
class UserProvider extends AutocompleteProvider {
  constructor(_room) {
    var _room$currentState$ge;
    super(USER_REGEX, FORCED_USER_REGEX);
    (0,defineProperty/* default */.Z)(this, "matcher", void 0);
    (0,defineProperty/* default */.Z)(this, "users", void 0);
    (0,defineProperty/* default */.Z)(this, "room", void 0);
    (0,defineProperty/* default */.Z)(this, "countMemberType", void 0);
    (0,defineProperty/* default */.Z)(this, "onRoomTimeline", (ev, room, toStartOfTimeline, removed, data) => {
      if (!room) return;
      if (removed) return;
      if (room.roomId !== this.room.roomId) return;

      // ignore events from filtered timelines
      if (data.timeline.getTimelineSet() !== room.getUnfilteredTimelineSet()) return;

      // ignore anything but real-time updates at the end of the room:
      // updates from pagination will happen when the paginate completes.
      if (toStartOfTimeline || !data || !data.liveEvent) return;

      // TODO: lazyload if we have no ev.sender room member?
      this.onUserSpoke(ev.sender);
    });
    (0,defineProperty/* default */.Z)(this, "onRoomStateMember", (ev, state, member) => {
      // ignore members in other rooms
      if (member.roomId !== this.room.roomId) {
        return;
      }

      // blow away the users cache
      this.users = null;
    });
    (0,defineProperty/* default */.Z)(this, "getCompletion", (user, selection, range) => {
      var _RemarkStore$get$getR;
      const nickname = this.room.getRoomUserNickName(user.userId);
      const remarkName = (_RemarkStore$get$getR = browser_index/* RemarkStore */.Tq.get().getRemarkMap()[user.userId]) === null || _RemarkStore$get$getR === void 0 ? void 0 : _RemarkStore$get$getR.name;
      const displayName = remarkName || nickname || user.name || user.userId || "";
      const subtitle = "";
      // user.name !== user.rawDisplayName ? `(${user.rawDisplayName})` : "";
      return {
        // Length of completion should equal length of text in decorator. draft-js
        // relies on the length of the entity === length of the text in the decoration.
        completion: user.rawDisplayName,
        completionId: user.userId,
        type: "user",
        suffix: selection.beginning && range.start === 0 ? ": " : " ",
        href: (0,Permalinks/* makeUserPermalink */.KU)(user.userId),
        component: /*#__PURE__*/react.createElement(PillCompletion, {
          title: displayName,
          description: user.userId,
          subtitle: subtitle
        }, /*#__PURE__*/react.createElement(MemberAvatar/* default */.Z, {
          member: user,
          size: 34
        })),
        range
      };
    });
    this.room = _room;
    this.matcher = new QueryMatcher/* default */.Z([], {
      keys: ["name", "rawDisplayName"],
      funcs: [obj => obj.displayName, obj => obj.rawDisplayName],
      // index by user id minus the leading '@'
      shouldMatchWordsOnly: false,
      fuzzy: false
    });

    // access no limit or invited is tacit joined
    const eventContent = ((_room$currentState$ge = _room.currentState.getStateEvents(_types_event/* EventType */.tw.RoomJoinRules, "")) === null || _room$currentState$ge === void 0 ? void 0 : _room$currentState$ge.getContent()) || {};
    const {
      join_rule: joinRule
    } = eventContent;
    this.countMemberType = (joinRule === partials/* JoinRule */.iE.Invite || joinRule === partials/* JoinRule */.iE.Public) && !(0,getRoomScene/* isCommunityRoom */.eg)(_room) ? CountMemberType.UNLEAVE : CountMemberType.JOIN;
    MatrixClientPeg/* MatrixClientPeg */.p.get().on("Room.timeline", this.onRoomTimeline);
    MatrixClientPeg/* MatrixClientPeg */.p.get().on("RoomState.members", this.onRoomStateMember);
  }
  destroy() {
    if (MatrixClientPeg/* MatrixClientPeg */.p.get()) {
      MatrixClientPeg/* MatrixClientPeg */.p.get().removeListener("Room.timeline", this.onRoomTimeline);
      MatrixClientPeg/* MatrixClientPeg */.p.get().removeListener("RoomState.members", this.onRoomStateMember);
    }
  }
  async getCompletions(rawQuery, selection, force = false, limit = -1) {
    if (this.room.isDmRoom()) {
      return [];
    }
    // lazy-load user list into matcher
    if (!this.users) this.makeUsers();
    let completions = [];
    const {
      command,
      range
    } = this.getCurrentCommand(rawQuery, selection, force);
    if (!command) return completions;
    const [fullMatch, second] = command;

    // Don't search if the query is a single "@"
    if (fullMatch && fullMatch !== "@") {
      // Don't include the '@' in our search query - it's only used as a way to trigger completion
      const query = fullMatch.startsWith("@") ? fullMatch.substring(1) : fullMatch;
      completions = this.matcher.match(query, limit).map(user => {
        return this.getCompletion(user, selection, range);
      });
    } else if (fullMatch === "@" && !second) {
      if (this.countMemberType === CountMemberType.UNLEAVE) {
        completions = this.room.getUnleaveMembers().map(user => {
          return this.getCompletion(user, selection, range);
        });
      } else {
        completions = this.room.getJoinedMembers().map(user => {
          return this.getCompletion(user, selection, range);
        });
      }
    }
    return completions;
  }
  getName() {
    return (0,languageHandler._t)("Users");
  }
  makeUsers() {
    const events = this.room.getLiveTimeline().getEvents();
    const lastSpoken = {};
    for (const event of events) {
      lastSpoken[event.getSender()] = event.getTs();
    }
    const currentUserId = MatrixClientPeg/* MatrixClientPeg */.p.get().credentials.userId;
    if (this.countMemberType === CountMemberType.UNLEAVE) {
      this.users = this.room.getUnleaveMembers().filter(({
        userId
      }) => userId !== currentUserId);
    } else {
      this.users = this.room.getJoinedMembers().filter(({
        userId
      }) => userId !== currentUserId);
    }
    this.users = this.users.concat(this.room.getMembersWithMembership("invite"));
    this.users = (0,sortBy/* default */.Z)(this.users, member => 1e20 - lastSpoken[member.userId] || 1e20);
    this.matcher.setObjects(this.users);
  }
  onUserSpoke(user) {
    if (!this.users) return;
    if (!user) return;
    if (user.userId === MatrixClientPeg/* MatrixClientPeg */.p.get().credentials.userId) return;

    // Move the user that spoke to the front of the array
    this.users.splice(this.users.findIndex(user2 => user2.userId === user.userId), 1);
    this.users = [user, ...this.users];
    this.matcher.setObjects(this.users);
  }
  renderCompletions(completions) {
    return /*#__PURE__*/react.createElement(lib["default"], {
      className: "mx_Autocomplete_Completion_container_pill",
      role: "presentation",
      "aria-label": (0,languageHandler._t)("User Autocomplete"),
      data: completions,
      itemKey: "key",
      itemHeight: 40,
      height: 300,
      fullHeight: false
    }, index => index);
  }
  shouldForceComplete() {
    return true;
  }
}
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/dispatcher/dispatcher.ts
var dispatcher = __webpack_require__(245539);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/dispatcher/actions.ts
var actions = __webpack_require__(473627);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/avatars/BaseAvatar.tsx
var BaseAvatar = __webpack_require__(56607);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/utils/replaceableComponent.ts
var replaceableComponent = __webpack_require__(90287);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/avatars/TokenAvatar.tsx



const TokenAvatar_excluded = ["token", "onClick", "viewUserOnClick"];
var _dec, _class, _class2;
/*
Copyright 2015, 2016 OpenMarket Ltd
Copyright 2019 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/






let TokenAvatar = (_dec = (0,replaceableComponent/* replaceableComponent */.U)("views.avatars.TokenAvatar"), _dec(_class = (_class2 = class TokenAvatar extends react.Component {
  constructor(props) {
    super(props);
    this.state = {
      name: props.token.symbol,
      title: props.token.symbol,
      imageUrl: props.token.icon
    };
  }
  render() {
    let _this$props = this.props,
      {
        token,
        onClick,
        viewUserOnClick
      } = _this$props,
      otherProps = (0,objectWithoutProperties/* default */.Z)(_this$props, TokenAvatar_excluded);
    if (viewUserOnClick) {
      onClick = () => {
        dispatcher/* default */.ZP.dispatch({
          action: actions/* Action */.a.ViewToken,
          token: token
        });
      };
    }
    return /*#__PURE__*/react.createElement(BaseAvatar/* default */.Z, (0,esm_extends/* default */.Z)({}, otherProps, {
      name: this.state.name,
      title: this.state.title,
      url: this.state.imageUrl,
      onClick: onClick
    }));
  }
}, (0,defineProperty/* default */.Z)(_class2, "defaultProps", {
  width: 40,
  height: 40,
  resizeMethod: 'crop',
  viewUserOnClick: false
}), _class2)) || _class);

// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/TokenStore.ts + 1 modules
var TokenStore = __webpack_require__(600358);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/autocomplete/TokenProvider.tsx

/*
Copyright 2016 Aviral Dasgupta
Copyright 2017 Vector Creations Ltd
Copyright 2017, 2018 New Vector Ltd
Copyright 2018 Michael Telatynski <7t3chguy@gmail.com>

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/








// import { RoomState } from "matrix-js-sdk/src/models/room-state";




const TOKEN_REGEX = /\B\$\S*/g;

// used when you hit 'tab' - we allow some separator chars at the beginning
// to allow you to tab-complete /mat into /(matthew)
// const FORCED_USER_REGEX = /[^/,:; \t\n]\S*/g;
class TokenProvider extends AutocompleteProvider {
  constructor(_room) {
    super(TOKEN_REGEX);
    (0,defineProperty/* default */.Z)(this, "matcher", void 0);
    (0,defineProperty/* default */.Z)(this, "tokens", void 0);
    (0,defineProperty/* default */.Z)(this, "room", void 0);
    (0,defineProperty/* default */.Z)(this, "makeTokens", () => {
      this.tokens = TokenStore/* default */.Z.instance.getTokens();
      this.matcher.setObjects(this.tokens);
    });
    (0,defineProperty/* default */.Z)(this, "onRoomTimeline", (ev, room, toStartOfTimeline, removed, data) => {
      if (!room) return;
      if (removed) return;
      if (room.roomId !== this.room.roomId) return;

      // ignore events from filtered timelines
      if (data.timeline.getTimelineSet() !== room.getUnfilteredTimelineSet()) return;

      // ignore anything but real-time updates at the end of the room:
      // updates from pagination will happen when the paginate completes.
      if (toStartOfTimeline || !data || !data.liveEvent) return;

      // TODO: lazyload if we have no ev.sender room member?
      this.onUserSpoke(ev.sender);
    });
    this.room = _room;
    this.matcher = new QueryMatcher/* default */.Z([], {
      keys: ['name', 'symbol'],
      funcs: [obj => obj.name, obj => obj.symbol],
      // index by user id minus the leading '@'
      shouldMatchWordsOnly: false,
      fuzzy: false
    });
    MatrixClientPeg/* MatrixClientPeg */.p.get().on("Room.timeline", this.onRoomTimeline);
    // MatrixClientPeg.get().on("RoomState.members", this.onRoomStateMember);
  }

  destroy() {
    if (MatrixClientPeg/* MatrixClientPeg */.p.get()) {
      MatrixClientPeg/* MatrixClientPeg */.p.get().removeListener("Room.timeline", this.onRoomTimeline);
      // MatrixClientPeg.get().removeListener("RoomState.members", this.onRoomStateMember);
    }
  }

  // private onRoomStateMember = (ev: MatrixEvent, state: RoomState, member: RoomMember) => {
  //     // ignore members in other rooms
  //     if (member.roomId !== this.room.roomId) {
  //         return;
  //     }

  //     // blow away the users cache
  //     this.users = null;
  // };
  async getCompletions(rawQuery, selection, force = false, limit = -1) {
    // lazy-load user list into matcher
    if (!this.tokens) await this.makeTokens();
    let completions = [];
    const {
      command,
      range
    } = this.getCurrentCommand(rawQuery, selection, force);
    if (!command) return completions;
    const fullMatch = command[0];
    // Don't search if the query is a single "@"
    if (fullMatch && fullMatch !== '$') {
      // Don't include the '@' in our search query - it's only used as a way to trigger completion
      const query = fullMatch.startsWith('$') ? fullMatch.substring(1) : fullMatch;
      const items = this.matcher.match(query, limit);
      completions = items.map(token => {
        const displayName = /*#__PURE__*/react.createElement("div", {
          className: "mx_Token_displayName"
        }, /*#__PURE__*/react.createElement("span", {
          className: "mx_Token_symbol"
        }, token.name), /*#__PURE__*/react.createElement("span", {
          className: "mx_Token_name"
        }, token.symbol));
        return {
          // Length of completion should equal length of text in decorator. draft-js
          // relies on the length of the entity === length of the text in the decoration.
          completion: token.symbol,
          completionId: token.slug,
          type: "token",
          suffix: ' ',
          href: (0,Permalinks/* makeTokenPermalink */.XB)(`$${token.symbol}`),
          component: /*#__PURE__*/react.createElement(PillCompletion, {
            title: displayName
          }, /*#__PURE__*/react.createElement(TokenAvatar, {
            token: token,
            width: 24,
            height: 24
          })),
          range
        };
      });
    }
    return completions;
  }
  getName() {
    return (0,languageHandler._t)('Tokens');
  }
  onUserSpoke(user) {
    if (!this.tokens) return;
    if (!user) return;

    // Move the user that spoke to the front of the array
    this.matcher.setObjects(this.tokens);
  }
  renderCompletions(completions) {
    return /*#__PURE__*/react.createElement("div", {
      className: "mx_Autocomplete_Completion_container_pill",
      role: "presentation",
      "aria-label": (0,languageHandler._t)("Token Autocomplete")
    }, completions);
  }
  shouldForceComplete() {
    return true;
  }
}
// EXTERNAL MODULE: ./node_modules/lodash-es/uniq.js
var uniq = __webpack_require__(94207);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/emoji.ts + 2 modules
var emoji = __webpack_require__(408530);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/autocomplete/EmojiProvider.tsx

/*
Copyright 2016 Aviral Dasgupta
Copyright 2017 Vector Creations Ltd
Copyright 2017, 2018 New Vector Ltd
Copyright 2019 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/










const LIMIT = 20;

// Match for ascii-style ";-)" emoticons or ":wink:" shortcodes provided by emojibase
// anchored to only match from the start of parts otherwise it'll show emoji suggestions whilst typing matrix IDs
const EMOJI_REGEX = new RegExp("(" + (emoticon_default()).source + "|(?:^|\\s):[+-\\w]*:?)$", "g");
const SORTED_EMOJI = emoji/* EMOJI */.Dd.sort((a, b) => {
  if (a.group === b.group) {
    return a.order - b.order;
  }
  return a.group - b.group;
}).map((emoji, index) => ({
  emoji,
  // Include the index so that we can preserve the original order
  _orderBy: index
}));
function score(query, space) {
  const index = space.indexOf(query);
  if (index === -1) {
    return Infinity;
  } else {
    return index;
  }
}
class EmojiProvider extends AutocompleteProvider {
  constructor() {
    super(EMOJI_REGEX);
    (0,defineProperty/* default */.Z)(this, "matcher", void 0);
    (0,defineProperty/* default */.Z)(this, "nameMatcher", void 0);
    this.matcher = new QueryMatcher/* default */.Z(SORTED_EMOJI, {
      keys: [],
      funcs: [o => o.emoji.shortcodes.map(s => `:${s}:`)],
      // For matching against ascii equivalents
      shouldMatchWordsOnly: false
    });
    this.nameMatcher = new QueryMatcher/* default */.Z(SORTED_EMOJI, {
      keys: ["emoji.annotation"],
      // For removing punctuation
      shouldMatchWordsOnly: true
    });
  }
  async getCompletions(query, selection, force, limit = -1) {
    if (!SettingsStore/* default */.C.getValue("MessageComposerInput.suggestEmoji")) {
      return []; // don't give any suggestions if the user doesn't want them
    }

    let completions = [];
    const {
      command,
      range
    } = this.getCurrentCommand(query, selection);
    if (command && command[0].length > 2) {
      const matchedString = command[0];
      completions = this.matcher.match(matchedString, limit);

      // Do second match with shouldMatchWordsOnly in order to match against 'name'
      completions = completions.concat(this.nameMatcher.match(matchedString));
      const sorters = [];
      // make sure that emoticons come first
      sorters.push(c => score(matchedString, c.emoji.emoticon || ""));

      // then sort by score (Infinity if matchedString not in shortcode)
      sorters.push(c => score(matchedString, c.emoji.shortcodes[0]));
      // then sort by max score of all shortcodes, trim off the `:`
      sorters.push(c => Math.min(...c.emoji.shortcodes.map(s => score(matchedString.substring(1), s))));
      // If the matchedString is not empty, sort by length of shortcode. Example:
      //  matchedString = ":bookmark"
      //  completions = [":bookmark:", ":bookmark_tabs:", ...]
      if (matchedString.length > 1) {
        sorters.push(c => c.emoji.shortcodes[0].length);
      }
      // Finally, sort by original ordering
      sorters.push(c => c._orderBy);
      completions = (0,sortBy/* default */.Z)((0,uniq/* default */.Z)(completions), sorters);
      completions = completions.map(c => ({
        completion: c.emoji.unicode,
        component: /*#__PURE__*/react.createElement(PillCompletion, {
          title: `:${c.emoji.shortcodes[0]}:`,
          "aria-label": c.emoji.unicode
        }, /*#__PURE__*/react.createElement("span", null, c.emoji.unicode)),
        range
      })).slice(0, LIMIT);
    }
    return completions;
  }
  getName() {
    return "😃 " + (0,languageHandler._t)("Emoji");
  }
  renderCompletions(completions) {
    return /*#__PURE__*/react.createElement("div", {
      className: "mx_Autocomplete_Completion_container_pill",
      role: "presentation",
      "aria-label": (0,languageHandler._t)("Emoji Autocomplete")
    }, completions);
  }
}
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/avatars/RoomAvatar.tsx
var RoomAvatar = __webpack_require__(139319);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/PermissionStore.ts
var PermissionStore = __webpack_require__(825291);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/autocomplete/NotifProvider.tsx

/*
Copyright 2017 New Vector Ltd

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/








const AT_ROOM_REGEX = /@\S*/g;
class NotifProvider extends AutocompleteProvider {
  constructor(room) {
    super(AT_ROOM_REGEX);
    (0,defineProperty/* default */.Z)(this, "room", void 0);
    this.room = room;
  }
  async getCompletions(query, selection, force = false, limit = -1) {
    const client = MatrixClientPeg/* MatrixClientPeg */.p.get();
    if (this.room.isDmRoom()) return [];
    const [hasNotifyEveryone] = await PermissionStore/* default */.ZP.hasPermission(this.room.roomId, PermissionStore/* PermissionMap */.$W.RoomNotifyEveryone);
    if (!hasNotifyEveryone) return [];
    const {
      command,
      range
    } = this.getCurrentCommand(query, selection, force);
    if (command && command[0] && "@room".startsWith(command[0])) {
      // && command[0].length > 1)
      return [{
        completion: "@room",
        // completionId: "@room",
        completionId: this.room.roomId,
        type: "at-room",
        suffix: " ",
        component: /*#__PURE__*/react.createElement(PillCompletion, {
          title: "@room",
          description: (0,languageHandler._t)("Notify the whole room")
        }, /*#__PURE__*/react.createElement(RoomAvatar/* default */.Z, {
          size: 38,
          room: this.room
        })),
        range
      }];
    }
    return [];
  }
  getName() {
    return (0,languageHandler._t)("Room Notification");
  }
  renderCompletions(completions) {
    return /*#__PURE__*/react.createElement("div", {
      className: "mx_Autocomplete_Completion_container_pill mx_Autocomplete_Completion_container_truncate",
      role: "presentation",
      "aria-label": (0,languageHandler._t)("Notification Autocomplete")
    }, completions);
  }
}
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/utils/promise.ts
var promise = __webpack_require__(222000);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/autocomplete/TopicProvider.tsx





const TOPIC_REGEX = /\B(#(\d+)?([\u4e00-\u9fa5a-zA-Z]{1,120})(\d+)?)/g;
const TOPIC_MATCH_REGEX = /\B(#(\d+)?([\u4e00-\u9fa5a-zA-Z]{1,120})?)/g;
class TopicProvider extends AutocompleteProvider {
  constructor(room) {
    super(TOPIC_MATCH_REGEX);
    this.room = room;
  }
  getName() {
    return (0,languageHandler._t)('Topic');
  }
  async getCompletions(rawQuery, selection, force = false, limit = -1) {
    let completions = [];
    const {
      command,
      range
    } = this.getCurrentCommand(rawQuery, selection, force);
    if (!command) return completions;
    const fullMatch = command[0];
    if (fullMatch && fullMatch !== '#') {
      TOPIC_REGEX.lastIndex = 0;
      if (TOPIC_REGEX.test(fullMatch)) {
        completions = [{
          completion: fullMatch,
          completionId: fullMatch,
          type: 'topic',
          suffix: ' ',
          href: (0,Permalinks/* makeTokenPermalink */.XB)(`#${fullMatch}`),
          component: /*#__PURE__*/react.createElement(PillCompletion, {
            title: fullMatch,
            highlight: fullMatch
          }),
          range
        }];
      }
      const res = await this.room.client.getTopicOfRoom(this.room.roomId, fullMatch);
      if (res.data.length !== 0) {
        completions = completions.concat(res.data.map(topic => {
          if (topic === fullMatch) {
            return;
          }
          return {
            completion: topic,
            completionId: topic,
            type: 'topic',
            suffix: ' ',
            href: (0,Permalinks/* makeTokenPermalink */.XB)(`#${topic}`),
            component: /*#__PURE__*/react.createElement(PillCompletion, {
              title: topic,
              highlight: fullMatch
            }),
            range
          };
        }).filter(Boolean));
      }
    }
    return completions;
  }
  renderCompletions(completions) {
    return /*#__PURE__*/react.createElement("div", {
      className: "mx_Autocomplete_Completion_container_pill",
      role: "presentation",
      "aria-label": (0,languageHandler._t)("Topic Autocomplete")
    }, completions);
  }
}
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/autocomplete/Autocompleter.ts

/*
Copyright 2016 Aviral Dasgupta
Copyright 2017, 2018 New Vector Ltd

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/








const PROVIDERS = [UserProvider,
// RoomProvider,
EmojiProvider, NotifProvider, CommandProvider, TokenProvider, TopicProvider];

// if (SpaceStore.spacesEnabled) {
//     PROVIDERS.push(SpaceProvider);
// } else {
//     PROVIDERS.push(CommunityProvider);
// }

// Providers will get rejected if they take longer than this.
const PROVIDER_COMPLETION_TIMEOUT = 3000;
class Autocompleter {
  constructor(room) {
    (0,defineProperty/* default */.Z)(this, "room", void 0);
    (0,defineProperty/* default */.Z)(this, "providers", void 0);
    this.room = room;
    this.providers = PROVIDERS.map(Prov => {
      return new Prov(room);
    });
  }
  destroy() {
    this.providers.forEach(p => {
      p.destroy();
    });
  }
  async getCompletions(query, selection, force = false, limit = -1) {
    /* Note: This intentionally waits for all providers to return,
     otherwise, we run into a condition where new completions are displayed
     while the user is interacting with the list, which makes it difficult
     to predict whether an action will actually do what is intended
    */
    // list of results from each provider, each being a list of completions or null if it times out
    const completionsList = await Promise.all(this.providers.map(async provider => {
      return await (0,promise/* timeout */.V)(provider.getCompletions(query, selection, force, limit), null, PROVIDER_COMPLETION_TIMEOUT);
    }));

    // map then filter to maintain the index for the map-operation, for this.providers to line up
    return completionsList.map((completions, i) => {
      if (!completions || !completions.length) return;
      return {
        completions,
        provider: this.providers[i],
        /* the currently matched "command" the completer tried to complete
         * we pass this through so that Autocomplete can figure out when to
         * re-show itself once hidden.
         */
        command: this.providers[i].getCurrentCommand(query, selection, force)
      };
    }).filter(Boolean);
  }
}
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/SdkConfig.ts
var SdkConfig = __webpack_require__(374312);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/rooms/Autocomplete.tsx

var Autocomplete_dec, Autocomplete_class;
/*
Copyright 2016 Aviral Dasgupta
Copyright 2017 New Vector Ltd

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/













const MAX_PROVIDER_MATCHES = 20;
const generateCompletionDomId = number => `mx_Autocomplete_Completion_${number}`;
let Autocomplete = (Autocomplete_dec = (0,replaceableComponent/* replaceableComponent */.U)("views.rooms.Autocomplete"), Autocomplete_dec(Autocomplete_class = class Autocomplete extends react.PureComponent {
  constructor(props) {
    super(props);
    (0,defineProperty/* default */.Z)(this, "autocompleter", void 0);
    (0,defineProperty/* default */.Z)(this, "queryRequested", void 0);
    (0,defineProperty/* default */.Z)(this, "debounceCompletionsRequest", void 0);
    (0,defineProperty/* default */.Z)(this, "containerRef", /*#__PURE__*/(0,react.createRef)());
    (0,defineProperty/* default */.Z)(this, "hide", () => {
      this.setState({
        hide: true,
        selectionOffset: 1,
        completions: [],
        completionList: []
      });
    });
    (0,defineProperty/* default */.Z)(this, "onConfirmCompletion", () => {
      this.onCompletionClicked(this.state.selectionOffset);
    });
    (0,defineProperty/* default */.Z)(this, "onCompletionClicked", selectionOffset => {
      const count = this.countCompletions();
      if (count === 0 || selectionOffset < 1 || selectionOffset > count) {
        return false;
      }
      this.props.onConfirm(this.state.completionList[selectionOffset - 1]);
      this.hide();
      return true;
    });
    this.autocompleter = new Autocompleter(props.room);
    this.state = {
      // list of completionResults, each containing completions
      completions: [],
      // array of completions, so we can look up current selection by offset quickly
      completionList: [],
      // how far down the completion list we are (THIS IS 1-INDEXED!)
      selectionOffset: 1,
      // whether we should show completions if they're available
      shouldShowCompletions: true,
      hide: false,
      forceComplete: false
    };
  }
  componentDidMount() {
    this.applyNewProps();
  }
  applyNewProps(oldQuery, oldRoom) {
    if (oldRoom && this.props.room.roomId !== oldRoom.roomId) {
      this.autocompleter.destroy();
      this.autocompleter = new Autocompleter(this.props.room);
    }

    // Query hasn't changed so don't try to complete it
    if (oldQuery === this.props.query) {
      return;
    }
    this.complete(this.props.query, this.props.selection);
  }
  componentWillUnmount() {
    this.autocompleter.destroy();
  }
  complete(query, selection) {
    this.queryRequested = query;
    if (this.debounceCompletionsRequest) {
      clearTimeout(this.debounceCompletionsRequest);
    }
    if (query === "") {
      this.setState({
        // Clear displayed completions
        completions: [],
        completionList: [],
        // Reset selected completion
        selectionOffset: 1,
        // Hide the autocomplete box
        hide: true
      });
      return Promise.resolve(null);
    }
    let autocompleteDelay = SettingsStore/* default */.C.getValue("autocompleteDelay");

    // Don't debounce if we are already showing completions
    if (this.state.completions.length > 0 || this.state.forceComplete) {
      autocompleteDelay = 0;
    }
    return new Promise(resolve => {
      this.debounceCompletionsRequest = setTimeout(() => {
        resolve(this.processQuery(query, selection));
      }, autocompleteDelay);
    });
  }
  processQuery(query, selection) {
    return this.autocompleter.getCompletions(query, selection, this.state.forceComplete, MAX_PROVIDER_MATCHES).then(completions => {
      // Only ever process the completions for the most recent query being processed
      if (query !== this.queryRequested) {
        return;
      }
      if (completions) {
        let roomItem;
        let userCompletions;
        for (const item of completions) {
          if (item.provider instanceof UserProvider) {
            userCompletions = item;
            const index = item.completions.findIndex(item => item.completionId === MatrixClientPeg/* MatrixClientPeg */.p.get().getUserId());
            if (index !== -1) {
              item.completions.splice(index, 1);
            }
          } else if (item.provider instanceof NotifProvider) {
            const index = item.completions.findIndex(
            // (item) => item.completionId === "@room"
            item => item.completionId === this.props.room.roomId);
            if (index !== -1) {
              roomItem = {
                index,
                completion: item
              };
            }
          }
        }
        if (roomItem && userCompletions) {
          const tmpItem = roomItem.completion.completions.splice(roomItem.index, 1)[0];
          userCompletions.completions.unshift(tmpItem);
        }
      }
      this.processCompletions(completions);
    });
  }
  processCompletions(completions) {
    const completionList = (0,flatMap/* default */.Z)(completions, provider => provider.completions);

    // Reset selection when completion list becomes empty.
    let selectionOffset = 1;
    if (completionList.length > 0) {
      /* If the currently selected completion is still in the completion list,
       try to find it and jump to it. If not, select composer.
       */
      const currentSelection = this.state.selectionOffset <= 1 ? null : this.state.completionList[this.state.selectionOffset - 1].completion;
      selectionOffset = completionList.findIndex(completion => completion.completion === currentSelection);
      if (selectionOffset === -1) {
        selectionOffset = 1;
      } else {
        selectionOffset++; // selectionOffset is 1-indexed!
      }
    }

    let hide = true;
    // If `completion.command.command` is truthy, then a provider has matched with the query
    const anyMatches = completions.some(completion => !!completion.command.command);
    if (anyMatches) {
      hide = false;
      if (this.props.onSelectionChange) {
        this.props.onSelectionChange(selectionOffset - 1);
      }
    }
    this.setState({
      completions,
      completionList,
      selectionOffset,
      hide,
      // Force complete is turned off each time since we can't edit the query in that case
      forceComplete: false
    });
  }
  hasSelection() {
    return this.countCompletions() > 0 && this.state.selectionOffset !== 0;
  }
  countCompletions() {
    return this.state.completionList.length;
  }

  // called from MessageComposerInput
  moveSelection(delta) {
    const completionCount = this.countCompletions();
    if (completionCount === 0) return; // there are no items to move the selection through

    // Note: selectionOffset 0 represents the unsubstituted text, while 1 means first pill selected
    const index = (this.state.selectionOffset + delta + completionCount - 1) % completionCount;
    this.setSelection(1 + index);
  }
  onEscape(e) {
    const completionCount = this.countCompletions();
    if (completionCount === 0) {
      // autocomplete is already empty, so don't preventDefault
      return;
    }
    e.preventDefault();

    // selectionOffset = 0, so we don't end up completing when autocomplete is hidden
    this.hide();
  }
  forceComplete() {
    return new Promise(resolve => {
      this.setState({
        forceComplete: true,
        hide: false
      }, () => {
        this.complete(this.props.query, this.props.selection).then(() => {
          resolve(this.countCompletions());
        });
      });
    });
  }
  setSelection(selectionOffset) {
    this.setState({
      selectionOffset,
      hide: false
    });
    if (this.props.onSelectionChange) {
      this.props.onSelectionChange(selectionOffset - 1);
    }
  }
  componentDidUpdate(prevProps) {
    this.applyNewProps(prevProps.query, prevProps.room);
    // this is the selected completion, so scroll it into view if needed
    const selectedCompletion = this.refs[`completion${this.state.selectionOffset}`];
    if (selectedCompletion) {
      selectedCompletion.scrollIntoView({
        behavior: "auto",
        block: "nearest"
      });
    } else if (this.containerRef.current) {
      this.containerRef.current.scrollTo({
        top: 0
      });
    }
  }
  render() {
    let position = 1;
    const UNABLE_FUN_PERMISSION = SdkConfig/* default */.Z.get("UNABLE_FUN_PERMISSION");
    const renderedCompletions = this.state.completions.map((completionResult, i) => {
      const bothUserAndRoom = completionResult.completions.length > 1 && completionResult.completions[0].completionId === this.props.room.roomId;
      const completions = completionResult.completions.map((completion, j) => {
        const selected = position === this.state.selectionOffset;
        const className = classnames_default()("mx_Autocomplete_Completion", {
          selected,
          mx_Autocomplete_Completion_user_room: bothUserAndRoom && completion.completionId === this.props.room.roomId
        });
        const componentPosition = position;
        position++;
        const onClick = () => {
          this.onCompletionClicked(componentPosition);
        };
        return /*#__PURE__*/react.cloneElement(completion.component, {
          key: j,
          ref: `completion${componentPosition}`,
          id: generateCompletionDomId(componentPosition - 1),
          // 0 index the completion IDs
          className,
          onClick,
          "aria-selected": selected
        });
      });
      if (completionResult.provider instanceof CommandProvider && !UNABLE_FUN_PERMISSION) {
        return null;
      }
      return completions.length > 0 ? /*#__PURE__*/react.createElement("div", {
        key: i,
        className: "mx_Autocomplete_ProviderSection",
        role: "presentation"
      }, /*#__PURE__*/react.createElement("div", {
        className: "mx_Autocomplete_provider_name"
      }, bothUserAndRoom ? (0,languageHandler._t)("Room Notification") : completionResult.provider.getName()), completionResult.provider.renderCompletions(completions)) : null;
    }).filter(completion => !!completion);
    return !this.state.hide && renderedCompletions.length > 0 ? /*#__PURE__*/react.createElement("div", {
      id: "mx_Autocomplete",
      className: "mx_Autocomplete",
      ref: this.containerRef,
      role: "listbox"
    }, renderedCompletions) : null;
  }
}) || Autocomplete_class);

// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/editor/deserialize.ts
var deserialize = __webpack_require__(906087);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/TypingStore.ts
var TypingStore = __webpack_require__(423040);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/Keyboard.ts
var Keyboard = __webpack_require__(389310);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/elements/AccessibleTooltipButton.tsx
var AccessibleTooltipButton = __webpack_require__(717919);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/rooms/MessageComposerFormatBar.tsx

var MessageComposerFormatBar_dec, MessageComposerFormatBar_class;
/*
Copyright 2019 - 2021 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/






let Formatting = /*#__PURE__*/function (Formatting) {
  Formatting["Bold"] = "bold";
  Formatting["Italics"] = "italics";
  Formatting["Strikethrough"] = "strikethrough";
  Formatting["Code"] = "code";
  Formatting["Quote"] = "quote";
  return Formatting;
}({});
let MessageComposerFormatBar = (MessageComposerFormatBar_dec = (0,replaceableComponent/* replaceableComponent */.U)("views.rooms.MessageComposerFormatBar"), MessageComposerFormatBar_dec(MessageComposerFormatBar_class = class MessageComposerFormatBar extends react.PureComponent {
  constructor(props) {
    super(props);
    (0,defineProperty/* default */.Z)(this, "formatBarRef", /*#__PURE__*/(0,react.createRef)());
    this.state = {
      visible: false
    };
  }
  render() {
    const classes = classnames_default()("mx_MessageComposerFormatBar", {
      "mx_MessageComposerFormatBar_shown": this.state.visible
    });
    return /*#__PURE__*/react.createElement("div", {
      className: classes,
      ref: this.formatBarRef
    }, /*#__PURE__*/react.createElement(FormatButton, {
      label: (0,languageHandler._t)("Bold"),
      onClick: () => this.props.onAction(Formatting.Bold),
      icon: "Bold",
      shortcut: this.props.shortcuts.bold,
      visible: this.state.visible
    }), /*#__PURE__*/react.createElement(FormatButton, {
      label: (0,languageHandler._t)("Italics"),
      onClick: () => this.props.onAction(Formatting.Italics),
      icon: "Italic",
      shortcut: this.props.shortcuts.italics,
      visible: this.state.visible
    }), /*#__PURE__*/react.createElement(FormatButton, {
      label: (0,languageHandler._t)("Strikethrough"),
      onClick: () => this.props.onAction(Formatting.Strikethrough),
      icon: "Strikethrough",
      visible: this.state.visible
    }), /*#__PURE__*/react.createElement(FormatButton, {
      label: (0,languageHandler._t)("Code block"),
      onClick: () => this.props.onAction(Formatting.Code),
      icon: "Code",
      visible: this.state.visible
    }), /*#__PURE__*/react.createElement(FormatButton, {
      label: (0,languageHandler._t)("Quote"),
      onClick: () => this.props.onAction(Formatting.Quote),
      icon: "Quote",
      shortcut: this.props.shortcuts.quote,
      visible: this.state.visible
    }));
  }
  showAt(selectionRect) {
    if (!this.formatBarRef.current) return;
    this.setState({
      visible: true
    });
    const parentRect = this.formatBarRef.current.parentElement.getBoundingClientRect();
    this.formatBarRef.current.style.left = `${selectionRect.left - parentRect.left}px`;
    // 12 is half the height of the bar (e.g. to center it) and 16 is an offset that felt ok.
    this.formatBarRef.current.style.top = `${selectionRect.top - parentRect.top - 16 - 12}px`;
  }
  hide() {
    this.setState({
      visible: false
    });
  }
}) || MessageComposerFormatBar_class);

class FormatButton extends react.PureComponent {
  render() {
    const className = `mx_MessageComposerFormatBar_button mx_MessageComposerFormatBar_buttonIcon${this.props.icon}`;
    let shortcut;
    if (this.props.shortcut) {
      shortcut = /*#__PURE__*/react.createElement("div", {
        className: "mx_MessageComposerFormatBar_tooltipShortcut"
      }, this.props.shortcut);
    }
    const tooltip = /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement("div", {
      className: "mx_Tooltip_title"
    }, this.props.label), /*#__PURE__*/react.createElement("div", {
      className: "mx_Tooltip_sub"
    }, shortcut));
    return /*#__PURE__*/react.createElement(AccessibleTooltipButton/* default */.Z, {
      element: "button",
      type: "button",
      onClick: this.props.onClick,
      title: this.props.label,
      tooltip: tooltip,
      className: className
    });
  }
}
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/KeyBindingsManager.ts + 1 modules
var KeyBindingsManager = __webpack_require__(481493);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/utils/units.ts
var units = __webpack_require__(612559);
// EXTERNAL MODULE: ./node_modules/sendingme-ui/dist/index.js
var dist = __webpack_require__(602271);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/settings/GlobalConfig.ts
var GlobalConfig = __webpack_require__(2902);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/rooms/BasicMessageComposer.tsx

var BasicMessageComposer_dec, BasicMessageComposer_class;
/*
Copyright 2019 - 2021 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

























// matches emoticons which follow the start of a line or whitespace
const REGEX_EMOTICON_WHITESPACE = new RegExp("(?:^|\\s)(" + (emoticon_default()).source + ")\\s|:^$");
const REGEX_EMOTICON = new RegExp("(?:^|\\s)(" + (emoticon_default()).source + ")$");
const IS_MAC = navigator.platform.indexOf("Mac") !== -1;
const SURROUND_WITH_CHARACTERS = ['"', "_", "`", "'", "*", "~", "$"];
const SURROUND_WITH_DOUBLE_CHARACTERS = new Map([["(", ")"], ["[", "]"], ["{", "}"], ["<", ">"]]);
function ctrlShortcutLabel(key) {
  return (IS_MAC ? "⌘" : "Ctrl") + "+" + key;
}
function cloneSelection(selection) {
  return {
    anchorNode: selection.anchorNode,
    anchorOffset: selection.anchorOffset,
    focusNode: selection.focusNode,
    focusOffset: selection.focusOffset,
    isCollapsed: selection.isCollapsed,
    rangeCount: selection.rangeCount,
    type: selection.type
  };
}
function selectionEquals(a, b) {
  return a.anchorNode === b.anchorNode && a.anchorOffset === b.anchorOffset && a.focusNode === b.focusNode && a.focusOffset === b.focusOffset && a.isCollapsed === b.isCollapsed && a.rangeCount === b.rangeCount && a.type === b.type;
}
let BasicMessageEditor = (BasicMessageComposer_dec = (0,replaceableComponent/* replaceableComponent */.U)("views.rooms.BasicMessageEditor"), BasicMessageComposer_dec(BasicMessageComposer_class = class BasicMessageEditor extends react.Component {
  constructor(props) {
    super(props);
    (0,defineProperty/* default */.Z)(this, "MAX_INPUT_LENGTH", GlobalConfig/* GlobalConfig */.Q.MaxTextLength);
    (0,defineProperty/* default */.Z)(this, "editorRef", /*#__PURE__*/(0,react.createRef)());
    (0,defineProperty/* default */.Z)(this, "editorWrapper", /*#__PURE__*/(0,react.createRef)());
    (0,defineProperty/* default */.Z)(this, "autocompleteRef", /*#__PURE__*/(0,react.createRef)());
    (0,defineProperty/* default */.Z)(this, "formatBarRef", /*#__PURE__*/(0,react.createRef)());
    (0,defineProperty/* default */.Z)(this, "modifiedFlag", false);
    (0,defineProperty/* default */.Z)(this, "isIMEComposing", false);
    (0,defineProperty/* default */.Z)(this, "hasTextSelected", false);
    (0,defineProperty/* default */.Z)(this, "_isCaretAtEnd", void 0);
    (0,defineProperty/* default */.Z)(this, "lastCaret", void 0);
    (0,defineProperty/* default */.Z)(this, "lastSelection", void 0);
    (0,defineProperty/* default */.Z)(this, "emoticonSettingHandle", void 0);
    (0,defineProperty/* default */.Z)(this, "shouldShowPillAvatarSettingHandle", void 0);
    (0,defineProperty/* default */.Z)(this, "surroundWithHandle", void 0);
    (0,defineProperty/* default */.Z)(this, "historyManager", new HistoryManager());
    (0,defineProperty/* default */.Z)(this, "updateEditorState", (selection, inputType, diff) => {
      (0,render/* renderModel */.EP)(this.editorRef.current, this.props.model);
      if (selection) {
        // set the caret/selection
        try {
          setSelection(this.editorRef.current, this.props.model, selection);
        } catch (err) {
          console.error(err);
        }
        // if caret selection is a range, take the end position
        const position = selection instanceof range/* default */.Z ? selection.end : selection;
        this.setLastCaretFromPosition(position);
      }
      const {
        isEmpty
      } = this.props.model;
      if (this.props.placeholder) {
        if (isEmpty) {
          this.showPlaceholder();
        } else {
          this.hidePlaceholder();
        }
      }
      if (isEmpty) {
        this.formatBarRef.current.hide();
      }
      this.setState({
        autoComplete: this.props.model.autoComplete,
        // if a change is happening then clear the showVisualBell
        showVisualBell: diff ? false : this.state.showVisualBell
      });
      this.historyManager.tryPush(this.props.model, selection, inputType, diff);
      let isTyping = !this.props.model.isEmpty;
      // If the user is entering a command, only consider them typing if it is one which sends a message into the room
      if (isTyping && this.props.model.parts[0].type === "command") {
        const {
          cmd
        } = (0,SlashCommands/* parseCommandString */.dV)(this.props.model.parts[0].text);
        const command = SlashCommands/* CommandMap */.QQ.get(cmd);
        if (!command || !command.isEnabled() || command.category !== SlashCommands/* CommandCategories */.Mv.messages) {
          isTyping = false;
        }
      }
      TypingStore/* default */.Z.sharedInstance().setSelfTyping(this.props.room.roomId, isTyping);
      if (this.props.onChange) {
        this.props.onChange();
      }
    });
    (0,defineProperty/* default */.Z)(this, "onCompositionStart", () => {
      this.isIMEComposing = true;
      // even if the model is empty, the composition text shouldn't be mixed with the placeholder
      this.hidePlaceholder();
    });
    (0,defineProperty/* default */.Z)(this, "onCompositionEnd", () => {
      this.isIMEComposing = false;
      // some browsers (Chrome) don't fire an input event after ending a composition,
      // so trigger a model update after the composition is done by calling the input handler.

      // however, modifying the DOM (caused by the editor model update) from the compositionend handler seems
      // to confuse the IME in Chrome, likely causing https://github.com/vector-im/element-web/issues/10913 ,
      // so we do it async

      // however, doing this async seems to break things in Safari for some reason, so browser sniff.

      const ua = navigator.userAgent.toLowerCase();
      const isSafari = ua.includes("safari/") && !ua.includes("chrome/");
      if (isSafari) {
        this.onInput({
          inputType: "insertCompositionText"
        });
      } else {
        Promise.resolve().then(() => {
          this.onInput({
            inputType: "insertCompositionText"
          });
        });
      }
    });
    (0,defineProperty/* default */.Z)(this, "onCutCopy", (event, type) => {
      const selection = document.getSelection();
      const text = selection.toString();
      if (text) {
        const {
          model
        } = this.props;
        const range = (0,dom/* getRangeForSelection */.gK)(this.editorRef.current, model, selection);
        const selectedParts = range.parts.map(p => p.serialize());
        event.clipboardData.setData("application/x-element-composer", JSON.stringify(selectedParts));
        event.clipboardData.setData("text/plain", text); // so plain copy/paste works
        if (type === "cut") {
          // Remove the text, updating the model as appropriate
          this.modifiedFlag = true;
          replaceRangeAndMoveCaret(range, []);
        }
        event.preventDefault();
      }
    });
    (0,defineProperty/* default */.Z)(this, "onCopy", event => {
      this.onCutCopy(event, "copy");
    });
    (0,defineProperty/* default */.Z)(this, "onCut", event => {
      this.onCutCopy(event, "cut");
    });
    (0,defineProperty/* default */.Z)(this, "onPaste", event => {
      event.preventDefault(); // we always handle the paste ourselves
      if (this.props.onPaste && this.props.onPaste(event, this.props.model)) {
        // to prevent double handling, allow props.onPaste to skip internal onPaste
        return true;
      }
      const {
        model
      } = this.props;
      const {
        partCreator
      } = model;
      const partsText = event.clipboardData.getData("application/x-element-composer");
      let parts;
      if (partsText) {
        const serializedTextParts = JSON.parse(partsText);
        const deserializedParts = serializedTextParts.map(p => partCreator.deserializePart(p));
        parts = deserializedParts;
      } else {
        const text = event.clipboardData.getData("text/plain");
        parts = (0,deserialize/* parsePlainTextMessage */.R)(text, partCreator);
      }
      this.modifiedFlag = true;
      const sel = document.getSelection();
      const range = (0,dom/* getRangeForSelection */.gK)(this.editorRef.current, model, sel);
      // const { text } = getCaretOffsetAndText(this.editorRef.current, sel);
      // const newLength = parts.reduce(
      //     (sum, part) => sum + part.text.length,
      //     text.length - range.length,
      // );
      // if (newLength > this.MAX_INPUT_LENGTH) {
      //     return;
      // }
      replaceRangeAndMoveCaret(range, parts);
    });
    (0,defineProperty/* default */.Z)(this, "onInput", event => {
      // ignore any input while doing IME compositions
      if (this.isIMEComposing) {
        return;
      }
      this.modifiedFlag = true;
      const sel = document.getSelection();
      let {
        caret,
        text
      } = (0,dom/* getCaretOffsetAndText */.Aq)(this.editorRef.current, sel);
      const lastLength = this.props.model.parts.reduce((sum, part) => sum + part.text.length, 0);
      if (text.length > this.MAX_INPUT_LENGTH && lastLength < text.length) {
        const caretPosition = this.props.model.positionForOffset(caret.offset - (text.length - lastLength), caret.atNodeEnd);
        this.updateEditorState(caretPosition);
        return;
      }
      if (event.inputType === "insertLineBreak") {
        text = text.replace(/\n{2,}$/, "\n");
      }
      this.props.model.update(text, event.inputType, caret);
    });
    (0,defineProperty/* default */.Z)(this, "onBlur", () => {
      document.removeEventListener("selectionchange", this.onSelectionChange);
    });
    (0,defineProperty/* default */.Z)(this, "onFocus", () => {
      if (this.props.room.slowModeCounting) {
        dist.SdMessage.warning("Sending too quickly");
        return;
      }
      document.addEventListener("selectionchange", this.onSelectionChange);
      // force to recalculate
      this.lastSelection = null;
      this.refreshLastCaretIfNeeded();
    });
    (0,defineProperty/* default */.Z)(this, "onSelectionChange", () => {
      const {
        isEmpty
      } = this.props.model;
      this.refreshLastCaretIfNeeded();
      const selection = document.getSelection();
      if (this.hasTextSelected && selection.isCollapsed) {
        this.hasTextSelected = false;
        if (this.formatBarRef.current) {
          this.formatBarRef.current.hide();
        }
      } else if (!selection.isCollapsed && !isEmpty) {
        this.hasTextSelected = true;
        if (this.formatBarRef.current) {
          const selectionRect = selection.getRangeAt(0).getBoundingClientRect();
          this.formatBarRef.current.showAt(selectionRect);
        }
      }
    });
    (0,defineProperty/* default */.Z)(this, "onKeyDown", event => {
      var _model$autoComplete;
      const model = this.props.model;
      let handled = false;
      if (this.state.surroundWith && document.getSelection().type !== "Caret") {
        // This surrounds the selected text with a character. This is
        // intentionally left out of the keybinding manager as the keybinds
        // here shouldn't be changeable

        const selectionRange = (0,dom/* getRangeForSelection */.gK)(this.editorRef.current, this.props.model, document.getSelection());
        // trim the range as we want it to exclude leading/trailing spaces
        selectionRange.trim();
        if ([...SURROUND_WITH_DOUBLE_CHARACTERS.keys(), ...SURROUND_WITH_CHARACTERS].includes(event.key)) {
          this.historyManager.ensureLastChangesPushed(this.props.model);
          this.modifiedFlag = true;
          toggleInlineFormat(selectionRange, event.key, SURROUND_WITH_DOUBLE_CHARACTERS.get(event.key));
          handled = true;
        }
      }
      const autocompleteAction = (0,KeyBindingsManager/* getKeyBindingsManager */.zL)().getAutocompleteAction(event);
      if ((_model$autoComplete = model.autoComplete) !== null && _model$autoComplete !== void 0 && _model$autoComplete.hasCompletions()) {
        const autoComplete = model.autoComplete;
        switch (autocompleteAction) {
          case KeyBindingsManager/* AutocompleteAction */.eD.ForceComplete:
          case KeyBindingsManager/* AutocompleteAction */.eD.Complete:
            autoComplete.confirmCompletion();
            handled = true;
            break;
          case KeyBindingsManager/* AutocompleteAction */.eD.PrevSelection:
            autoComplete.selectPreviousSelection();
            handled = true;
            break;
          case KeyBindingsManager/* AutocompleteAction */.eD.NextSelection:
            autoComplete.selectNextSelection();
            handled = true;
            break;
          case KeyBindingsManager/* AutocompleteAction */.eD.Cancel:
            autoComplete.onEscape(event);
            handled = true;
            break;
          default:
            return;
          // don't preventDefault on anything else
        }
      } else if (autocompleteAction === KeyBindingsManager/* AutocompleteAction */.eD.ForceComplete && !this.state.showVisualBell) {
        // there is no current autocomplete window, try to open it
        this.tabCompleteName();
        handled = true;
      } else if (event.key === Keyboard/* Key */.sr.BACKSPACE || event.key === Keyboard/* Key */.sr.DELETE) {
        this.formatBarRef.current.hide();
      }
      if (handled) {
        event.preventDefault();
        event.stopPropagation();
        return;
      }
      const action = (0,KeyBindingsManager/* getKeyBindingsManager */.zL)().getMessageComposerAction(event);
      switch (action) {
        case KeyBindingsManager/* MessageComposerAction */.XE.FormatBold:
          this.onFormatAction(Formatting.Bold);
          handled = true;
          break;
        case KeyBindingsManager/* MessageComposerAction */.XE.FormatItalics:
          this.onFormatAction(Formatting.Italics);
          handled = true;
          break;
        case KeyBindingsManager/* MessageComposerAction */.XE.FormatQuote:
          this.onFormatAction(Formatting.Quote);
          handled = true;
          break;
        case KeyBindingsManager/* MessageComposerAction */.XE.EditRedo:
          if (this.historyManager.canRedo()) {
            const {
              parts,
              caret
            } = this.historyManager.redo();
            // pass matching inputType so historyManager doesn't push echo
            // when invoked from rerender callback.
            model.reset(parts, caret, "historyRedo");
          }
          handled = true;
          break;
        case KeyBindingsManager/* MessageComposerAction */.XE.EditUndo:
          if (this.historyManager.canUndo()) {
            const {
              parts,
              caret
            } = this.historyManager.undo(this.props.model);
            // pass matching inputType so historyManager doesn't push echo
            // when invoked from rerender callback.
            model.reset(parts, caret, "historyUndo");
          }
          handled = true;
          break;
        case KeyBindingsManager/* MessageComposerAction */.XE.NewLine:
          this.insertText("\n");
          handled = true;
          break;
        case KeyBindingsManager/* MessageComposerAction */.XE.MoveCursorToStart:
          setSelection(this.editorRef.current, model, {
            index: 0,
            offset: 0
          });
          handled = true;
          break;
        case KeyBindingsManager/* MessageComposerAction */.XE.MoveCursorToEnd:
          setSelection(this.editorRef.current, model, {
            index: model.parts.length - 1,
            offset: model.parts[model.parts.length - 1].text.length
          });
          handled = true;
          break;
      }
      if (handled) {
        event.preventDefault();
        event.stopPropagation();
      }
    });
    (0,defineProperty/* default */.Z)(this, "onAutoCompleteConfirm", completion => {
      var _completion$completio;
      this.modifiedFlag = true;
      const {
        text
      } = (0,dom/* getCaretOffsetAndText */.Aq)(this.editorRef.current, document.getSelection());
      if (text.length + ((_completion$completio = completion.completion) === null || _completion$completio === void 0 ? void 0 : _completion$completio.length) + 1 > this.MAX_INPUT_LENGTH) {
        return;
      }
      this.props.model.autoComplete.onComponentConfirm(completion);
    });
    (0,defineProperty/* default */.Z)(this, "onAutoCompleteSelectionChange", completionIndex => {
      this.modifiedFlag = true;
      this.setState({
        completionIndex
      });
    });
    (0,defineProperty/* default */.Z)(this, "configureEmoticonAutoReplace", () => {
      this.props.model.setTransformCallback(this.transform);
    });
    (0,defineProperty/* default */.Z)(this, "configureShouldShowPillAvatar", () => {
      const showPillAvatar = SettingsStore/* default */.C.getValue("Pill.shouldShowPillAvatar");
      this.setState({
        showPillAvatar
      });
    });
    (0,defineProperty/* default */.Z)(this, "surroundWithSettingChanged", () => {
      const surroundWith = SettingsStore/* default */.C.getValue("MessageComposerInput.surroundWith");
      this.setState({
        surroundWith
      });
    });
    (0,defineProperty/* default */.Z)(this, "transform", documentPosition => {
      const shouldReplace = SettingsStore/* default */.C.getValue("MessageComposerInput.autoReplaceEmoji");
      if (shouldReplace) this.replaceEmoticon(documentPosition, REGEX_EMOTICON_WHITESPACE);
    });
    (0,defineProperty/* default */.Z)(this, "onFormatAction", action => {
      const range = (0,dom/* getRangeForSelection */.gK)(this.editorRef.current, this.props.model, document.getSelection());
      // trim the range as we want it to exclude leading/trailing spaces
      range.trim();
      if (range.length === 0) {
        return;
      }
      this.historyManager.ensureLastChangesPushed(this.props.model);
      this.modifiedFlag = true;
      switch (action) {
        case Formatting.Bold:
          toggleInlineFormat(range, "**");
          break;
        case Formatting.Italics:
          toggleInlineFormat(range, "_");
          break;
        case Formatting.Strikethrough:
          toggleInlineFormat(range, "<del>", "</del>");
          break;
        case Formatting.Code:
          formatRangeAsCode(range);
          break;
        case Formatting.Quote:
          formatRangeAsQuote(range);
          break;
      }
    });
    this.state = {
      showPillAvatar: SettingsStore/* default */.C.getValue("Pill.shouldShowPillAvatar"),
      surroundWith: SettingsStore/* default */.C.getValue("MessageComposerInput.surroundWith"),
      showVisualBell: false
    };
    this.emoticonSettingHandle = SettingsStore/* default */.C.watchSetting("MessageComposerInput.autoReplaceEmoji", null, this.configureEmoticonAutoReplace);
    this.configureEmoticonAutoReplace();
    this.shouldShowPillAvatarSettingHandle = SettingsStore/* default */.C.watchSetting("Pill.shouldShowPillAvatar", null, this.configureShouldShowPillAvatar);
    this.surroundWithHandle = SettingsStore/* default */.C.watchSetting("MessageComposerInput.surroundWith", null, this.surroundWithSettingChanged);
  }
  componentDidUpdate(prevProps) {
    // We need to re-check the placeholder when the enabled state changes because it causes the
    // placeholder element to remount, which gets rid of the `::before` class. Re-evaluating the
    // placeholder means we get a proper `::before` with the placeholder.
    const enabledChange = this.props.disabled !== prevProps.disabled;
    const placeholderChanged = this.props.placeholder !== prevProps.placeholder;
    if (this.props.placeholder && (placeholderChanged || enabledChange)) {
      const {
        isEmpty
      } = this.props.model;
      if (isEmpty) {
        this.showPlaceholder();
      } else {
        this.hidePlaceholder();
      }
    }
  }
  replaceEmoticon(caretPosition, regex) {
    const {
      model
    } = this.props;
    const range = model.startRange(caretPosition);
    // expand range max 8 characters backwards from caretPosition,
    // as a space to look for an emoticon
    let n = 8;
    range.expandBackwardsWhile((index, offset) => {
      const part = model.parts[index];
      n -= 1;
      return n >= 0 && [editor_parts/* Type */.Dy.Plain, editor_parts/* Type */.Dy.PillCandidate, editor_parts/* Type */.Dy.Newline].includes(part.type);
    });
    const emoticonMatch = regex.exec(range.text);
    if (emoticonMatch) {
      const query = emoticonMatch[1].replace("-", "");
      // try both exact match and lower-case, this means that xd won't match xD but :P will match :p
      const data = emoji/* EMOTICON_TO_EMOJI */.uZ.get(query) || emoji/* EMOTICON_TO_EMOJI */.uZ.get(query.toLowerCase());
      if (data) {
        const {
          partCreator
        } = model;
        const firstMatch = emoticonMatch[0];
        const moveStart = firstMatch[0] === " " ? 1 : 0;

        // we need the range to only comprise of the emoticon
        // because we'll replace the whole range with an emoji,
        // so move the start forward to the start of the emoticon.
        // Take + 1 because index is reported without the possible preceding space.
        range.moveStartForwards(emoticonMatch.index + moveStart);
        // If the end is a trailing space/newline move end backwards, so that we don't replace it
        if (["\n", " "].includes(firstMatch[firstMatch.length - 1])) {
          range.moveEndBackwards(1);
        }

        // this returns the amount of added/removed characters during the replace
        // so the caret position can be adjusted.
        return range.replace([partCreator.plain(data.unicode)]);
      }
    }
  }
  showPlaceholder() {
    // escape single quotes
    const placeholder = this.props.placeholder.replace(/'/g, "\\'");
    this.editorRef.current.style.setProperty("--placeholder", `'${placeholder}'`);
    this.editorRef.current.classList.add("mx_BasicMessageComposer_inputEmpty");
  }
  hidePlaceholder() {
    this.editorRef.current.classList.remove("mx_BasicMessageComposer_inputEmpty");
    this.editorRef.current.style.removeProperty("--placeholder");
  }
  isComposing(event) {
    // checking the event.isComposing flag just in case any browser out there
    // emits events related to the composition after compositionend
    // has been fired
    return !!(this.isIMEComposing || event.nativeEvent && event.nativeEvent.isComposing);
  }
  insertText(textToInsert, inputType = "insertText") {
    const sel = document.getSelection();
    const {
      caret,
      text
    } = (0,dom/* getCaretOffsetAndText */.Aq)(this.editorRef.current, sel);
    const newText = text.substr(0, caret.offset) + textToInsert + text.substr(caret.offset);
    if (newText.length > this.MAX_INPUT_LENGTH) {
      return;
    }
    caret.offset += textToInsert.length;
    this.modifiedFlag = true;
    this.props.model.update(newText, inputType, caret);
  }

  // this is used later to see if we need to recalculate the caret
  // on selectionchange. If it is just a consequence of typing
  // we don't need to. But if the user is navigating the caret without input
  // we need to recalculate it, to be able to know where to insert content after
  // losing focus
  setLastCaretFromPosition(position) {
    const {
      model
    } = this.props;
    this._isCaretAtEnd = position.isAtEnd(model);
    this.lastCaret = position.asOffset(model);
    this.lastSelection = cloneSelection(document.getSelection());
  }
  refreshLastCaretIfNeeded() {
    // XXX: needed when going up and down in editing messages ... not sure why yet
    // because the editors should stop doing this when when blurred ...
    // maybe it's on focus and the _editorRef isn't available yet or something.
    if (!this.editorRef.current) {
      return;
    }
    const selection = document.getSelection();
    if (!this.lastSelection || !selectionEquals(this.lastSelection, selection)) {
      this.lastSelection = cloneSelection(selection);
      const {
        caret,
        text
      } = (0,dom/* getCaretOffsetAndText */.Aq)(this.editorRef.current, selection);
      this.lastCaret = caret;
      this._isCaretAtEnd = caret.offset === text.length;
    }
    return this.lastCaret;
  }
  clearUndoHistory() {
    this.historyManager.clear();
  }
  getCaret() {
    return this.lastCaret;
  }
  isSelectionCollapsed() {
    return !this.lastSelection || this.lastSelection.isCollapsed;
  }
  isCaretAtStart() {
    return this.getCaret().offset === 0;
  }
  isCaretAtEnd() {
    return this._isCaretAtEnd;
  }
  async tabCompleteName() {
    try {
      await new Promise(resolve => this.setState({
        showVisualBell: false
      }, resolve));
      const {
        model
      } = this.props;
      const caret = this.getCaret();
      const position = model.positionForOffset(caret.offset, caret.atNodeEnd);
      const range = model.startRange(position);
      range.expandBackwardsWhile((index, offset, part) => {
        return part.text[offset] !== " " && part.text[offset] !== "+" && (part.type === editor_parts/* Type */.Dy.Plain || part.type === editor_parts/* Type */.Dy.PillCandidate || part.type === editor_parts/* Type */.Dy.Command);
      });
      const {
        partCreator
      } = model;
      // await for auto-complete to be open
      await model.transform(() => {
        const addedLen = range.replace([partCreator.pillCandidate(range.text)]);
        return model.positionForOffset(caret.offset + addedLen, true);
      });

      // Don't try to do things with the autocomplete if there is none shown
      if (model.autoComplete) {
        await model.autoComplete.startSelection();
        if (!model.autoComplete.hasSelection()) {
          this.setState({
            showVisualBell: true
          });
          model.autoComplete.close();
        }
      } else {
        this.setState({
          showVisualBell: true
        });
      }
    } catch (err) {
      console.error(err);
    }
  }
  isModified() {
    return this.modifiedFlag;
  }
  componentWillUnmount() {
    document.removeEventListener("selectionchange", this.onSelectionChange);
    this.editorRef.current.removeEventListener("input", this.onInput, true);
    this.editorRef.current.removeEventListener("compositionstart", this.onCompositionStart, true);
    this.editorRef.current.removeEventListener("compositionend", this.onCompositionEnd, true);
    SettingsStore/* default */.C.unwatchSetting(this.emoticonSettingHandle);
    SettingsStore/* default */.C.unwatchSetting(this.shouldShowPillAvatarSettingHandle);
    SettingsStore/* default */.C.unwatchSetting(this.surroundWithHandle);
  }
  componentDidMount() {
    const model = this.props.model;
    model.setUpdateCallback(this.updateEditorState);
    const partCreator = model.partCreator;
    // TODO: does this allow us to get rid of EditorStateTransfer?
    // not really, but we could not serialize the parts, and just change the autoCompleter
    partCreator.setAutoCompleteCreator((0,editor_parts/* getAutoCompleteCreator */.TX)(() => this.autocompleteRef.current, query => new Promise(resolve => this.setState({
      query
    }, resolve))));
    // initial render of model
    this.updateEditorState(this.getInitialCaretPosition());
    // attach input listener by hand so React doesn't proxy the events,
    // as the proxied event doesn't support inputType, which we need.
    this.editorRef.current.addEventListener("input", this.onInput, true);
    this.editorRef.current.addEventListener("compositionstart", this.onCompositionStart, true);
    this.editorRef.current.addEventListener("compositionend", this.onCompositionEnd, true);
    if (!(0,units/* isMobile */.tq)()) {
      this.editorRef.current.focus();
    }
  }
  getInitialCaretPosition() {
    let caretPosition;
    if (this.props.initialCaret) {
      // if restoring state from a previous editor,
      // restore caret position from the state
      const caret = this.props.initialCaret;
      caretPosition = this.props.model.positionForOffset(caret.offset, caret.atNodeEnd);
    } else {
      // otherwise, set it at the end
      caretPosition = this.props.model.getPositionAtEnd();
    }
    return caretPosition;
  }
  render() {
    let autoComplete;
    const room = this.props.room;
    if (this.state.autoComplete) {
      const query = this.state.query;
      const queryLen = query.length;
      autoComplete = /*#__PURE__*/react.createElement("div", {
        className: "mx_BasicMessageComposer_AutoCompleteWrapper"
      }, /*#__PURE__*/react.createElement(Autocomplete, {
        ref: this.autocompleteRef,
        query: query,
        onConfirm: this.onAutoCompleteConfirm,
        onSelectionChange: this.onAutoCompleteSelectionChange,
        selection: {
          beginning: true,
          end: queryLen,
          start: queryLen
        },
        room: room
      }));
    }
    const wrapperClasses = classnames_default()("mx_BasicMessageComposer", {
      mx_BasicMessageComposer_input_error: this.state.showVisualBell
    });
    const classes = classnames_default()("mx_BasicMessageComposer_input", {
      mx_BasicMessageComposer_input_shouldShowPillAvatar: this.state.showPillAvatar,
      mx_BasicMessageComposer_input_disabled: this.props.disabled
    });
    const shortcuts = {
      [Formatting.Bold]: ctrlShortcutLabel("B"),
      [Formatting.Italics]: ctrlShortcutLabel("I"),
      [Formatting.Quote]: ctrlShortcutLabel(">")
    };
    const {
      completionIndex
    } = this.state;
    const hasAutocomplete = Boolean(this.state.autoComplete);
    let activeDescendant;
    if (hasAutocomplete && completionIndex >= 0) {
      activeDescendant = generateCompletionDomId(completionIndex);
    }
    return /*#__PURE__*/react.createElement("div", {
      className: wrapperClasses
    }, autoComplete, /*#__PURE__*/react.createElement(MessageComposerFormatBar, {
      ref: this.formatBarRef,
      onAction: this.onFormatAction,
      shortcuts: shortcuts
    }), /*#__PURE__*/react.createElement("div", {
      className: "mx_BasicMessageComposer_input_wrapper",
      ref: this.editorWrapper
    }, this.props.prefix ? /*#__PURE__*/react.createElement("div", {
      className: "mx_BasicMessageComposer_input_prefix"
    }, this.props.prefix) : null, /*#__PURE__*/react.createElement("div", {
      className: classes,
      contentEditable: this.props.disabled ? null : true,
      tabIndex: 0,
      onBlur: this.onBlur,
      onFocus: this.onFocus,
      onCopy: this.onCopy,
      onCut: this.onCut,
      onPaste: this.onPaste,
      onKeyDown: this.onKeyDown,
      ref: this.editorRef,
      "aria-label": this.props.label,
      role: "textbox",
      "aria-multiline": "true",
      "aria-autocomplete": "list",
      "aria-haspopup": "listbox",
      "aria-expanded": hasAutocomplete,
      "aria-owns": "mx_Autocomplete",
      "aria-activedescendant": activeDescendant,
      dir: "auto",
      "aria-disabled": this.props.disabled
    })));
  }
  focus() {
    this.editorRef.current.focus();
  }
  blur() {
    this.editorRef.current.blur();
  }
  insertMention(userId) {
    this.modifiedFlag = true;
    const {
      model
    } = this.props;
    const {
      partCreator
    } = model;
    const member = this.props.room.getMember(userId);
    const displayName = member ? member.rawDisplayName : userId;
    const caret = this.getCaret();
    const position = model.positionForOffset(caret.offset, caret.atNodeEnd);
    // Insert suffix only if the caret is at the start of the composer
    const parts = partCreator.createMentionParts(false, displayName, userId);
    model.transform(() => {
      const addedLen = model.insert(parts, position);
      return model.positionForOffset(caret.offset + addedLen, true);
    });
    // refocus on composer, as we just clicked "Mention"
    this.focus();
  }
  insertQuotedMessage(event) {
    this.modifiedFlag = true;
    const {
      model
    } = this.props;
    const {
      partCreator
    } = model;
    const quoteParts = (0,deserialize/* parseEvent */.E)(event, partCreator, {
      isQuotedMessage: true
    });
    // add two newlines
    quoteParts.push(partCreator.newline());
    quoteParts.push(partCreator.newline());
    model.transform(() => {
      const addedLen = model.insert(quoteParts, model.positionForOffset(0));
      return model.positionForOffset(addedLen, true);
    });
    // refocus on composer, as we just clicked "Quote"
    this.focus();
  }
  insertPlaintext(text) {
    this.modifiedFlag = true;
    const {
      model
    } = this.props;
    const {
      partCreator
    } = model;
    const caret = this.getCaret();
    const position = model.positionForOffset(caret.offset, caret.atNodeEnd);
    model.transform(() => {
      const addedLen = model.insert([partCreator.plain(text)], position);
      return model.positionForOffset(caret.offset + addedLen, true);
    });
  }
}) || BasicMessageComposer_class);


/***/ }),

/***/ 539315:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Km: () => (/* binding */ EmojiButton),
  ZP: () => (/* binding */ MessageComposer)
});

// UNUSED EXPORTS: ImageType

// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/node_modules/@babel/runtime/helpers/esm/extends.js
var esm_extends = __webpack_require__(166644);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/node_modules/@babel/runtime/helpers/esm/defineProperty.js
var defineProperty = __webpack_require__(225259);
// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(667294);
// EXTERNAL MODULE: ./node_modules/classnames/index.js
var classnames = __webpack_require__(294184);
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/languageHandler.tsx
var languageHandler = __webpack_require__(867614);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/MatrixClientPeg.ts + 3 modules
var src_MatrixClientPeg = __webpack_require__(933393);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/dispatcher/dispatcher.ts
var dispatcher = __webpack_require__(245539);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/utils/permalinks/Permalinks.ts
var Permalinks = __webpack_require__(954105);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/ContentMessages.tsx + 1 modules
var ContentMessages = __webpack_require__(601877);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/settings/SettingsStore.ts + 9 modules
var SettingsStore = __webpack_require__(571879);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/structures/ContextMenu.tsx + 6 modules
var ContextMenu = __webpack_require__(760172);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/RoomViewStore.tsx
var RoomViewStore = __webpack_require__(144332);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/utils/replaceableComponent.ts
var replaceableComponent = __webpack_require__(90287);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/rooms/ReplyTile.tsx
var ReplyTile = __webpack_require__(102766);
// EXTERNAL MODULE: ./node_modules/sendingme-ui/dist/index.js
var dist = __webpack_require__(602271);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/rooms/ReplyPreview.tsx

var _dec, _class;
/*
Copyright 2017 - 2021 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/







function cancelQuoting() {
  dispatcher/* default */.ZP.dispatch({
    action: "reply_to_event",
    event: null
  });
}
let ReplyPreview = (_dec = (0,replaceableComponent/* replaceableComponent */.U)("views.rooms.ReplyPreview"), _dec(_class = class ReplyPreview extends react.Component {
  constructor(props) {
    super(props);
    (0,defineProperty/* default */.Z)(this, "unmounted", false);
    (0,defineProperty/* default */.Z)(this, "roomStoreToken", void 0);
    (0,defineProperty/* default */.Z)(this, "onRoomViewStoreUpdate", () => {
      if (this.unmounted) return;
      const event = RoomViewStore/* default */.Z.getQuotingEvent();
      if (this.state.event !== event) {
        this.setState({
          event
        });
      }
    });
    this.state = {
      event: RoomViewStore/* default */.Z.getQuotingEvent()
    };
    this.roomStoreToken = RoomViewStore/* default */.Z.addListener(this.onRoomViewStoreUpdate);
  }
  componentWillUnmount() {
    this.unmounted = true;

    // Remove RoomStore listener
    if (this.roomStoreToken) {
      this.roomStoreToken.remove();
    }
  }
  render() {
    if (!this.state.event) return null;
    return /*#__PURE__*/react.createElement("div", {
      className: "mx_ReplyPreview"
    }, /*#__PURE__*/react.createElement("div", {
      className: "mx_ReplyPreview_section"
    }, /*#__PURE__*/react.createElement("div", {
      className: "mx_ReplyPreview_left_icon"
    }), /*#__PURE__*/react.createElement("blockquote", {
      className: "mx_ReplyThread",
      key: this.state.event.getId()
    }, /*#__PURE__*/react.createElement(ReplyTile/* default */.Z, {
      mxEvent: this.state.event,
      permalinkCreator: this.props.permalinkCreator
    })), /*#__PURE__*/react.createElement(dist.SdIcon, {
      className: "mx_ReplyPreview_cancel",
      icon: "CloseOutlines",
      onClick: cancelQuoting
    })));
  }
}) || _class);

// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/settings/UIFeature.ts
var UIFeature = __webpack_require__(187565);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/AsyncStore.ts
var AsyncStore = __webpack_require__(10879);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/audio/VoiceRecording.ts + 4 modules
var VoiceRecording = __webpack_require__(930764);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/utils/arrays.ts
var arrays = __webpack_require__(902232);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/audio_messages/Waveform.tsx
var Waveform = __webpack_require__(721303);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/utils/MarkedExecution.ts
var MarkedExecution = __webpack_require__(396274);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/audio_messages/LiveRecordingWaveform.tsx

var LiveRecordingWaveform_dec, LiveRecordingWaveform_class, _class2;
/*
Copyright 2021 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/







/**
 * A waveform which shows the waveform of a live recording
 */
let LiveRecordingWaveform = (LiveRecordingWaveform_dec = (0,replaceableComponent/* replaceableComponent */.U)("views.audio_messages.LiveRecordingWaveform"), LiveRecordingWaveform_dec(LiveRecordingWaveform_class = (_class2 = class LiveRecordingWaveform extends react.PureComponent {
  constructor(props) {
    super(props);
    (0,defineProperty/* default */.Z)(this, "waveform", []);
    (0,defineProperty/* default */.Z)(this, "scheduledUpdate", new MarkedExecution/* MarkedExecution */.x(() => this.updateWaveform(), () => requestAnimationFrame(() => this.scheduledUpdate.trigger())));
    this.state = {
      waveform: (0,arrays/* arraySeed */.Hf)(0, VoiceRecording/* RECORDING_PLAYBACK_SAMPLES */.K8)
    };
  }
  componentDidMount() {
    this.props.recorder.liveData.onUpdate(update => {
      // The incoming data is between zero and one, so we don't need to clamp/rescale it.
      this.waveform = (0,arrays/* arrayFastResample */.MO)(Array.from(update.waveform), VoiceRecording/* RECORDING_PLAYBACK_SAMPLES */.K8);
      this.scheduledUpdate.mark();
    });
  }
  updateWaveform() {
    this.setState({
      waveform: this.waveform
    });
  }
  render() {
    return /*#__PURE__*/react.createElement(Waveform/* default */.Z, {
      relHeights: this.state.waveform
    });
  }
}, (0,defineProperty/* default */.Z)(_class2, "defaultProps", {
  progress: 1
}), _class2)) || LiveRecordingWaveform_class);

// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/audio_messages/Clock.tsx
var Clock = __webpack_require__(634847);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/audio_messages/LiveRecordingClock.tsx

var LiveRecordingClock_dec, LiveRecordingClock_class;
/*
Copyright 2021 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/





/**
 * A clock for a live recording.
 */
let LiveRecordingClock = (LiveRecordingClock_dec = (0,replaceableComponent/* replaceableComponent */.U)("views.audio_messages.LiveRecordingClock"), LiveRecordingClock_dec(LiveRecordingClock_class = class LiveRecordingClock extends react.PureComponent {
  constructor(props) {
    super(props);
    (0,defineProperty/* default */.Z)(this, "seconds", 0);
    (0,defineProperty/* default */.Z)(this, "scheduledUpdate", new MarkedExecution/* MarkedExecution */.x(() => this.updateClock(), () => requestAnimationFrame(() => this.scheduledUpdate.trigger())));
    this.state = {
      seconds: 0
    };
  }
  componentDidMount() {
    this.props.recorder.liveData.onUpdate(update => {
      this.seconds = update.timeSeconds;
      this.scheduledUpdate.mark();
    });
  }
  updateClock() {
    this.setState({
      seconds: this.seconds
    });
  }
  render() {
    return /*#__PURE__*/react.createElement(Clock/* default */.Z, {
      seconds: this.state.seconds
    });
  }
}) || LiveRecordingClock_class);

// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/AsyncStoreWithClient.ts
var AsyncStoreWithClient = __webpack_require__(555371);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/stores/VoiceRecordingStore.ts

var VoiceRecordingStore_class;
/*
Copyright 2021 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/




class VoiceRecordingStore extends AsyncStoreWithClient/* AsyncStoreWithClient */._ {
  constructor() {
    super(dispatcher/* default */.ZP, {});
  }

  /**
   * Gets the active recording instance, if any.
   */
  get activeRecording() {
    return this.state.recording;
  }
  static get instance() {
    if (!VoiceRecordingStore.internalInstance) {
      VoiceRecordingStore.internalInstance = new VoiceRecordingStore();
    }
    return VoiceRecordingStore.internalInstance;
  }
  async onAction(payload) {
    // Nothing to do, but we're required to override the function
    return;
  }

  /**
   * Starts a new recording if one isn't already in progress. Note that this simply
   * creates a recording instance - whether or not recording is actively in progress
   * can be seen via the VoiceRecording class.
   * @returns {VoiceRecording} The recording.
   */
  startRecording() {
    if (!this.matrixClient) throw new Error("Cannot start a recording without a MatrixClient");
    if (this.state.recording) throw new Error("A recording is already in progress");
    const recording = new VoiceRecording/* VoiceRecording */.Yi(this.matrixClient);

    // noinspection JSIgnoredPromiseFromCall - we can safely run this async
    this.updateState({
      recording
    });
    return recording;
  }

  /**
   * Disposes of the current recording, no matter the state of it.
   * @returns {Promise<void>} Resolves when complete.
   */
  disposeRecording() {
    if (this.state.recording) {
      this.state.recording.destroy(); // stops internally
    }

    return this.updateState({
      recording: null
    });
  }
}
VoiceRecordingStore_class = VoiceRecordingStore;
(0,defineProperty/* default */.Z)(VoiceRecordingStore, "internalInstance", void 0);
window.mxVoiceRecordingStore = VoiceRecordingStore.instance;
// EXTERNAL MODULE: ./node_modules/matrix-js-sdk/src/@types/event.ts
var _types_event = __webpack_require__(907977);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/Modal.tsx + 1 modules
var Modal = __webpack_require__(241648);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/dialogs/ErrorDialog.tsx
var ErrorDialog = __webpack_require__(705636);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/MediaDeviceHandler.ts
var MediaDeviceHandler = __webpack_require__(710008);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/rooms/NotificationBadge.tsx
var NotificationBadge = __webpack_require__(565839);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/notifications/StaticNotificationState.ts
var StaticNotificationState = __webpack_require__(112544);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/notifications/NotificationColor.ts
var NotificationColor = __webpack_require__(634857);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/elements/InlineSpinner.tsx
var InlineSpinner = __webpack_require__(650193);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/audio/PlaybackManager.ts + 1 modules
var PlaybackManager = __webpack_require__(539379);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/utils/units.ts
var units = __webpack_require__(612559);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/utils/feature/isFeatureEnabled.ts
var feature_isFeatureEnabled = __webpack_require__(94948);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/defenderSettings/settingsStore.ts
var settingsStore = __webpack_require__(650478);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/rooms/VoiceRecordComposerTile.tsx

var VoiceRecordComposerTile_dec, VoiceRecordComposerTile_class;
/*
Copyright 2021 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/























/**
 * Container tile for rendering the voice message recorder in the composer.
 */
let VoiceRecordComposerTile = (VoiceRecordComposerTile_dec = (0,replaceableComponent/* replaceableComponent */.U)("views.rooms.VoiceRecordComposerTile"), VoiceRecordComposerTile_dec(VoiceRecordComposerTile_class = class VoiceRecordComposerTile extends react.PureComponent {
  constructor(props) {
    super(props);
    (0,defineProperty/* default */.Z)(this, "onCancel", async () => {
      await this.disposeRecording();
    });
    (0,defineProperty/* default */.Z)(this, "onRecordStartEndClick", async () => {
      if (this.props.disabled) return;
      if (this.state.recorder) {
        await this.state.recorder.stop();
        return;
      }

      // The "microphone access error" dialogs are used a lot, so let's functionify them
      const accessError = () => {
        Modal/* default */.Z.createTrackedDialog("Microphone Access Error", "", ErrorDialog/* default */.Z, {
          title: (0,languageHandler._t)("Unable to access your microphone"),
          description: /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("p", null, (0,languageHandler._t)("We were unable to access your microphone. Please check your browser settings and try again.")))
        });
      };

      // Do a sanity test to ensure we're about to grab a valid microphone reference. Things might
      // change between this and recording, but at least we will have tried.
      try {
        var _devices$MediaDeviceK;
        const devices = await MediaDeviceHandler/* default */.ZP.getDevices();
        if (!(devices !== null && devices !== void 0 && (_devices$MediaDeviceK = devices[MediaDeviceHandler/* MediaDeviceKindEnum */.C.AudioInput]) !== null && _devices$MediaDeviceK !== void 0 && _devices$MediaDeviceK.length)) {
          Modal/* default */.Z.createTrackedDialog("No Microphone Error", "", ErrorDialog/* default */.Z, {
            title: (0,languageHandler._t)("No microphone found"),
            description: /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("p", null, (0,languageHandler._t)("We didn't find a microphone on your device. Please check your settings and try again.")))
          });
          return;
        }
        // else we probably have a device that is good enough
      } catch (e) {
        console.error("Error getting devices: ", e);
        accessError();
        return;
      }
      try {
        // stop any noises which might be happening
        await PlaybackManager/* PlaybackManager */.r.instance.pauseAllExcept(null);
        const recorder = VoiceRecordingStore.instance.startRecording();
        await recorder.start();

        // We don't need to remove the listener: the recorder will clean that up for us.
        recorder.on(AsyncStore/* UPDATE_EVENT */.aY, ev => {
          if (ev === VoiceRecording/* RecordingState */.SR.EndingSoon) return; // ignore this state: it has no UI purpose here
          this.setState({
            recordingPhase: ev
          });
        });
        this.setState({
          recorder,
          recordingPhase: VoiceRecording/* RecordingState */.SR.Started
        });
      } catch (e) {
        console.error("Error starting recording: ", e);
        accessError();

        // noinspection ES6MissingAwait - if this goes wrong we don't want it to affect the call stack
        VoiceRecordingStore.instance.disposeRecording();
      }
    });
    this.state = {
      recorder: null // no recording started by default
    };
  }

  async componentWillUnmount() {
    await VoiceRecordingStore.instance.disposeRecording();
  }

  // called by composer
  async send() {
    if (!this.state.recorder) {
      throw new Error("No recording started - cannot send anything");
    }
    await this.state.recorder.stop();
    let upload;
    try {
      upload = await this.state.recorder.upload(this.props.room.roomId);
    } catch (e) {
      console.error("Error uploading voice message:", e);

      // Flag error and move on. The recording phase will be reset by the upload function.
      this.setState({
        didUploadFail: true
      });
      return; // don't dispose the recording: the user has a chance to re-upload
    }

    try {
      const content = {
        body: "Voice message",
        //"msgtype": "org.matrix.msc2516.voice",
        msgtype: _types_event/* MsgType */.Zw.Audio,
        url: upload.mxc,
        file: upload.encrypted,
        info: {
          duration: Math.round(this.state.recorder.durationSeconds * 1000),
          mimetype: this.state.recorder.contentType,
          size: this.state.recorder.contentLength
        },
        // MSC1767 + Ideals of MSC2516 as MSC3245
        // https://github.com/matrix-org/matrix-doc/pull/3245
        "org.matrix.msc1767.text": "Voice message",
        "org.matrix.msc1767.file": {
          url: upload.mxc,
          file: upload.encrypted,
          name: "Voice message.ogg",
          mimetype: this.state.recorder.contentType,
          size: this.state.recorder.contentLength
        },
        "org.matrix.msc1767.audio": {
          duration: Math.round(this.state.recorder.durationSeconds * 1000),
          // https://github.com/matrix-org/matrix-doc/pull/3246
          waveform: this.state.recorder.getPlayback().thumbnailWaveform.map(v => Math.round(v * 1024))
        },
        "org.matrix.msc3245.voice": {} // No content, this is a rendering hint
      };

      const isFeatureEnabled = (0,feature_isFeatureEnabled/* default */.Z)();
      if (isFeatureEnabled) {
        const {
          settings: settingsMap
        } = settingsStore/* useDefendSettingsStore */.IO.getState() || {};
        const {
          messageAliveSecond
        } = (settingsMap === null || settingsMap === void 0 ? void 0 : settingsMap.get(this.props.room.roomId)) || {};
        if (messageAliveSecond > 0) {
          content["messageAliveSecond"] = messageAliveSecond;
        }
      }

      // noinspection ES6MissingAwait - we don't care if it fails, it'll get queued.
      src_MatrixClientPeg/* MatrixClientPeg */.p.get().sendMessage(this.props.room.roomId, content);
    } catch (e) {
      console.error("Error sending voice message:", e);

      // Voice message should be in the timeline at this point, so let other things take care
      // of error handling. We also shouldn't need the recording anymore, so fall through to
      // disposal.
    }

    await this.disposeRecording();
  }
  async disposeRecording() {
    await VoiceRecordingStore.instance.disposeRecording();

    // Reset back to no recording, which means no phase (ie: restart component entirely)
    this.setState({
      recorder: null,
      recordingPhase: null,
      didUploadFail: false
    });
  }
  renderWaveformArea() {
    if (!this.state.recorder) return null; // no recorder means we're not recording: no waveform

    // if (this.state.recordingPhase !== RecordingState.Started) {
    //     return (
    //         <RecordingPlayback
    //             playback={this.state.recorder.getPlayback()}
    //         />
    //     );
    // }

    // only other UI is the recording-in-progress UI
    return /*#__PURE__*/react.createElement("div", {
      className: "mx_MediaBody mx_VoiceMessagePrimaryContainer mx_VoiceRecordComposerTile_recording"
    }, /*#__PURE__*/react.createElement(LiveRecordingClock, {
      recorder: this.state.recorder
    }), /*#__PURE__*/react.createElement(LiveRecordingWaveform, {
      recorder: this.state.recorder
    }));
  }
  render() {
    if (!this.state.recordingPhase) return null;

    // let stopBtn;
    let deleteButton;
    // if (this.state.recordingPhase === RecordingState.Started) {
    //     let tooltip = _t("Send voice message");
    //     if (!!this.state.recorder) {
    //         tooltip = _t("Stop recording");
    //     }

    //     stopBtn = (
    //         <AccessibleTooltipButton
    //             className="mx_VoiceRecordComposerTile_stop"
    //             onClick={this.onRecordStartEndClick}
    //             title={tooltip}
    //         />
    //     );
    //     if (this.state.recorder && !this.state.recorder?.isRecording) {
    //         stopBtn = null;
    //     }
    // }

    if (this.state.recorder && this.state.recordingPhase !== VoiceRecording/* RecordingState */.SR.Uploading) {
      deleteButton =
      /*#__PURE__*/
      // <AccessibleTooltipButton
      //     className="mx_VoiceRecordComposerTile_delete"
      //     title={_t("Delete")}
      //     onClick={this.onCancel}
      // >
      //     <SdIcon icon="DeleteOutLines" />
      // </AccessibleTooltipButton>
      react.createElement(dist.SdTooltip, {
        title: (0,languageHandler._t)("Delete"),
        placement: "top"
      }, /*#__PURE__*/react.createElement(dist.SdButton, {
        className: "mx_VoiceRecordComposerTile_delete",
        onClick: this.onCancel,
        icon: "DeleteOutLines"
      }));
    }
    let uploadIndicator;
    if (this.state.recordingPhase === VoiceRecording/* RecordingState */.SR.Uploading) {
      uploadIndicator = /*#__PURE__*/react.createElement("span", {
        className: "mx_VoiceRecordComposerTile_uploadingState"
      }, /*#__PURE__*/react.createElement(InlineSpinner/* default */.Z, {
        w: 16,
        h: 16
      }));
    } else if (this.state.didUploadFail && this.state.recordingPhase === VoiceRecording/* RecordingState */.SR.Ended) {
      uploadIndicator = /*#__PURE__*/react.createElement("span", {
        className: "mx_VoiceRecordComposerTile_failedState"
      }, /*#__PURE__*/react.createElement("span", {
        className: "mx_VoiceRecordComposerTile_uploadState_badge"
      }, /*#__PURE__*/react.createElement(NotificationBadge/* default */.Z, {
        notification: StaticNotificationState/* StaticNotificationState */.Z.forSymbol("!", NotificationColor/* NotificationColor */.v.Red)
      })), /*#__PURE__*/react.createElement("span", {
        className: "text-warning"
      }, (0,languageHandler._t)("Failed to send")));
    }
    return /*#__PURE__*/react.createElement("div", {
      className: "mx_VoiceRecordComposer_wrapper"
    }, uploadIndicator, (0,units/* isMobile */.tq)() ? this.state.recordingPhase === VoiceRecording/* RecordingState */.SR.Ended ? deleteButton : null : deleteButton, this.renderWaveformArea());
  }
}) || VoiceRecordComposerTile_class);

// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/elements/Tooltip.tsx
var Tooltip = __webpack_require__(578413);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/rooms/SendMessageComposer.tsx
var SendMessageComposer = __webpack_require__(467315);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/dispatcher/actions.ts
var actions = __webpack_require__(473627);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/emojipicker/EmojiPicker.tsx + 7 modules
var EmojiPicker = __webpack_require__(310392);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/stickerpicker/Search.tsx
var Search = __webpack_require__(858687);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/RightPanelStorePhases.ts
var RightPanelStorePhases = __webpack_require__(274057);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/StickerStore.tsx
var StickerStore = __webpack_require__(478396);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/stickerpicker/StickerNav.tsx





class StickerNav extends react.Component {
  handleClick(id) {
    if (id === StickerStore/* SYSTEM_STICKER_PACKAGE */.l5.SHOPPING.id) {
      dispatcher/* default */.ZP.dispatch({
        action: actions/* Action */.a.SetRightPanelPhase,
        phase: RightPanelStorePhases/* RightPanelPhases */.q4.StickerShopping
      });
    } else {
      this.props.onAnchorClick(id);
    }
  }
  render() {
    return /*#__PURE__*/react.createElement("div", {
      className: "mx_StickerPicker_nav"
    }, StickerStore/* commonCategories */.nY.map(category => {
      return /*#__PURE__*/react.createElement("div", {
        className: "mx_StickerPicker_nav_button",
        "data-sticker-nav-id": category.id,
        "aria-selected": category.visible
      }, /*#__PURE__*/react.createElement("button", {
        key: category.id,
        ref: category.ref,
        onClick: () => this.handleClick(category.id),
        title: category.name,
        role: "tab",
        tabIndex: category.visible ? 0 : -1 // roving
        ,
        "aria-controls": `mx_EmojiPicker_category_${category.id}`
      }, category.thumbnail));
    }), this.props.squad && this.props.squadCategories && this.props.squadCategories.map(category => {
      return /*#__PURE__*/react.createElement("div", {
        className: "mx_StickerPicker_nav_button",
        "data-sticker-nav-id": category.id,
        "aria-selected": category.visible
      }, /*#__PURE__*/react.createElement("button", {
        key: category.id,
        ref: category.ref,
        onClick: () => this.handleClick(category.id),
        title: category.name,
        role: "tab",
        tabIndex: category.visible ? 0 : -1 // roving
        ,
        "aria-controls": `mx_EmojiPicker_category_${category.id}`
      }, /*#__PURE__*/react.createElement("img", {
        src: category.thumbnail,
        alt: ""
      })));
    }), /*#__PURE__*/react.createElement("div", {
      className: "mx_StickerPicker_nav_divider"
    }), this.props.categories && this.props.categories.map(category => {
      return /*#__PURE__*/react.createElement("div", {
        className: "mx_StickerPicker_nav_button",
        "data-sticker-nav-id": category.id,
        "aria-selected": category.visible
      }, /*#__PURE__*/react.createElement("button", {
        key: category.id,
        ref: category.ref,
        onClick: () => this.props.onAnchorClick(category.id),
        title: category.name,
        role: "tab",
        tabIndex: category.visible ? 0 : -1 // roving
        ,
        "aria-controls": `mx_EmojiPicker_category_${category.id}`
      }, /*#__PURE__*/react.createElement("img", {
        src: category.thumbnail,
        alt: ""
      })));
    }));
  }
}
/* harmony default export */ const stickerpicker_StickerNav = (StickerNav);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/structures/AutoHideScrollbar.tsx
var AutoHideScrollbar = __webpack_require__(651070);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/elements/LazyRenderList.js
var LazyRenderList = __webpack_require__(748214);
// EXTERNAL MODULE: ./node_modules/antd/lib/index.js
var lib = __webpack_require__(769215);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/stickerpicker/ContextMenu.tsx

// import { SdTooltip } from 'sendingme-ui';

const ContextMenuWrapper = ({
  children,
  menuEle,
  wrappedRef
}) => {
  const tooltipRef = (0,react.useRef)();
  react.useEffect(() => {
    if (tooltipRef.current) {
      wrappedRef(tooltipRef.current);
    }
  }, [tooltipRef, tooltipRef === null || tooltipRef === void 0 ? void 0 : tooltipRef.current]);
  function renderTitle() {
    return menuEle || null;
  }

  // can't use SdTooltip, please use antd Tooltip
  // SdTooltip not have fn: setPopupVisible ...
  return /*#__PURE__*/react.createElement(lib.Tooltip, {
    placement: "right",
    trigger: ['contextMenu'],
    title: renderTitle(),
    zIndex: 5000,
    overlayClassName: "mx_ContextMenu_Actions_wrapper",
    ref: tooltipRef
  }, children);
};
/* harmony default export */ const stickerpicker_ContextMenu = (ContextMenuWrapper);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/context_menus/IconizedContextMenu.tsx
var IconizedContextMenu = __webpack_require__(882385);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/res/img/stickers-picker/add.svg
var add = __webpack_require__(848168);
var add_default = /*#__PURE__*/__webpack_require__.n(add);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/stickerpicker/Sticker.tsx

var Sticker_dec, Sticker_class;












let Sticker = (Sticker_dec = (0,replaceableComponent/* replaceableComponent */.U)("views.emojipicker.Emoji"), Sticker_dec(Sticker_class = class Sticker extends react.PureComponent {
  constructor(props) {
    super(props);
    (0,defineProperty/* default */.Z)(this, "contextMenuRef", /*#__PURE__*/react.createRef());
    (0,defineProperty/* default */.Z)(this, "handleCloseMenu", () => {
      var _this$contextMenuRef;
      if (this !== null && this !== void 0 && (_this$contextMenuRef = this.contextMenuRef) !== null && _this$contextMenuRef !== void 0 && _this$contextMenuRef.current) {
        var _this$contextMenuRef$;
        // @ts-ignore
        (_this$contextMenuRef$ = this.contextMenuRef.current) === null || _this$contextMenuRef$ === void 0 ? void 0 : _this$contextMenuRef$.setPopupVisible(false);
      }
    });
    (0,defineProperty/* default */.Z)(this, "handleViewAll", e => {
      e && e.preventDefault();
      dispatcher/* default */.ZP.dispatch({
        action: actions/* Action */.a.SetRightPanelPhase,
        phase: RightPanelStorePhases/* RightPanelPhases */.q4.StickerViewAll,
        refireParams: {
          params: {
            sticker: this.props.sticker
          }
        }
      });
      this.handleCloseMenu();
    });
    (0,defineProperty/* default */.Z)(this, "handleAddFavorite", async e => {
      e && e.preventDefault();
      this.setState({
        actionLoading: true
      });
      await StickerStore/* default */.ZP.instance.addStickerToFavorite(this.props.sticker);
      this.setState({
        actionLoading: false
      });
      this.handleCloseMenu();
    });
    (0,defineProperty/* default */.Z)(this, "handleRemoveFavorite", async e => {
      e && e.preventDefault();
      this.setState({
        actionLoading: true
      });
      await StickerStore/* default */.ZP.instance.removeStickerToFavorite(this.props.sticker);
      this.setState({
        actionLoading: false
      });
      this.handleCloseMenu();
    });
    (0,defineProperty/* default */.Z)(this, "handleRemoveRecently", async e => {
      e && e.preventDefault();
      this.setState({
        actionLoading: true
      });
      await StickerStore/* default */.ZP.instance.removeStickerToRecently(this.props.sticker);
      this.setState({
        actionLoading: false
      });
      this.handleCloseMenu();
    });
    this.state = {
      actionLoading: false
    };
  }
  renderContextMenuContent() {
    const {
      readonly,
      isFavorited,
      isRecentlyArea,
      sticker
    } = this.props;
    if (readonly) return null;
    const viewAllItem = /*#__PURE__*/react.createElement(IconizedContextMenu/* IconizedContextMenuOption */.$k, null, /*#__PURE__*/react.createElement(IconizedContextMenu/* IconizedContextMenuItem */.XH, {
      className: "mx_StickerPicker_ContextMenu_item",
      iconClassName: "mx_StickerPicker_ContextMenu_item_viewAll",
      label: (0,languageHandler._t)("View All"),
      onClick: e => this.handleViewAll(e)
    }));
    const addFavoriteItem = /*#__PURE__*/react.createElement(IconizedContextMenu/* IconizedContextMenuOption */.$k, null, /*#__PURE__*/react.createElement(IconizedContextMenu/* IconizedContextMenuItem */.XH, {
      className: "mx_StickerPicker_ContextMenu_item",
      iconClassName: "mx_StickerPicker_ContextMenu_item_addFavorite",
      label: (0,languageHandler._t)("Add to Favorite"),
      onClick: e => this.handleAddFavorite(e)
    }));
    const removeFavoriteItem = /*#__PURE__*/react.createElement(IconizedContextMenu/* IconizedContextMenuOption */.$k, null, /*#__PURE__*/react.createElement(IconizedContextMenu/* IconizedContextMenuItem */.XH, {
      className: "mx_StickerPicker_ContextMenu_item",
      iconClassName: "mx_StickerPicker_ContextMenu_item_removeFavorite",
      label: (0,languageHandler._t)("Remove from Favorite"),
      onClick: e => this.handleRemoveFavorite(e)
    }));
    const removeRecentlyItem = /*#__PURE__*/react.createElement(IconizedContextMenu/* IconizedContextMenuOption */.$k, null, /*#__PURE__*/react.createElement(IconizedContextMenu/* IconizedContextMenuItem */.XH, {
      className: "mx_StickerPicker_ContextMenu_item",
      iconClassName: "mx_StickerPicker_ContextMenu_item_removeRecently",
      label: (0,languageHandler._t)("Remove from Recently"),
      onClick: e => this.handleRemoveRecently(e)
    }));
    let buttonList = [];
    if (isFavorited) {
      buttonList.push(removeFavoriteItem);
    } else {
      buttonList.push(addFavoriteItem);
    }
    if (isRecentlyArea) {
      buttonList.push(removeRecentlyItem);
    }
    if (sticker !== null && sticker !== void 0 && sticker.package_id && !StickerStore/* commonCategories */.nY.map(i => i.id).includes(sticker === null || sticker === void 0 ? void 0 : sticker.package_id)) {
      buttonList.push(viewAllItem);
    }
    return /*#__PURE__*/react.createElement(lib.Spin, {
      spinning: this.state.actionLoading
    }, /*#__PURE__*/react.createElement(IconizedContextMenu/* IconizedContextMenuOptionList */.I2, null, buttonList));
  }
  render() {
    const {
      onClick,
      sticker,
      selectedEmojis
    } = this.props;
    // const isSelected = selectedEmojis && selectedEmojis.has(sticker.unicode);
    const isSelected = false;
    if (sticker.id === StickerStore/* SYSTEM_STICKER_PACKAGE */.l5.FAVORITE.id) {
      return /*#__PURE__*/react.createElement("li", {
        onClick: () => onClick(sticker),
        className: "mx_StickerPicker_item_wrapper"
      }, /*#__PURE__*/react.createElement("div", {
        className: `mx_StickerPicker_item mx_StickerPicker_item_import`
      }, /*#__PURE__*/react.createElement("img", {
        src: (add_default()),
        alt: "add"
      })));
    }
    if (sticker.id === StickerStore/* SYSTEM_STICKER_PACKAGE */.l5.SQUAD.id) {
      return /*#__PURE__*/react.createElement("li", {
        onClick: () => onClick(sticker),
        className: "mx_StickerPicker_item_wrapper"
      }, /*#__PURE__*/react.createElement("div", {
        className: `mx_StickerPicker_item mx_StickerPicker_item_import mx_StickerPicker_item_import_squad`
      }, /*#__PURE__*/react.createElement("div", {
        className: "mx_StickerPicker_item_import_squad_inner"
      }, /*#__PURE__*/react.createElement("div", {
        className: "mx_StickerPicker_item_import_squad_img"
      }), /*#__PURE__*/react.createElement("div", {
        className: "mx_StickerPicker_item_import_squad_text"
      }, (0,languageHandler._t)("Add")))));
    }
    return /*#__PURE__*/react.createElement(stickerpicker_ContextMenu, {
      menuEle: this.renderContextMenuContent(),
      wrappedRef: ref => {
        // @ts-ignore
        this.contextMenuRef.current = ref;
      }
    }, /*#__PURE__*/react.createElement(ContextMenu/* MenuItem */.sN, {
      element: "li",
      onClick: () => onClick(sticker),
      className: "mx_StickerPicker_item_wrapper",
      label: sticker.name
    }, /*#__PURE__*/react.createElement("div", {
      className: `mx_StickerPicker_item ${isSelected ? 'mx_StickerPicker_item_selected' : ''}`
    }, /*#__PURE__*/react.createElement("img", {
      src: sticker.url,
      alt: sticker.name
    }))));
  }
}) || Sticker_class);
/* harmony default export */ const stickerpicker_Sticker = (Sticker);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/utils/space.tsx + 4 modules
var space = __webpack_require__(568542);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/dialogs/SpaceSettingsDialog.tsx + 15 modules
var SpaceSettingsDialog = __webpack_require__(855198);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/stickerpicker/Category.tsx

var Category_dec, Category_class;









const OVERFLOW_ROWS = 3;
let Category = (Category_dec = (0,replaceableComponent/* replaceableComponent */.U)("views.emojipicker.Category"), Category_dec(Category_class = class Category extends react.PureComponent {
  constructor(...args) {
    super(...args);
    (0,defineProperty/* default */.Z)(this, "renderStickerRow", rowIndex => {
      const {
        onClick,
        images,
        onContextMenu,
        favoriteStickerList = [],
        isRecentlyArea = false,
        id
      } = this.props;
      const stickersForRow = images.slice(rowIndex * 8, (rowIndex + 1) * 8);
      return stickersForRow.map(sticker => /*#__PURE__*/react.createElement(stickerpicker_Sticker, {
        key: sticker.id || sticker.url,
        sticker: sticker,
        onClick: onClick,
        isFavorited: favoriteStickerList.some(i => i.url === sticker.url),
        isRecentlyArea: isRecentlyArea
      }));
    });
    (0,defineProperty/* default */.Z)(this, "handleUploadSquadSticker", () => {
      (0,space/* showSpaceSettings */.qS)(this.props.squad, SpaceSettingsDialog/* SpaceSettingsTab */.h.Stickers);
      const emojiPickerEle = document.getElementById("mx_ContextualMenu_background_id");
      emojiPickerEle && emojiPickerEle.click();
    });
  }
  render() {
    const {
      images,
      name,
      heightBefore,
      viewportHeight,
      scrollTop,
      id
    } = this.props;
    // If the image length is 0, it proves that there is no permission to upload it.
    // If the image length is 1, then it is the upload button
    if (id === StickerStore/* SYSTEM_STICKER_PACKAGE */.l5.SQUAD.id && [0, 1].includes(images.length)) {
      const hasPermission = StickerStore/* default */.ZP.instance.checkPermissions(this.props.squad);
      return /*#__PURE__*/react.createElement("section", {
        className: "mx_StickerPicker_category mx_StickerPicker_category_empty",
        id: `mx_StickerPicker_category_${this.props.id}`,
        "data-category-id": this.props.id,
        role: "tabpanel",
        "aria-label": name
      }, /*#__PURE__*/react.createElement("h2", {
        className: "mx_StickerPicker_category_label"
      }, name), /*#__PURE__*/react.createElement("div", {
        className: "mx_StickerPicker_list_empty"
      }, /*#__PURE__*/react.createElement("div", {
        className: "icon"
      }), /*#__PURE__*/react.createElement("div", {
        className: "content"
      }, hasPermission ? "Your Squad is waiting for you to upload some stickers!" : "Hey! Squad is waiting for stickers. 😊Remind the admin to upload some!"), hasPermission && /*#__PURE__*/react.createElement("div", {
        className: "action",
        onClick: () => this.handleUploadSquadSticker()
      }, (0,languageHandler._t)("Upload"))));
    }
    if (!images || images.length === 0) {
      return null;
    }
    const rows = new Array(Math.ceil(images.length / EMOJIS_PER_ROW));
    for (let counter = 0; counter < rows.length; ++counter) {
      rows[counter] = counter;
    }
    const viewportTop = scrollTop;
    const viewportBottom = viewportTop + viewportHeight;
    const listTop = heightBefore + CATEGORY_HEADER_HEIGHT;
    const listBottom = listTop + rows.length * EMOJI_HEIGHT;
    const top = Math.max(viewportTop, listTop);
    const bottom = Math.min(viewportBottom, listBottom);
    // the viewport height and scrollTop passed to the LazyRenderList
    // is capped at the intersection with the real viewport, so lists
    // out of view are passed height 0, so they won't render any items.
    const localHeight = Math.max(0, bottom - top);
    const localScrollTop = Math.max(0, scrollTop - listTop);
    return /*#__PURE__*/react.createElement("section", {
      id: `mx_StickerPicker_category_${this.props.id}`,
      className: "mx_StickerPicker_category",
      "data-category-id": this.props.id,
      role: "tabpanel",
      "aria-label": name
    }, /*#__PURE__*/react.createElement("h2", {
      className: "mx_StickerPicker_category_label"
    }, name), /*#__PURE__*/react.createElement(LazyRenderList/* default */.Z, {
      element: "ul",
      className: "mx_StickerPicker_list",
      itemHeight: EMOJI_HEIGHT,
      items: rows,
      scrollTop: localScrollTop,
      height: localHeight,
      overflowItems: OVERFLOW_ROWS,
      overflowMargin: 0,
      renderItem: this.renderStickerRow
    }));
  }
}) || Category_class);
/* harmony default export */ const stickerpicker_Category = (Category);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/stickerpicker/StickerPicker.tsx
















const CATEGORY_HEADER_HEIGHT = 22;
const EMOJI_HEIGHT = 72;
const EMOJIS_PER_ROW = 4;
class StickerPicker extends react.Component {
  constructor(props) {
    super(props);
    (0,defineProperty/* default */.Z)(this, "stickerBodyRef", /*#__PURE__*/react.createRef());
    (0,defineProperty/* default */.Z)(this, "stickerMainRef", /*#__PURE__*/react.createRef());
    (0,defineProperty/* default */.Z)(this, "memoizedDataByCategory", void 0);
    (0,defineProperty/* default */.Z)(this, "stickerEventLister", state => {
      const personalStickers = state.personalStickers || [];
      const squadStickers = state.squadStickers;
      let categories = [];
      let squadCategories;
      if (this.props.squad) {
        var _this$props$squad;
        squadCategories = [];
        squadCategories.push({
          id: StickerStore/* SYSTEM_STICKER_PACKAGE */.l5.SQUAD.id,
          name: ((_this$props$squad = this.props.squad) === null || _this$props$squad === void 0 ? void 0 : _this$props$squad.name) || StickerStore/* SYSTEM_STICKER_PACKAGE */.l5.SQUAD.name,
          thumbnail: this.props.squad.getAvatarUrl(),
          enabled: false,
          visible: false,
          ref: /*#__PURE__*/react.createRef(),
          key: StickerStore/* SYSTEM_STICKER_PACKAGE */.l5.SQUAD.key
        });
      }
      try {
        personalStickers.forEach((sticker, index) => {
          let category = {
            id: sticker.package_id,
            name: sticker.package_name,
            thumbnail: sticker.thumbnail,
            enabled: false,
            visible: false,
            ref: /*#__PURE__*/react.createRef()
          };
          categories.push(category);
        });
      } catch (err) {
        console.log(err);
      }
      if (this.props.squad) {
        this.setState({
          squadStickerPackage: squadStickers.get(this.props.squad.roomId) || []
        });
      }
      this.setState({
        personalStickerPackage: state.personalStickers || [],
        collectStickerPackage: state.collectStickers || [],
        recentStickerPackage: state.recentStickers || [],
        loading: state.loading || false,
        categories: categories,
        squadCategories: squadCategories
      }, () => {
        this.onChangeFilter(this.props.search);
      });
    });
    (0,defineProperty/* default */.Z)(this, "setStickerEventLoading", value => {
      this.setState({
        loading: value
      });
    });
    (0,defineProperty/* default */.Z)(this, "getPersonalStickers", async () => {
      await StickerStore/* default */.ZP.instance.refreshStickers();
      if (this.props.squad) {
        await StickerStore/* default */.ZP.instance.getSquadStickersBySquadId(this.props.squad.roomId);
      }
    });
    (0,defineProperty/* default */.Z)(this, "scrollToCategory", id => {
      this.stickerBodyRef.current.querySelector(`[data-category-id="${id}"]`).scrollIntoView();
    });
    (0,defineProperty/* default */.Z)(this, "onChangeFilter", filter => {
      const lcFilter = filter.toLowerCase().trim(); // filter is case insensitive
      let allPackageList = [];
      if (this.props.squad && this.state.squadCategories) {
        allPackageList = [...StickerStore/* commonCategories */.nY, ...this.state.squadCategories, ...this.state.categories];
      } else {
        allPackageList = [...StickerStore/* commonCategories */.nY, ...this.state.categories];
      }
      for (const cat of allPackageList) {
        let images = [];
        if (cat.id === StickerStore/* SYSTEM_STICKER_PACKAGE */.l5.FAVORITE.id) {
          images = this.state.collectStickerPackage || [];
        } else if (cat.id === StickerStore/* SYSTEM_STICKER_PACKAGE */.l5.RECENTLY.id) {
          images = this.state.recentStickerPackage || [];
        } else if (cat.id === StickerStore/* SYSTEM_STICKER_PACKAGE */.l5.SQUAD.id) {
          images = this.state.squadStickerPackage || [];
        } else {
          const stickerPkg = this.state.personalStickerPackage.find(pkg => pkg.package_id === cat.id);
          images = (stickerPkg === null || stickerPkg === void 0 ? void 0 : stickerPkg.images) || [];
        }
        // If the new filter string includes the old filter string, we don't have to re-filter the whole dataset.
        // if (lcFilter.includes(this.state.filter)) {
        //     images = this.memoizedDataByCategory[cat.id];
        // }
        images = images.filter(emoji => this.emojiMatchesFilter(emoji, lcFilter));
        this.memoizedDataByCategory[cat.id] = images;
        cat.enabled = images.length > 0 || [StickerStore/* SYSTEM_STICKER_PACKAGE */.l5.SHOPPING.id, StickerStore/* SYSTEM_STICKER_PACKAGE */.l5.SQUAD.id, StickerStore/* SYSTEM_STICKER_PACKAGE */.l5.FAVORITE.id].includes(cat.id);
        // The setState below doesn't re-render the header and we already have the refs for updateVisibility, so...
        cat.ref.current.disabled = !cat.enabled;
      }
      this.props.onChangeSearch(filter);

      // check filter empty
      let isEmpty = true;
      for (var key in this.memoizedDataByCategory) {
        if (this.memoizedDataByCategory[key].length > 0) {
          isEmpty = false;
        }
      }
      this.setState({
        isEmpty: isEmpty,
        filter: filter
      });
      // Header underlines need to be updated, but updating requires knowing
      // where the categories are, so we wait for a tick.
      setTimeout(this.updateVisibility, 0);
    });
    (0,defineProperty/* default */.Z)(this, "emojiMatchesFilter", (sticker, filter) => {
      var _sticker$info, _sticker$info2, _sticker$info2$emoji_, _sticker$info2$emoji_2;
      return sticker.name && sticker.name.toLowerCase().includes(filter) || sticker.body && sticker.body.toLowerCase().includes(filter) ||
      // @ts-ignore
      ((_sticker$info = sticker.info) === null || _sticker$info === void 0 ? void 0 : _sticker$info.emoji_short_name) && ((_sticker$info2 = sticker.info) === null || _sticker$info2 === void 0 ? void 0 : (_sticker$info2$emoji_ = _sticker$info2.emoji_short_name) === null || _sticker$info2$emoji_ === void 0 ? void 0 : (_sticker$info2$emoji_2 = _sticker$info2$emoji_.toLowerCase()) === null || _sticker$info2$emoji_2 === void 0 ? void 0 : _sticker$info2$emoji_2.includes(filter));
    });
    (0,defineProperty/* default */.Z)(this, "onEnterFilter", () => {});
    (0,defineProperty/* default */.Z)(this, "onScroll", () => {
      const body = this.stickerBodyRef.current;
      this.setState({
        scrollTop: body.scrollTop,
        viewportHeight: body.clientHeight
      });
      this.updateVisibility();
    });
    (0,defineProperty/* default */.Z)(this, "updateVisibility", () => {
      const offsetDiff = 2 + 107;
      const body = this.stickerBodyRef.current;
      let categories = this.state.categories;
      let allPackageList = [];
      if (this.props.squad && this.state.squadCategories) {
        allPackageList = [...StickerStore/* commonCategories */.nY, ...this.state.squadCategories, ...categories];
      } else {
        allPackageList = [...StickerStore/* commonCategories */.nY, ...categories];
      }
      const linkIds = allPackageList.map(i => i.id);
      allPackageList.forEach(cat => {
        const elem = body.querySelector(`[data-category-id="${cat.id}"]`);
        if (!elem) {
          return;
        }
        // @ts-ignore
        if (body.scrollTop > elem.offsetTop - offsetDiff) {
          const currentNavEle = this.stickerMainRef.current.querySelector(`[data-sticker-nav-id="${cat.id}"]`);
          currentNavEle.classList.add('active');
          currentNavEle.setAttribute("aria-selected", "true");
          linkIds.forEach(k => {
            if (k !== cat.id) {
              const navEle = this.stickerMainRef.current.querySelector(`[data-sticker-nav-id="${k}"]`);
              navEle && navEle.classList.remove('active');
              navEle && navEle.setAttribute("aria-selected", "false");
            }
          });
        }
      });
    });
    (0,defineProperty/* default */.Z)(this, "sendSticker", sticker => {
      console.log(sticker);
      if (sticker.id === StickerStore/* SYSTEM_STICKER_PACKAGE */.l5.FAVORITE.id) {
        dispatcher/* default */.ZP.dispatch({
          action: actions/* Action */.a.SetRightPanelPhase,
          phase: RightPanelStorePhases/* RightPanelPhases */.q4.StickerFavoriteManagement
        });
      } else if (sticker.id === StickerStore/* SYSTEM_STICKER_PACKAGE */.l5.SQUAD.id) {
        (0,space/* showSpaceSettings */.qS)(this.props.squad, SpaceSettingsDialog/* SpaceSettingsTab */.h.Stickers);
        const emojiPickerEle = document.getElementById("mx_ContextualMenu_background_id");
        emojiPickerEle && emojiPickerEle.click();
      } else {
        StickerStore/* default */.ZP.instance.addStickerToRecently(sticker);
        this.props.sendSticker(sticker);
      }
    });
    (0,defineProperty/* default */.Z)(this, "renderPersonStickerArea", () => {
      var _this$getMemoImageLis, _this$getMemoImageLis2;
      let heightBefore = 0;
      const recentlyArea = /*#__PURE__*/react.createElement(stickerpicker_Category, {
        key: StickerStore/* SYSTEM_STICKER_PACKAGE */.l5.RECENTLY.id,
        id: StickerStore/* SYSTEM_STICKER_PACKAGE */.l5.RECENTLY.id,
        name: StickerStore/* SYSTEM_STICKER_PACKAGE */.l5.RECENTLY.name,
        heightBefore: heightBefore,
        viewportHeight: this.state.viewportHeight,
        scrollTop: this.state.scrollTop
        // images={this.state.recentStickerPackage || []}
        ,
        images: this.getMemoImageList(StickerStore/* SYSTEM_STICKER_PACKAGE */.l5.RECENTLY.id) || [],
        onClick: this.sendSticker,
        isRecentlyArea: true,
        favoriteStickerList: this.state.collectStickerPackage || []
      });
      heightBefore += StickerPicker.categoryHeightForEmojiCount(
      // this.state.recentStickerPackage?.length
      ((_this$getMemoImageLis = this.getMemoImageList(StickerStore/* SYSTEM_STICKER_PACKAGE */.l5.RECENTLY.id)) === null || _this$getMemoImageLis === void 0 ? void 0 : _this$getMemoImageLis.length) || 0);
      const favoriteUploadImg = {
        description: "",
        id: StickerStore/* SYSTEM_STICKER_PACKAGE */.l5.FAVORITE.id,
        info: {},
        name: "",
        package_id: StickerStore/* SYSTEM_STICKER_PACKAGE */.l5.FAVORITE.id,
        url: ""
      };
      // emoji: string; h: string; w: string; mimetype: string; size: string;

      const favoriteArea = /*#__PURE__*/react.createElement(stickerpicker_Category, {
        key: StickerStore/* SYSTEM_STICKER_PACKAGE */.l5.FAVORITE.id,
        id: StickerStore/* SYSTEM_STICKER_PACKAGE */.l5.FAVORITE.id,
        name: StickerStore/* SYSTEM_STICKER_PACKAGE */.l5.FAVORITE.name,
        heightBefore: heightBefore,
        viewportHeight: this.state.viewportHeight,
        scrollTop: this.state.scrollTop,
        images: [favoriteUploadImg, ...this.getMemoImageList(StickerStore/* SYSTEM_STICKER_PACKAGE */.l5.FAVORITE.id)] || [],
        onClick: this.sendSticker,
        favoriteStickerList: this.state.collectStickerPackage || []
      });
      heightBefore += StickerPicker.categoryHeightForEmojiCount(
      // Collections have their own add button, so the minimum length is 1
      ((_this$getMemoImageLis2 = this.getMemoImageList(StickerStore/* SYSTEM_STICKER_PACKAGE */.l5.FAVORITE.id)) === null || _this$getMemoImageLis2 === void 0 ? void 0 : _this$getMemoImageLis2.length) + 1 || 1);
      let squadArea;
      if (this.props.squad) {
        var _this$getMemoImageLis3;
        const hasPermission = StickerStore/* default */.ZP.instance.checkPermissions(this.props.squad);
        const squadUploadImgs = [];
        hasPermission && squadUploadImgs.push({
          description: "",
          id: StickerStore/* SYSTEM_STICKER_PACKAGE */.l5.SQUAD.id,
          info: {},
          name: "",
          package_id: StickerStore/* SYSTEM_STICKER_PACKAGE */.l5.SQUAD.id,
          url: ""
        });
        squadArea = /*#__PURE__*/react.createElement(stickerpicker_Category, {
          key: StickerStore/* SYSTEM_STICKER_PACKAGE */.l5.SQUAD.id,
          id: StickerStore/* SYSTEM_STICKER_PACKAGE */.l5.SQUAD.id,
          name: this.props.squad.name || StickerStore/* SYSTEM_STICKER_PACKAGE */.l5.SQUAD.name,
          heightBefore: heightBefore,
          viewportHeight: this.state.viewportHeight,
          scrollTop: this.state.scrollTop,
          images: [...this.getMemoImageList(StickerStore/* SYSTEM_STICKER_PACKAGE */.l5.SQUAD.id), ...squadUploadImgs] || [],
          onClick: this.sendSticker,
          favoriteStickerList: this.state.collectStickerPackage || [],
          squad: this.props.squad
        });
        heightBefore += StickerPicker.categoryHeightForEmojiCount( // If the squad does not upload a sticker, the height of the empty element is 50
        (_this$getMemoImageLis3 = this.getMemoImageList(StickerStore/* SYSTEM_STICKER_PACKAGE */.l5.SQUAD.id)) === null || _this$getMemoImageLis3 === void 0 ? void 0 : _this$getMemoImageLis3.length) || CATEGORY_HEADER_HEIGHT + 50;
      }
      const personalArea = this.state.personalStickerPackage.map(sticker => {
        let images = sticker.images || [];
        if (this.memoizedDataByCategory && this.memoizedDataByCategory[sticker.package_id]) {
          images = this.memoizedDataByCategory[sticker.package_id];
        }
        const categoryElement = /*#__PURE__*/react.createElement(stickerpicker_Category, {
          key: sticker.package_id,
          id: sticker.package_id,
          name: sticker.package_name,
          heightBefore: heightBefore,
          viewportHeight: this.state.viewportHeight,
          scrollTop: this.state.scrollTop,
          images: images,
          onClick: this.sendSticker,
          favoriteStickerList: this.state.collectStickerPackage || []
          // selectedEmojis={this.props.selectedEmojis}
        });

        const height = StickerPicker.categoryHeightForEmojiCount(images.length);
        heightBefore += height;
        return categoryElement;
      });
      return [recentlyArea, favoriteArea, squadArea, personalArea];
    });
    (0,defineProperty/* default */.Z)(this, "renderStickerContent", () => {
      if (this.state.loading) {
        return /*#__PURE__*/react.createElement("div", {
          className: "mx_StickerPicker_skeleton"
        }, /*#__PURE__*/react.createElement(dist.SdSkeleton.Block, {
          active: true,
          rows: 4,
          cols: 4,
          rowGap: 10,
          colGap: 10
        }));
      }
      if (!this.state.isEmpty) {
        return this.renderPersonStickerArea();
      }
      return /*#__PURE__*/react.createElement("div", {
        className: "mx_StickerPicker_empty"
      }, /*#__PURE__*/react.createElement("div", {
        className: "mx_StickerPicker_empty_import",
        onClick: () => {
          dispatcher/* default */.ZP.dispatch({
            action: actions/* Action */.a.SetRightPanelPhase,
            phase: RightPanelStorePhases/* RightPanelPhases */.q4.StickerShopping
          });
        }
      }, /*#__PURE__*/react.createElement("img", {
        src: (add_default())
      })), /*#__PURE__*/react.createElement("p", {
        className: "empty_title"
      }, (0,languageHandler._t)("sticker empty title")), /*#__PURE__*/react.createElement("p", {
        className: "empty_description"
      }, (0,languageHandler._t)("sticker empty description")));
    });
    this.state = {
      filter: "",
      isEmpty: false,
      scrollTop: 0,
      viewportHeight: 280,
      personalStickerPackage: [],
      categories: [],
      recentStickerPackage: [],
      collectStickerPackage: [],
      squadStickerPackage: [],
      loading: true
    };
    this.memoizedDataByCategory = {};
    this.getPersonalStickers();
  }
  componentDidMount() {
    if (this.props.search) {
      this.onChangeFilter(this.props.search);
    }
    StickerStore/* default */.ZP.instance.on(StickerStore/* StickerStoreAction */.ZU.updateStickerHooksState, this.stickerEventLister);
  }
  componentDidUpdate(prevProps, prevState, snapshot) {
    if (prevProps.search !== this.props.search) {
      this.onChangeFilter(this.props.search);
    }
  }
  componentWillUnmount() {
    StickerStore/* default */.ZP.instance.off(StickerStore/* StickerStoreAction */.ZU.updateStickerHooksState, this.stickerEventLister);
  }
  static categoryHeightForEmojiCount(count) {
    if (!count) {
      return 0;
    }
    if (count === 0) {
      return 0;
    }
    return CATEGORY_HEADER_HEIGHT + Math.ceil(count / EMOJIS_PER_ROW) * EMOJI_HEIGHT;
  }
  settingStickers() {
    dispatcher/* default */.ZP.dispatch({
      action: actions/* Action */.a.SetRightPanelPhase,
      phase: RightPanelStorePhases/* RightPanelPhases */.q4.StickerSetting
    });
  }
  getMemoImageList(package_id) {
    if (this.memoizedDataByCategory && this.memoizedDataByCategory[package_id]) {
      return this.memoizedDataByCategory[package_id] || [];
    }
    if (package_id === StickerStore/* SYSTEM_STICKER_PACKAGE */.l5.FAVORITE.id) {
      return this.state.collectStickerPackage;
    }
    if (package_id === StickerStore/* SYSTEM_STICKER_PACKAGE */.l5.RECENTLY.id) {
      return this.state.recentStickerPackage;
    }
    if (package_id === StickerStore/* SYSTEM_STICKER_PACKAGE */.l5.SQUAD.id) {
      return this.state.squadStickerPackage;
    }
    return [];
  }
  render() {
    return /*#__PURE__*/react.createElement("div", {
      className: "mx_StickerPicker"
    }, /*#__PURE__*/react.createElement(Search/* default */.Z, {
      query: this.state.filter,
      onChange: this.onChangeFilter,
      onEnter: this.onEnterFilter
    }), /*#__PURE__*/react.createElement("div", {
      className: "mx_StickerPicker_container",
      ref: this.stickerMainRef
    }, this.state.categories ? /*#__PURE__*/react.createElement("div", {
      className: "mx_StickerPicker_nav_wrapper"
    }, /*#__PURE__*/react.createElement(stickerpicker_StickerNav, {
      categories: this.state.categories,
      squadCategories: this.state.squadCategories,
      onAnchorClick: this.scrollToCategory,
      squad: this.props.squad
    }), /*#__PURE__*/react.createElement("div", {
      className: "mx_StickerPicker_nav_setting",
      onClick: () => this.settingStickers()
    }, /*#__PURE__*/react.createElement(dist.SdIcon, {
      icon: "SettingOutlines"
    }))) : null, /*#__PURE__*/react.createElement(AutoHideScrollbar/* default */.Z, {
      id: "mx_StickerPicker_body",
      className: "mx_StickerPicker_body",
      wrappedRef: ref => {
        // @ts-ignore - AutoHideScrollbar should accept a RefObject or fall back to its own instead
        this.stickerBodyRef.current = ref;
      },
      onScroll: this.onScroll
    }, this.renderStickerContent())));
  }
}
/* harmony default export */ const stickerpicker_StickerPicker = (StickerPicker);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/UIStore.ts
var UIStore = __webpack_require__(563869);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/lib/constants.ts
var constants = __webpack_require__(877294);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/elements/AccessibleButton.tsx
var elements_AccessibleButton = __webpack_require__(805035);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/structures/space_home/DappButtons.tsx + 1 modules
var DappButtons = __webpack_require__(249135);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/rooms/DappsMenu.tsx









const FavoritesButton = ({
  room
}) => {
  const {
    accessToken,
    userId
  } = MatrixClientPeg.getCredentials();
  return /*#__PURE__*/React.createElement(AccessibleButton, {
    key: "Favorites",
    className: "mx_DappsMenu_button",
    onClick: () => {
      dis.dispatch({
        action: Action.SetRightPanelPhase,
        phase: RightPanelPhases.IframeWidget,
        refireParams: {
          params: {
            src: `${FAV_HOST_URL}/fav?token=${accessToken}&userId=${userId}`,
            title: _t("Cart")
          }
        }
      });
    }
  }, /*#__PURE__*/React.createElement("div", {
    className: "mx_DappsMenu_button_bg favorite"
  }), /*#__PURE__*/React.createElement("div", null, _t("Cart")));
};
const PeerSwapButton = ({
  room
}) => {
  return /*#__PURE__*/React.createElement(AccessibleButton, {
    key: "PeerSwap",
    className: "mx_DappsMenu_button",
    onClick: () => {
      dis.dispatch({
        action: Action.SetRightPanelPhase,
        phase: RightPanelPhases.IframeWidget,
        refireParams: {
          params: {
            src: `${PEERSWAP_URL}/create?roomId=${room.roomId}`,
            title: "PeerSwap"
          }
        }
      });
    }
  }, /*#__PURE__*/React.createElement("div", {
    className: "mx_DappsMenu_button_bg peerswap"
  }), /*#__PURE__*/React.createElement("div", null, _t("PeerSwap")));
};
const AirDropButton = ({
  room
}) => {
  const squad = room.getParentRoom();
  return /*#__PURE__*/React.createElement(AccessibleButton, {
    key: "AirDrop",
    disabled: !squad.roomId,
    className: "mx_DappsMenu_button",
    onClick: () => {
      dis.dispatch({
        action: Action.SetRightPanelPhase,
        phase: RightPanelPhases.IframeWidget,
        refireParams: {
          params: {
            src: `${AIRDROP_URL}/record?roomId=${squad.roomId}`,
            title: "AirDrop"
          }
        }
      });
    }
  }, /*#__PURE__*/React.createElement("div", {
    className: "mx_DappsMenu_button_bg airdrop"
  }), /*#__PURE__*/React.createElement("div", null, _t("AirDrop")));
};
const SmartButton = ({
  room
}) => {
  return /*#__PURE__*/React.createElement(AccessibleButton, {
    key: "Smart",
    className: "mx_DappsMenu_button",
    onClick: () => {
      dis.dispatch({
        action: Action.SetRightPanelPhase,
        phase: RightPanelPhases.IframeWidget,
        refireParams: {
          params: {
            src: `${SMART_URL}/squad-mart?roomId=${room.roomId}`,
            title: _t("SMart")
          }
        }
      });
    }
  }, /*#__PURE__*/React.createElement("div", {
    className: "mx_DappsMenu_button_bg smart"
  }), /*#__PURE__*/React.createElement("div", null, _t("SMart")));
};
const AuctionButton = ({
  room
}) => {
  return /*#__PURE__*/React.createElement(AccessibleButton, {
    key: "Auction",
    disabled: !room.roomId,
    className: "mx_DappsMenu_button",
    onClick: () => {
      dis.dispatch({
        action: Action.SetRightPanelPhase,
        phase: RightPanelPhases.IframeWidget,
        refireParams: {
          params: {
            src: `${AUCTION_URL}/squad-auctions?roomId=${room.roomId}`,
            title: "Auction"
          }
        }
      });
    }
  }, /*#__PURE__*/React.createElement("div", {
    className: "mx_DappsMenu_button_bg auction"
  }), /*#__PURE__*/React.createElement("div", null, _t("Auction")));
};
const GiftExchangeButton = ({
  room
}) => {
  return /*#__PURE__*/React.createElement(AccessibleButton, {
    key: "GiftExchange",
    className: "mx_DappsMenu_button",
    onClick: () => {
      dis.dispatch({
        action: Action.SetRightPanelPhase,
        phase: RightPanelPhases.IframeWidget,
        refireParams: {
          params: {
            src: `${GIFTEXCHANGE_URL}/create?roomId=${room.roomId}`,
            title: "Gift Exchange"
          }
        }
      });
    }
  }, /*#__PURE__*/React.createElement("div", {
    className: "mx_DappsMenu_button_bg giftexchange"
  }), /*#__PURE__*/React.createElement("div", null, _t("Gift Exchange")));
};
const GameCenterButton = ({
  room
}) => {
  return /*#__PURE__*/React.createElement(AccessibleButton, {
    key: "GameCenter",
    className: "mx_DappsMenu_button",
    onClick: () => {
      dis.dispatch({
        action: Action.SetRightPanelPhase,
        phase: RightPanelPhases.IframeWidget,
        refireParams: {
          params: {
            src: `${GAMECENTER_URL}/?roomId=${room.roomId}`,
            title: "LuLu Ludo"
          }
        }
      });
    }
  }, /*#__PURE__*/React.createElement("div", {
    className: "mx_DappsMenu_button_bg gamecenter"
  }), /*#__PURE__*/React.createElement("div", null, _t("LuLu Ludo")));
};
const MemePunksButton = ({
  room
}) => {
  return /*#__PURE__*/React.createElement(AccessibleButton, {
    key: "MemePunks",
    className: "mx_DappsMenu_button",
    onClick: () => {
      dis.dispatch({
        action: Action.SetRightPanelPhase,
        phase: RightPanelPhases.IframeWidget,
        refireParams: {
          params: {
            src: `${MEMEPUNKS_URL}/?roomId=${room.roomId}`,
            title: "MemePunks"
          }
        }
      });
    }
  }, /*#__PURE__*/React.createElement("div", {
    className: "mx_DappsMenu_button_bg memepunks"
  }), /*#__PURE__*/React.createElement("div", null, _t("MemePunks")));
};
const SquadVaultButton = ({
  room
}) => {
  return /*#__PURE__*/React.createElement(AccessibleButton, {
    key: "squadVault",
    className: "mx_DappsMenu_button",
    onClick: () => {
      const timestamp = +new Date();
      dis.dispatch({
        action: Action.SetRightPanelPhase,
        phase: RightPanelPhases.IframeWidget,
        refireParams: {
          params: {
            src: `${SQUAD_VAULT_URL}/home?roomId=${room.roomId}`,
            title: _t("Squad Vault")
          }
        }
      });
    }
  }, /*#__PURE__*/React.createElement("div", {
    className: "mx_DappsMenu_button_bg squad_vault"
  }), /*#__PURE__*/React.createElement("div", null, _t("Squad Vault")));
};
const DappsMenu = props => {
  var _props$room, _props$room$getParent;
  const contextParams = {
    userId: props.room.myUserId,
    roomId: props.room.roomId,
    squadId: (_props$room = props.room) === null || _props$room === void 0 ? void 0 : (_props$room$getParent = _props$room.getParentRoom()) === null || _props$room$getParent === void 0 ? void 0 : _props$room$getParent.roomId,
    timestamp: constants/* DAY_TIMESTAMP */.BG
  };
  return /*#__PURE__*/react.createElement("div", {
    className: "mx_DappsMenu_card"
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_DappsMenu_btn_back",
    onClick: () => {
      props.isDappsOpen(false);
      props.isAdditionalOpen(true);
    }
  }), /*#__PURE__*/react.createElement("div", {
    className: "mx_DappsBtns_box"
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_DappsBtns_box_inner"
  }, /*#__PURE__*/react.createElement(DappButtons/* default */.Z, {
    layout: "vertical",
    loading: true,
    context: contextParams,
    displayPosition: DappButtons/* DisplayPosition */.n.CHAT_BOX_L2
  }))));
};
/* harmony default export */ const rooms_DappsMenu = (DappsMenu);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/Keyboard.ts
var Keyboard = __webpack_require__(389310);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/gifspicker/Search.tsx

var Search_dec, Search_class;
/*
Copyright 2019 Tulir Asokan <tulir@maunium.net>
Copyright 2020 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/






let Search_Search = (Search_dec = (0,replaceableComponent/* replaceableComponent */.U)("views.emojipicker.Search"), Search_dec(Search_class = class Search extends react.PureComponent {
  constructor(...args) {
    super(...args);
    (0,defineProperty/* default */.Z)(this, "inputRef", /*#__PURE__*/react.createRef());
    (0,defineProperty/* default */.Z)(this, "onKeyDown", ev => {
      if (ev.key === Keyboard/* Key */.sr.ENTER) {
        this.props.onEnter();
        ev.stopPropagation();
        ev.preventDefault();
      }
    });
  }
  componentDidMount() {
    // For some reason, neither the autoFocus nor just calling focus() here worked, so here's a setTimeout
    // setTimeout(() => this.inputRef.current.focus(), 0);
  }
  render() {
    let rightButton;
    if (this.props.query) {
      rightButton = /*#__PURE__*/react.createElement("button", {
        onClick: () => this.props.onChange(""),
        className: "mx_EmojiPicker_search_icon mx_EmojiPicker_search_clear",
        title: (0,languageHandler._t)("Cancel search")
      });
    }
    return /*#__PURE__*/react.createElement("div", {
      className: "mx_EmojiPicker_search"
    }, /*#__PURE__*/react.createElement("span", {
      className: "mx_EmojiPicker_search_icon"
    }), /*#__PURE__*/react.createElement("input", {
      autoFocus: !(0,units/* isMobile */.tq)(),
      type: "text",
      placeholder: (0,languageHandler._t)("Search Tenor"),
      value: this.props.query,
      onChange: ev => this.props.onChange(ev.target.value),
      onKeyDown: this.onKeyDown,
      ref: this.inputRef
    }), rightButton);
  }
}) || Search_class);
/* harmony default export */ const gifspicker_Search = (Search_Search);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/accessibility/context_menu/MenuItem.tsx
var MenuItem = __webpack_require__(529072);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/gifspicker/Gif.tsx
var Gif_dec, Gif_class;



const DATA_BY_CATEGORY = {
  "people": [],
  "nature": [],
  "foods": [],
  "places": [],
  "activity": [],
  "objects": [],
  "symbols": [],
  "flags": []
};
const DEFAULT_CATEGORIES = {};
const Gif_CATEGORY_HEADER_HEIGHT = 22;
const Gif_EMOJI_HEIGHT = 37;
const Gif_EMOJIS_PER_ROW = 8;
// url Async requesting function
const httpGetAsync = (theUrl, callback, msg) => {
  // create the request object
  const xmlHttp = new XMLHttpRequest();

  // set the state change callback to capture when the response comes in
  xmlHttp.onreadystatechange = function () {
    if (xmlHttp.readyState == 4 && xmlHttp.status == 200) {
      callback(xmlHttp.responseText, msg);
    }
  };

  // open as a GET call, pass in the url and set async = True
  xmlHttp.open("GET", theUrl, true);

  // call send with no params as they were passed in on the url string
  xmlHttp.send(null);
  return;
};
let Gif = (Gif_dec = (0,replaceableComponent/* replaceableComponent */.U)("views.emojipicker.Gif"), Gif_dec(Gif_class = class Gif extends react.PureComponent {
  render() {
    const {
      onClick,
      onMouseEnter,
      onMouseLeave,
      gif,
      selectedGifs
    } = this.props;
    const isSelected = selectedGifs && selectedGifs.has(gif.unicode);
    return /*#__PURE__*/react.createElement(MenuItem/* MenuItem */.s, {
      element: "li",
      onClick: () => onClick(gif),
      onMouseEnter: () => onMouseEnter(gif),
      onMouseLeave: () => onMouseLeave(gif),
      className: "mx_EmojiPicker_item_wrapper",
      label: gif.unicode
    }, /*#__PURE__*/react.createElement("div", {
      className: `mx_EmojiPicker_item ${isSelected ? 'mx_EmojiPicker_item_selected' : ''}`
    }, gif.unicode));
  }
}) || Gif_class);
/* harmony default export */ const gifspicker_Gif = ((/* unused pure expression or super */ null && (Gif)));
// EXTERNAL MODULE: ./node_modules/rc-virtual-list/lib/index.js
var rc_virtual_list_lib = __webpack_require__(727032);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/emojipicker/collection.ts
var collection = __webpack_require__(132622);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/gifspicker/Categroy.tsx
/*
Copyright 2019 Tulir Asokan <tulir@maunium.net>
Copyright 2020 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/









const ContainerHeight = 400;
const RECOMMAND_CATEGORIES = ["thanks", "got it", "awesome", "one more", "don't stop", "wagmi", "Hodl", "FOMO", "Ded", "Degen"];
const GifCategory = props => {
  const [category, setCategory] = (0,react.useState)('');
  const [categoryDetails, setCategoryDetails] = (0,react.useState)([]);
  const [showDetail, setShowDetail] = (0,react.useState)(false);
  const [customCategory, setCustomCategory] = (0,react.useState)([]);
  const [defaultCategory, setDefaultCategory] = (0,react.useState)([]);
  const [nextIndex, setNextIndex] = (0,react.useState)('');
  const [featureCategory, setFeatureCategory] = (0,react.useState)([]);
  const [collectCategory, setCollectCategory] = (0,react.useState)([]);
  (0,react.useEffect)(() => {
    if (defaultCategory.length === 0) {
      grab_categories_data();
    }
    if (customCategory.length === 0) {
      grab_recommandCategories();
    }
  }, []);
  (0,react.useEffect)(() => {
    if (featureCategory.length === 0) {
      grab_featured_data(false);
    }
  }, []);
  (0,react.useEffect)(() => {
    if (collectCategory.length === 0) {
      setCollectCategory(collection/* get */.U());
    }
  }, []);

  // callback for GIF categories
  const tenorCallback_recommand = (responsetext, search_term) => {
    // Parse the JSON response
    const response_objects = JSON.parse(responsetext);
    const custom_category = {
      image: response_objects.results[0].media_formats.tinygif.url,
      name: "",
      path: "",
      searchterm: search_term
    };
    const cus_tmp = customCategory;
    cus_tmp.push(custom_category);
    setCustomCategory(cus_tmp);
    return;
  };
  const grab_recommandCategories = () => {
    // set the apikey and limit
    const apikey = "AIzaSyDj8YSuGO_oxzvFYa1yiqdMuiF5GMaS7WI";
    const clientkey = "hiseas-apps";
    const lmt = 1;
    for (let i = 0; i < RECOMMAND_CATEGORIES.length; i++) {
      const search_term = RECOMMAND_CATEGORIES[i];
      // using default locale of en_US
      const search_url = "https://tenor.googleapis.com/v2/search?q=" + search_term + "&key=" + apikey + "&client_key=" + clientkey + "&limit=" + lmt;
      httpGetAsync(search_url, tenorCallback_recommand, search_term);
    }
    return;
  };

  // callback for GIF categories
  const tenorCallback_categories = responsetext => {
    // Parse the JSON response
    const response_objects = JSON.parse(responsetext);
    setDefaultCategory(response_objects["tags"]);
    console.log('11111defaultcategory', response_objects["tags"]);
    return;
  };

  // function to call the featured and category endpoints
  const grab_categories_data = () => {
    // set the apikey and limit
    const apikey = "AIzaSyDj8YSuGO_oxzvFYa1yiqdMuiF5GMaS7WI";
    const clientkey = "hiseas-apps";
    // get the current list of categories - using the default locale of en_US
    const cat_url = "https://tenor.googleapis.com/v2/categories?key=" + apikey + "&client_key=" + clientkey;
    httpGetAsync(cat_url, tenorCallback_categories);
    // data will be loaded by each call's callback
    return;
  };

  // callback for the top 8 GIFs of search
  const tenorCallback_search = responsetext => {
    // Parse the JSON response
    const response_objects = JSON.parse(responsetext);
    if (categoryDetails && categoryDetails.length != 1) {
      setCategoryDetails(categoryDetails.concat(response_objects["results"]));
    } else {
      setCategoryDetails(response_objects["results"]);
    }
    setNextIndex(response_objects["next"]);
    return;
  };

  // function to call the trending and category endpoints
  const grab_img_data = (search_term, next_index) => {
    const apikey = "AIzaSyDj8YSuGO_oxzvFYa1yiqdMuiF5GMaS7WI";
    const clientkey = "hiseas-apps";
    const lmt = 10;
    if (next_index) {
      // using default locale of en_US
      var search_url = "https://tenor.googleapis.com/v2/search?q=" + search_term + "&key=" + apikey + "&client_key=" + clientkey + "&limit=" + lmt + "&pos=" + next_index;
      setNextIndex('');
    } else {
      // using default locale of en_US
      var search_url = "https://tenor.googleapis.com/v2/search?q=" + search_term + "&key=" + apikey + "&client_key=" + clientkey + "&limit=" + lmt;
    }
    httpGetAsync(search_url, tenorCallback_search);

    // data will be loaded by each call's callback
    return;
  };

  // callback for featured top 10 GIFs
  function tenorCallback_featured(responsetext) {
    // Parse the JSON response
    const response_objects = JSON.parse(responsetext);
    setFeatureCategory(response_objects["results"]);
    if (categoryDetails && categoryDetails.length != 1) {
      setCategoryDetails(categoryDetails.concat(response_objects["results"]));
    } else {
      setCategoryDetails(response_objects["results"]);
    }
    setNextIndex(response_objects["next"]);
    return;
  }

  // function to call the featured endpoint
  function grab_featured_data(featureDetail, next_index) {
    const apikey = "AIzaSyDj8YSuGO_oxzvFYa1yiqdMuiF5GMaS7WI";
    const clientkey = "hiseas-apps";
    let featured_url;
    let lmt = 1;
    if (featureDetail) {
      lmt = 10;
    }
    if (next_index) {
      // using default locale of en_US
      featured_url = "https://tenor.googleapis.com/v2/featured?key=" + apikey + "&client_key=" + clientkey + "&limit=" + lmt + "&pos=" + next_index;
      setNextIndex('');
    } else {
      // using default locale of en_US
      featured_url = "https://tenor.googleapis.com/v2/featured?key=" + apikey + "&client_key=" + clientkey + "&limit=" + lmt;
    }
    httpGetAsync(featured_url, tenorCallback_featured);
    return;
  }
  function grab_collection_data() {
    setCategoryDetails(collection/* get */.U());
  }
  const goDetail = search_term => {
    setCategoryDetails([]);
    if (search_term) {
      if (search_term === "featured") {
        grab_featured_data(true);
      } else if (search_term === "collections") {
        grab_collection_data();
      } else {
        grab_img_data(search_term);
      }
      setShowDetail(true);
      setCategory(search_term);
    }
  };
  const appendData = () => {
    if (nextIndex) {
      grab_img_data(category, nextIndex);
    }
  };
  const appendFeaturedData = () => {
    if (nextIndex) {
      grab_featured_data(true, nextIndex);
    }
  };
  const onScroll = e => {
    if (e.currentTarget.scrollHeight - e.currentTarget.scrollTop <= ContainerHeight) {
      if (category === "featured") {
        appendFeaturedData();
      } else if (category === "collections") {} else {
        appendData();
      }
    }
  };
  const sendGif = async detail => {
    props.sendGif(detail);
  };
  const goCategories = () => {
    setShowDetail(false);
    setCategory('');
    setCategoryDetails([]);
    setFeatureCategory([]);
  };
  const setCollection = (e, detail, isCollected) => {
    e.stopPropagation();
    e.preventDefault();
    const collect = {
      url: "",
      dims: [0, 0]
    };
    if (detail !== null && detail !== void 0 && detail.media_formats) {
      collect.url = detail.media_formats.tinygif.url;
      collect.dims[0] = detail.media_formats.tinygif.dims[0];
      collect.dims[1] = detail.media_formats.tinygif.dims[1];
    } else {
      collect.url = detail.url;
      collect.dims[0] = detail.dims[0];
      collect.dims[1] = detail.dims[1];
    }
    if (category === "collections") {
      setCategoryDetails(collection/* add */.I(collect));
    } else {
      collection/* add */.I(collect);
    }
    setCollectCategory(collection/* get */.U());
    dispatcher/* default */.ZP.dispatch({
      action: actions/* Action */.a.UpdateStarState,
      detail,
      isCollected
    });
  };
  return /*#__PURE__*/react.createElement("div", {
    className: "mx_GifPicker_Category_wapper"
  }, showDetail ? /*#__PURE__*/react.createElement("span", {
    onClick: goCategories,
    style: {
      "cursor": "pointer",
      "margin": " 0 0 0 5px"
    }
  }, /*#__PURE__*/react.createElement("span", {
    className: "mx_GifPicker_Category_icon"
  }), /*#__PURE__*/react.createElement("span", {
    className: "mx_GifPicker_Category_text"
  }, category === "featured" ? (0,languageHandler._t)("Hot GIFs") : category)) : null, showDetail ?
  /*#__PURE__*/
  // <List>
  react.createElement(rc_virtual_list_lib["default"], {
    data: categoryDetails,
    itemKey: "itemkey",
    height: ContainerHeight,
    onScroll: onScroll
  }, detail => {
    const imgStyle = {};
    let url = "";
    if (detail !== null && detail !== void 0 && detail.media_formats) {
      const countHeight = detail.media_formats.tinygif.dims[1] / detail.media_formats.tinygif.dims[0] * 180;
      imgStyle['--imgHeight'] = `${countHeight}px`;
      url = detail.media_formats.tinygif.url;
    } else {
      const countHeight = detail.dims[1] / detail.dims[0] * 180;
      imgStyle['--imgHeight'] = `${countHeight}px`;
      url = detail.url;
    }
    let isCollected = false;
    if (category === "collections") {
      isCollected = true;
    } else {
      for (let i = 0; i < collectCategory.length; i++) {
        if (detail.media_formats.tinygif.url === collectCategory[i].url) {
          isCollected = true;
        }
      }
    }
    return /*#__PURE__*/react.createElement("div", {
      key: detail.id,
      className: "mx_GifPicker_Category_detail",
      onClick: () => sendGif(detail),
      style: {
        "cursor": "pointer"
      }
    }, /*#__PURE__*/react.createElement("img", {
      // onClick={()=>{isCollected = !isCollected, console.log('11111isCollected', isCollected)}}
      onClick: e => setCollection(e, detail, !isCollected),
      className: isCollected ? "mx_GifPicker_Category_collect_svg_selected" : "mx_GifPicker_Category_collect_svg"
      // title={isCollected? "concel" : "collect"}
    }), /*#__PURE__*/react.createElement("img", {
      className: "mx_GifPicker_Category_img",
      src: url,
      width: 180,
      style: imgStyle
    }));
  }) : /*#__PURE__*/react.createElement(AutoHideScrollbar/* default */.Z, null, collectCategory.length != 0 ? collectCategory.slice(0, 1).map((category, index) => {
    const style = {};
    if (category !== null && category !== void 0 && category.url) {
      style['--imageBackground'] = `url(${category === null || category === void 0 ? void 0 : category.url})`;
    }
    return /*#__PURE__*/react.createElement("div", {
      key: index,
      className: "mx_GifPicker_Category_container",
      onClick: () => goDetail("collections"),
      style: {
        "cursor": "pointer"
      }
    }, /*#__PURE__*/react.createElement("div", {
      className: "mx_GifPicker_Category_card",
      style: style
    }, /*#__PURE__*/react.createElement("p", {
      className: "mx_GifPicker_CateGory_text"
    }, (0,languageHandler._t)("Collections"))));
  }) : /*#__PURE__*/react.createElement("div", {
    className: "mx_GifPicker_Category_container",
    onClick: () => goDetail("collections"),
    style: {
      "cursor": "pointer"
    }
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_GifPicker_Category_card_null"
  }, /*#__PURE__*/react.createElement("p", {
    className: "mx_GifPicker_CateGory_text"
  }, (0,languageHandler._t)("Collections")))), featureCategory.map((category, index) => {
    const style = {};
    if (category.media_formats.tinygif.url) {
      style['--imageBackground'] = `url(${category.media_formats.tinygif.url})`;
    }
    return /*#__PURE__*/react.createElement("div", {
      key: index,
      className: "mx_GifPicker_Category_container",
      onClick: () => goDetail("featured"),
      style: {
        "cursor": "pointer"
      }
    }, /*#__PURE__*/react.createElement("div", {
      className: "mx_GifPicker_Category_card",
      style: style
    }, /*#__PURE__*/react.createElement("p", {
      className: "mx_GifPicker_CateGory_text"
    }, (0,languageHandler._t)("Hot GIFs"))));
  }), customCategory.concat(defaultCategory).map((category, index) => {
    const style = {};
    if (category.image) {
      style['--imageBackground'] = `url(${category.image})`;
    }
    return /*#__PURE__*/react.createElement("div", {
      key: index,
      className: "mx_GifPicker_Category_container",
      onClick: () => goDetail(category.searchterm),
      style: {
        "cursor": "pointer"
      }
    }, /*#__PURE__*/react.createElement("div", {
      className: "mx_GifPicker_Category_card",
      style: style
    }, /*#__PURE__*/react.createElement("p", {
      className: "mx_GifPicker_CateGory_text"
    }, category.searchterm)));
  })));
};
/* harmony default export */ const Categroy = (GifCategory);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/gifspicker/GifPicker.tsx








const GifPicker_ContainerHeight = 600;
const GifsPicker = props => {
  const [filter, setFilter] = (0,react.useState)("");
  const [searchRes, setSearchRes] = (0,react.useState)([]);
  const [searchNext, setSearchNext] = (0,react.useState)("");
  const [collectionList, setCollectionList] = (0,react.useState)([]);
  const bodyRef = /*#__PURE__*/react.createRef();
  (0,react.useEffect)(() => {
    if (props.search) {
      onChangeFilter(props.search);
    }
  }, [props.search]);
  (0,react.useEffect)(() => {
    if (filter) {
      grab_img_data(filter);
    }
  }, [filter]);
  (0,react.useEffect)(() => {
    if (collectionList.length === 0) {
      setCollectionList(collection/* get */.U());
    }
  }, []);

  // callback for the top 8 GIFs of search
  const tenorCallback_search = responsetext => {
    const response_objects = JSON.parse(responsetext);
    setSearchRes(searchRes.concat(response_objects["results"]));
    // setSearchRes(response_objects["results"])
    setSearchNext(response_objects["next"]);
    return;
  };

  // function to call the trending and category endpoints
  const grab_img_data = (filter, next) => {
    const apikey = "AIzaSyDj8YSuGO_oxzvFYa1yiqdMuiF5GMaS7WI";
    const clientkey = "hiseas-apps";
    const lmt = 10;
    const search_term = filter;
    if (next) {
      // using default locale of en_US
      var search_url = "https://tenor.googleapis.com/v2/search?q=" + search_term + "&key=" + apikey + "&client_key=" + clientkey + "&limit=" + lmt + "&pos=" + next;
      setSearchNext("");
    } else {
      // using default locale of en_US
      var search_url = "https://tenor.googleapis.com/v2/search?q=" + search_term + "&key=" + apikey + "&client_key=" + clientkey + "&limit=" + lmt;
    }
    httpGetAsync(search_url, tenorCallback_search);
    return;
  };
  const onChangeFilter = filter => {
    setFilter(filter);
    setSearchRes([]);
    props === null || props === void 0 ? void 0 : props.onChangeSearch(filter);
  };
  const onEnterFilter = () => {
    const btn = bodyRef.current.querySelector(".mx_EmojiPicker_item");
    if (btn) {
      btn.click();
    }
  };
  const appendData = () => {
    if (searchNext) {
      grab_img_data(filter, searchNext);
    }
  };
  const onScroll = e => {
    if (e.currentTarget.scrollHeight - e.currentTarget.scrollTop <= GifPicker_ContainerHeight) {
      appendData();
    }
  };
  const setCollection = (e, detail, isCollected) => {
    e.stopPropagation();
    e.preventDefault();
    const collect = {
      url: "",
      dims: [0, 0]
    };
    if (detail !== null && detail !== void 0 && detail.media_formats) {
      collect.url = detail.media_formats.tinygif.url;
      collect.dims[0] = detail.media_formats.tinygif.dims[0];
      collect.dims[1] = detail.media_formats.tinygif.dims[1];
    } else {
      collect.url = detail.url;
      collect.dims[0] = detail.dims[0];
      collect.dims[1] = detail.dims[1];
    }
    collection/* add */.I(collect);
    setCollectionList(collection/* get */.U());
    dispatcher/* default */.ZP.dispatch({
      action: actions/* Action */.a.UpdateStarState,
      detail,
      isCollected
    });
  };
  return /*#__PURE__*/react.createElement("div", {
    className: "mx_GifPicker"
  }, /*#__PURE__*/react.createElement(gifspicker_Search, {
    query: filter,
    onChange: onChangeFilter,
    onEnter: onEnterFilter
  }), filter != "" ?
  /*#__PURE__*/
  // <div>
  react.createElement(rc_virtual_list_lib["default"], {
    data: searchRes,
    itemKey: "id",
    height: GifPicker_ContainerHeight,
    onScroll: onScroll
  }, detail => {
    const imgStyle = {};
    if (detail.media_formats.tinygif.dims[1]) {
      const countHeight = detail.media_formats.tinygif.dims[1] / detail.media_formats.tinygif.dims[0] * 180;
      imgStyle["--imgHeight"] = `${countHeight}px`;
    }
    let isCollected = false;
    for (let i = 0; i < collectionList.length; i++) {
      if (detail.media_formats.tinygif.url === collectionList[i].url) {
        isCollected = true;
      }
    }
    return /*#__PURE__*/react.createElement("div", {
      key: detail.id,
      className: "mx_GifPicker_Category_detail",
      onClick: () => props.sendGif(detail),
      style: {
        cursor: "pointer"
      }
    }, /*#__PURE__*/react.createElement("img", {
      onClick: e => setCollection(e, detail, !isCollected),
      className: isCollected ? "mx_GifPicker_Category_collect_svg_selected" : "mx_GifPicker_Category_collect_svg"
      // title={isCollected? "concel" : "collect"}
    }), /*#__PURE__*/react.createElement("img", {
      className: "mx_GifPicker_Category_img",
      src: detail.media_formats.tinygif.url,
      width: 180,
      style: imgStyle
    }));
  }) : /*#__PURE__*/react.createElement("div", {
    className: "mx_GifPicker_Category_wapper"
  }, /*#__PURE__*/react.createElement(Categroy, {
    sendGif: props.sendGif
  })));
};
/* harmony default export */ const GifPicker = (GifsPicker);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/hooks/useDispatcher.ts
var useDispatcher = __webpack_require__(694284);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/lib/util.ts
var util = __webpack_require__(25654);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/PermissionStore.ts
var PermissionStore = __webpack_require__(825291);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/structures/IframeWidget.tsx + 7 modules
var IframeWidget = __webpack_require__(731400);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/stores/ContactStore.ts + 1 modules
var ContactStore = __webpack_require__(476979);
// EXTERNAL MODULE: ./node_modules/matrix-js-sdk/src/@types/user.ts
var user = __webpack_require__(650540);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/SdkConfig.ts
var SdkConfig = __webpack_require__(374312);
// EXTERNAL MODULE: ./node_modules/ahooks/lib/index.js
var ahooks_lib = __webpack_require__(924737);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/features/FeatureWrapper/index.tsx
var FeatureWrapper = __webpack_require__(158340);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/contexts/MatrixClientContext.ts
var MatrixClientContext = __webpack_require__(311878);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/elements/Spinner.tsx
var Spinner = __webpack_require__(641542);
// EXTERNAL MODULE: ./node_modules/lodash-es/get.js
var get = __webpack_require__(216423);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/icons/securityAndPrivacy/Disappear.tsx
var Disappear = __webpack_require__(851527);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/rooms/MessageSenderBar/DisappearMessagesPicker.tsx

function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0,defineProperty/* default */.Z)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }














const covertString = str => {
  var _unit$;
  if (!str) {
    return "";
  }
  const [timer, unit] = (str === null || str === void 0 ? void 0 : str.split(" ")) || [];
  return `${timer}${(_unit$ = unit[0]) === null || _unit$ === void 0 ? void 0 : _unit$.toLocaleLowerCase()}`;
};
const DisappearMessagesPicker = ({
  roomId
}) => {
  const cli = (0,react.useContext)(MatrixClientContext/* default */.Z);
  const state = (0,settingsStore/* useDefendSettingsStore */.IO)(state => state.settings);
  const [open, {
    set: setOpen
  }] = (0,ahooks_lib.useBoolean)(false);
  const [isLoading, {
    set: setLoadingState
  }] = (0,ahooks_lib.useBoolean)(false);
  const [loadingIndex, setLoadingIndex] = (0,react.useState)(-1);
  const {
    screenshot,
    forwarding,
    watermark,
    messageAliveSecond,
    roomAliveTimestamps
  } = state.get(roomId) || {};
  const handleOpenChange = newOpen => {
    setOpen(newOpen);
  };
  const handleChange = async state => {
    try {
      setLoadingState(true);
      const newState = _objectSpread({
        forwarding,
        watermark,
        screenshot,
        roomAliveTimestamps,
        messageAliveSecond
      }, state);
      await cli.updateSecurityAndPrivacyState(roomId, newState);
      dist.SdMessage.success("Successful");
      (0,settingsStore/* updateDefendSettings */.BA)({
        roomID: roomId,
        value: newState
      });
    } catch (error) {
      dist.SdMessage.error("Failed");
    } finally {
      setLoadingIndex(-1);
      setLoadingState(false);
      setOpen(false);
    }
  };
  const getProtectionPermission = () => {
    const room = cli.getRoom(roomId);
    if (room !== null && room !== void 0 && room.hasSpaceParent()) {
      // channel
      const [ManageSquadEnabled, SquadManageRoomEnabled] = PermissionStore/* default */.ZP.hasPermission(roomId, [PermissionStore/* PermissionMap */.$W.ManageSquad, PermissionStore/* PermissionMap */.$W.SquadManageRoom]);
      return ManageSquadEnabled && SquadManageRoomEnabled;
    }
    const powerLevel = room === null || room === void 0 ? void 0 : room.currentState.getStateEvents(_types_event/* EventType */.tw.RoomPowerLevels, "");
    const powerLevels = powerLevel === null || powerLevel === void 0 ? void 0 : powerLevel.getContent();
    const {
      role_bindings
    } = powerLevels || {};
    const isOwner = (0,get/* default */.Z)(role_bindings, "Owner", []).some(userId => userId === cli.getUserId());
    const isAdmin = (0,get/* default */.Z)(role_bindings, "SA", []).some(userId => userId === cli.getUserId());
    return isOwner || isAdmin;
  };
  if (messageAliveSecond <= 0) {
    return null;
  }
  if (!getProtectionPermission()) {
    return /*#__PURE__*/react.createElement(FeatureWrapper/* default */.Z, null, /*#__PURE__*/react.createElement(elements_AccessibleButton/* default */.Z, {
      onClick: () => {
        lib.message.info({
          icon: /*#__PURE__*/react.createElement(react.Fragment, null),
          content: /*#__PURE__*/react.createElement("div", {
            style: {
              display: "flex",
              flexDirection: "row",
              alignItems: "center",
              gap: "4px"
            }
          }, /*#__PURE__*/react.createElement(Disappear/* default */.Z, null), "Messages in this group chat will disappear after", " ", covertString(settingsStore/* aliveTimeMap2Value */.OT.get(messageAliveSecond)))
        });
      }
    }, covertString(settingsStore/* aliveTimeMap2Value */.OT.get(messageAliveSecond))));
  }
  return /*#__PURE__*/react.createElement(FeatureWrapper/* default */.Z, null, /*#__PURE__*/react.createElement(lib.Popover, {
    content: /*#__PURE__*/react.createElement(lib.Space, {
      direction: "vertical",
      className: "mx_disappear_Messages_Picker_pop",
      size: 0
    }, settingsStore/* aliveTimeLists */.bc.map(item => /*#__PURE__*/react.createElement("div", {
      className: classnames_default()({
        mx_disappear_Messages_Picker_item: true,
        active: messageAliveSecond === item
      }),
      key: item,
      onClick: () => {
        setLoadingIndex(item);
        handleChange({
          messageAliveSecond: item
        });
      }
    }, isLoading && loadingIndex === item && /*#__PURE__*/react.createElement(Spinner/* default */.Z, {
      w: 12,
      h: 12
    }), settingsStore/* aliveTimeMap2Value */.OT.get(item)))),
    title: null,
    trigger: "click",
    open: open,
    onOpenChange: handleOpenChange
  }, /*#__PURE__*/react.createElement(elements_AccessibleButton/* default */.Z, {
    onClick: () => null
  }, covertString(settingsStore/* aliveTimeMap2Value */.OT.get(messageAliveSecond)))));
};
/* harmony default export */ const MessageSenderBar_DisappearMessagesPicker = (DisappearMessagesPicker);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/messages/MImageReplyBody.tsx
var MImageReplyBody = __webpack_require__(494748);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/messages/MPollReplyBody.tsx
var MPollReplyBody = __webpack_require__(740142);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/utils/EventUtils.ts
var EventUtils = __webpack_require__(26031);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/messages/MFileBody.tsx
var MFileBody = __webpack_require__(393562);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/messages/MVoiceReplyBody.tsx
var MVoiceReplyBody = __webpack_require__(836452);
// EXTERNAL MODULE: ./node_modules/@sdm/react/dist/index.js
var react_dist = __webpack_require__(654384);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/elements/RoomName.tsx
var RoomName = __webpack_require__(75865);
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/components/views/rooms/EventTileType.tsx
var EventTileType = __webpack_require__(442025);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/rooms/ForwardTile.tsx

var ForwardTile_dec, ForwardTile_class;
/*
Copyright 2020-2021 Tulir Asokan <tulir@maunium.net>

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/















let ForwardTile = (ForwardTile_dec = (0,replaceableComponent/* replaceableComponent */.U)("views.rooms.ForwardTile"), ForwardTile_dec(ForwardTile_class = class ForwardTile extends react.PureComponent {
  constructor(...args) {
    super(...args);
    (0,defineProperty/* default */.Z)(this, "renderRoomName", () => {
      const roomId = this.props.forwardEvents[0].getRoomId();
      const originRoom = src_MatrixClientPeg/* MatrixClientPeg */.p.get().getRoom(roomId);
      let settingsHint = false;
      const members = originRoom ? originRoom.getJoinedMembers() : undefined;
      const memberName = {
        rawDisplayName: "",
        ens: 0
      };
      if (members) {
        if (members.length === 1 && members[0].userId === src_MatrixClientPeg/* MatrixClientPeg */.p.get().credentials.userId) {
          const nameEvent = originRoom.currentState.getStateEvents("m.room.name", "");
          if (!nameEvent || !nameEvent.getContent().name) {
            settingsHint = true;
          }
        }
        if (originRoom.isDmRoom()) {
          members.forEach(item => {
            if (src_MatrixClientPeg/* MatrixClientPeg */.p.get().getUserId() !== item.userId) {
              memberName.ens = item.ens;
              memberName.rawDisplayName = item.rawDisplayName;
            }
          });
        }
      }
      const textClasses = classnames_default()("mx_RoomHeader_nametext", {
        mx_RoomHeader_settingsHint: settingsHint
      });
      return /*#__PURE__*/react.createElement(RoomName/* default */.Z, {
        room: originRoom
      }, (name, remark) => {
        const roomName = remark || name;
        return /*#__PURE__*/react.createElement("div", {
          dir: "auto",
          className: textClasses,
          title: roomName
        }, memberName.ens && memberName.rawDisplayName === roomName ? /*#__PURE__*/react.createElement(react_dist.Text, null, roomName) : /*#__PURE__*/react.createElement("span", null, roomName));
      });
    });
  }
  render() {
    if (this.props.forwardEvents.length === 1) {
      const mxEvent = this.props.forwardEvents[0];
      const msgType = mxEvent.getContent().msgtype;
      const {
        tileHandler,
        isInfoMessage
      } = (0,EventUtils/* getEventDisplayInfo */.UL)(mxEvent);
      // This shouldn't happen: the caller should check we support this type
      // before trying to instantiate us
      if (!tileHandler) {
        console.warn(`Event type not supported: type:${mxEvent.getType()} isState:${mxEvent.isState()}`);
        return /*#__PURE__*/react.createElement("div", {
          className: "mx_ForwardTile mx_ForwardTile_info mx_MNoticeBody"
        }, (0,languageHandler._t)('This event could not be displayed'));
      }

      // const EventTileType = sdk.getComponent(tileHandler);

      const classes = classnames_default()("mx_ForwardTile", {
        mx_ForwardTile_info: isInfoMessage && !mxEvent.isRedacted(),
        mx_ForwardTile_audio: msgType === _types_event/* MsgType */.Zw.Audio,
        mx_ForwardTile_video: msgType === _types_event/* MsgType */.Zw.Video
      });
      const msgtypeOverrides = {
        [_types_event/* MsgType */.Zw.Image]: MImageReplyBody["default"],
        [_types_event/* MsgType */.Zw.Sticker]: MImageReplyBody["default"],
        // Override audio and video body with file body. We also hide the download/decrypt button using CSS
        [_types_event/* MsgType */.Zw.Audio]: (0,EventUtils/* isVoiceMessage */.CZ)(mxEvent) ? MVoiceReplyBody["default"] : MFileBody["default"],
        [_types_event/* MsgType */.Zw.Video]: MImageReplyBody["default"]
      };
      const evOverrides = {
        // Use MImageReplyBody so that the sticker isn't taking up a lot of space
        [_types_event/* EventType */.tw.Sticker]: MImageReplyBody["default"],
        [_types_event/* EventType */.tw.PollStart]: MPollReplyBody["default"]
      };
      return /*#__PURE__*/react.createElement("div", {
        className: classes
      }, this.renderRoomName(), /*#__PURE__*/react.createElement(EventTileType/* default */.Z, {
        messageType: tileHandler,
        ref: "tile",
        mxEvent: mxEvent,
        showUrlPreview: false,
        overrideBodyTypes: msgtypeOverrides,
        overrideEventTypes: evOverrides,
        replacingEventId: mxEvent.replacingEventId(),
        maxImageHeight: 96,
        isReply: true
      }));
    } else if (this.props.forwardEvents.length > 1) {
      return /*#__PURE__*/react.createElement("div", {
        className: "mx_ForwardTile"
      }, this.renderRoomName(), /*#__PURE__*/react.createElement("div", {
        className: "mx_ForwardTile_preview"
      }, `${this.props.forwardEvents.length} forwarded messages`));
    }
    return null;
  }
}) || ForwardTile_class);

;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/rooms/ForwardPreview.tsx






class ForwardPreview extends react.Component {
  cancelFroward() {
    dispatcher/* default */.ZP.dispatch({
      action: actions/* Action */.a.ForwardMessage,
      forwardPhase: null
    });
  }
  render() {
    const quotingEvent = RoomViewStore/* default */.Z.getQuotingEvent();
    if (quotingEvent) return null;
    if (!this.props.forwardPhase) return null;
    const {
      forwardEvents,
      forwardTargetRoom
    } = this.props.forwardPhase;
    if (!forwardTargetRoom) return null;
    if (forwardTargetRoom.roomId !== this.props.room.roomId) return null;
    return /*#__PURE__*/react.createElement("div", {
      className: "mx_ForwardPreview"
    }, /*#__PURE__*/react.createElement("div", {
      className: "mx_ForwardPreview_section"
    }, /*#__PURE__*/react.createElement(dist.SdIcon, {
      className: "mx_ForwardPreview_left_icon",
      icon: "ReplyOutlines"
    }), /*#__PURE__*/react.createElement("blockquote", {
      className: "mx_ReplyThread",
      key: forwardEvents[0].getId()
    }, /*#__PURE__*/react.createElement(ForwardTile, {
      forwardEvents: forwardEvents
    })), /*#__PURE__*/react.createElement(dist.SdIcon, {
      className: "mx_ForwardPreview_cancel",
      icon: "CloseOutlines",
      onClick: this.cancelFroward
    })));
  }
}
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/components/views/rooms/MessageComposer.tsx


var MessageComposer_dec, MessageComposer_class2, _class3;
function MessageComposer_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function MessageComposer_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? MessageComposer_ownKeys(Object(t), !0).forEach(function (r) { (0,defineProperty/* default */.Z)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : MessageComposer_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
/*
Copyright 2015-2021 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/





// import Stickerpicker from "./Stickerpicker";


// import E2EIcon from './E2EIcon';














// import MemberStatusMessageAvatar from "../avatars/MemberStatusMessageAvatar";

// import { JSEncrypt } from "encryptlong";
// import { LUCKY_DROP_URL, LUCKY_DROP_PUBLIC_KEY } from '../../../lib/constants';



















// import PollCreateDialog from "../elements/PollCreateDialog";

let instanceCount = 0;
const NARROW_MODE_BREAKPOINT = 500;
function SendButton(props) {
  var _props$title;
  return /*#__PURE__*/react.createElement(dist.SdTooltip, {
    title: (_props$title = props.title) !== null && _props$title !== void 0 ? _props$title : (0,languageHandler._t)("Send message"),
    placement: "left",
    autoAdjustOverflow: true
  }, /*#__PURE__*/react.createElement(dist.SdButton, {
    key: "mx_MessageComposer_sendMessage",
    className: "mx_MessageComposer_sendMessage",
    onClick: props.onClick
  }));
}

// interface IAdditionalButtonProps {
//     width: number;
//     menuPosition: any; // TODO: Types
// }
let ImageType = /*#__PURE__*/function (ImageType) {
  ImageType["GIF"] = "gif";
  ImageType["Emoji"] = "emoji";
  ImageType["Sticker"] = "sticker";
  return ImageType;
}({});
const EmojiButton = ({
  addEmoji,
  menuPosition,
  roomId,
  squad,
  disabled
}) => {
  const WHITE_LIST_PERMISSION = SdkConfig/* default */.Z.get("WHITE_LIST_PERMISSION");
  const [menuDisplayed, button, openMenu, closeMenu] = (0,ContextMenu/* useContextMenu */.av)();
  const [cuteMessage, setCuteMessage] = (0,react.useState)(ImageType.Sticker);
  const [search, setSearch] = (0,react.useState)("");
  const initialState = {
    dapp: ""
  };
  function reducer(dappState, action) {
    switch (action.type) {
      case "set_dapp":
        return {
          dapp: "dapp"
        };
      case "init_dapp":
        return {
          dapp: ""
        };
      default:
        return initialState;
    }
  }
  const [dappState, dispatch] = (0,react.useReducer)(reducer, initialState);
  (0,useDispatcher/* useDispatcher */.P)(dispatcher/* defaultDispatcher */.ec, payload => {
    if (payload.action === actions/* Action */.a.EmojiShow) {
      if (payload.from === "dapp") {
        dispatch({
          type: "set_dapp"
        });
        setTimeout(() => {
          setCuteMessage(ImageType.GIF);
        }, 100);
      }
      if (payload.imageType) {
        setCuteMessage(payload.imageType);
      }
      if (payload.search && (0,util/* isString */.HD)(payload.search)) {
        setSearch(payload.search);
      }
      if (!menuDisplayed) {
        openMenu();
      } else {
        closeMenu();
      }
    }
  });

  // 发送给DApp gitDetail
  const sendGifToDapp = gifDetail => {
    dispatcher/* default */.ZP.dispatch({
      action: IframeWidget/* IFrameAction */.O.SendGifToDapp,
      data: MessageComposer_objectSpread({}, gifDetail)
    });
  };

  /**
   * DataUrl转为File
   * @param {String} dataUrl - dataUrl地址
   * @param {String} fileName - file文件名
   */
  // const dataURLtoFile = (dataUrl, fileName) => {
  //     const arr = dataUrl.split(','); const mime = arr[0].match(/:(.*?);/)[1];
  //     const bstr = atob(arr[1]); let n = bstr.length; const u8arr = new Uint8Array(n);
  //     while (n--) {
  //         u8arr[n] = bstr.charCodeAt(n);
  //     }
  //     return new File([u8arr], fileName, { type: mime });
  // };

  /**
   * url转base64
   * @param {String} url - url地址
   */
  // const urlToBase64 = (url, width, height) => {
  //     return new Promise((resolve, reject) => {
  //         const image = new Image();
  //         image.onload = function() {
  //             const canvas = document.createElement('canvas');
  //             canvas.width = width;
  //             canvas.height = height;
  //             // 将图片插入画布并开始绘制
  //             canvas.getContext('2d').drawImage(image, 10, 10);
  //             // result
  //             const result = canvas.toDataURL('image/gif');
  //             resolve(result);
  //         };
  //         // CORS 策略，会存在跨域问题https://stackoverflow.com/questions/20424279/canvas-todataurl-securityerror
  //         image.setAttribute("crossOrigin", 'Anonymous');
  //         image.src = url;
  //         // 图片加载失败的错误处理
  //         image.onerror = () => {
  //             reject(new Error('转换失败'));
  //         };
  //     });
  // };

  /**
   * Base64转
   * @param base64 String base64格式字符串
   * @param contentType String file对象的文件类型，如："image/png"
   * @param filename String 文件名称或者文件路径
   */
  // function translateBase64ImgToFile(base64, filename, contentType) {
  //     const arr = base64.split(',');  //去掉base64格式图片的头部
  //     const bstr = atob(arr[1]);   //atob()方法将数据解码
  //     let leng = bstr.length;
  //     const u8arr = new Uint8Array(leng);
  //     while (leng--) {
  //         u8arr[leng] = bstr.charCodeAt(leng); //返回指定位置的字符的 Unicode 编码
  //     }
  //     return new File([u8arr], filename, { type: contentType });
  // }

  // const urlToFile = (gifDetail: IGif) => {
  //     if (gifDetail) {
  //         urlToBase64(gifDetail.media_formats.tinygif.url, gifDetail.media_formats.tinygif.dims[0], gifDetail.media_formats.tinygif.dims[1]).then(blobType=>{
  //             console.log(blobType);
  //             console.log('11111uploadGif', blobType)
  //             const fileType = translateBase64ImgToFile(blobType, gifDetail.content_description,"image/png")
  //             console.log('11111fileType', fileType)
  //             return fileType
  //         })
  //     } else {
  //         return false
  //     }
  // }

  const onUploadFileInputChange = gifDetail => {
    if (gifDetail) {
      if (dappState.dapp) {
        sendGifToDapp(gifDetail);
        dispatch({
          type: "init_dapp"
        });
        closeMenu();
        return false;
      }
      closeMenu();
      const newFile = new File([""], "emptyFile*-");
      const tfiles = [];
      tfiles.push(newFile);
      ContentMessages/* default */.ZP.sharedInstance().sendContentListToRoom(tfiles, roomId, src_MatrixClientPeg/* MatrixClientPeg */.p.get(),
      // gifDetail?.media_formats?.tinygif?.url ? gifDetail.media_formats.tinygif.url : gifDetail.url,
      // gifDetail?.media_formats ? gifDetail?.media_formats.tinygif.dims: gifDetail.dims,
      gifDetail);

      // This is the onChange handler for a file form control, but we're
      // not keeping any state, so reset the value of the form control
      // to empty.
      // NB. we need to set 'value': the 'files' property is immutable.
      // })

      // console.log('11111uploadGif', uploadGif)
      return true;
    } else {
      return false;
    }

    // if (ev.target.files.length === 0) return;

    // // take a copy so we can safely reset the value of the form control
    // // (Note it is a FileList: we can't use slice or sensible iteration).
    // const tfiles = [];
    // for (let i = 0; i < ev.target.files.length; ++i) {
    //     tfiles.push(ev.target.files[i]);
    // }

    // ContentMessages.sharedInstance().sendContentListToRoom(
    //     tfiles,
    //     roomId,
    //     MatrixClientPeg.get(),
    // );

    // This is the onChange handler for a file form control, but we're
    // not keeping any state, so reset the value of the form control
    // to empty.
    // NB. we need to set 'value': the 'files' property is immutable.
    // ev.target.value = "";
    // this.props.closeMenu();
  };

  const sendSticker = stickerDetail => {
    let url = stickerDetail.url;
    let info = stickerDetail.info;
    let text = stickerDetail.name;
    let package_id = stickerDetail.package_id;
    ContentMessages/* default */.ZP.sharedInstance().sendStickerContentToRoom({
      url: url,
      roomId: roomId,
      info: info,
      text: text,
      matrixClient: src_MatrixClientPeg/* MatrixClientPeg */.p.get(),
      package_id: package_id
    });
    closeMenu();
  };
  let contextEmotion;
  if (cuteMessage === ImageType.GIF) {
    contextEmotion = /*#__PURE__*/react.createElement(GifPicker, {
      search: search,
      sendGif: onUploadFileInputChange,
      onChangeSearch: setSearch
    });
  } else if (cuteMessage === ImageType.Emoji) {
    contextEmotion = /*#__PURE__*/react.createElement(EmojiPicker/* default */.ZP, {
      search: search,
      onChoose: addEmoji,
      showQuickReactions: true,
      onChangeSearch: setSearch
    });
  } else if (cuteMessage === ImageType.Sticker) {
    contextEmotion = /*#__PURE__*/react.createElement(stickerpicker_StickerPicker, {
      search: search,
      sendSticker: sendSticker,
      onChangeSearch: setSearch,
      squad: squad
    });
  }
  let contextMenu;
  if (menuDisplayed) {
    const position = menuPosition !== null && menuPosition !== void 0 ? menuPosition : (0,ContextMenu/* aboveLeftOf */.LS)(button.current.getBoundingClientRect());
    if (position.right === 0) {
      position.right += 122;
      position.bottom += 10;
    }
    contextMenu = /*#__PURE__*/react.createElement(ContextMenu/* ContextMenu */.xV, (0,esm_extends/* default */.Z)({}, position, {
      wrapperClassName: "mx_ContextualMenu_wrapper_emo",
      onFinished: closeMenu,
      managed: false
    }), /*#__PURE__*/react.createElement("div", {
      className: "mx_MessageComposer_emotion_actionGroup"
    }, /*#__PURE__*/react.createElement(elements_AccessibleButton/* default */.Z, {
      onClick: () => setCuteMessage(ImageType.GIF),
      kind: "primary",
      className: cuteMessage === ImageType.GIF ? "mx_MessageComposer_emotion_button_focus" : "mx_MessageComposer_emotion_button"
    }, (0,languageHandler._t)("GIFs")), /*#__PURE__*/react.createElement(elements_AccessibleButton/* default */.Z, {
      onClick: () => setCuteMessage(ImageType.Sticker),
      kind: "primary",
      className: cuteMessage === ImageType.Sticker ? "mx_MessageComposer_emotion_button_focus" : "mx_MessageComposer_emotion_button"
    }, (0,languageHandler._t)("Stickers")), dappState.dapp ? /*#__PURE__*/react.createElement(react.Fragment, null) : /*#__PURE__*/react.createElement(elements_AccessibleButton/* default */.Z, {
      onClick: () => setCuteMessage(ImageType.Emoji),
      kind: "primary",
      className: cuteMessage === ImageType.Emoji ? "mx_MessageComposer_emotion_button_focus" : "mx_MessageComposer_emotion_button"
    }, (0,languageHandler._t)("Emoji"))), contextEmotion);
  }
  const className = classnames_default()(
  // "mx_MessageComposer_inner_button",
  "mx_MessageComposer_emoji"
  // {
  //     mx_MessageComposer_button_highlight: menuDisplayed,
  // },
  );

  // TODO: replace ContextMenuTooltipButton with a unified representation of
  // the header buttons and the right panel buttons
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(dist.SdTooltip, {
    title: (0,languageHandler._t)("Emoji picker"),
    placement: "top"
  }, /*#__PURE__*/react.createElement(dist.SdButton, {
    key: "Emoji picker",
    className: className,
    onClick: openMenu,
    disabled: disabled
  }, /*#__PURE__*/react.createElement(dist.SdIcon, {
    icon: "EmojiOutlines"
  }))), contextMenu);
};
class UploadButton extends react.Component {
  constructor(props) {
    super(props);
    (0,defineProperty/* default */.Z)(this, "uploadInput", /*#__PURE__*/react.createRef());
    (0,defineProperty/* default */.Z)(this, "dispatcherRef", void 0);
    (0,defineProperty/* default */.Z)(this, "onAction", payload => {
      if (payload.action === "upload_file") {
        this.onUploadClick();
      }
    });
    (0,defineProperty/* default */.Z)(this, "onUploadClick", () => {
      if (src_MatrixClientPeg/* MatrixClientPeg */.p.get().isGuest()) {
        dispatcher/* default */.ZP.dispatch({
          action: "require_registration"
        });
        return;
      }
      this.uploadInput.current.click();
    });
    (0,defineProperty/* default */.Z)(this, "onUploadFileInputChange", ev => {
      if (ev.target.files.length === 0) return;

      // take a copy so we can safely reset the value of the form control
      // (Note it is a FileList: we can't use slice or sensible iteration).
      const tfiles = [];
      for (let i = 0; i < ev.target.files.length; ++i) {
        tfiles.push(ev.target.files[i]);
      }
      ContentMessages/* default */.ZP.sharedInstance().sendContentListToRoom(tfiles, this.props.roomId, src_MatrixClientPeg/* MatrixClientPeg */.p.get());

      // This is the onChange handler for a file form control, but we're
      // not keeping any state, so reset the value of the form control
      // to empty.
      // NB. we need to set 'value': the 'files' property is immutable.
      ev.target.value = "";
      this.props.closeMenu();
    });
    this.dispatcherRef = dispatcher/* default */.ZP.register(this.onAction);
  }
  componentWillUnmount() {
    dispatcher/* default */.ZP.unregister(this.dispatcherRef);
  }
  render() {
    const uploadInputStyle = {
      display: "none"
    };
    return /*#__PURE__*/react.createElement(elements_AccessibleButton/* default */.Z, {
      key: "mx_MessageComposer_upload",
      className: "mx_MessageComposer_button",
      onClick: this.onUploadClick
    }, /*#__PURE__*/react.createElement("div", {
      className: "mx_MessageComposer_button_bg mx_MessageComposer_upload"
    }), /*#__PURE__*/react.createElement("div", null, (0,languageHandler._t)("File")), /*#__PURE__*/react.createElement("input", {
      ref: this.uploadInput,
      className: "mx_MessageComposer_upload_input",
      type: "file",
      style: uploadInputStyle,
      multiple: true,
      onChange: this.onUploadFileInputChange
    }));
  }
}
const LuckyDropButton = ({
  room
}) => {
  // function encryptCredentials() {
  //     const credentials = window.mxMatrixClientPeg.getCredentials();
  //     const encrypt = new JSEncrypt();
  //     encrypt.setPublicKey(LUCKY_DROP_PUBLIC_KEY);
  //     return encrypt.encryptLong(JSON.stringify(credentials));
  // }
  return /*#__PURE__*/React.createElement(AccessibleButton, {
    key: "MysteryBox",
    className: "mx_MessageComposer_button",
    onClick: () => {
      dis.dispatch({
        action: Action.SetRightPanelPhase,
        phase: RightPanelPhases.IframeWidget,
        refireParams: {
          params: {
            src: `${LUCKY_DROP_URL}/create?roomId=${room.roomId}`,
            title: "MysteryBox"
          }
        }
      });
    }
  }, /*#__PURE__*/React.createElement("div", {
    className: "mx_MessageComposer_button_bg mx_MessageComposer_luckybox"
  }), /*#__PURE__*/React.createElement("div", null, _t("MysteryBox")));
};
const PolygonButton = ({
  room
}) => {
  // function encryptCredentials() {
  //     const credentials = window.mxMatrixClientPeg.getCredentials();
  //     const encrypt = new JSEncrypt();
  //     encrypt.setPublicKey(LUCKY_DROP_PUBLIC_KEY);
  //     return encrypt.encryptLong(JSON.stringify(credentials));
  // }
  return /*#__PURE__*/React.createElement(AccessibleButton, {
    key: "Polygon",
    className: "mx_MessageComposer_button",
    onClick: () => {
      dis.dispatch({
        action: Action.SetRightPanelPhase,
        phase: RightPanelPhases.IframeWidget,
        refireParams: {
          params: {
            src: "https://w3w.ai/main/apps",
            title: "Polygon Dapp Store"
          }
        }
      });
    }
  }, /*#__PURE__*/React.createElement("div", {
    className: "mx_MessageComposer_button_bg mx_MessageComposer_polygon"
  }), /*#__PURE__*/React.createElement("div", {
    className: "mx_ellipsis"
  }, _t("Polygon Dapp Store")));
};
const TestButton = ({
  room
}) => {
  const url = location.hostname !== "localhost" ? "https://dapp-alpha.sending.me/test" : "http://localhost:3001/test";
  // const url = "https://businesscard.web3-tp.net/select?st=sdn&from=profile"
  return /*#__PURE__*/react.createElement(elements_AccessibleButton/* default */.Z, {
    key: "Test",
    className: "mx_MessageComposer_button",
    onClick: () => {
      dispatcher/* default */.ZP.dispatch({
        action: actions/* Action */.a.SetRightPanelPhase,
        phase: RightPanelStorePhases/* RightPanelPhases */.q4.IframeWidget,
        refireParams: {
          params: {
            src: url,
            title: "Test"
          }
        }
      });
    }
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_MessageComposer_button_bg mx_MessageComposer_transfer"
  }), /*#__PURE__*/react.createElement("div", null, (0,languageHandler._t)("Test")));
};
const GroupNoteButton = ({
  room
}) => {
  return /*#__PURE__*/react.createElement(elements_AccessibleButton/* default */.Z, {
    key: "GroupNote",
    className: "mx_MessageComposer_button",
    onClick: () => {
      dispatcher/* defaultDispatcher */.ec.dispatch({
        action: actions/* Action */.a.SetRightPanelPhase,
        phase: RightPanelStorePhases/* RightPanelPhases */.q4.GroupNote,
        room: room,
        refireParams: {
          params: {
            content: null,
            eventId: ""
          }
        }
      });
    }
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_MessageComposer_button_bg mx_MessageComposer_groupnote"
  }), /*#__PURE__*/react.createElement("div", null, (0,languageHandler._t)("Group Note")));
};
const LiveButton = ({
  room
}) => {
  return /*#__PURE__*/react.createElement(elements_AccessibleButton/* default */.Z, {
    key: "Live",
    className: "mx_MessageComposer_button",
    onClick: () => {
      dispatcher/* default */.ZP.dispatch({
        action: "show_live_view",
        roomId: room.roomId
      });
    }
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_MessageComposer_button_bg mx_MessageComposer_live"
  }), /*#__PURE__*/react.createElement("div", null, (0,languageHandler._t)("Live")));
};
let MessageComposer = (MessageComposer_dec = (0,replaceableComponent/* replaceableComponent */.U)("views.rooms.MessageComposer"), MessageComposer_dec(MessageComposer_class2 = (_class3 = class MessageComposer extends react.PureComponent {
  constructor(props) {
    super(props);
    (0,defineProperty/* default */.Z)(this, "dispatcherRef", void 0);
    (0,defineProperty/* default */.Z)(this, "messageComposerInput", void 0);
    (0,defineProperty/* default */.Z)(this, "voiceRecordingButton", void 0);
    (0,defineProperty/* default */.Z)(this, "ref", /*#__PURE__*/(0,react.createRef)());
    (0,defineProperty/* default */.Z)(this, "messageComposerToolbar", /*#__PURE__*/(0,react.createRef)());
    (0,defineProperty/* default */.Z)(this, "instanceId", void 0);
    (0,defineProperty/* default */.Z)(this, "clickHideMenu", e => {
      try {
        if (e.target.className !== "ant-card-body" && e.target.className !== "mx_MessageComposer_btn_additional" && e.target.className !== "mx_DappsMenu_btn_back" && e.target.className.indexOf("mx_MessageComposer_upload") === -1) {
          this.isAddtionalOpen(false);
        }
        if (e.target.className !== "ant-card-body" && e.target.className.indexOf("mx_MessageComposer_button_bg") === -1 && e.target.className.indexOf("mx_MessageComposer_upload_input") === -1) {
          this.isDappsOpen(false);
        }
      } catch (err) {
        console.log(err);
      }
    });
    (0,defineProperty/* default */.Z)(this, "onResize", (type, entry) => {
      if (type === UIStore/* UI_EVENTS */.Q.Resize) {
        const narrowMode = entry.contentRect.width <= NARROW_MODE_BREAKPOINT;
        this.setState({
          narrowMode,
          isMenuOpen: !narrowMode ? false : this.state.isMenuOpen,
          showStickers: false,
          showLre: false
        });
      }
    });
    (0,defineProperty/* default */.Z)(this, "onAction", payload => {
      if (payload.action === "reply_to_event") {
        // add a timeout for the reply preview to be rendered, so
        // that the ScrollPanel listening to the resizeNotifier can
        // correctly measure it's new height and scroll down to keep
        // at the bottom if it already is
        setTimeout(() => {
          this.props.resizeNotifier.notifyTimelineHeightChanged();
        }, 100);
      }
      if (payload.action === actions/* Action */.a.TurnOnMultiSelection) {
        const selectorVisable = payload.openSelectorPanel;
        this.setState({
          hidden: selectorVisable
        });
      }
    });
    (0,defineProperty/* default */.Z)(this, "onRoomStateEvents", (ev, state) => {
      if (ev.getType() === "m.room.power_levels") {
        this.checkPermissions();
      }
      if (ev.getRoomId() !== this.props.room.roomId) return;
      if (ev.getType() === "m.room.tombstone") {
        this.setState({
          tombstone: this.getRoomTombstone()
        });
      }
      if (ev.getType() === "m.room.slow_mode") {
        this.setPlaceholderText();
      }
    });
    (0,defineProperty/* default */.Z)(this, "onRoomLastSendMessageTimeUpdate", time => {
      this.setSlowModeText();
    });
    (0,defineProperty/* default */.Z)(this, "getUserShip", () => {
      const members = this.props.room.getMembers();
      const he = members.find(member => member.userId !== this.props.room.myUserId);
      const userShip = ContactStore["default"].instance.getUserShip(he === null || he === void 0 ? void 0 : he.userId);
      this.setState({
        userShip
      });
      return userShip;
    });
    (0,defineProperty/* default */.Z)(this, "sendFriendRequest", () => {
      const members = this.props.room.getMembers();
      const he = members.find(member => member.userId !== this.props.room.myUserId);
      if (he) {
        dispatcher/* default */.ZP.dispatch({
          action: "view_add_friend_apply",
          applyFriendsInfo: {
            userId: he.userId,
            room: this.props.room
          }
        });
      }
    });
    (0,defineProperty/* default */.Z)(this, "checkPermissions", () => {
      const [canUpload, canSendMessages, canManageMessage] = PermissionStore/* default */.ZP.hasPermission(this.props.room.roomId, [PermissionStore/* PermissionMap */.$W.RoomAttachFiles, PermissionStore/* PermissionMap */.$W.RoomSendMessage, PermissionStore/* PermissionMap */.$W.RoomManageMessage]);
      const isDmRoom = this.props.room.isDmRoom();
      const userShip = this.getUserShip();
      this.setState({
        canUpload: !!canUpload,
        canSendMessages: isDmRoom ? !!canSendMessages && !userShip.includes(user/* UserShip */.J.Stranger) : !!canSendMessages,
        canManageMessage: !!canManageMessage
      });
    });
    (0,defineProperty/* default */.Z)(this, "onTombstoneClick", ev => {
      ev.preventDefault();
      const replacementRoomId = this.state.tombstone.getContent()["replacement_room"];
      const replacementRoom = src_MatrixClientPeg/* MatrixClientPeg */.p.get().getRoom(replacementRoomId);
      let createEventId = null;
      if (replacementRoom) {
        const createEvent = replacementRoom.currentState.getStateEvents("m.room.create", "");
        if (createEvent && createEvent.getId()) {
          createEventId = createEvent.getId();
        }
      }
      const viaServers = [this.state.tombstone.getSender().split(":").splice(1).join(":")];
      dispatcher/* default */.ZP.dispatch({
        action: "view_room",
        highlighted: true,
        event_id: createEventId,
        room_id: replacementRoomId,
        auto_join: true,
        _type: "tombstone",
        // instrumentation

        // Try to join via the server that sent the event. This converts @something:example.org
        // into a server domain by splitting on colons and ignoring the first entry ("@something").
        via_servers: viaServers,
        opts: {
          // These are passed down to the js-sdk's /join call
          viaServers: viaServers
        }
      });
    });
    (0,defineProperty/* default */.Z)(this, "setSlowModeText", () => {
      var _this$props;
      let placeHolderText;
      const slowModeCoolTime = (_this$props = this.props) === null || _this$props === void 0 ? void 0 : _this$props.room.getSlowModeCoolTime();
      const lastSendMessageTime = this.props.room.lastSendMessageTime;
      const currentTime = new Date().getTime();
      const intervalTime = Math.floor((currentTime - lastSendMessageTime) / 1000);
      const count = slowModeCoolTime - intervalTime;
      if (count > 0 && !this.state.canManageMessage) {
        const hour = "0" + Math.floor(count / 3600);
        const minute = "0" + Math.floor(count % 3600 / 60);
        const seconds = "0" + count % 60;
        const hourS = hour.substring(hour.length - 2);
        const minuteS = minute.substring(minute.length - 2);
        const secondsS = seconds.substring(seconds.length - 2);
        placeHolderText = (0,languageHandler._t)("Slowmode") + " " + hourS + ":" + minuteS + ":" + secondsS;
        this.updatePlaceHolder(placeHolderText);
        this.props.room.slowModeCounting = true;
        setTimeout(() => {
          this.setSlowModeText();
        }, 1000);
      } else {
        placeHolderText = (0,languageHandler._t)("Slowmode");
        this.updatePlaceHolder(placeHolderText);
        this.props.room.slowModeCounting = false;
      }
    });
    (0,defineProperty/* default */.Z)(this, "updatePlaceHolder", text => {
      this.setState({
        placeHolderText: text
      });
    });
    (0,defineProperty/* default */.Z)(this, "setPlaceholderText", () => {
      var _this$props2;
      let placeHolderText;
      const slowModeCoolTime = (_this$props2 = this.props) === null || _this$props2 === void 0 ? void 0 : _this$props2.room.getSlowModeCoolTime();
      if (slowModeCoolTime) {
        this.setSlowModeText();
      } else if (this.props.replyToEvent) {
        if (this.props.replyInThread && this.props.e2eStatus) {
          placeHolderText = (0,languageHandler._t)("Reply to encrypted thread…");
        } else if (this.props.replyInThread) {
          placeHolderText = (0,languageHandler._t)("Reply to thread…");
        } else if (this.props.e2eStatus) {
          placeHolderText = (0,languageHandler._t)("Send an encrypted reply…");
        } else {
          placeHolderText = (0,languageHandler._t)("Send a reply…");
        }
        this.updatePlaceHolder(placeHolderText);
      } else {
        if (this.props.e2eStatus) {
          placeHolderText = (0,languageHandler._t)("Send an encrypted message…");
        } else {
          placeHolderText = (0,languageHandler._t)("Send a message…");
        }
        this.updatePlaceHolder(placeHolderText);
      }
    });
    (0,defineProperty/* default */.Z)(this, "sendMessage", async () => {
      if (this.state.haveRecording && this.voiceRecordingButton) {
        // There shouldn't be any text message to send when a voice recording is active, so
        // just send out the voice recording.
        await this.voiceRecordingButton.send();
        return;
      }
      if (!this.state.haveRecording && this.state.isComposerEmpty && !this.props.forwardPhase) {
        return;
      }
      this.messageComposerInput.sendMessage();
    });
    (0,defineProperty/* default */.Z)(this, "onChange", model => {
      this.setState({
        isComposerEmpty: model.isEmpty
      });
    });
    (0,defineProperty/* default */.Z)(this, "onVoiceStoreUpdate", () => {
      const recording = VoiceRecordingStore.instance.activeRecording;
      if (recording) {
        // Delay saying we have a recording until it is started, as we might not yet have A/V permissions
        recording.on(VoiceRecording/* RecordingState */.SR.Started, () => {
          this.setState({
            haveRecording: !!VoiceRecordingStore.instance.activeRecording
          });
        });
        // We show a little heads up that the recording is about to automatically end soon. The 3s
        // display time is completely arbitrary. Note that we don't need to deregister the listener
        // because the recording instance will clean that up for us.
        recording.on(VoiceRecording/* RecordingState */.SR.EndingSoon, ({
          secondsLeft
        }) => {
          this.setState({
            recordingTimeLeftSeconds: secondsLeft
          });
          setTimeout(() => this.setState({
            recordingTimeLeftSeconds: null
          }), 3000);
        });
      } else {
        this.setState({
          haveRecording: false
        });
      }
    });
    (0,defineProperty/* default */.Z)(this, "shouldShowStickerPicker", () => {
      return SettingsStore/* default */.C.getValue(UIFeature/* UIFeature */.H.Widgets) && SettingsStore/* default */.C.getValue("MessageComposerInput.showStickersButton") && !this.state.haveRecording;
    });
    (0,defineProperty/* default */.Z)(this, "shouldShowLrePicker", () => {
      return SettingsStore/* default */.C.getValue(UIFeature/* UIFeature */.H.Widgets) && SettingsStore/* default */.C.getValue("MessageComposerInput.showLreButton");
    });
    (0,defineProperty/* default */.Z)(this, "showStickers", showStickers => {
      this.setState({
        showStickers
      });
    });
    // private handleOpenLrePicker = (data: ISendProps) => {
    //     const roomId = this.props.room.roomId;
    //     ContentMessages.sharedInstance().sendLreToRoom(data, roomId, MatrixClientPeg.get());
    // };
    (0,defineProperty/* default */.Z)(this, "toggleButtonMenu", () => {
      this.setState({
        isMenuOpen: !this.state.isMenuOpen
      });
    });
    (0,defineProperty/* default */.Z)(this, "dappsButton", ({
      room
    }) => {
      return /*#__PURE__*/react.createElement(elements_AccessibleButton/* default */.Z, {
        key: "Dapps",
        className: "mx_MessageComposer_button",
        onClick: () => {
          this.isDappsOpen(true);
        }
      }, /*#__PURE__*/react.createElement("div", {
        className: "mx_MessageComposer_button_bg mx_MessageComposer_dapps"
      }), /*#__PURE__*/react.createElement("div", null, (0,languageHandler._t)("Dapps")));
    });
    (0,defineProperty/* default */.Z)(this, "isDappsOpen", isOpen => {
      this.setState({
        isDappsOpen: isOpen
      });
    });
    (0,defineProperty/* default */.Z)(this, "isAddtionalOpen", isOpen => {
      this.setState({
        isAdditionalOpen: isOpen
      });
    });
    VoiceRecordingStore.instance.on(AsyncStore/* UPDATE_EVENT */.aY, this.onVoiceStoreUpdate);
    this.state = {
      tombstone: this.getRoomTombstone(),
      canSendMessages: true,
      isComposerEmpty: true,
      haveRecording: false,
      recordingTimeLeftSeconds: null,
      // when set to a number, shows a toast
      isMenuOpen: false,
      showStickers: false,
      showLre: false,
      hidden: false,
      isDappsOpen: false,
      isAdditionalOpen: false,
      userShip: [user/* UserShip */.J.Stranger],
      placeHolderText: ""
    };
    this.instanceId = instanceCount++;
  }
  componentDidMount() {
    this.dispatcherRef = dispatcher/* default */.ZP.register(this.onAction);
    src_MatrixClientPeg/* MatrixClientPeg */.p.get().on("RoomState.events", this.onRoomStateEvents);
    this.props.room.on("Room.updateLastSendMessageTime", this.onRoomLastSendMessageTimeUpdate);
    this.waitForOwnMember();
    UIStore/* default */.Z.instance.trackElementDimensions(`MessageComposer${this.instanceId}`, this.ref.current);
    UIStore/* default */.Z.instance.on(`MessageComposer${this.instanceId}`, this.onResize);
    PermissionStore/* default */.ZP.instance.on(PermissionStore/* UPDATE_PERMISSION */.SH, this.checkPermissions);
    ContactStore["default"].instance.on(ContactStore/* FRIEND_UPDATE_EVENT */.rG, this.checkPermissions);
    document.addEventListener("click", this.clickHideMenu);
    this.setPlaceholderText();
    this.checkPermissions();
  }
  componentWillUnmount() {
    if (src_MatrixClientPeg/* MatrixClientPeg */.p.get()) {
      src_MatrixClientPeg/* MatrixClientPeg */.p.get().removeListener("RoomState.events", this.onRoomStateEvents);
      this.props.room.off("Room.updateLastSendMessageTime", this.onRoomLastSendMessageTimeUpdate);
    }
    VoiceRecordingStore.instance.off(AsyncStore/* UPDATE_EVENT */.aY, this.onVoiceStoreUpdate);
    dispatcher/* default */.ZP.unregister(this.dispatcherRef);
    UIStore/* default */.Z.instance.stopTrackingElementDimensions(`MessageComposer${this.instanceId}`);
    UIStore/* default */.Z.instance.removeListener(`MessageComposer${this.instanceId}`, this.onResize);
    PermissionStore/* default */.ZP.instance.off(PermissionStore/* UPDATE_PERMISSION */.SH, this.checkPermissions);
    ContactStore["default"].instance.off(ContactStore/* FRIEND_UPDATE_EVENT */.rG, this.checkPermissions);
    document.removeEventListener("click", this.clickHideMenu);
  }
  componentDidUpdate(prevProps) {
    var _this$messageComposer;
    const input = (_this$messageComposer = this.messageComposerInput) === null || _this$messageComposer === void 0 ? void 0 : _this$messageComposer.getActualInput();
    if (input && this.messageComposerToolbar) {
      input.style.paddingRight = `${this.messageComposerToolbar.current.clientWidth + 8}px`;
    }
    if (prevProps.e2eStatus !== this.props.e2eStatus || prevProps.replyToEvent != this.props.replyToEvent || prevProps.replyInThread !== this.props.replyInThread) {
      this.setPlaceholderText();
    }
  }
  waitForOwnMember() {
    // if we have the member already, do that
    const me = this.props.room.getMember(src_MatrixClientPeg/* MatrixClientPeg */.p.get().getUserId());
    if (me) {
      this.setState({
        me
      });
      return;
    }
    // Otherwise, wait for member loading to finish and then update the member for the avatar.
    // The members should already be loading, and loadMembersIfNeeded
    // will return the promise for the existing operation
    // this.props.room.loadMembersIfNeeded().then(() => {
    //     const me = this.props.room.getMember(
    //         MatrixClientPeg.get().getUserId(),
    //     );
    //     this.setState({ me });
    // });
  }

  getRoomTombstone() {
    return this.props.room.currentState.getStateEvents("m.room.tombstone", "");
  }
  addEmoji(emoji) {
    dispatcher/* default */.ZP.dispatch({
      action: actions/* Action */.a.ComposerInsert,
      text: emoji
    });
    return true;
  }
  renderAdditionals(closeMenu) {
    var _this$props$room, _this$props$room$getP;
    const buttons = [];
    const contextParams = {
      userId: this.props.room.myUserId,
      roomId: this.props.room.roomId,
      squadId: (_this$props$room = this.props.room) === null || _this$props$room === void 0 ? void 0 : (_this$props$room$getP = _this$props$room.getParentRoom()) === null || _this$props$room$getP === void 0 ? void 0 : _this$props$room$getP.roomId,
      timestamp: constants/* DAY_TIMESTAMP */.BG
    };
    const dappItems = this.props.dappItems;
    if (!this.state.haveRecording) {
      // const squad = this.props.room.getParentRoom();
      // if (squad) {
      //     buttons.push(
      //         <AuctionButton
      //             key="auction_button"
      //             room={this.props.room}
      //         />,
      //         <AirDropButton
      //             key="airdrop_button"
      //             room={this.props.room}
      //         />,
      //         <SmartButton key="smart_button" room={this.props.room} />,
      //     );
      // }
      // buttons.push(
      //     <FavoritesButton key="favorites" room={this.props.room} />,
      // );
      if (this.state.canUpload) {
        buttons.push( /*#__PURE__*/react.createElement(UploadButton, {
          key: "controls_upload",
          closeMenu: closeMenu,
          roomId: this.props.room.roomId
        }));
      }
      if (!this.props.room.isDmRoom()) {
        buttons.push( /*#__PURE__*/react.createElement(GroupNoteButton, {
          key: "controls_group_note",
          room: this.props.room
        }));
      }
      buttons.push( /*#__PURE__*/react.createElement(PollButton, {
        key: "controls_poll",
        closeMenu: closeMenu,
        roomId: this.props.room.roomId
      }));
      buttons.push( /*#__PURE__*/react.createElement(DappButtons/* default */.Z, {
        layout: "vertical",
        className: "mx_MessageComposer_button",
        context: contextParams,
        displayPosition: DappButtons/* DisplayPosition */.n.CHAT_BOX_L1,
        items: dappItems
      }));

      /* buttons.push(
          <EmojiButton key="emoji_button" addEmoji={this.addEmoji} menuPosition={menuPosition} narrowMode={this.state.narrowMode} />,
      );*/
      // buttons.push(
      //     <LuckyDropButton
      //         key="luckyDrop_button"
      //         room={this.props.room}
      //     />
      // );
      // buttons.push(
      //     <PeerSwapButton key="peerswap_button" room={this.props.room} />,
      // );
      if (location.hostname === "chat-alpha.sending.me" || location.hostname === "localhost") {
        buttons.push( /*#__PURE__*/react.createElement(TestButton, {
          key: "transfer_button",
          room: this.props.room
        }));
      }
      buttons.push( /*#__PURE__*/react.createElement(LiveButton, {
        key: "live_button",
        room: this.props.room
      }));
      // buttons.push(
      //     <GiftExchangeButton key="giftexchange_button" room={this.props.room} />,
      // );
      if (SdkConfig/* default */.Z.get("UNABLE_FUN_PERMISSION")) {
        buttons.push(this.dappsButton({
          room: this.props.room
        })
        // <DappsButton key="dapps_button" room={this.props.room} />,
        );
      }

      // buttons.push(
      //     <PolygonButton key="polygon_button" room={this.props.room} />
      // );
    }
    // if (this.shouldShowLrePicker()) {
    //     let title;
    //     if (!this.state.narrowMode) {
    //         title = this.state.showLre ? _t("Hide lucky red envelop") : _t("Show lucky red envelop");
    //     }

    //     buttons.push(
    //         <MagicBoxButton
    //             title={title}
    //             room={this.props.room}
    //             menuPosition={menuPosition}
    //             onSend={this.handleOpenLrePicker}
    //         />);
    // }
    if (this.shouldShowStickerPicker()) {
      buttons.push( /*#__PURE__*/react.createElement(elements_AccessibleButton/* default */.Z, {
        id: "stickersButton",
        key: "controls_stickers",
        className: "mx_MessageComposer_button",
        onClick: () => this.showStickers(!this.state.showStickers)
      }, /*#__PURE__*/react.createElement("div", {
        className: "mx_MessageComposer_button_bg mx_MessageComposer_sticker"
      }), /*#__PURE__*/react.createElement("div", null, this.state.showStickers ? (0,languageHandler._t)("Hide Stickers") : (0,languageHandler._t)("Show Stickers"))));
    }
    /*if (!this.state.haveRecording && !this.state.narrowMode) {
        buttons.push(
            <AccessibleTooltipButton
                key="mx_MessageComposer_voiceMessage"
                className="mx_MessageComposer_button mx_MessageComposer_voiceMessage"
                onClick={() => this.voiceRecordingButton?.onRecordStartEndClick()}
                title={_t("Send voice message")}
            />);
    }*/
    //
    return buttons;
  }
  renderButtons(menuPosition) {
    const buttons = [];
    if (!this.state.haveRecording) {
      buttons.push( /*#__PURE__*/react.createElement(EmojiButton, {
        key: "emoji_button",
        addEmoji: this.addEmoji,
        menuPosition: menuPosition,
        roomId: this.props.room.roomId,
        squad: this.props.room.getParentRoom(),
        disabled: this.props.room.slowModeCounting
      }));
    }
    return buttons;
  }
  /**
   * TODO: too many render function here!
   * all state in one container component.
   * this is bad.
   * split them!
   * @returns ReactNode
   */
  render() {
    const controls = [];
    // const controls = [
    //     this.state.me && !this.props.compact ? <ComposerAvatar key="controls_avatar" me={this.state.me} /> : null,
    //     this.props.e2eStatus ?
    //         <E2EIcon key="e2eIcon" status={this.props.e2eStatus} className="mx_MessageComposer_e2eIcon" /> :
    //         null,
    // ];

    let menuPosition;
    // let btnPosition: AboveLeftOf | undefined;
    // let width = 0;
    if (this.ref.current) {
      const contentRect = this.ref.current.getBoundingClientRect();
      // width = contentRect.width;
      menuPosition = (0,ContextMenu/* aboveLeftOf */.LS)(contentRect);
      // btnPosition = alwaysAboveRightOf(contentRect);
    }

    let canSend = false;
    if (this.state.canSendMessages) {
      canSend = true;
      controls.push( /*#__PURE__*/react.createElement(SendMessageComposer/* default */.ZP, {
        ref: c => this.messageComposerInput = c,
        key: "controls_input",
        room: this.props.room,
        placeholder: this.state.placeHolderText,
        permalinkCreator: this.props.permalinkCreator,
        replyInThread: this.props.replyInThread,
        replyToEvent: this.props.replyToEvent,
        onChange: this.onChange,
        forwardPhase: this.props.forwardPhase,
        disabled: this.state.haveRecording || this.props.room.slowModeCounting
      }));
      controls.push( /*#__PURE__*/react.createElement(VoiceRecordComposerTile, {
        key: "controls_voice_record",
        ref: c => this.voiceRecordingButton = c,
        room: this.props.room,
        disabled: this.props.room.slowModeCounting
      }));
    } else if (this.state.tombstone) {
      const replacementRoomId = this.state.tombstone.getContent()["replacement_room"];
      const continuesLink = replacementRoomId ? /*#__PURE__*/react.createElement("a", {
        href: (0,Permalinks/* makeRoomPermalink */.dl)(replacementRoomId),
        className: "mx_MessageComposer_roomReplaced_link",
        onClick: this.onTombstoneClick
      }, (0,languageHandler._t)("The conversation continues here.")) : /*#__PURE__*/react.createElement("div", {
        className: "mx_MessageComposer_roomReplaced_link"
      }, (0,languageHandler._t)("No conversation."));
      controls.push( /*#__PURE__*/react.createElement("div", {
        className: "mx_MessageComposer_replaced_wrapper",
        key: "room_replaced"
      }, /*#__PURE__*/react.createElement("div", {
        className: "mx_MessageComposer_replaced_valign"
      }, /*#__PURE__*/react.createElement("img", {
        className: "mx_MessageComposer_roomReplaced_icon",
        src: __webpack_require__(553090)
      }), /*#__PURE__*/react.createElement("span", {
        className: "mx_MessageComposer_roomReplaced_header"
      }, (0,languageHandler._t)("This room has been replaced and is no longer active.")), /*#__PURE__*/react.createElement("br", null), continuesLink)));
    } else {
      if (this.state.userShip.includes(user/* UserShip */.J.Stranger) && this.props.room.isDmRoom()) {
        controls.push( /*#__PURE__*/react.createElement("div", {
          className: "mx_MessageComposer_stranger"
        }, /*#__PURE__*/react.createElement("span", null, "The user is not your friend, "), /*#__PURE__*/react.createElement("span", {
          className: "mx_MessageComposer_link_button",
          onClick: this.sendFriendRequest
        }, "send friend request")));
      } else {
        controls.push( /*#__PURE__*/react.createElement("div", {
          key: "controls_error",
          className: "mx_MessageComposer_noperm_error"
        }, (0,languageHandler._t)("You do not have permission to post to this room")));
      }
    }
    let recordingTooltip;
    const secondsLeft = Math.round(this.state.recordingTimeLeftSeconds);
    if (secondsLeft) {
      recordingTooltip = /*#__PURE__*/react.createElement(Tooltip/* default */.Z, {
        label: (0,languageHandler._t)("%(seconds)ss left", {
          seconds: secondsLeft
        }),
        alignment: Tooltip/* Alignment */.v.Top
      });
    }
    // controls.push(
    //     <Stickerpicker
    //         key={controls.length + 1}
    //         room={this.props.room}
    //         showStickers={this.state.showStickers}
    //         setShowStickers={this.showStickers}
    //         menuPosition={menuPosition}
    //     />
    // );
    /// TODO!: add Lrepicker
    // controls.push(
    //     <Stickerpicker
    //         room={this.props.room}
    //         showStickers={this.state.showLre}
    //         setShowStickers={this.showLre}
    //         menuPosition={menuPosition} />,
    // );

    const classes = classnames_default()({
      mx_MessageComposer: true,
      mx_GroupLayout: true,
      "mx_MessageComposer--compact": this.props.compact,
      "mx_MessageComposer--hidden": this.state.hidden
    });
    const AdditionalButton = () => {
      const openMenu = () => {
        this.isAddtionalOpen(true);
      };
      const closeMenu = () => {
        this.isAddtionalOpen(false);
      };
      const handleMenu = e => {
        if (this.props.room.slowModeCounting) return;
        if (!(this.state.isAdditionalOpen || this.state.isDappsOpen)) {
          openMenu();
        } else if (this.state.isAdditionalOpen) {
          closeMenu();
        }
      };
      const addtionalBtn = this.renderAdditionals(closeMenu);
      let menu;
      if (this.state.isAdditionalOpen) {
        menu = /*#__PURE__*/react.createElement("div", {
          className: "mx_ContextMenu_additional"
        }, /*#__PURE__*/react.createElement(lib.Card, null, addtionalBtn));
      }
      return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("div", {
        onClick: handleMenu,
        className: classnames_default()("mx_MessageComposer_btn_additional", {
          mx_MessageComposer_btn_additional_close: this.state.isAdditionalOpen || this.state.isDappsOpen
        })
      }, this.state.isAdditionalOpen || this.state.isDappsOpen ? /*#__PURE__*/react.createElement(dist.SdIcon, {
        icon: "CloseOutlines"
      }) : /*#__PURE__*/react.createElement(dist.SdIcon, {
        icon: "AddOutlines"
      })), this.state.isDappsOpen ? /*#__PURE__*/react.createElement(rooms_DappsMenu, {
        room: this.props.room,
        isDappsOpen: this.isDappsOpen,
        isAdditionalOpen: this.isAddtionalOpen
      }) : menu);
    };
    return /*#__PURE__*/react.createElement("div", {
      className: classes,
      ref: this.ref
    }, recordingTooltip, /*#__PURE__*/react.createElement("div", {
      className: "mx_MessageComposer_wrapper"
    }, this.props.showReplyPreview && /*#__PURE__*/react.createElement(ReplyPreview, {
      permalinkCreator: this.props.permalinkCreator
    }), this.props.forwardPhase ? /*#__PURE__*/react.createElement(ForwardPreview, {
      room: this.props.room,
      forwardPhase: this.props.forwardPhase
    }) : null, /*#__PURE__*/react.createElement("div", {
      className: "mx_MessageComposer_row"
    }, canSend && /*#__PURE__*/react.createElement(AdditionalButton, null), controls, canSend && /*#__PURE__*/react.createElement("div", {
      className: "mx_MessageComposer_toolbar",
      ref: this.messageComposerToolbar
    }, /*#__PURE__*/react.createElement(MessageSenderBar_DisappearMessagesPicker, {
      roomId: this.props.room.roomId
    }), this.renderButtons(menuPosition)), canSend && (this.state.haveRecording || !this.state.isComposerEmpty || this.props.forwardPhase ? /*#__PURE__*/react.createElement(SendButton, {
      key: "controls_send",
      onClick: this.sendMessage,
      title: this.state.haveRecording ? (0,languageHandler._t)("Send voice message") : undefined
    }) : /*#__PURE__*/react.createElement(dist.SdTooltip, {
      title: (0,languageHandler._t)("Send voice message"),
      placement: "left",
      autoAdjustOverflow: true
    }, /*#__PURE__*/react.createElement(dist.SdButton, {
      key: "mx_MessageComposer_btn_voice",
      className: "mx_MessageComposer_button mx_MessageComposer_voiceMessage",
      onClick: () => {
        var _this$voiceRecordingB;
        return (_this$voiceRecordingB = this.voiceRecordingButton) === null || _this$voiceRecordingB === void 0 ? void 0 : _this$voiceRecordingB.onRecordStartEndClick();
      }
    }, /*#__PURE__*/react.createElement(dist.SdIcon, {
      icon: "VioceOutlines"
    })))))));
  }
}, (0,defineProperty/* default */.Z)(_class3, "defaultProps", {
  replyInThread: false,
  showReplyPreview: true,
  compact: false
}), _class3)) || MessageComposer_class2);

const PollButton = props => {
  const handlePollClick = (0,react.useCallback)(() => {
    const client = src_MatrixClientPeg/* MatrixClientPeg */.p.get();
    const room = client.getRoom(props.roomId);
    if (room !== null && room !== void 0 && room.maySendMessage()) {
      dispatcher/* default */.ZP.dispatch({
        action: actions/* Action */.a.SetRightPanelPhase,
        phase: RightPanelStorePhases/* RightPanelPhases */.q4.CreatePoll
        // refireParams: { member: this.props.member },
      });
      // Modal.createDialog(PollCreateDialog, {
      //     room,
      // });
    } else {
      Modal/* default */.Z.createDialog(ErrorDialog/* default */.Z, {
        title: (0,languageHandler._t)("Permission Required"),
        description: (0,languageHandler._t)("You do not have permission to start polls in this room.")
      });
    }
    props.closeMenu();
  }, [props.closeMenu, props.roomId]);
  return /*#__PURE__*/react.createElement(elements_AccessibleButton/* default */.Z, {
    key: "mx_MessageComposer_upload",
    className: "mx_MessageComposer_button",
    onClick: handlePollClick
  }, /*#__PURE__*/react.createElement("div", {
    className: "mx_MessageComposer_button_bg mx_MessageComposer_poll"
  }), /*#__PURE__*/react.createElement("div", null, (0,languageHandler._t)("Poll")));
};

/***/ }),

/***/ 467315:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ZP: () => (/* binding */ SendMessageComposer)
/* harmony export */ });
/* unused harmony exports createMessageContent, isQuickReaction */
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(225259);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(667294);
/* harmony import */ var emojibase_regex__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(210976);
/* harmony import */ var emojibase_regex__WEBPACK_IMPORTED_MODULE_32___default = /*#__PURE__*/__webpack_require__.n(emojibase_regex__WEBPACK_IMPORTED_MODULE_32__);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(300111);
/* harmony import */ var matrix_js_sdk_src_types_event__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(907977);
/* harmony import */ var _dispatcher_dispatcher__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(245539);
/* harmony import */ var _editor_model__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(300252);
/* harmony import */ var _editor_serialize__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(555461);
/* harmony import */ var _BasicMessageComposer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(934735);
/* harmony import */ var _editor_parts__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(887403);
/* harmony import */ var _elements_ReplyThread__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(980531);
/* harmony import */ var _utils_EventUtils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(26031);
/* harmony import */ var _SendHistoryManager__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(231124);
/* harmony import */ var _SlashCommands__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(662316);
/* harmony import */ var _Modal__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(241648);
/* harmony import */ var _languageHandler__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(867614);
/* harmony import */ var _ContentMessages__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(601877);
/* harmony import */ var _contexts_MatrixClientContext__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(311878);
/* harmony import */ var _dispatcher_actions__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(473627);
/* harmony import */ var _effects_utils__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(458372);
/* harmony import */ var _effects__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(410603);
/* harmony import */ var _CountlyAnalytics__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(817826);
/* harmony import */ var _MatrixClientPeg__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(933393);
/* harmony import */ var _KeyBindingsManager__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(481493);
/* harmony import */ var _utils_replaceableComponent__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(90287);
/* harmony import */ var _settings_SettingsStore__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(571879);
/* harmony import */ var _dialogs_ErrorDialog__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(705636);
/* harmony import */ var _dialogs_QuestionDialog__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(433773);
/* harmony import */ var _sendTimePerformanceMetrics__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(325310);
/* harmony import */ var _stores_room_list_MessagePreviewStore__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(686821);
/* harmony import */ var _src_firebase_analytics__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(937139);
/* harmony import */ var _utils_commonPointParams__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(970698);
/* harmony import */ var _stores_defenderSettings_settingsStore__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(650478);
/* harmony import */ var _utils_feature_isFeatureEnabled__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(94948);
/* harmony import */ var _utils_units__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(612559);
/* harmony import */ var _stores_room_list_RoomListStore__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(109660);
/* harmony import */ var _settings_GlobalConfig__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(2902);
/* harmony import */ var sendingme_ui__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(602271);
/* harmony import */ var _structures_PinnedMsgBar__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(832227);

var _dec, _class, _class2;
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
/*
Copyright 2019 - 2021 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/








































function addReplyToMessageContent(content, replyToEvent, replyInThread, permalinkCreator, showNestedReply = true) {
  const replyContent = _elements_ReplyThread__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z.makeReplyMixIn(replyToEvent, replyInThread);
  Object.assign(content, replyContent);

  // Part of Replies fallback support - prepend the text we're sending
  // with the text we're replying to
  const nestedReply = _elements_ReplyThread__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z.getNestedReplyText(replyToEvent, permalinkCreator);
  if (nestedReply && showNestedReply) {
    if (content.formatted_body) {
      content.formatted_body = nestedReply.html + content.formatted_body;
    }
    content.body = nestedReply.body + content.body;
  }
}

// exported for tests
function createMessageContent(model, replyToEvent, replyInThread, permalinkCreator) {
  const isEmote = (0,_editor_serialize__WEBPACK_IMPORTED_MODULE_4__/* .containsEmote */ .i$)(model);
  if (isEmote) {
    model = (0,_editor_serialize__WEBPACK_IMPORTED_MODULE_4__/* .stripEmoteCommand */ .b7)(model);
  }
  if ((0,_editor_serialize__WEBPACK_IMPORTED_MODULE_4__/* .startsWith */ .Ny)(model, "//")) {
    model = (0,_editor_serialize__WEBPACK_IMPORTED_MODULE_4__/* .stripPrefix */ .I1)(model, "/");
  }
  model = (0,_editor_serialize__WEBPACK_IMPORTED_MODULE_4__/* .unescapeMessage */ .PI)(model);
  const body = (0,_editor_serialize__WEBPACK_IMPORTED_MODULE_4__/* .textSerialize */ .$9)(model);
  const content = {
    msgtype: isEmote ? "m.emote" : "m.text",
    body: body
  };
  const formattedBody = (0,_editor_serialize__WEBPACK_IMPORTED_MODULE_4__/* .htmlSerializeIfNeeded */ .Yi)(model, {
    forceHTML: !!replyToEvent
  });
  if (formattedBody) {
    content.format = "org.matrix.custom.html";
    content.formatted_body = formattedBody;
  }
  if (replyToEvent) {
    addReplyToMessageContent(content, replyToEvent, replyInThread, permalinkCreator, true);
  }
  return content;
}

// exported for tests
function isQuickReaction(model) {
  const parts = model.parts;
  if (parts.length == 0) return false;
  const text = (0,_editor_serialize__WEBPACK_IMPORTED_MODULE_4__/* .textSerialize */ .$9)(model);
  // shortcut takes the form "+:emoji:" or "+ :emoji:""
  // can be in 1 or 2 parts
  if (parts.length <= 2) {
    const hasShortcut = text.startsWith("+") || text.startsWith("+ ");
    const emojiMatch = text.match((emojibase_regex__WEBPACK_IMPORTED_MODULE_32___default()));
    if (hasShortcut && emojiMatch && emojiMatch.length == 1) {
      return emojiMatch[0] === text.substring(1) || emojiMatch[0] === text.substring(2);
    }
  }
  return false;
}
let SendMessageComposer = (_dec = (0,_utils_replaceableComponent__WEBPACK_IMPORTED_MODULE_19__/* .replaceableComponent */ .U)("views.rooms.SendMessageComposer"), _dec(_class = (_class2 = class SendMessageComposer extends react__WEBPACK_IMPORTED_MODULE_1__.Component {
  constructor(props, context) {
    super(props);
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this, "context", void 0);
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this, "prepareToEncrypt", void 0);
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this, "editorRef", /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.createRef)());
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this, "model", null);
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this, "currentlyComposedEditorState", null);
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this, "dispatcherRef", void 0);
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this, "sendHistoryManager", void 0);
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this, "onKeyDown", event => {
      var _this$editorRef$curre, _this$editorRef$curre2, _this$editorRef$curre3;
      // ignore any keypress while doing IME compositions
      if ((_this$editorRef$curre = this.editorRef.current) !== null && _this$editorRef$curre !== void 0 && _this$editorRef$curre.isComposing(event)) {
        return;
      }
      const action = (0,_KeyBindingsManager__WEBPACK_IMPORTED_MODULE_18__/* .getKeyBindingsManager */ .zL)().getMessageComposerAction(event);
      switch (action) {
        case _KeyBindingsManager__WEBPACK_IMPORTED_MODULE_18__/* .MessageComposerAction */ .XE.Send:
          this.sendMessage();
          event.preventDefault();
          break;
        case _KeyBindingsManager__WEBPACK_IMPORTED_MODULE_18__/* .MessageComposerAction */ .XE.SelectPrevSendHistory:
        case _KeyBindingsManager__WEBPACK_IMPORTED_MODULE_18__/* .MessageComposerAction */ .XE.SelectNextSendHistory:
          {
            // Try select composer history
            const selected = this.selectSendHistory(action === _KeyBindingsManager__WEBPACK_IMPORTED_MODULE_18__/* .MessageComposerAction */ .XE.SelectPrevSendHistory);
            if (selected) {
              // We're selecting history, so prevent the key event from doing anything else
              event.preventDefault();
            }
            break;
          }
        case _KeyBindingsManager__WEBPACK_IMPORTED_MODULE_18__/* .MessageComposerAction */ .XE.EditPrevMessage:
          // selection must be collapsed and caret at start
          if ((_this$editorRef$curre2 = this.editorRef.current) !== null && _this$editorRef$curre2 !== void 0 && _this$editorRef$curre2.isSelectionCollapsed() && (_this$editorRef$curre3 = this.editorRef.current) !== null && _this$editorRef$curre3 !== void 0 && _this$editorRef$curre3.isCaretAtStart()) {
            const editEvent = (0,_utils_EventUtils__WEBPACK_IMPORTED_MODULE_8__/* .findEditableEvent */ .xJ)(this.props.room, false);
            if (editEvent) {
              // We're selecting history, so prevent the key event from doing anything else
              event.preventDefault();
              _dispatcher_dispatcher__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .ZP.dispatch({
                action: "edit_event",
                event: editEvent
              });
            }
          }
          break;
        case _KeyBindingsManager__WEBPACK_IMPORTED_MODULE_18__/* .MessageComposerAction */ .XE.CancelEditing:
          _dispatcher_dispatcher__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .ZP.dispatch({
            action: "reply_to_event",
            event: null
          });
          break;
        default:
          if (this.prepareToEncrypt) {
            // This needs to be last!
            this.prepareToEncrypt();
          }
      }
    });
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this, "sendForwardMessage", async () => {
      const cli = _MatrixClientPeg__WEBPACK_IMPORTED_MODULE_17__/* .MatrixClientPeg */ .p.get();
      const {
        forwardMessageType,
        forwardEvents: event,
        forwardTargetRoom: room
      } = this.props.forwardPhase;
      const slowModeCounting = room.slowModeCounting;
      if (slowModeCounting) {
        sendingme_ui__WEBPACK_IMPORTED_MODULE_30__.SdMessage.warning("Sending too quickly");
        return;
      }
      try {
        if (forwardMessageType === "forward_combine") {
          var _cli$getRoom;
          const content = {
            msgtype: matrix_js_sdk_src_types_event__WEBPACK_IMPORTED_MODULE_2__/* .MsgType */ .Zw.Text,
            body: event.reduce((arr, v) => {
              const {
                tag,
                content
              } = (0,_structures_PinnedMsgBar__WEBPACK_IMPORTED_MODULE_31__/* .getContentOfMsg */ .oG)(v);
              arr.push(`${v.sender.name || v.getSender()}: ${tag ? `[${tag}]` : content}`);
              return arr;
            }, []).join("\x0a"),
            forward_list: event.map(e => {
              const content = e.getContent();
              const newContent = JSON.parse(JSON.stringify(content));
              if (newContent["save_message"]) {
                delete newContent.save_message;
              }
              if (newContent["send_method"]) {
                delete newContent.send_method;
              }
              if (room && !room.isSaveMessageRoom()) {
                newContent === null || newContent === void 0 ? true : delete newContent.save_message;
              }
              if (newContent !== null && newContent !== void 0 && newContent.prepContent) {
                delete newContent.prepContent;
              }
              return {
                age: e.getAge(),
                content: newContent,
                displayname: e.sender.name,
                event_id: e.getId(),
                origin_server_ts: e.getTs(),
                room_id: e.getRoomId(),
                sender: e.sender.userId,
                type: e.getType(),
                user_id: e.sender.userId
              };
            }),
            "m.forward": {
              event_id: event.map(e => e.getId()),
              room_id: event[0].getRoomId(),
              room_name: ((_cli$getRoom = cli.getRoom(event[0].getRoomId())) === null || _cli$getRoom === void 0 ? void 0 : _cli$getRoom.name) || event[0].getRoomId()
            }
          };
          cli.sendMessage(room.roomId, content);
        } else {
          Promise.all(event.map(event => {
            const content = event.getEffectiveEvent();
            const newContent = JSON.parse(JSON.stringify(content));
            if (newContent["save_message"]) {
              delete newContent.save_message;
            }
            if (newContent["send_method"]) {
              delete newContent.send_method;
            }
            if (room && !room.isSaveMessageRoom()) {
              delete newContent.content.save_message;
            }
            if (newContent !== null && newContent !== void 0 && newContent.content.prepContent) {
              delete newContent.content.prepContent;
            }
            return cli.sendMessage(room.roomId, newContent.content);
          }));
        }
      } catch (err) {
        {
          //done firebase : send_message_failed
          (0,_src_firebase_analytics__WEBPACK_IMPORTED_MODULE_24__/* .logEvent */ .K)(_src_firebase_analytics__WEBPACK_IMPORTED_MODULE_24__/* .analytics */ .c, "send_message_failed", _objectSpread(_objectSpread({}, (0,_utils_commonPointParams__WEBPACK_IMPORTED_MODULE_25__/* .getCommonPointParams */ .I)()), {}, {
            type: "m.forward",
            room_id: room.roomId.split(":")[0],
            error_code: err.httpStatus || err.errcode || 0,
            error_reason: err.name || err.message || err.stack
          }));
        }
      }
      _dispatcher_dispatcher__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .ZP.dispatch({
        action: _dispatcher_actions__WEBPACK_IMPORTED_MODULE_14__/* .Action */ .a.ForwardMessage,
        forwardPhase: null
      });
    });
    // should save state when editor has contents or reply is open
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this, "shouldSaveStoredEditorState", () => {
      return (!this.model.isEmpty || !!this.props.replyToEvent) && !this.props.disableCache;
    });
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this, "saveStoredEditorState", () => {
      if (this.shouldSaveStoredEditorState()) {
        const item = _SendHistoryManager__WEBPACK_IMPORTED_MODULE_33__/* ["default"] */ .Z.createItem(this.model, this.props.replyToEvent);
        localStorage.setItem(this.editorStateKey, JSON.stringify(item));
        this.props.room.lastDraftMessageTimestamp = Date.now();
        _stores_room_list_RoomListStore__WEBPACK_IMPORTED_MODULE_28__/* ["default"] */ .ZP.instance.emit(_stores_room_list_RoomListStore__WEBPACK_IMPORTED_MODULE_28__/* .LISTS_UPDATE_EVENT */ .N);
      } else {
        this.clearStoredEditorState();
        this.props.room.lastDraftMessageTimestamp = 0;
        _stores_room_list_RoomListStore__WEBPACK_IMPORTED_MODULE_28__/* ["default"] */ .ZP.instance.emit(_stores_room_list_RoomListStore__WEBPACK_IMPORTED_MODULE_28__/* .LISTS_UPDATE_EVENT */ .N);
      }
      _stores_room_list_MessagePreviewStore__WEBPACK_IMPORTED_MODULE_23__/* .MessagePreviewStore */ .z.instance.dispatchPreviewChange(this.props.room);
    });
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this, "onAction", payload => {
      var _this$props$privateKe;
      // don't let the user into the composer if it is disabled - all of these branches lead
      // to the cursor being in the composer
      if (this.props.disabled) return;
      switch (payload.action) {
        case "reply_to_event":
        case _dispatcher_actions__WEBPACK_IMPORTED_MODULE_14__/* .Action */ .a.FocusSendMessageComposer:
          if (!((_this$props$privateKe = this.props.privateKey) !== null && _this$props$privateKe !== void 0 && _this$props$privateKe.includes("topic"))) {
            var _this$editorRef$curre4;
            (_this$editorRef$curre4 = this.editorRef.current) === null || _this$editorRef$curre4 === void 0 ? void 0 : _this$editorRef$curre4.focus();
          }
          break;
        case "send_composer_insert":
          if ((this.props.privateKey || payload.privateKey) && payload.privateKey !== this.props.privateKey) {
            return;
          }
          if (payload.userId) {
            var _this$editorRef$curre5;
            (_this$editorRef$curre5 = this.editorRef.current) === null || _this$editorRef$curre5 === void 0 ? void 0 : _this$editorRef$curre5.insertMention(payload.userId);
          } else if (payload.event) {
            var _this$editorRef$curre6;
            (_this$editorRef$curre6 = this.editorRef.current) === null || _this$editorRef$curre6 === void 0 ? void 0 : _this$editorRef$curre6.insertQuotedMessage(payload.event);
          } else if (payload.text) {
            var _this$editorRef$curre7;
            (_this$editorRef$curre7 = this.editorRef.current) === null || _this$editorRef$curre7 === void 0 ? void 0 : _this$editorRef$curre7.insertPlaintext(payload.text);
          }
          break;
      }
    });
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this, "onPaste", event => {
      const {
        clipboardData
      } = event;
      // Prioritize text on the clipboard over files if RTF is present as Office on macOS puts a bitmap
      // in the clipboard as well as the content being copied. Modern versions of Office seem to not do this anymore.
      // We check text/rtf instead of text/plain as when copy+pasting a file from Finder or Gnome Image Viewer
      // it puts the filename in as text/plain which we want to ignore.
      if (clipboardData.files.length && !clipboardData.types.includes("text/rtf")) {
        _ContentMessages__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .ZP.sharedInstance().sendContentListToRoom(Array.from(clipboardData.files), this.props.room.roomId, this.context);
        return true; // to skip internal onPaste handler
      }
    });
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this, "onChange", () => {
      if (this.props.onChange) this.props.onChange(this.model);
    });
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this, "focusComposer", () => {
      var _this$editorRef$curre8;
      (_this$editorRef$curre8 = this.editorRef.current) === null || _this$editorRef$curre8 === void 0 ? void 0 : _this$editorRef$curre8.focus();
    });
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this, "getActualInput", () => {
      // return this.editorRef.current.editorRef.current;
      return this.editorRef.current.editorWrapper.current;
    });
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this, "getModel", () => {
      return this.model;
    });
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this, "getPrefix", () => {
      var _this$props;
      const slowModeCoolTime = (_this$props = this.props) === null || _this$props === void 0 ? void 0 : _this$props.room.getSlowModeCoolTime();
      if (slowModeCoolTime) {
        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("img", {
          src: __webpack_require__(530725),
          alt: ""
        });
      }
      return null;
    });
    this.context = context; // otherwise React will only set it prior to render due to type def above
    if (this.context.isCryptoEnabled() && this.context.isRoomEncrypted(this.props.room.roomId)) {
      this.prepareToEncrypt = (0,lodash_es__WEBPACK_IMPORTED_MODULE_34__/* ["default"] */ .Z)(() => {
        this.context.prepareToEncrypt(this.props.room);
      }, 60000, {
        leading: true,
        trailing: false
      });
    }
    window.addEventListener("beforeunload", this.saveStoredEditorState);
  }
  // we keep sent messages/commands in a separate history (separate from undo history)
  // so you can alt+up/down in them
  selectSendHistory(up) {
    const delta = up ? -1 : 1;
    // True if we are not currently selecting history, but composing a message
    if (this.sendHistoryManager.currentIndex === this.sendHistoryManager.history.length) {
      // We can't go any further - there isn't any more history, so nop.
      if (!up) {
        return false;
      }
      this.currentlyComposedEditorState = this.model.serializeParts();
    } else if (this.sendHistoryManager.currentIndex + delta === this.sendHistoryManager.history.length) {
      // True when we return to the message being composed currently
      this.model.reset(this.currentlyComposedEditorState);
      this.sendHistoryManager.currentIndex = this.sendHistoryManager.history.length;
      return true;
    }
    const {
      parts,
      replyEventId
    } = this.sendHistoryManager.getItem(delta);
    _dispatcher_dispatcher__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .ZP.dispatch({
      action: "reply_to_event",
      event: replyEventId ? this.props.room.findEventById(replyEventId) : null
    });
    if (parts) {
      var _this$editorRef$curre9;
      this.model.reset(parts);
      (_this$editorRef$curre9 = this.editorRef.current) === null || _this$editorRef$curre9 === void 0 ? void 0 : _this$editorRef$curre9.focus();
    }
    return true;
  }
  async isCommandParse() {
    const [cmd, argStr] = this.getSlashCommand();
    async function parseError(error) {
      // ask the user if their unknown command should be sent as a message
      const {
        finished
      } = _Modal__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z.createTrackedDialog("Prase command fail", "", _dialogs_QuestionDialog__WEBPACK_IMPORTED_MODULE_22__/* ["default"] */ .Z, {
        title: (0,_languageHandler__WEBPACK_IMPORTED_MODULE_11__._t)("Prase Command Fail"),
        description: /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("p", null, error.message)),
        button: (0,_languageHandler__WEBPACK_IMPORTED_MODULE_11__._t)("Send as message")
      });
      const [sendAnyway] = await finished;
      // if !sendAnyway bail to let the user edit the composer and try again
      if (!sendAnyway) return false;
    }
    if (cmd.program) {
      try {
        const args = argStr.split(" ");
        cmd.program.parse(args, {
          from: "user"
        });
        return true;
      } catch (error) {
        await parseError(error);
        return false;
      }
    }
    return true;
  }
  isSlashCommand() {
    const parts = this.model.parts;
    const firstPart = parts[0];
    if (firstPart) {
      if (firstPart.type === _editor_parts__WEBPACK_IMPORTED_MODULE_6__/* .Type */ .Dy.Command && firstPart.text.startsWith("/") && !firstPart.text.startsWith("//")) {
        return true;
      }
      // be extra resilient when somehow the AutocompleteWrapperModel or
      // CommandPartCreator fails to insert a command part, so we don't send
      // a command as a message
      if (firstPart.text.startsWith("/") && !firstPart.text.startsWith("//") && (firstPart.type === _editor_parts__WEBPACK_IMPORTED_MODULE_6__/* .Type */ .Dy.Plain || firstPart.type === _editor_parts__WEBPACK_IMPORTED_MODULE_6__/* .Type */ .Dy.PillCandidate)) {
        return true;
      }
    }
    return false;
  }
  sendQuickReaction() {
    const timeline = this.props.room.getLiveTimeline();
    const events = timeline.getEvents();
    const reaction = this.model.parts[1].text;
    for (let i = events.length - 1; i >= 0; i--) {
      if (events[i].getType() === matrix_js_sdk_src_types_event__WEBPACK_IMPORTED_MODULE_2__/* .EventType */ .tw.RoomMessage) {
        let shouldReact = true;
        const lastMessage = events[i];
        const userId = _MatrixClientPeg__WEBPACK_IMPORTED_MODULE_17__/* .MatrixClientPeg */ .p.get().getUserId();
        const messageReactions = this.props.room.getUnfilteredTimelineSet().getRelationsForEvent(lastMessage.getId(), matrix_js_sdk_src_types_event__WEBPACK_IMPORTED_MODULE_2__/* .RelationType */ .uT.Annotation, matrix_js_sdk_src_types_event__WEBPACK_IMPORTED_MODULE_2__/* .EventType */ .tw.Reaction);

        // if we have already sent this reaction, don't redact but don't re-send
        if (messageReactions) {
          const myReactionEvents = messageReactions.getAnnotationsBySender()[userId] || [];
          const myReactionKeys = [...myReactionEvents].filter(event => !event.isRedacted()).map(event => event.getRelation().key);
          shouldReact = !myReactionKeys.includes(reaction);
        }
        if (shouldReact) {
          _MatrixClientPeg__WEBPACK_IMPORTED_MODULE_17__/* .MatrixClientPeg */ .p.get().sendEvent(lastMessage.getRoomId(), matrix_js_sdk_src_types_event__WEBPACK_IMPORTED_MODULE_2__/* .EventType */ .tw.Reaction, {
            "m.relates_to": {
              rel_type: matrix_js_sdk_src_types_event__WEBPACK_IMPORTED_MODULE_2__/* .RelationType */ .uT.Annotation,
              event_id: lastMessage.getId(),
              key: reaction
            }
          });
          _dispatcher_dispatcher__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .ZP.dispatch({
            action: "message_sent"
          });
        }
        break;
      }
    }
  }
  getSlashCommand() {
    const commandText = this.model.parts.reduce((text, part) => {
      // use mxid to textify user pills in a command
      if (part.type === "user-pill") {
        return text + part.resourceId;
      }
      return text + part.text;
    }, "");
    const {
      cmd,
      args
    } = (0,_SlashCommands__WEBPACK_IMPORTED_MODULE_9__/* .getCommand */ .hW)(commandText);
    return [cmd, args, commandText];
  }
  async runSlashCommand(cmd, args) {
    const result = cmd.run(this.props.room.roomId, args, cmd.program);
    let messageContent;
    let error = result.error;
    if (result.promise) {
      try {
        if (cmd.category === _SlashCommands__WEBPACK_IMPORTED_MODULE_9__/* .CommandCategories */ .Mv.messages) {
          // The command returns a modified message that we need to pass on
          messageContent = await result.promise;
        } else {
          await result.promise;
        }
      } catch (err) {
        error = err;
      }
    }
    if (error) {
      console.error("Command failure: %s", error);
      // assume the error is a server error when the command is async
      const isServerError = !!result.promise;
      const title = isServerError ? (0,_languageHandler__WEBPACK_IMPORTED_MODULE_11__/* ._td */ .I8)("Server error") : (0,_languageHandler__WEBPACK_IMPORTED_MODULE_11__/* ._td */ .I8)("Command error");
      let errText;
      if (typeof error === "string") {
        errText = error;
      } else if (error.message) {
        errText = error.message;
      } else {
        errText = (0,_languageHandler__WEBPACK_IMPORTED_MODULE_11__._t)("Server unavailable, overloaded, or something else went wrong.");
      }
      _Modal__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z.createTrackedDialog(title, "", _dialogs_ErrorDialog__WEBPACK_IMPORTED_MODULE_21__/* ["default"] */ .Z, {
        title: (0,_languageHandler__WEBPACK_IMPORTED_MODULE_11__._t)(title),
        description: errText
      });
    } else {
      console.log("Command success.");
      if (messageContent) return messageContent;
    }
  }
  async sendMessage() {
    var _this$editorRef$curre12;
    // send forward message
    if (this.props.forwardPhase) {
      this.sendForwardMessage();
    }
    const model = this.model;
    if (model.isEmpty) {
      return;
    }

    // Replace emoticon at the end of the message
    if (_settings_SettingsStore__WEBPACK_IMPORTED_MODULE_20__/* ["default"] */ .C.getValue("MessageComposerInput.autoReplaceEmoji")) {
      var _this$editorRef$curre10, _this$editorRef$curre11;
      const caret = (_this$editorRef$curre10 = this.editorRef.current) === null || _this$editorRef$curre10 === void 0 ? void 0 : _this$editorRef$curre10.getCaret();
      const position = model.positionForOffset(caret.offset, caret.atNodeEnd);
      (_this$editorRef$curre11 = this.editorRef.current) === null || _this$editorRef$curre11 === void 0 ? void 0 : _this$editorRef$curre11.replaceEmoticon(position, _BasicMessageComposer__WEBPACK_IMPORTED_MODULE_5__/* .REGEX_EMOTICON */ .m);
    }
    const replyToEvent = this.props.replyToEvent;
    let shouldSend = true;
    let content;
    if (!(0,_editor_serialize__WEBPACK_IMPORTED_MODULE_4__/* .containsEmote */ .i$)(model) && this.isSlashCommand()) {
      const [cmd, args, commandText] = this.getSlashCommand();
      if (cmd) {
        const isParsePass = await this.isCommandParse();
        if (!isParsePass) return;
        if (cmd.category === _SlashCommands__WEBPACK_IMPORTED_MODULE_9__/* .CommandCategories */ .Mv.messages) {
          content = await this.runSlashCommand(cmd, args);
          if (replyToEvent) {
            addReplyToMessageContent(content, replyToEvent, this.props.replyInThread, this.props.permalinkCreator, false);
          }
        } else {
          this.runSlashCommand(cmd, args);
          shouldSend = false;
        }
      } else {
        // ask the user if their unknown command should be sent as a message
        const {
          finished
        } = _Modal__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z.createTrackedDialog("Unknown command", "", _dialogs_QuestionDialog__WEBPACK_IMPORTED_MODULE_22__/* ["default"] */ .Z, {
          title: (0,_languageHandler__WEBPACK_IMPORTED_MODULE_11__._t)("Unknown Command"),
          description: /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("p", null, (0,_languageHandler__WEBPACK_IMPORTED_MODULE_11__._t)("Unrecognised command: %(commandText)s", {
            commandText
          })), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("p", null, (0,_languageHandler__WEBPACK_IMPORTED_MODULE_11__._t)("You can use <code>/help</code> to list available commands. " + "Did you mean to send this as a message?", {}, {
            code: t => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("code", null, t)
          })), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("p", null, (0,_languageHandler__WEBPACK_IMPORTED_MODULE_11__._t)("Hint: Begin your message with <code>//</code> to start it with a slash.", {}, {
            code: t => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("code", null, t)
          }))),
          button: (0,_languageHandler__WEBPACK_IMPORTED_MODULE_11__._t)("Send as message")
        });
        const [sendAnyway] = await finished;
        // if !sendAnyway bail to let the user edit the composer and try again
        if (!sendAnyway) return;
      }
    }
    if (isQuickReaction(model)) {
      shouldSend = false;
      this.sendQuickReaction();
    }
    if (shouldSend) {
      // TODO: if disappear messages !
      const startTime = _CountlyAnalytics__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z.getTimestamp();
      const {
        roomId
      } = this.props.room;
      if (!content) {
        content = createMessageContent(model, replyToEvent, this.props.replyInThread, this.props.permalinkCreator);
      }
      const isFeatureEnabled = (0,_utils_feature_isFeatureEnabled__WEBPACK_IMPORTED_MODULE_27__/* ["default"] */ .Z)();
      if (isFeatureEnabled) {
        const {
          settings: settingsMap
        } = _stores_defenderSettings_settingsStore__WEBPACK_IMPORTED_MODULE_26__/* .useDefendSettingsStore */ .IO.getState() || {};
        const {
          messageAliveSecond
        } = (settingsMap === null || settingsMap === void 0 ? void 0 : settingsMap.get(roomId)) || {};
        if (messageAliveSecond > 0) {
          content["messageAliveSecond"] = messageAliveSecond;
        }
      }

      // done firebase : send_message
      (0,_src_firebase_analytics__WEBPACK_IMPORTED_MODULE_24__/* .logEvent */ .K)(_src_firebase_analytics__WEBPACK_IMPORTED_MODULE_24__/* .analytics */ .c, "send_message", _objectSpread(_objectSpread({}, (0,_utils_commonPointParams__WEBPACK_IMPORTED_MODULE_25__/* .getCommonPointParams */ .I)()), {}, {
        room_id: roomId.split(":")[0],
        type: content.msgtype,
        send_message_type: content.msgtype
      }));

      // don't bother sending an empty message
      if (!content.body.trim()) return;
      if (_settings_SettingsStore__WEBPACK_IMPORTED_MODULE_20__/* ["default"] */ .C.getValue("Performance.addSendMessageTimingMetadata")) {
        (0,_sendTimePerformanceMetrics__WEBPACK_IMPORTED_MODULE_35__/* .decorateStartSendingTime */ .N)(content);
      }

      // check content length
      let _body = content.body;
      let _formattedBody = content.formatted_body;
      let plainBody = typeof _body === "string" ? _body : "";
      let formattedBody = typeof _formattedBody === "string" ? _formattedBody : null;
      formattedBody = _elements_ReplyThread__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z.stripHTMLReply(formattedBody);
      plainBody = _elements_ReplyThread__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z.stripPlainReply(plainBody);
      const isHtmlMessage = content.format === "org.matrix.custom.html" && _formattedBody;
      const _bodyString = isHtmlMessage ? formattedBody : plainBody;
      if (_bodyString.length > _settings_GlobalConfig__WEBPACK_IMPORTED_MODULE_29__/* .GlobalConfig */ .Q.MaxTextLength) {
        sendingme_ui__WEBPACK_IMPORTED_MODULE_30__.SdModal.createDialog({
          title: (0,_languageHandler__WEBPACK_IMPORTED_MODULE_11__._t)("Something went wrong"),
          okText: (0,_languageHandler__WEBPACK_IMPORTED_MODULE_11__._t)("OK"),
          showCancel: false,
          children: /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("span", null, (0,_languageHandler__WEBPACK_IMPORTED_MODULE_11__._t)("The maximum message length allowed is %(limit)s characters. Please remove %(beyonds)s characters.", {
            beyonds: _bodyString.length - _settings_GlobalConfig__WEBPACK_IMPORTED_MODULE_29__/* .GlobalConfig */ .Q.MaxTextLength,
            limit: _settings_GlobalConfig__WEBPACK_IMPORTED_MODULE_29__/* .GlobalConfig */ .Q.MaxTextLength
          })),
          onOk: close => {
            close();
          }
        });
        return;
      }
      const prom = this.context.sendMessage(roomId, content);
      prom.then(res => {
        //done firebase : send_message_success
        (0,_src_firebase_analytics__WEBPACK_IMPORTED_MODULE_24__/* .logEvent */ .K)(_src_firebase_analytics__WEBPACK_IMPORTED_MODULE_24__/* .analytics */ .c, "send_message_success", _objectSpread(_objectSpread({}, (0,_utils_commonPointParams__WEBPACK_IMPORTED_MODULE_25__/* .getCommonPointParams */ .I)()), {}, {
          room_id: roomId.split(":")[0],
          type: content.msgtype,
          event_id: res.event_id
        }));

        // point report
        _MatrixClientPeg__WEBPACK_IMPORTED_MODULE_17__/* .MatrixClientPeg */ .p.get().pointReport({
          action_type: "send_message"
        });
      }, err => {
        //done firebase : send_message_failed
        (0,_src_firebase_analytics__WEBPACK_IMPORTED_MODULE_24__/* .logEvent */ .K)(_src_firebase_analytics__WEBPACK_IMPORTED_MODULE_24__/* .analytics */ .c, "send_message_failed", _objectSpread(_objectSpread({}, (0,_utils_commonPointParams__WEBPACK_IMPORTED_MODULE_25__/* .getCommonPointParams */ .I)()), {}, {
          type: content.msgtype,
          room_id: roomId.split(":")[0],
          error_code: err.httpStatus || err.errcode || 0,
          error_reason: err.name || err.message || err.stack
        }));
      });
      if (replyToEvent) {
        // Clear reply_to_event as we put the message into the queue
        // if the send fails, retry will handle resending.
        _dispatcher_dispatcher__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .ZP.dispatch({
          action: "reply_to_event",
          event: null
        });
      }
      _dispatcher_dispatcher__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .ZP.dispatch({
        action: "message_sent"
      });
      _effects__WEBPACK_IMPORTED_MODULE_15__/* .CHAT_EFFECTS */ .b.forEach(effect => {
        if ((0,_effects_utils__WEBPACK_IMPORTED_MODULE_36__/* .containsEmoji */ .R)(content, effect.emojis)) {
          _dispatcher_dispatcher__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .ZP.dispatch({
            action: `effects.${effect.command}`
          });
        }
      });
      if (_settings_SettingsStore__WEBPACK_IMPORTED_MODULE_20__/* ["default"] */ .C.getValue("Performance.addSendMessageTimingMetadata")) {
        prom.then(resp => {
          (0,_sendTimePerformanceMetrics__WEBPACK_IMPORTED_MODULE_35__/* .sendRoundTripMetric */ .G)(this.context, roomId, resp.event_id);
        });
      }
      _CountlyAnalytics__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z.instance.trackSendMessage(startTime, prom, roomId, false, !!replyToEvent, content);
    }
    this.clearStoredEditorState();
    try {
      // catch session storage exceeded the quota
      this.sendHistoryManager.save(model, replyToEvent);
    } catch (error) {
      console.error("save send history failed", error);
    }
    // clear composer
    model.reset([]);
    (_this$editorRef$curre12 = this.editorRef.current) === null || _this$editorRef$curre12 === void 0 ? void 0 : _this$editorRef$curre12.clearUndoHistory();
    if ((0,_utils_units__WEBPACK_IMPORTED_MODULE_37__/* .isMobile */ .tq)()) {
      var _this$editorRef$curre13;
      (_this$editorRef$curre13 = this.editorRef.current) === null || _this$editorRef$curre13 === void 0 ? void 0 : _this$editorRef$curre13.blur();
    } else {
      var _this$editorRef$curre14;
      (_this$editorRef$curre14 = this.editorRef.current) === null || _this$editorRef$curre14 === void 0 ? void 0 : _this$editorRef$curre14.focus();
    }
    if (_settings_SettingsStore__WEBPACK_IMPORTED_MODULE_20__/* ["default"] */ .C.getValue("scrollToBottomOnMessageSent")) {
      _dispatcher_dispatcher__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .ZP.dispatch({
        action: "scroll_to_bottom"
      });
    }
  }
  componentWillUnmount() {
    _dispatcher_dispatcher__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .ZP.unregister(this.dispatcherRef);
    window.removeEventListener("beforeunload", this.saveStoredEditorState);
    this.saveStoredEditorState();
  }

  // TODO: [REACT-WARNING] Move this to constructor
  UNSAFE_componentWillMount() {
    // eslint-disable-line
    const partCreator = new _editor_parts__WEBPACK_IMPORTED_MODULE_6__/* .CommandPartCreator */ .w8(this.props.room, this.context);
    const parts = this.restoreStoredEditorState(partCreator) || [];
    this.model = new _editor_model__WEBPACK_IMPORTED_MODULE_38__/* ["default"] */ .Z(parts, partCreator);
    this.dispatcherRef = _dispatcher_dispatcher__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .ZP.register(this.onAction);
    this.sendHistoryManager = new _SendHistoryManager__WEBPACK_IMPORTED_MODULE_33__/* ["default"] */ .Z(this.props.room.roomId, "mx_cider_history_");
  }
  get editorStateKey() {
    return `mx_cider_state_${this.props.room.roomId}` + (this.props.privateKey ? `_${this.props.privateKey}` : "");
  }
  clearStoredEditorState() {
    localStorage.removeItem(this.editorStateKey);
  }
  restoreStoredEditorState(partCreator) {
    const json = localStorage.getItem(this.editorStateKey);
    if (json) {
      try {
        const {
          parts: serializedParts,
          replyEventId
        } = JSON.parse(json);
        const parts = serializedParts.map(p => partCreator.deserializePart(p));
        if (replyEventId) {
          _dispatcher_dispatcher__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .ZP.dispatch({
            action: "reply_to_event",
            event: this.props.room.findEventById(replyEventId)
          });
        }
        return parts;
      } catch (e) {
        console.error(e);
      }
    }
  }
  render() {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
      className: "mx_SendMessageComposer",
      onClick: this.focusComposer,
      onKeyDown: this.onKeyDown
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(_BasicMessageComposer__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z, {
      onChange: this.onChange,
      ref: this.editorRef,
      model: this.model,
      room: this.props.room,
      label: this.props.placeholder,
      placeholder: this.props.placeholder,
      onPaste: this.onPaste,
      disabled: this.props.disabled,
      prefix: this.getPrefix()
    }));
  }
}, (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(_class2, "contextType", _contexts_MatrixClientContext__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z), _class2)) || _class);


/***/ }),

/***/ 161732:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   v: () => (/* binding */ dateFormat)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(225259);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(667294);
/* harmony import */ var _dispatcher_actions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(473627);
/* harmony import */ var _dispatcher_dispatcher__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(245539);
/* harmony import */ var _languageHandler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(867614);
/* harmony import */ var _stores_RightPanelStorePhases__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(274057);
/* harmony import */ var _stores_ActivityStore__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(182445);

function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }






const getMonth = month => {
  let mm;
  switch (month) {
    case "01":
      mm = "Jan";
      break;
    case "02":
      mm = "Feb";
      break;
    case "03":
      mm = "Mar";
      break;
    case "04":
      mm = "Apr";
      break;
    case "05":
      mm = "May";
      break;
    case "06":
      mm = "Jun";
      break;
    case "07":
      mm = "Jul";
      break;
    case "08":
      mm = "Aug";
      break;
    case "09":
      mm = "Sep";
      break;
    case "10":
      mm = "Oct";
      break;
    case "11":
      mm = "Nov";
      break;
    case "12":
      mm = "Dec";
      break;
  }
  return mm;
};
const dateFormat = (startTime, endTime) => {
  if (!startTime) {
    return "";
  }
  const num = Number.parseInt(startTime);
  const start = new Date(num.toString() === startTime ? num : startTime);
  const startY = start.getFullYear();
  const startM = (start.getMonth() + 1 + "").padStart(2, "0");
  const startD = (start.getDate() + "").padStart(2, "0");
  const startMonth = getMonth(startM);
  if (endTime) {
    const numEnd = Number.parseInt(endTime);
    const end = new Date(num.toString() === endTime ? numEnd : endTime);
    const endY = end.getFullYear();
    const endM = (end.getMonth() + 1 + "").padStart(2, "0");
    const endD = (end.getDay() + "").padStart(2, "0");
    const endMonth = getMonth(endM);
    if (startY === endY) {
      if (startM === endM) {
        if (startD === endD) {
          return startMonth + " " + startD + "," + startY;
        } else {
          return startMonth + " " + startD + "-" + endD + "," + startY;
        }
      } else {
        return startMonth + " " + startD + "-" + endMonth + " " + endD + "," + startY;
      }
    } else {
      return startMonth + " " + startD + "," + startY + "-" + endMonth + " " + endD + "," + endY;
    }
  }
  return startMonth + " " + startD + "," + startY;
};
const onClickCard = url => {
  _dispatcher_dispatcher__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .ZP.dispatch({
    action: _dispatcher_actions__WEBPACK_IMPORTED_MODULE_2__/* .Action */ .a.SetRightPanelPhase,
    phase: _stores_RightPanelStorePhases__WEBPACK_IMPORTED_MODULE_5__/* .RightPanelPhases */ .q4.IframeWidget,
    refireParams: {
      params: {
        src: url,
        title: "Soshow"
      }
    }
  });
};
const bgColorMap = {
  live: "linear-gradient(135deg, rgb(172, 98, 255) 0%, rgb(100, 89, 255) 100%)",
  scheduled: "rgb(73, 152, 234)",
  ended: "rgb(149, 183, 218)"
};
const ActivityCard = props => {
  var _props$tagText, _props$coHost, _props$participates;
  const interestedChange = ev => {
    ev.preventDefault();
    ev.stopPropagation();
    const array = [..._stores_ActivityStore__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z.instance.getInterests()];
    const index = array.findIndex(item => item === props.id);
    if (index === -1) {
      array.unshift(props.id);
    } else {
      array.splice(index, 1);
    }
    _stores_ActivityStore__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z.instance.setInterests(array);
  };
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
    className: "mx_ActivityCard",
    style: _objectSpread(_objectSpread({}, props.style), {}, {
      background: bgColorMap[(_props$tagText = props.tagText) === null || _props$tagText === void 0 ? void 0 : _props$tagText.toLowerCase()]
    }),
    onClick: () => props.disClickable ? null : onClickCard(props.url)
  }, (props.tagIcon || props.tagText) && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
    className: "mx_ActivityCard_tag"
  }, props.tagIcon && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("img", {
    src: props.tagIcon
  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("span", null, props.tagText)), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
    className: "mx_ActivityCard_title"
  }, props.title), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
    className: "mx_ActivityCard_host"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("img", {
    src: props.hostAvatar,
    loading: "lazy",
    onError: e => {
      e.target.src = __webpack_require__(317523);
    }
  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("span", null, props.host), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
    className: "mx_ActivityCard_host_tag"
  }, (0,_languageHandler__WEBPACK_IMPORTED_MODULE_4__._t)("Host"))), ((_props$coHost = props.coHost) === null || _props$coHost === void 0 ? void 0 : _props$coHost.length) > 0 && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
    className: "mx_ActivityCard_cohost"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
    className: "mx_ActivityCard_cohost_faces"
  }, props.coHost.map((cohost, index) => {
    if (index < 3) {
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("img", {
        src: cohost.co_host_avatar,
        loading: "lazy",
        onError: e => {
          e.target.src = __webpack_require__(317523);
        }
      });
    }
  })), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
    className: "mx_ActivityCard_cohost_span_wrapper"
  }, props.coHost.map(cohost => {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("span", null, cohost.co_host);
  })), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
    className: "mx_ActivityCard_cohost_tag"
  }, (0,_languageHandler__WEBPACK_IMPORTED_MODULE_4__._t)("CoHost"))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
    className: "mx_ActivityCard_time"
  }, props.endTime ? dateFormat(props.startTime, props.endTime) : dateFormat(props.startTime)), ((_props$participates = props.participates) === null || _props$participates === void 0 ? void 0 : _props$participates.length) > 0 && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
    className: "mx_ActivityCard_participate"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", {
    className: "mx_ActivityCard_participate_faces"
  }, props.participates.map((participate, index) => {
    if (index < 3) {
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("img", {
        src: participate.participate_avatar,
        loading: "lazy",
        onError: e => {
          e.target.src = __webpack_require__(317523);
        }
      });
    }
  })), props.filter === "contacts_participate" ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("span", null, (0,_languageHandler__WEBPACK_IMPORTED_MODULE_4__._t)("%(count)s friend joined", {
    count: props.participates.length
  })) : /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement("span", null, (0,_languageHandler__WEBPACK_IMPORTED_MODULE_4__._t)("%(count)s people joined", {
    count: props.participates.length
  }))));
};
ActivityCard.defaultProps = {};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ActivityCard);

/***/ }),

/***/ 858687:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(225259);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(667294);
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(294184);
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _languageHandler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(867614);
/* harmony import */ var _Keyboard__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(389310);
/* harmony import */ var _utils_replaceableComponent__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(90287);

var _dec, _class;
/*
Copyright 2019 Tulir Asokan <tulir@maunium.net>
Copyright 2020 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/






let Search = (_dec = (0,_utils_replaceableComponent__WEBPACK_IMPORTED_MODULE_4__/* .replaceableComponent */ .U)("views.emojipicker.Search"), _dec(_class = class Search extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {
  constructor(...args) {
    super(...args);
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(this, "inputRef", /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createRef());
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(this, "onKeyDown", ev => {
      if (ev.key === _Keyboard__WEBPACK_IMPORTED_MODULE_3__/* .Key */ .sr.ENTER) {
        this.props.onEnter();
        ev.stopPropagation();
        ev.preventDefault();
      }
    });
  }
  componentDidMount() {
    // For some reason, neither the autoFocus nor just calling focus() here worked, so here's a setTimeout
    // setTimeout(() => this.inputRef.current.focus(), 0);
  }
  render() {
    let rightButton;
    if (this.props.query) {
      rightButton = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("button", {
        onClick: () => this.props.onChange(""),
        className: "mx_EmojiPicker_search_icon mx_EmojiPicker_search_clear",
        title: (0,_languageHandler__WEBPACK_IMPORTED_MODULE_2__._t)("Cancel search")
      });
    }
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: classnames__WEBPACK_IMPORTED_MODULE_1___default()("mx_EmojiPicker_search", this.props.className)
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
      className: "mx_EmojiPicker_search_icon"
    }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", {
      autoFocus: true,
      type: "text",
      placeholder: (0,_languageHandler__WEBPACK_IMPORTED_MODULE_2__._t)("Search"),
      value: this.props.query,
      onChange: ev => this.props.onChange(ev.target.value),
      onKeyDown: this.onKeyDown,
      ref: this.inputRef
    }), rightButton);
  }
}) || _class);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Search);

/***/ }),

/***/ 906087:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   E: () => (/* binding */ parseEvent),
/* harmony export */   R: () => (/* binding */ parsePlainTextMessage)
/* harmony export */ });
/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(980680);
/* harmony import */ var _HtmlUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(714813);
/* harmony import */ var _utils_permalinks_Permalinks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(954105);
/* harmony import */ var _parts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(887403);
/* harmony import */ var _SdkConfig__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(374312);
/*
Copyright 2019 New Vector Ltd
Copyright 2019, 2020 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/






function parseAtRoomMentions(text, partCreator, roomId) {
  const ATROOM = "@room";
  const parts = [];
  text.split(ATROOM).forEach((textPart, i, arr) => {
    if (textPart.length) {
      parts.push(partCreator.plain(textPart));
    }
    // it's safe to never append @room after the last textPart
    // as split will report an empty string at the end if
    // `text` ended in @room.
    const isLast = i === arr.length - 1;
    if (!isLast) {
      parts.push(partCreator.atRoomPill(ATROOM, roomId));
    }
  });
  return parts;
}
function parseLink(a, partCreator) {
  const {
    href
  } = a;
  const resourceId = (0,_utils_permalinks_Permalinks__WEBPACK_IMPORTED_MODULE_2__/* .getPrimaryPermalinkEntity */ .qD)(href); // The room/user ID
  const prefix = resourceId ? resourceId[0] : undefined; // First character of ID
  switch (prefix) {
    case "@":
      return partCreator.userPill(a.textContent, resourceId);
    case "#":
      return partCreator.roomPill(resourceId);
    case "!":
      return partCreator.atRoomPill(a.textContent, resourceId);
    default:
      {
        if (href === a.textContent) {
          return partCreator.plain(a.textContent);
        } else if (href.startsWith('topic://')) {
          return partCreator.topicPill(a.textContent);
        } else {
          return partCreator.plain(`[${a.textContent.replace(/[[\\\]]/g, c => "\\" + c)}](${href})`);
        }
      }
  }
}
function parseImage(img, partCreator) {
  const {
    src
  } = img;
  return partCreator.plain(`![${img.alt.replace(/[[\\\]]/g, c => "\\" + c)}](${src})`);
}
function parseCodeBlock(n, partCreator) {
  const parts = [];
  let language = "";
  if (n.firstChild && n.firstChild.nodeName === "CODE") {
    for (const className of n.firstChild.classList) {
      if (className.startsWith("language-") && !className.startsWith("language-_")) {
        language = className.substr("language-".length);
        break;
      }
    }
  }
  const preLines = ("```" + language + "\n" + n.textContent + "```").split("\n");
  preLines.forEach((l, i) => {
    parts.push(partCreator.plain(l));
    if (i < preLines.length - 1) {
      parts.push(partCreator.newline());
    }
  });
  return parts;
}
function parseHeader(el, partCreator) {
  const depth = parseInt(el.nodeName.substr(1), 10);
  return partCreator.plain("#".repeat(depth) + " ");
}
function parseElement(n, partCreator, lastNode, state) {
  switch (n.nodeName) {
    case "H1":
    case "H2":
    case "H3":
    case "H4":
    case "H5":
    case "H6":
      return parseHeader(n, partCreator);
    case "A":
      return parseLink(n, partCreator);
    case "IMG":
      return parseImage(n, partCreator);
    case "BR":
      return partCreator.newline();
    case "EM":
      return partCreator.plain(`_${n.textContent}_`);
    case "STRONG":
      return partCreator.plain(`**${n.textContent}**`);
    case "PRE":
      return parseCodeBlock(n, partCreator);
    case "CODE":
      return partCreator.plain(`\`${n.textContent}\``);
    case "DEL":
      return partCreator.plain(`<del>${n.textContent}</del>`);
    case "SUB":
      return partCreator.plain(`<sub>${n.textContent}</sub>`);
    case "SUP":
      return partCreator.plain(`<sup>${n.textContent}</sup>`);
    case "U":
      return partCreator.plain(`<u>${n.textContent}</u>`);
    case "LI":
      {
        const indent = "  ".repeat(state.listDepth - 1);
        if (n.parentElement.nodeName === "OL") {
          // The markdown parser doesn't do nested indexed lists at all, but this supports it anyway.
          const index = state.listIndex[state.listIndex.length - 1];
          state.listIndex[state.listIndex.length - 1] += 1;
          return partCreator.plain(`${indent}${index}. `);
        } else {
          return partCreator.plain(`${indent}- `);
        }
      }
    case "P":
      {
        if (lastNode) {
          return partCreator.newline();
        }
        break;
      }
    case "DIV":
    case "SPAN":
      {
        // math nodes are translated back into delimited latex strings
        if (n.hasAttribute("data-mx-maths")) {
          const delimLeft = n.nodeName == "SPAN" ? ((_SdkConfig__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z.get()['latex_maths_delims'] || {})['inline'] || {})['left'] || "\\(" : ((_SdkConfig__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z.get()['latex_maths_delims'] || {})['display'] || {})['left'] || "\\[";
          const delimRight = n.nodeName == "SPAN" ? ((_SdkConfig__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z.get()['latex_maths_delims'] || {})['inline'] || {})['right'] || "\\)" : ((_SdkConfig__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z.get()['latex_maths_delims'] || {})['display'] || {})['right'] || "\\]";
          const tex = n.getAttribute("data-mx-maths");
          return partCreator.plain(delimLeft + tex + delimRight);
        } else if (!checkDescendInto(n)) {
          return partCreator.plain(n.textContent);
        }
        break;
      }
    case "OL":
      state.listIndex.push(n.start || 1);
    /* falls through */
    case "UL":
      state.listDepth = (state.listDepth || 0) + 1;
    /* falls through */
    default:
      // don't textify block nodes we'll descend into
      if (!checkDescendInto(n)) {
        return partCreator.plain(n.textContent);
      }
  }
}
function checkDescendInto(node) {
  switch (node.nodeName) {
    case "PRE":
      // a code block is textified in parseCodeBlock
      // as we don't want to preserve markup in it,
      // so no need to descend into it
      return false;
    default:
      return (0,_HtmlUtils__WEBPACK_IMPORTED_MODULE_1__/* .checkBlockNode */ .TP)(node);
  }
}
function checkIgnored(n) {
  if (n.nodeType === Node.TEXT_NODE) {
    // Element adds \n text nodes in a lot of places,
    // which should be ignored
    return n.nodeValue === "\n";
  } else if (n.nodeType === Node.ELEMENT_NODE) {
    return n.nodeName === "MX-REPLY";
  }
  return true;
}
const QUOTE_LINE_PREFIX = "> ";
function prefixQuoteLines(isFirstNode, parts, partCreator) {
  // a newline (to append a > to) wouldn't be added to parts for the first line
  // if there was no content before the BLOCKQUOTE, so handle that
  if (isFirstNode) {
    parts.splice(0, 0, partCreator.plain(QUOTE_LINE_PREFIX));
  }
  for (let i = 0; i < parts.length; i += 1) {
    if (parts[i].type === _parts__WEBPACK_IMPORTED_MODULE_3__/* .Type */ .Dy.Newline) {
      parts.splice(i + 1, 0, partCreator.plain(QUOTE_LINE_PREFIX));
      i += 1;
    }
  }
}
function parseHtmlMessage(html, partCreator, isQuotedMessage, roomId) {
  // no nodes from parsing here should be inserted in the document,
  // as scripts in event handlers, etc would be executed then.
  // we're only taking text, so that is fine
  const rootNode = new DOMParser().parseFromString(html, "text/html").body;
  const parts = [];
  let lastNode;
  let inQuote = isQuotedMessage;
  const state = {
    listIndex: []
  };
  function onNodeEnter(n) {
    if (checkIgnored(n)) {
      return false;
    }
    if (n.nodeName === "BLOCKQUOTE") {
      inQuote = true;
    }
    const newParts = [];
    if (lastNode && ((0,_HtmlUtils__WEBPACK_IMPORTED_MODULE_1__/* .checkBlockNode */ .TP)(lastNode) || (0,_HtmlUtils__WEBPACK_IMPORTED_MODULE_1__/* .checkBlockNode */ .TP)(n))) {
      newParts.push(partCreator.newline());
    }
    if (n.nodeType === Node.TEXT_NODE) {
      newParts.push(...parseAtRoomMentions(n.nodeValue, partCreator, roomId));
    } else if (n.nodeType === Node.ELEMENT_NODE) {
      const parseResult = parseElement(n, partCreator, lastNode, state);
      if (parseResult) {
        if (Array.isArray(parseResult)) {
          newParts.push(...parseResult);
        } else {
          newParts.push(parseResult);
        }
      }
    }
    if (newParts.length && inQuote) {
      const isFirstPart = parts.length === 0;
      prefixQuoteLines(isFirstPart, newParts, partCreator);
    }
    parts.push(...newParts);
    const descend = checkDescendInto(n);
    // when not descending (like for PRE), onNodeLeave won't be called to set lastNode
    // so do that here.
    lastNode = descend ? null : n;
    return descend;
  }
  function onNodeLeave(n) {
    if (checkIgnored(n)) {
      return;
    }
    switch (n.nodeName) {
      case "BLOCKQUOTE":
        inQuote = false;
        break;
      case "OL":
        state.listIndex.pop();
      /* falls through */
      case "UL":
        state.listDepth -= 1;
        break;
    }
    lastNode = n;
  }
  (0,_dom__WEBPACK_IMPORTED_MODULE_0__/* .walkDOMDepthFirst */ .y1)(rootNode, onNodeEnter, onNodeLeave);
  return parts;
}
function parsePlainTextMessage(body, partCreator, isQuotedMessage, roomId) {
  const lines = body.split(/\r\n|\r|\n/g); // split on any new-line combination not just \n, collapses \r\n
  return lines.reduce((parts, line, i) => {
    if (isQuotedMessage) {
      parts.push(partCreator.plain(QUOTE_LINE_PREFIX));
    }
    parts.push(...parseAtRoomMentions(line, partCreator, roomId));
    const isLast = i === lines.length - 1;
    if (!isLast) {
      parts.push(partCreator.newline());
    }
    return parts;
  }, []);
}
function parseEvent(event, partCreator, {
  isQuotedMessage = false
} = {}) {
  const content = event.getContent();
  const roomId = event.getRoomId();
  let parts;
  if (content.format === "org.matrix.custom.html") {
    parts = parseHtmlMessage(content.formatted_body || "", partCreator, isQuotedMessage, roomId);
  } else {
    parts = parsePlainTextMessage(content.body || "", partCreator, isQuotedMessage, roomId);
  }
  if (content.msgtype === "m.emote") {
    parts.unshift(partCreator.plain("/me "));
  }
  return parts;
}

/***/ }),

/***/ 980680:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Aq: () => (/* binding */ getCaretOffsetAndText),
/* harmony export */   gK: () => (/* binding */ getRangeForSelection),
/* harmony export */   y1: () => (/* binding */ walkDOMDepthFirst)
/* harmony export */ });
/* harmony import */ var _render__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(91021);
/* harmony import */ var _offset__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(29160);
/*
Copyright 2019 New Vector Ltd
Copyright 2019 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/



function walkDOMDepthFirst(rootNode, enterNodeCallback, leaveNodeCallback) {
  let node = rootNode.firstChild;
  while (node && node !== rootNode) {
    const shouldDescend = enterNodeCallback(node);
    if (shouldDescend && node.firstChild) {
      node = node.firstChild;
    } else if (node.nextSibling) {
      node = node.nextSibling;
    } else {
      while (!node.nextSibling && node !== rootNode) {
        node = node.parentElement;
        if (node !== rootNode) {
          leaveNodeCallback(node);
        }
      }
      if (node !== rootNode) {
        node = node.nextSibling;
      }
    }
  }
}
function getCaretOffsetAndText(editor, sel) {
  const {
    offset,
    text
  } = getSelectionOffsetAndText(editor, sel.focusNode, sel.focusOffset);
  return {
    caret: offset,
    text
  };
}
function tryReduceSelectionToTextNode(selectionNode, selectionOffset) {
  // if selectionNode is an element, the selected location comes after the selectionOffset-th child node,
  // which can point past any childNode, in which case, the end of selectionNode is selected.
  // we try to simplify this to point at a text node with the offset being
  // a character offset within the text node
  // Also see https://developer.mozilla.org/en-US/docs/Web/API/Selection
  while (selectionNode && selectionNode.nodeType === Node.ELEMENT_NODE) {
    const childNodeCount = selectionNode.childNodes.length;
    if (childNodeCount) {
      if (selectionOffset >= childNodeCount) {
        selectionNode = selectionNode.lastChild;
        if (selectionNode.nodeType === Node.TEXT_NODE) {
          selectionOffset = selectionNode.textContent.length;
        } else {
          // this will select the last child node in the next iteration
          selectionOffset = Number.MAX_SAFE_INTEGER;
        }
      } else {
        selectionNode = selectionNode.childNodes[selectionOffset];
        // this will select the first child node in the next iteration
        selectionOffset = 0;
      }
    } else {
      // here node won't be a text node,
      // but characterOffset should be 0,
      // this happens under some circumstances
      // when the editor is empty.
      // In this case characterOffset=0 is the right thing to do
      break;
    }
  }
  return {
    node: selectionNode,
    characterOffset: selectionOffset
  };
}
function getSelectionOffsetAndText(editor, selectionNode, selectionOffset) {
  const {
    node,
    characterOffset
  } = tryReduceSelectionToTextNode(selectionNode, selectionOffset);
  const {
    text,
    offsetToNode
  } = getTextAndOffsetToNode(editor, node);
  const offset = getCaret(node, offsetToNode, characterOffset);
  return {
    offset,
    text
  };
}

// gets the caret position details, ignoring and adjusting to
// the ZWS if you're typing in a caret node
function getCaret(node, offsetToNode, offsetWithinNode) {
  // if no node is selected, return an offset at the start
  if (!node) {
    return new _offset__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z(0, false);
  }
  let atNodeEnd = offsetWithinNode === node.textContent.length;
  if (node.nodeType === Node.TEXT_NODE && (0,_render__WEBPACK_IMPORTED_MODULE_0__/* .isCaretNode */ .i0)(node.parentElement)) {
    const zwsIdx = node.nodeValue.indexOf(_render__WEBPACK_IMPORTED_MODULE_0__/* .CARET_NODE_CHAR */ .pE);
    if (zwsIdx !== -1 && zwsIdx < offsetWithinNode) {
      offsetWithinNode -= 1;
    }
    // if typing in a caret node, you're either typing before or after the ZWS.
    // In both cases, you should be considered at node end because the ZWS is
    // not included in the text here, and once the model is updated and rerendered,
    // that caret node will be removed.
    atNodeEnd = true;
  }
  return new _offset__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z(offsetToNode + offsetWithinNode, atNodeEnd);
}

// gets the text of the editor as a string,
// and the offset in characters where the selectionNode starts in that string
// all ZWS from caret nodes are filtered out
function getTextAndOffsetToNode(editor, selectionNode) {
  let offsetToNode = 0;
  let foundNode = false;
  let text = "";
  function enterNodeCallback(node) {
    if (!foundNode) {
      if (node === selectionNode) {
        foundNode = true;
      }
    }
    // usually newlines are entered as new DIV elements,
    // but for example while pasting in some browsers, they are still
    // converted to BRs, so also take these into account when they
    // are not the last element in the DIV.
    if (node.tagName === "BR" && node.nextSibling) {
      if (!foundNode) {
        offsetToNode += 1;
      }
      text += "\n";
    }
    const nodeText = node.nodeType === Node.TEXT_NODE && getTextNodeValue(node);
    if (nodeText) {
      if (!foundNode) {
        offsetToNode += nodeText.length;
      }
      text += nodeText;
    }
    return true;
  }
  function leaveNodeCallback(node) {
    // if this is not the last DIV (which are only used as line containers atm)
    // we don't just check if there is a nextSibling because sometimes the caret ends up
    // after the last DIV and it creates a newline if you type then,
    // whereas you just want it to be appended to the current line
    if (node.tagName === "DIV" && node.nextSibling && node.nextSibling.tagName === "DIV") {
      text += "\n";
      if (!foundNode) {
        offsetToNode += 1;
      }
    }
  }
  walkDOMDepthFirst(editor, enterNodeCallback, leaveNodeCallback);
  return {
    text,
    offsetToNode
  };
}

// get text value of text node, ignoring ZWS if it's a caret node
function getTextNodeValue(node) {
  const nodeText = node.nodeValue;
  // filter out ZWS for caret nodes
  if ((0,_render__WEBPACK_IMPORTED_MODULE_0__/* .isCaretNode */ .i0)(node.parentElement)) {
    // typed in the caret node, so there is now something more in it than the ZWS
    // so filter out the ZWS, and take the typed text into account
    if (nodeText.length !== 1) {
      return nodeText.replace(_render__WEBPACK_IMPORTED_MODULE_0__/* .CARET_NODE_CHAR */ .pE, "");
    } else {
      // only contains ZWS, which is ignored, so return emtpy string
      return "";
    }
  } else {
    return nodeText;
  }
}
function getRangeForSelection(editor, model, selection) {
  const focusOffset = getSelectionOffsetAndText(editor, selection.focusNode, selection.focusOffset).offset;
  const anchorOffset = getSelectionOffsetAndText(editor, selection.anchorNode, selection.anchorOffset).offset;
  const focusPosition = focusOffset.asPosition(model);
  const anchorPosition = anchorOffset.asPosition(model);
  return model.startRange(focusPosition, anchorPosition);
}

/***/ }),

/***/ 300252:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Z: () => (/* binding */ EditorModel)
});

// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/node_modules/@babel/runtime/helpers/esm/defineProperty.js
var defineProperty = __webpack_require__(225259);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/editor/diff.ts
/*
Copyright 2019 New Vector Ltd
Copyright 2019 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

function firstDiff(a, b) {
  const compareLen = Math.min(a.length, b.length);
  for (let i = 0; i < compareLen; ++i) {
    if (a[i] !== b[i]) {
      return i;
    }
  }
  return compareLen;
}
function diffStringsAtEnd(oldStr, newStr) {
  const len = Math.min(oldStr.length, newStr.length);
  const startInCommon = oldStr.substr(0, len) === newStr.substr(0, len);
  if (startInCommon && oldStr.length > newStr.length) {
    return {
      removed: oldStr.substr(len),
      at: len
    };
  } else if (startInCommon && oldStr.length < newStr.length) {
    return {
      added: newStr.substr(len),
      at: len
    };
  } else {
    const commonStartLen = firstDiff(oldStr, newStr);
    return {
      removed: oldStr.substr(commonStartLen),
      added: newStr.substr(commonStartLen),
      at: commonStartLen
    };
  }
}

// assumes only characters have been deleted at one location in the string, and none added
function diffDeletion(oldStr, newStr) {
  if (oldStr === newStr) {
    return {};
  }
  const firstDiffIdx = firstDiff(oldStr, newStr);
  const amount = oldStr.length - newStr.length;
  return {
    at: firstDiffIdx,
    removed: oldStr.substr(firstDiffIdx, amount)
  };
}

/**
 * Calculates which string was added and removed around the caret position
 * @param {String} oldValue the previous value
 * @param {String} newValue the new value
 * @param {Number} caretPosition the position of the caret after `newValue` was applied.
 * @return {object} an object with `at` as the offset where characters were removed and/or added,
 *                  `added` with the added string (if any), and
 *                  `removed` with the removed string (if any)
 */
function diffAtCaret(oldValue, newValue, caretPosition) {
  const diffLen = newValue.length - oldValue.length;
  const caretPositionBeforeInput = caretPosition - diffLen;
  const oldValueBeforeCaret = oldValue.substr(0, caretPositionBeforeInput);
  const newValueBeforeCaret = newValue.substr(0, caretPosition);
  return diffStringsAtEnd(oldValueBeforeCaret, newValueBeforeCaret);
}
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/editor/offset.ts
var editor_offset = __webpack_require__(29160);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/editor/position.ts
/*
Copyright 2019 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/


class DocumentPosition {
  constructor(index, offset) {
    this.index = index;
    this.offset = offset;
  }
  compare(otherPos) {
    if (this.index === otherPos.index) {
      return this.offset - otherPos.offset;
    } else {
      return this.index - otherPos.index;
    }
  }
  iteratePartsBetween(other, model, callback) {
    if (this.index === -1 || other.index === -1) {
      return;
    }
    const [startPos, endPos] = this.compare(other) < 0 ? [this, other] : [other, this];
    if (startPos.index === endPos.index) {
      callback(model.parts[this.index], startPos.offset, endPos.offset);
    } else {
      const firstPart = model.parts[startPos.index];
      callback(firstPart, startPos.offset, firstPart.text.length);
      for (let i = startPos.index + 1; i < endPos.index; ++i) {
        const part = model.parts[i];
        callback(part, 0, part.text.length);
      }
      const lastPart = model.parts[endPos.index];
      callback(lastPart, 0, endPos.offset);
    }
  }
  forwardsWhile(model, predicate) {
    if (this.index === -1) {
      return this;
    }
    let {
      index,
      offset
    } = this;
    const {
      parts
    } = model;
    while (index < parts.length) {
      const part = parts[index];
      while (offset < part.text.length) {
        if (!predicate(index, offset, part)) {
          return new DocumentPosition(index, offset);
        }
        offset += 1;
      }
      // end reached
      if (index === parts.length - 1) {
        return new DocumentPosition(index, offset);
      } else {
        index += 1;
        offset = 0;
      }
    }
  }
  backwardsWhile(model, predicate) {
    if (this.index === -1) {
      return this;
    }
    let {
      index,
      offset
    } = this;
    const parts = model.parts;
    while (index >= 0) {
      const part = parts[index];
      while (offset > 0) {
        if (!predicate(index, offset - 1, part)) {
          return new DocumentPosition(index, offset);
        }
        offset -= 1;
      }
      // start reached
      if (index === 0) {
        return new DocumentPosition(index, offset);
      } else {
        index -= 1;
        offset = parts[index].text.length;
      }
    }
  }
  asOffset(model) {
    if (this.index === -1) {
      return new editor_offset/* default */.Z(0, true);
    }
    let offset = 0;
    for (let i = 0; i < this.index; ++i) {
      offset += model.parts[i].text.length;
    }
    offset += this.offset;
    const lastPart = model.parts[this.index];
    const atEnd = !lastPart || offset >= lastPart.text.length; // if no last part, we're at the end
    return new editor_offset/* default */.Z(offset, atEnd);
  }
  isAtEnd(model) {
    if (model.parts.length === 0) {
      return true;
    }
    const lastPartIdx = model.parts.length - 1;
    const lastPart = model.parts[lastPartIdx];
    return this.index === lastPartIdx && this.offset === lastPart.text.length;
  }
  isAtStart() {
    return this.index === 0 && this.offset === 0;
  }
}
// EXTERNAL MODULE: ./node_modules/matrix-react-sdk/src/editor/range.ts
var range = __webpack_require__(123245);
;// CONCATENATED MODULE: ./node_modules/matrix-react-sdk/src/editor/model.ts

/*
Copyright 2019 New Vector Ltd
Copyright 2019 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/




const strs = ["@", "$"];

/**
 * @callback ModelCallback
 * @param {DocumentPosition?} caretPosition the position where the caret should be position
 * @param {string?} inputType the inputType of the DOM input event
 * @param {object?} diff an object with `removed` and `added` strings
 */

/**
 * @callback TransformCallback
 * @param {DocumentPosition?} caretPosition the position where the caret should be position
 * @param {string?} inputType the inputType of the DOM input event
 * @param {object?} diff an object with `removed` and `added` strings
 * @return {Number?} addedLen how many characters were added/removed (-) before the caret during the transformation step.
 *    This is used to adjust the caret position.
 */

/**
 * @callback ManualTransformCallback
 * @return the caret position
 */
class EditorModel {
  constructor(parts, partCreator, updateCallback = null) {
    this.updateCallback = updateCallback;
    (0,defineProperty/* default */.Z)(this, "_parts", void 0);
    (0,defineProperty/* default */.Z)(this, "_partCreator", void 0);
    (0,defineProperty/* default */.Z)(this, "activePartIdx", null);
    (0,defineProperty/* default */.Z)(this, "_autoComplete", null);
    (0,defineProperty/* default */.Z)(this, "autoCompletePartIdx", null);
    (0,defineProperty/* default */.Z)(this, "autoCompletePartCount", 0);
    (0,defineProperty/* default */.Z)(this, "transformCallback", null);
    (0,defineProperty/* default */.Z)(this, "onAutoComplete", ({
      replaceParts,
      close
    }) => {
      let pos;
      if (replaceParts) {
        this._parts.splice(this.autoCompletePartIdx, this.autoCompletePartCount, ...replaceParts);
        this.autoCompletePartCount = replaceParts.length;
        const lastPart = replaceParts[replaceParts.length - 1];
        const lastPartIndex = this.autoCompletePartIdx + replaceParts.length - 1;
        pos = new DocumentPosition(lastPartIndex, lastPart.text.length);
      }
      if (close) {
        this._autoComplete = null;
        this.autoCompletePartIdx = null;
        this.autoCompletePartCount = 0;
      }
      // rerender even if editor contents didn't change
      // to make sure the MessageEditor checks
      // model.autoComplete being empty and closes it
      this.updateCallback(pos);
    });
    this._parts = parts;
    this._partCreator = partCreator;
    this.transformCallback = null;
  }

  /**
   * Set a callback for the transformation step.
   * While processing an update, right before calling the update callback,
   * a transform callback can be called, which serves to do modifications
   * on the model that can span multiple parts. Also see `startRange()`.
   * @param {TransformCallback} transformCallback
   */
  setTransformCallback(transformCallback) {
    this.transformCallback = transformCallback;
  }

  /**
   * Set a callback for rerendering the model after it has been updated.
   * @param {ModelCallback} updateCallback
   */
  setUpdateCallback(updateCallback) {
    this.updateCallback = updateCallback;
  }
  get partCreator() {
    return this._partCreator;
  }
  get isEmpty() {
    return this._parts.reduce((len, part) => {
      if (part) {
        var _part$text;
        return len + (part === null || part === void 0 ? void 0 : (_part$text = part.text) === null || _part$text === void 0 ? void 0 : _part$text.length);
      }
      return len;
    }, 0) === 0;
  }
  clone() {
    return new EditorModel(this._parts, this._partCreator, this.updateCallback);
  }
  insertPart(index, part) {
    this._parts.splice(index, 0, part);
    if (this.activePartIdx >= index) {
      ++this.activePartIdx;
    }
    if (this.autoCompletePartIdx >= index) {
      ++this.autoCompletePartIdx;
    }
  }
  removePart(index) {
    this._parts.splice(index, 1);
    if (index === this.activePartIdx) {
      this.activePartIdx = null;
    } else if (this.activePartIdx > index) {
      --this.activePartIdx;
    }
    if (index === this.autoCompletePartIdx) {
      this.autoCompletePartIdx = null;
    } else if (this.autoCompletePartIdx > index) {
      --this.autoCompletePartIdx;
    }
  }
  replacePart(index, part) {
    this._parts.splice(index, 1, part);
  }
  get parts() {
    return this._parts;
  }
  get autoComplete() {
    if (this.activePartIdx === this.autoCompletePartIdx) {
      return this._autoComplete;
    }
    return null;
  }
  getPositionAtEnd() {
    if (this._parts.length) {
      const index = this._parts.length - 1;
      const part = this._parts[index];
      return new DocumentPosition(index, part.text.length);
    } else {
      // part index -1, as there are no parts to point at
      return new DocumentPosition(-1, 0);
    }
  }
  serializeParts() {
    return this._parts.filter(p => p).map(p => p.serialize());
  }
  diff(newValue, inputType, caret) {
    const previousValue = this.parts.reduce((text, p) => text + p.text, "");
    // can't use caret position with drag and drop
    if (inputType === "deleteByDrag") {
      return diffDeletion(previousValue, newValue);
    } else {
      return diffAtCaret(previousValue, newValue, caret.offset);
    }
  }
  reset(serializedParts, caret, inputType) {
    this._parts = serializedParts.map(p => this._partCreator.deserializePart(p));
    if (!caret) {
      caret = this.getPositionAtEnd();
    }
    // close auto complete if open
    // this would happen when clearing the composer after sending
    // a message with the autocomplete still open
    if (this._autoComplete) {
      this._autoComplete = null;
      this.autoCompletePartIdx = null;
    }
    this.updateCallback(caret, inputType);
  }

  /**
   * Inserts the given parts at the given position.
   * Should be run inside a `model.transform()` callback.
   * @param {Part[]} parts the parts to replace the range with
   * @param {DocumentPosition} position the position to start inserting at
   * @return {Number} the amount of characters added
   */
  insert(parts, position) {
    const insertIndex = this.splitAt(position);
    let newTextLength = 0;
    for (let i = 0; i < parts.length; ++i) {
      const part = parts[i];
      newTextLength += part.text.length;
      this.insertPart(insertIndex + i, part);
    }
    return newTextLength;
  }
  update(newValue, inputType, caret) {
    const diff = this.diff(newValue, inputType, caret);
    const position = this.positionForOffset(diff.at, caret.atNodeEnd);
    let removedOffsetDecrease = 0;
    if (diff.removed) {
      removedOffsetDecrease = this.removeText(position, diff.removed.length);
    }
    let addedLen = 0;
    if (diff.added) {
      addedLen = this.addText(position, diff.added, inputType);
    }
    this.mergeAdjacentParts();
    const caretOffset = diff.at - removedOffsetDecrease + addedLen;
    let newPosition = this.positionForOffset(caretOffset, true);
    const canOpenAutoComplete = inputType !== "insertFromPaste" && inputType !== "insertFromDrop";
    const acPromise = this.setActivePart(newPosition, canOpenAutoComplete);
    if (this.transformCallback) {
      const transformAddedLen = this.getTransformAddedLen(newPosition, inputType, diff);
      newPosition = this.positionForOffset(caretOffset + transformAddedLen, true);
    }
    this.updateCallback(newPosition, inputType, diff);
    return acPromise;
  }
  getTransformAddedLen(newPosition, inputType, diff) {
    const result = this.transformCallback(newPosition, inputType, diff);
    return Number.isFinite(result) ? result : 0;
  }
  setActivePart(pos, canOpenAutoComplete) {
    const {
      index
    } = pos;
    const part = this._parts[index];
    if (part) {
      if (index !== this.activePartIdx) {
        this.activePartIdx = index;
        if (canOpenAutoComplete && this.activePartIdx !== this.autoCompletePartIdx) {
          // else try to create one
          const ac = part.createAutoComplete(this.onAutoComplete);
          if (ac) {
            // make sure that react picks up the difference between both acs
            this._autoComplete = ac;
            this.autoCompletePartIdx = index;
            this.autoCompletePartCount = 1;
          }
        }
      }
      // not autoComplete, only there if active part is autocomplete part
      if (this.autoComplete) {
        return this.autoComplete.onPartUpdate(part, pos);
      }
    } else {
      this.activePartIdx = null;
      this._autoComplete = null;
      this.autoCompletePartIdx = null;
      this.autoCompletePartCount = 0;
    }
    return Promise.resolve();
  }
  mergeAdjacentParts() {
    let prevPart;
    for (let i = 0; i < this._parts.length; ++i) {
      let part = this._parts[i];
      const isEmpty = !part.text.length;
      const isMerged = !isEmpty && prevPart && prevPart.merge(part);
      if (isEmpty || isMerged) {
        // remove empty or merged part
        part = prevPart;
        this.removePart(i);
        //repeat this index, as it's removed now
        --i;
      }
      prevPart = part;
    }
  }

  /**
   * removes `len` amount of characters at `pos`.
   * @param {Object} pos
   * @param {Number} len
   * @return {Number} how many characters before pos were also removed,
   * usually because of non-editable parts that can only be removed in their entirety.
   */
  removeText(pos, len) {
    let {
      index,
      offset
    } = pos;
    let removedOffsetDecrease = 0;
    while (len > 0) {
      // part might be undefined here
      let part = this._parts[index];
      const amount = Math.min(len, part.text.length - offset);
      // don't allow 0 amount deletions
      if (amount) {
        if (part.canEdit) {
          const replaceWith = part.remove(offset, amount);
          if (typeof replaceWith === "string") {
            this.replacePart(index, this._partCreator.createDefaultPart(replaceWith));
          }
          part = this._parts[index];
          // remove empty part
          if (!part.text.length) {
            this.removePart(index);
          } else {
            index += 1;
          }
        } else {
          removedOffsetDecrease += offset;
          this.removePart(index);
        }
      } else {
        index += 1;
      }
      len -= amount;
      offset = 0;
    }
    return removedOffsetDecrease;
  }

  // return part index where insertion will insert between at offset
  splitAt(pos) {
    if (pos.index === -1) {
      return 0;
    }
    if (pos.offset === 0) {
      return pos.index;
    }
    const part = this._parts[pos.index];
    if (pos.offset >= part.text.length) {
      return pos.index + 1;
    }
    const secondPart = part.split(pos.offset);
    this.insertPart(pos.index + 1, secondPart);
    return pos.index + 1;
  }

  /**
   * inserts `str` into the model at `pos`.
   * @param {Object} pos
   * @param {string} str
   * @param {string} inputType the source of the input, see html InputEvent.inputType
   * @param {bool} options.validate Whether characters will be validated by the part.
   *                                Validating allows the inserted text to be parsed according to the part rules.
   * @return {Number} how far from position (in characters) the insertion ended.
   * This can be more than the length of `str` when crossing non-editable parts, which are skipped.
   */
  addText(pos, str, inputType) {
    let {
      index
    } = pos;
    const {
      offset
    } = pos;
    let addLen = str.length;
    const part = this._parts[index];
    if (part) {
      if (part.canEdit) {
        if (part.validateAndInsert(offset, str, inputType)) {
          if (strs.includes(str)) {
            const splitPart = part.split(offset).split(1);
            index += 1;
            this.insertPart(index, splitPart);
          } else {
            str = null;
          }
        } else {
          const splitPart = part.split(offset);
          index += 1;
          this.insertPart(index, splitPart);
        }
      } else if (offset !== 0) {
        // not-editable part, caret is not at start,
        // so insert str after this part
        addLen += part.text.length - offset;
        index += 1;
      }
    } else if (index < 0) {
      // if position was not found (index: -1, as happens for empty editor)
      // reset it to insert as first part
      index = 0;
    }
    while (str) {
      const newPart = this._partCreator.createPartForInput(str, index, inputType);
      str = newPart.appendUntilRejected(str, inputType);
      this.insertPart(index, newPart);
      index += 1;
    }
    return addLen;
  }
  positionForOffset(totalOffset, atPartEnd = false) {
    let currentOffset = 0;
    const index = this._parts.findIndex(part => {
      const partLen = part.text.length;
      if (atPartEnd && currentOffset + partLen >= totalOffset || !atPartEnd && currentOffset + partLen > totalOffset) {
        return true;
      }
      currentOffset += partLen;
      return false;
    });
    if (index === -1) {
      return this.getPositionAtEnd();
    } else {
      return new DocumentPosition(index, totalOffset - currentOffset);
    }
  }

  /**
   * Starts a range, which can span across multiple parts, to find and replace text.
   * @param {DocumentPosition} positionA a boundary of the range
   * @param {DocumentPosition?} positionB the other boundary of the range, optional
   * @return {Range}
   */
  startRange(positionA, positionB = positionA) {
    return new range/* default */.Z(this, positionA, positionB);
  }
  replaceRange(startPosition, endPosition, parts) {
    // convert end position to offset, so it is independent of how the document is split into parts
    // which we'll change when splitting up at the start position
    const endOffset = endPosition.asOffset(this);
    const newStartPartIndex = this.splitAt(startPosition);
    // convert it back to position once split at start
    endPosition = endOffset.asPosition(this);
    const newEndPartIndex = this.splitAt(endPosition);
    for (let i = newEndPartIndex - 1; i >= newStartPartIndex; --i) {
      this.removePart(i);
    }
    let insertIdx = newStartPartIndex;
    for (const part of parts) {
      this.insertPart(insertIdx, part);
      insertIdx += 1;
    }
    this.mergeAdjacentParts();
  }

  /**
   * Performs a transformation not part of an update cycle.
   * Modifying the model should only happen inside a transform call if not part of an update call.
   * @param {ManualTransformCallback} callback to run the transformations in
   * @return {Promise} a promise when auto-complete (if applicable) is done updating
   */
  transform(callback) {
    const pos = callback();
    let acPromise = null;
    if (!(pos instanceof range/* default */.Z)) {
      acPromise = this.setActivePart(pos, true);
    } else {
      acPromise = Promise.resolve();
    }
    this.updateCallback(pos);
    return acPromise;
  }
}

/***/ }),

/***/ 29160:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (/* binding */ DocumentOffset)
/* harmony export */ });
/*
Copyright 2019 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

class DocumentOffset {
  constructor(offset, atNodeEnd) {
    this.offset = offset;
    this.atNodeEnd = atNodeEnd;
  }
  asPosition(model) {
    return model.positionForOffset(this.offset, this.atNodeEnd);
  }
  add(delta, atNodeEnd = false) {
    return new DocumentOffset(this.offset + delta, atNodeEnd);
  }
}

/***/ }),

/***/ 123245:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (/* binding */ Range)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(225259);

/*
Copyright 2019 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

const whitespacePredicate = (index, offset, part) => {
  return part.text[offset].trim() === "";
};
class Range {
  constructor(model, positionA, positionB = positionA) {
    this.model = model;
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this, "_start", void 0);
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this, "_end", void 0);
    const bIsLarger = positionA.compare(positionB) < 0;
    this._start = bIsLarger ? positionA : positionB;
    this._end = bIsLarger ? positionB : positionA;
  }
  moveStartForwards(delta) {
    this._start = this._start.forwardsWhile(this.model, () => {
      delta -= 1;
      return delta >= 0;
    });
  }
  moveEndBackwards(delta) {
    this._end = this._end.backwardsWhile(this.model, () => {
      delta -= 1;
      return delta >= 0;
    });
  }
  trim() {
    this._start = this._start.forwardsWhile(this.model, whitespacePredicate);
    this._end = this._end.backwardsWhile(this.model, whitespacePredicate);
  }
  expandBackwardsWhile(predicate) {
    this._start = this._start.backwardsWhile(this.model, predicate);
  }
  get text() {
    let text = "";
    this._start.iteratePartsBetween(this._end, this.model, (part, startIdx, endIdx) => {
      const t = part.text.substring(startIdx, endIdx);
      text = text + t;
    });
    return text;
  }

  /**
   * Splits the model at the range boundaries and replaces with the given parts.
   * Should be run inside a `model.transform()` callback.
   * @param {Part[]} parts the parts to replace the range with
   * @return {Number} the net amount of characters added, can be negative.
   */
  replace(parts) {
    const newLength = parts.reduce((sum, part) => sum + part.text.length, 0);
    let oldLength = 0;
    this._start.iteratePartsBetween(this._end, this.model, (part, startIdx, endIdx) => {
      oldLength += endIdx - startIdx;
    });
    this.model.replaceRange(this._start, this._end, parts);
    return newLength - oldLength;
  }

  /**
   * Returns a copy of the (partial) parts within the range.
   * For partial parts, only the text is adjusted to the part that intersects with the range.
   */
  get parts() {
    const parts = [];
    this._start.iteratePartsBetween(this._end, this.model, (part, startIdx, endIdx) => {
      const serializedPart = part.serialize();
      serializedPart.text = part.text.substring(startIdx, endIdx);
      const newPart = this.model.partCreator.deserializePart(serializedPart);
      parts.push(newPart);
    });
    return parts;
  }
  get length() {
    let len = 0;
    this._start.iteratePartsBetween(this._end, this.model, (part, startIdx, endIdx) => {
      len += endIdx - startIdx;
    });
    return len;
  }
  get start() {
    return this._start;
  }
  get end() {
    return this._end;
  }
}

/***/ }),

/***/ 91021:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EP: () => (/* binding */ renderModel),
/* harmony export */   PM: () => (/* binding */ needsCaretNodeBefore),
/* harmony export */   i0: () => (/* binding */ isCaretNode),
/* harmony export */   pE: () => (/* binding */ CARET_NODE_CHAR),
/* harmony export */   xP: () => (/* binding */ needsCaretNodeAfter)
/* harmony export */ });
/* harmony import */ var _parts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(887403);
/*
Copyright 2019 New Vector Ltd
Copyright 2019 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/


function needsCaretNodeBefore(part, prevPart) {
  const isFirst = !prevPart || prevPart.type === _parts__WEBPACK_IMPORTED_MODULE_0__/* .Type */ .Dy.Newline;
  return !part.canEdit && (isFirst || !prevPart.canEdit);
}
function needsCaretNodeAfter(part, isLastOfLine) {
  return !part.canEdit && isLastOfLine;
}
function insertAfter(node, nodeToInsert) {
  const next = node.nextSibling;
  if (next) {
    node.parentElement.insertBefore(nodeToInsert, next);
  } else {
    node.parentElement.appendChild(nodeToInsert);
  }
}

// Use a BOM marker for caret nodes.
// On a first test, they seem to be filtered out when copying text out of the editor,
// but this could be platform dependent.
// As a precautionary measure, I chose the character that slate also uses.
const CARET_NODE_CHAR = "\ufeff";
// a caret node is a node that allows the caret to be placed
// where otherwise it wouldn't be possible
// (e.g. next to a pill span without adjacent text node)
function createCaretNode() {
  const span = document.createElement("span");
  span.className = "caretNode";
  span.appendChild(document.createTextNode(CARET_NODE_CHAR));
  return span;
}
function updateCaretNode(node) {
  // ensure the caret node contains only a zero-width space
  if (node.textContent !== CARET_NODE_CHAR) {
    node.textContent = CARET_NODE_CHAR;
  }
}
function isCaretNode(node) {
  return node && node.tagName === "SPAN" && node.className === "caretNode";
}
function removeNextSiblings(node) {
  if (!node) {
    return;
  }
  node = node.nextSibling;
  while (node) {
    const removeNode = node;
    node = node.nextSibling;
    removeNode.remove();
  }
}
function removeChildren(parent) {
  const firstChild = parent.firstChild;
  if (firstChild) {
    removeNextSiblings(firstChild);
    firstChild.remove();
  }
}
function reconcileLine(lineContainer, parts) {
  let currentNode;
  let prevPart;
  const lastPart = parts[parts.length - 1];
  for (const part of parts) {
    const isFirst = !prevPart;
    currentNode = isFirst ? lineContainer.firstChild : currentNode.nextSibling;
    if (needsCaretNodeBefore(part, prevPart)) {
      if (isCaretNode(currentNode)) {
        updateCaretNode(currentNode);
        currentNode = currentNode.nextSibling;
      } else {
        lineContainer.insertBefore(createCaretNode(), currentNode);
      }
    }
    // remove nodes until matching current part
    while (currentNode && !part.canUpdateDOMNode(currentNode)) {
      const nextNode = currentNode.nextSibling;
      lineContainer.removeChild(currentNode);
      currentNode = nextNode;
    }
    // update or insert node for current part
    if (currentNode && part) {
      part.updateDOMNode(currentNode);
    } else if (part) {
      currentNode = part.toDOMNode();
      // hooks up nextSibling for next iteration
      lineContainer.appendChild(currentNode);
    }
    if (needsCaretNodeAfter(part, part === lastPart)) {
      if (isCaretNode(currentNode.nextSibling)) {
        currentNode = currentNode.nextSibling;
        updateCaretNode(currentNode);
      } else {
        const caretNode = createCaretNode();
        insertAfter(currentNode, caretNode);
        currentNode = caretNode;
      }
    }
    prevPart = part;
  }
  removeNextSiblings(currentNode);
}
function reconcileEmptyLine(lineContainer) {
  // empty div needs to have a BR in it to give it height
  let foundBR = false;
  let partNode = lineContainer.firstChild;
  while (partNode) {
    const nextNode = partNode.nextSibling;
    if (!foundBR && partNode.tagName === "BR") {
      foundBR = true;
    } else {
      partNode.remove();
    }
    partNode = nextNode;
  }
  if (!foundBR) {
    lineContainer.appendChild(document.createElement("br"));
  }
}
function renderModel(editor, model) {
  const lines = model.parts.reduce((linesArr, part) => {
    if (part.type === _parts__WEBPACK_IMPORTED_MODULE_0__/* .Type */ .Dy.Newline) {
      linesArr.push([]);
    } else {
      const lastLine = linesArr[linesArr.length - 1];
      lastLine.push(part);
    }
    return linesArr;
  }, [[]]);
  lines.forEach((parts, i) => {
    // find first (and remove anything else) div without className
    // (as browsers insert these in contenteditable) line container
    let lineContainer = editor.childNodes[i];
    while (lineContainer && (lineContainer.tagName !== "DIV" || !!lineContainer.className)) {
      editor.removeChild(lineContainer);
      lineContainer = editor.childNodes[i];
    }
    if (!lineContainer) {
      lineContainer = document.createElement("div");
      editor.appendChild(lineContainer);
    }
    if (parts.length) {
      reconcileLine(lineContainer, parts);
    } else {
      reconcileEmptyLine(lineContainer);
    }
  });
  if (lines.length) {
    removeNextSiblings(editor.children[lines.length - 1]);
  } else {
    removeChildren(editor);
  }
}

/***/ }),

/***/ 555461:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $9: () => (/* binding */ textSerialize),
/* harmony export */   I1: () => (/* binding */ stripPrefix),
/* harmony export */   Ny: () => (/* binding */ startsWith),
/* harmony export */   PI: () => (/* binding */ unescapeMessage),
/* harmony export */   Yi: () => (/* binding */ htmlSerializeIfNeeded),
/* harmony export */   b7: () => (/* binding */ stripEmoteCommand),
/* harmony export */   i$: () => (/* binding */ containsEmote)
/* harmony export */ });
/* unused harmony export mdSerialize */
/* harmony import */ var _Markdown__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(479376);
/* harmony import */ var _utils_permalinks_Permalinks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(954105);
/* harmony import */ var html_entities__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(235350);
/* harmony import */ var html_entities__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(html_entities__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _settings_SettingsStore__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(571879);
/* harmony import */ var _SdkConfig__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(374312);
/* harmony import */ var cheerio__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(77503);
/* harmony import */ var cheerio__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(cheerio__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _parts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(887403);
/* harmony import */ var _MatrixClientPeg__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(933393);
/*
Copyright 2019 New Vector Ltd
Copyright 2019, 2020 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/









function mdSerialize(model) {
  return model.parts.reduce((html, part) => {
    var _user;
    let user;
    let url;
    switch (part.type) {
      case _parts__WEBPACK_IMPORTED_MODULE_5__/* .Type */ .Dy.Newline:
        return html + "\n";
      case _parts__WEBPACK_IMPORTED_MODULE_5__/* .Type */ .Dy.Plain:
      case _parts__WEBPACK_IMPORTED_MODULE_5__/* .Type */ .Dy.Command:
      case _parts__WEBPACK_IMPORTED_MODULE_5__/* .Type */ .Dy.PillCandidate:
        return html + part.text;
      case _parts__WEBPACK_IMPORTED_MODULE_5__/* .Type */ .Dy.AtRoomPill:
        url = (0,_utils_permalinks_Permalinks__WEBPACK_IMPORTED_MODULE_1__/* .getPermalinkConstructor */ .bh)().forRoom(part.resourceId, []);
        return html + `[@room](${url})`;
      case _parts__WEBPACK_IMPORTED_MODULE_5__/* .Type */ .Dy.RoomPill:
        // Here we use the resourceId for compatibility with non-rich text clients
        // See https://github.com/vector-im/element-web/issues/16660
        return html + `[${part.resourceId.replace(/[[\\\]]/g, c => "\\" + c)}](${(0,_utils_permalinks_Permalinks__WEBPACK_IMPORTED_MODULE_1__/* .makeGenericPermalink */ .Mg)(part.resourceId)})`;
      case _parts__WEBPACK_IMPORTED_MODULE_5__/* .Type */ .Dy.UserPill:
        user = part && _MatrixClientPeg__WEBPACK_IMPORTED_MODULE_6__/* .MatrixClientPeg */ .p.get().getUser(part.resourceId);
        url = (0,_utils_permalinks_Permalinks__WEBPACK_IMPORTED_MODULE_1__/* .makeUserPermalink */ .KU)(part.resourceId);
        return html + `[${`@${(_user = user) === null || _user === void 0 ? void 0 : _user.rawDisplayName}`.replace(/[[\\\]]/g, c => "\\" + c)}](${url})`;
      case _parts__WEBPACK_IMPORTED_MODULE_5__/* .Type */ .Dy.TokenPill:
        return html + `[${part.text.replace(/[[\\\]]/g, c => "\\" + c)}](${(0,_utils_permalinks_Permalinks__WEBPACK_IMPORTED_MODULE_1__/* .makeTokenPermalink */ .XB)(part.resourceId)})`;
      case _parts__WEBPACK_IMPORTED_MODULE_5__/* .Type */ .Dy.TopicPill:
        return html + `[${part.text.replace(/[[\\\]]/g, c => "\\" + c)}](${(0,_utils_permalinks_Permalinks__WEBPACK_IMPORTED_MODULE_1__/* .makeTopicPermalink */ .cu)(part.resourceId)})`;
    }
  }, "");
}
function htmlSerializeIfNeeded(model, {
  forceHTML = false
} = {}) {
  let md = mdSerialize(model);
  // copy of raw input to remove unwanted math later
  const orig = md;
  if (_settings_SettingsStore__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .C.getValue("feature_latex_maths")) {
    const patternNames = ["tex", "latex"];
    const patternTypes = ["display", "inline"];
    const patternDefaults = {
      tex: {
        // detect math with tex delimiters, inline: $...$, display $$...$$
        // preferably use negative lookbehinds, not supported in all major browsers:
        // const displayPattern = "^(?<!\\\\)\\$\\$(?![ \\t])(([^$]|\\\\\\$)+?)\\$\\$$";
        // const inlinePattern = "(?:^|\\s)(?<!\\\\)\\$(?!\\s)(([^$]|\\\\\\$)+?)(?<!\\\\|\\s)\\$";

        // conditions for display math detection $$...$$:
        // - pattern starts and ends on a new line
        // - left delimiter ($$) is not escaped by backslash
        display: "(^)\\$\\$(([^$]|\\\\\\$)+?)\\$\\$$",
        // conditions for inline math detection $...$:
        // - pattern starts at beginning of line, follows whitespace character or punctuation
        // - pattern is on a single line
        // - left and right delimiters ($) are not escaped by backslashes
        // - left delimiter is not followed by whitespace character
        // - right delimiter is not prefixed with whitespace character
        inline: "(^|\\s|[.,!?:;])(?!\\\\)\\$(?!\\s)(([^$\\n]|\\\\\\$)*([^\\\\\\s\\$]|\\\\\\$)(?:\\\\\\$)?)\\$"
      },
      latex: {
        // detect math with latex delimiters, inline: \(...\), display \[...\]

        // conditions for display math detection \[...\]:
        // - pattern starts and ends on a new line
        // - pattern is not empty
        display: "(^)\\\\\\[(?!\\\\\\])(.*?)\\\\\\]$",
        // conditions for inline math detection \(...\):
        // - pattern starts at beginning of line or is not prefixed with backslash
        // - pattern is not empty
        inline: "(^|[^\\\\])\\\\\\((?!\\\\\\))(.*?)\\\\\\)"
      }
    };
    patternNames.forEach(function (patternName) {
      patternTypes.forEach(function (patternType) {
        // get the regex replace pattern from config or use the default
        const pattern = (((_SdkConfig__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z.get()["latex_maths_delims"] || {})[patternType] || {})["pattern"] || {})[patternName] || patternDefaults[patternName][patternType];
        md = md.replace(RegExp(pattern, "gms"), function (m, p1, p2) {
          const p2e = (0,html_entities__WEBPACK_IMPORTED_MODULE_7__.encode)(p2);
          switch (patternType) {
            case "display":
              return `${p1}<div data-mx-maths="${p2e}">\n\n</div>\n\n`;
            case "inline":
              return `${p1}<span data-mx-maths="${p2e}"></span>`;
          }
        });
      });
    });

    // make sure div tags always start on a new line, otherwise it will confuse
    // the markdown parser
    md = md.replace(/(.)<div/g, function (m, p1) {
      return `${p1}\n<div`;
    });
  }
  const parser = new _Markdown__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z(md);
  if (!parser.isPlainText() || forceHTML) {
    let parseHtml;
    // feed Markdown output to HTML parser
    const phtml = cheerio__WEBPACK_IMPORTED_MODULE_4___default().load(parser.toHTML(), {
      // @ts-ignore: The `_useHtmlParser2` internal option is the
      // simplest way to both parse and render using `htmlparser2`.
      _useHtmlParser2: true,
      decodeEntities: false
    });
    if (_settings_SettingsStore__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .C.getValue("feature_latex_maths")) {
      // original Markdown without LaTeX replacements
      const parserOrig = new _Markdown__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z(orig);
      const phtmlOrig = cheerio__WEBPACK_IMPORTED_MODULE_4___default().load(parserOrig.toHTML(), {
        // @ts-ignore: The `_useHtmlParser2` internal option is the
        // simplest way to both parse and render using `htmlparser2`.
        _useHtmlParser2: true,
        decodeEntities: false
      });

      // since maths delimiters are handled before Markdown,
      // code blocks could contain mangled content.
      // replace code blocks with original content
      phtmlOrig("code").each(function (i) {
        phtml("code").eq(i).text(phtmlOrig("code").eq(i).text());
      });

      // add fallback output for latex math, which should not be interpreted as markdown
      phtml("div, span").each(function (i, e) {
        const tex = phtml(e).attr("data-mx-maths");
        if (tex) {
          phtml(e).html(`<code>${tex}</code>`);
        }
      });
    }
    parseHtml = phtml.html();
    // parseHtml = parseHtml.replace(/<\/h[1-9]>\n/g, '<\/h[1-9]>'); 
    // parseHtml = parseHtml.replace(/<\/li>\n/g, '<\/li>'); 
    // parseHtml = parseHtml.replace(/<\/ul>\n/g, '<\/ul>'); 
    // parseHtml = parseHtml.replace(/<\/ol>\n/g, '<\/ol>'); 
    parseHtml = parseHtml.replace(/>\n/g, '>');
    return parseHtml;
  }
  // ensure removal of escape backslashes in non-Markdown messages
  if (md.indexOf("\\") > -1) {
    return parser.toPlaintext();
  }
}
function textSerialize(model) {
  return model.parts.reduce((text, part) => {
    switch (part.type) {
      case _parts__WEBPACK_IMPORTED_MODULE_5__/* .Type */ .Dy.Newline:
        return text + "\n";
      case _parts__WEBPACK_IMPORTED_MODULE_5__/* .Type */ .Dy.Plain:
      case _parts__WEBPACK_IMPORTED_MODULE_5__/* .Type */ .Dy.Command:
      case _parts__WEBPACK_IMPORTED_MODULE_5__/* .Type */ .Dy.PillCandidate:
      case _parts__WEBPACK_IMPORTED_MODULE_5__/* .Type */ .Dy.AtRoomPill:
        return text + part.text;
      case _parts__WEBPACK_IMPORTED_MODULE_5__/* .Type */ .Dy.RoomPill:
        // Here we use the resourceId for compatibility with non-rich text clients
        // See https://github.com/vector-im/element-web/issues/16660
        return text + `${part.resourceId}`;
      case _parts__WEBPACK_IMPORTED_MODULE_5__/* .Type */ .Dy.UserPill:
        return text + `@${part === null || part === void 0 ? void 0 : part.member.rawDisplayName}`;
      case _parts__WEBPACK_IMPORTED_MODULE_5__/* .Type */ .Dy.TokenPill:
      case _parts__WEBPACK_IMPORTED_MODULE_5__/* .Type */ .Dy.TopicPill:
        return text + `${part.text}`;
    }
  }, "");
}
function containsEmote(model) {
  return startsWith(model, "/me ", false);
}
function startsWith(model, prefix, caseSensitive = true) {
  const firstPart = model.parts[0];
  // part type will be "plain" while editing,
  // and "command" while composing a message.
  let text = firstPart && firstPart.text;
  if (!caseSensitive) {
    prefix = prefix.toLowerCase();
    text = text.toLowerCase();
  }
  return firstPart && (firstPart.type === _parts__WEBPACK_IMPORTED_MODULE_5__/* .Type */ .Dy.Plain || firstPart.type === _parts__WEBPACK_IMPORTED_MODULE_5__/* .Type */ .Dy.Command) && text.startsWith(prefix);
}
function stripEmoteCommand(model) {
  // trim "/me "
  return stripPrefix(model, "/me ");
}
function stripPrefix(model, prefix) {
  model = model.clone();
  model.removeText({
    index: 0,
    offset: 0
  }, prefix.length);
  return model;
}
function unescapeMessage(model) {
  const {
    parts
  } = model;
  if (parts.length) {
    const firstPart = parts[0];
    // only unescape \/ to / at start of editor
    if (firstPart.type === _parts__WEBPACK_IMPORTED_MODULE_5__/* .Type */ .Dy.Plain && firstPart.text.startsWith("\\/")) {
      model = model.clone();
      model.removeText({
        index: 0,
        offset: 0
      }, 1);
    }
  }
  return model;
}

/***/ }),

/***/ 132622:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   I: () => (/* binding */ add),
/* harmony export */   U: () => (/* binding */ get)
/* harmony export */ });
/* harmony import */ var _settings_SettingsStore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(571879);
/* harmony import */ var _settings_SettingLevel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(202385);
/* harmony import */ var sendingme_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(602271);



const SETTING_NAME = "collected_gifs";
const STORAGE_LIMIT = 50;

// TODO remove this after some time
function migrate() {
  const data = JSON.parse(window.localStorage.mx_reaction_count || "{}");
  const sorted = Object.entries(data).sort(([, [count1, date1]], [, [count2, date2]]) => date2 - date1);
  const newFormat = sorted.map(([emoji, [count, date]]) => [emoji, count]);
  SettingsStore.setValue(SETTING_NAME, null, SettingLevel.ACCOUNT, newFormat.slice(0, STORAGE_LIMIT));
}
function getCollectedGifs() {
  return _settings_SettingsStore__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .C.getValue(SETTING_NAME) || [];
}
function add(gif) {
  // clear data set
  // SettingsStore.setValue(SETTING_NAME, null, SettingLevel.ACCOUNT, []);
  // return []

  if (gif.url === "" || gif.url === undefined) {
    return;
  }
  const collections = getCollectedGifs();
  const i = collections.findIndex(c => {
    return c.url === gif.url;
  });
  if (i >= 0) {
    collections.splice(i, 1);
  } else {
    collections.unshift(gif);
  }
  if (collections.length > 50) {
    sendingme_ui__WEBPACK_IMPORTED_MODULE_2__.SdMessage.error("The maximum number has been reached");
    return;
  }
  _settings_SettingsStore__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .C.setValue(SETTING_NAME, null, _settings_SettingLevel__WEBPACK_IMPORTED_MODULE_1__/* .SettingLevel */ .R.ACCOUNT, collections.slice(0, STORAGE_LIMIT));
  return collections;
}
function get(limit = 50) {
  const collections = getCollectedGifs();
  return collections.slice(0, limit);
}

/***/ }),

/***/ 685070:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   JO: () => (/* binding */ useLeftPanelState),
/* harmony export */   L8: () => (/* binding */ useInboxNotificationState),
/* harmony export */   vt: () => (/* binding */ useSelected)
/* harmony export */ });
/* unused harmony export useSubSelected */
/* harmony import */ var _stores_LeftPanelStore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(290884);
/* harmony import */ var _useEventEmitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(457771);


const useSelected = () => (0,_useEventEmitter__WEBPACK_IMPORTED_MODULE_1__/* .useEventEmitterState */ .k)(_stores_LeftPanelStore__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .ZP.instance, _stores_LeftPanelStore__WEBPACK_IMPORTED_MODULE_0__/* .SELECTED_CHANGED */ .NM, () => {
  return _stores_LeftPanelStore__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .ZP.instance.getState().selected;
});

/**
 * observe typeof `SUB_SELECTED_CHANGED` event
 * @returns
 */
const useSubSelected = () => useEventEmitterState(LeftPanelStore.instance, SUB_SELECTED_CHANGED, () => {
  return LeftPanelStore.instance.getState().subSelected;
});
const useLeftPanelState = () => {
  const selected = useSelected();
  const state = (0,_useEventEmitter__WEBPACK_IMPORTED_MODULE_1__/* .useEventEmitterState */ .k)(_stores_LeftPanelStore__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .ZP.instance, _stores_LeftPanelStore__WEBPACK_IMPORTED_MODULE_0__/* .UI_STATE_CHANGED */ .rD, () => {
    return _stores_LeftPanelStore__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .ZP.instance.getState().uiStateForTab;
  });
  if (typeof selected !== "symbol" || !state[selected]) {
    return null;
  }
  console.log("useLeftPanelState", {
    state
  });
  return state[selected];
};
const useInboxNotificationState = () => {
  const state = (0,_useEventEmitter__WEBPACK_IMPORTED_MODULE_1__/* .useEventEmitterState */ .k)(_stores_LeftPanelStore__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .ZP.instance, _stores_LeftPanelStore__WEBPACK_IMPORTED_MODULE_0__/* .UI_STATE_CHANGED */ .rD, () => {
    return _stores_LeftPanelStore__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .ZP.instance.getState().uiStateForTab;
  });
  if (!(_stores_LeftPanelStore__WEBPACK_IMPORTED_MODULE_0__/* .INBOX_NOTIFICATION */ .mB in state)) {
    return null;
  }
  return state[_stores_LeftPanelStore__WEBPACK_IMPORTED_MODULE_0__/* .INBOX_NOTIFICATION */ .mB];
};

/***/ }),

/***/ 573266:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $: () => (/* binding */ useRoomMemberCount),
/* harmony export */   B: () => (/* binding */ useRoomMembers)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(667294);
/* harmony import */ var _useEventEmitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(457771);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(300111);
/*
Copyright 2020 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/





// Hook to simplify watching Matrix Room joined members
const useRoomMembers = (room, throttleWait = 250) => {
  const [members, setMembers] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(room.getJoinedMembers());
  (0,_useEventEmitter__WEBPACK_IMPORTED_MODULE_1__/* .useEventEmitter */ .x)(room.currentState, "RoomState.members", (0,lodash_es__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(() => {
    setMembers(room.getJoinedMembers());
  }, throttleWait, {
    leading: true,
    trailing: true
  }));
  return members;
};

// Hook to simplify watching Matrix Room joined member count
const useRoomMemberCount = (room, throttleWait = 250) => {
  const [count, setCount] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(room.getJoinedMemberCount());
  (0,_useEventEmitter__WEBPACK_IMPORTED_MODULE_1__/* .useEventEmitter */ .x)(room.currentState, "RoomState.members", () => {
    setCount(room.getJoinedMemberCount());
  });
  return count;
};

/***/ }),

/***/ 391952:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   d9: () => (/* binding */ useImage)
/* harmony export */ });
/* unused harmony exports ImageLoadStatus, useUserAvatar */
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(225259);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(667294);
/* harmony import */ var _useEffectOnce__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(794169);

function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }



let ImageLoadStatus = /*#__PURE__*/function (ImageLoadStatus) {
  ImageLoadStatus["LOAD_NOT_START"] = "notstart";
  ImageLoadStatus["LOAD_START"] = "start";
  ImageLoadStatus["LOAD_SUCCESS"] = "success";
  ImageLoadStatus["LOAD_ERROR"] = "error";
  return ImageLoadStatus;
}({});
const loadImg = (url, setState) => {
  return () => {
    const img = new Image();
    img.onload = () => {
      setState(url);
    };
    img.onerror = () => {
      setState("");
    };
    img.src = url;
  };
};
function useUserAvatar(url, userId) {
  const defAvatar = __webpack_require__(178327);
  const defSdnAvatar = getDefaultAvatar({
    id: userId
  });
  const [userAvatar, setUserAvatar] = useState();
  const [sdnAvatar, setSdnAvatar] = useState();
  const loadUserAvatar = loadImg(url, setUserAvatar);
  const loadSdnAvatar = loadImg(defSdnAvatar, setSdnAvatar);
  useEffectOnce(loadUserAvatar);
  useEffectOnce(loadSdnAvatar);
  return userAvatar || sdnAvatar || defAvatar;
}
const loadImgDis = (url, dispatch) => {
  return () => {
    const img = new Image();
    dispatch({
      type: ImageLoadStatus.LOAD_START
    });
    img.onload = () => {
      dispatch({
        type: ImageLoadStatus.LOAD_SUCCESS,
        url
      });
    };
    img.onerror = () => {
      dispatch({
        type: ImageLoadStatus.LOAD_ERROR,
        url: ""
      });
    };
    img.src = url;
  };
};
const initialState = {
  url: "",
  loading: false,
  status: ImageLoadStatus.LOAD_NOT_START
};
function reducer(state, action) {
  switch (action.type) {
    case ImageLoadStatus.LOAD_START:
      return _objectSpread(_objectSpread({}, state), {}, {
        url: "",
        loading: true,
        status: ImageLoadStatus.LOAD_START
      });
    case ImageLoadStatus.LOAD_SUCCESS:
      return _objectSpread(_objectSpread({}, state), {}, {
        url: action.url,
        loading: false,
        status: ImageLoadStatus.LOAD_SUCCESS
      });
    case ImageLoadStatus.LOAD_ERROR:
      return _objectSpread(_objectSpread({}, state), {}, {
        url: "",
        loading: false,
        status: ImageLoadStatus.LOAD_ERROR
      });
  }
}
function useImage(imgUrl, init) {
  const [state, dispatch] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useReducer)(reducer, _objectSpread(_objectSpread({}, initialState), init));
  (0,_useEffectOnce__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(loadImgDis(imgUrl, dispatch));
  return state || {};
}

/***/ }),

/***/ 426652:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Bx: () => (/* binding */ redirectUri),
/* harmony export */   Y_: () => (/* binding */ windowFeatures)
/* harmony export */ });
/* unused harmony export reqPrefix */
/* harmony import */ var _SdkConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(374312);

const reqPrefix = location.origin === "https://chat.sending.me" ? "https://chat.sending.me" : _SdkConfig__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z.get("permalinkPrefix") || "https://chat-alpha.sending.me";
const redirectUri = encodeURIComponent(`${reqPrefix}/third_auth`);
const windowFeatures = `left=${window.innerWidth / 2 - 580 / 2},top=100,width=580,innerWidth=580,innerHeight=800,height=${window.screen.height - 200},popup`;

/***/ }),

/***/ 182574:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   U: () => (/* binding */ openXAuthWindow)
/* harmony export */ });
/* harmony import */ var _SdkConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(374312);
/* harmony import */ var _popupWinConf__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(426652);


const DEF_X_CLIENT_ID = "bVl5ZTZmZ0s0VHh2MFQtbWRqX0I6MTpjaQ";
const openXAuthWindow = (state = "twitter") => {
  var _SdkConfig$get;
  const clientId = ((_SdkConfig$get = _SdkConfig__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z.get("thirdKeys")) === null || _SdkConfig$get === void 0 ? void 0 : _SdkConfig$get.twitterClientId) || DEF_X_CLIENT_ID;
  const searchParams = new URLSearchParams({
    response_type: "code",
    client_id: clientId,
    code_challenge: "challenge",
    code_challenge_method: "plain",
    state: state
  });
  const scope = ["tweet.read", "tweet.write", "users.read", "follows.write", "follows.read", "offline.access"].join(" ");
  const queryString = [`redirect_uri=${_popupWinConf__WEBPACK_IMPORTED_MODULE_1__/* .redirectUri */ .Bx}`, `scope=${encodeURIComponent(scope)}`, searchParams.toString()].join("&");
  window.open(`https://twitter.com/i/oauth2/authorize?${queryString}`, "SendingMeAuthWin", _popupWinConf__WEBPACK_IMPORTED_MODULE_1__/* .windowFeatures */ .Y_);
};

/***/ }),

/***/ 424758:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ZP: () => (/* binding */ CreateExternalGroupStore),
/* harmony export */   cT: () => (/* binding */ CreateExternalGroupStoreAction)
/* harmony export */ });
/* unused harmony export CreateExternalGroupStoreClass */
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(225259);
/* harmony import */ var _dispatcher_dispatcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(245539);
/* harmony import */ var _AsyncStoreWithClient__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(555371);



const INIT_STATE = {
  members: []
};
let CreateExternalGroupStoreAction = /*#__PURE__*/function (CreateExternalGroupStoreAction) {
  CreateExternalGroupStoreAction["UpdateSelectedMembers"] = "UpdateSelectedMembers";
  CreateExternalGroupStoreAction["CreateExternalGroupStoreUpdateUIState"] = "CreateExternalGroupStoreUpdateUIState";
  return CreateExternalGroupStoreAction;
}({});
class CreateExternalGroupStoreClass extends _AsyncStoreWithClient__WEBPACK_IMPORTED_MODULE_1__/* .AsyncStoreWithClient */ ._ {
  constructor() {
    super(_dispatcher_dispatcher__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .ZP, INIT_STATE);
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(this, "members", void 0);
    this.members = [];
  }
  async onAction(payload) {
    switch (payload.action) {
      case CreateExternalGroupStoreAction.UpdateSelectedMembers:
        {
          this.members = payload.params;
          this.updateState({
            members: payload.params
          });
          this.emit(CreateExternalGroupStoreAction.CreateExternalGroupStoreUpdateUIState, this.members);
        }
        break;
      default:
        break;
    }
  }
  getState() {
    return this.state;
  }
}
class CreateExternalGroupStore {
  static get instance() {
    return CreateExternalGroupStore.internalInstance;
  }
}
(0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(CreateExternalGroupStore, "internalInstance", new CreateExternalGroupStoreClass());
window.mxCreateExternalGroupStore = CreateExternalGroupStore.instance;

/***/ }),

/***/ 512892:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (/* binding */ ExploreStore)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(225259);
/* harmony import */ var _MatrixClientPeg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(933393);
/* harmony import */ var _customisations_Media__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(834208);
/* harmony import */ var _lib_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(877294);
/* harmony import */ var _utils_avatar__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(9266);

var _class;
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }




const LIMIT = 20;
class ExploreStore {
  constructor() {
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this, "_squads", void 0);
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this, "page", void 0);
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this, "total", void 0);
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this, "loading", void 0);
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this, "client", void 0);
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this, "listRefresh", void 0);
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this, "fetchSquads", async ({
      clear,
      query,
      size = 0
    }) => {
      if (this.loading && size) {
        return;
      }
      if (!size && !clear && this.page !== 0 && this.total <= this.page * LIMIT) {
        return {
          data: null
        };
      }
      if (clear) {
        this._squads = [];
        this.page = 0;
        this.total = 0;
      }
      this.loading = true;
      return this.client.getSquadExplore({
        limit: LIMIT,
        offset: this.page * LIMIT,
        from_sdn: _lib_constants__WEBPACK_IMPORTED_MODULE_3__/* .IS_SDN */ ._0
      }).then(res => {
        this._squads = [...this._squads, ...res.squads.map(item => {
          return ExploreStore.resolveItem(item, this.client);
        })];
        this.page++;
        this.total = res.total;
        return {
          data: this._squads,
          total: this.total
        };
      }).finally(() => {
        this.loading = false;
      });
    });
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this, "getLoading", () => {
      return this.loading;
    });
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this, "getSquads", () => {
      return ExploreStore.instance.squads;
    });
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this, "fetchSquadDetail", async id => {
      if (_lib_constants__WEBPACK_IMPORTED_MODULE_3__/* .IS_SDN */ ._0) {
        return this.client.getSdnSquadInfo$$(id).then(v => {
          let avatar = this.formatAccessTokeUrl(v.avatar);
          let background = this.formatAccessTokeUrl(v.background);
          let item = {
            avatar,
            name: v.name,
            id: v.room_id,
            alias: v.canonical_alias,
            auth: v.join_rules,
            // v.public ? "Public" : "Private",
            member: v.joined_members,
            desc: v.topic,
            bg: background,
            members: v.members,
            joinRules: v.join_rules,
            joinAdvance: v.join_advance,
            joinParams: v.join_params,
            isOfficial: v.is_official
          };
          item = ExploreStore.resolveItem(item, this.client);
          this.refresh(item);
          return item;
        });
      }
      return this.client.getRoomDetail(id).then(res => {
        const item = ExploreStore.resolveItem(res, this.client);
        this.refresh(item);
        return item;
      });
    });
    this.page = 0;
    this.total = 0;
    this.loading = false;
    this._squads = [];
    const {
      userId,
      accessToken
    } = JSON.parse(localStorage.getItem("mx_Homeserver_Creds") || "{}");
    this.client = _MatrixClientPeg__WEBPACK_IMPORTED_MODULE_1__/* .MatrixClientPeg */ .p.get();
  }
  static get instance() {
    if (!ExploreStore.exploreStore) {
      ExploreStore.exploreStore = new ExploreStore();
    }
    return ExploreStore.exploreStore;
  }
  formatAccessTokeUrl(url) {
    try {
      if (url) {
        const _url = new URL(url);
        _url.searchParams.set("access_token", _MatrixClientPeg__WEBPACK_IMPORTED_MODULE_1__/* .MatrixClientPeg */ .p.getCredentials().homeserverCreds.accessToken);
        return _url.toString();
      }
    } catch (error) {
      console.log("url paras error", url);
      return "";
    }
  }
  set squads(squads) {
    this._squads = squads;
  }
  get squads() {
    return this._squads;
  }
  refresh(res) {
    const index = this._squads.findIndex(item => item.id === res.id);
    this._squads[index] = res;
    this.listRefresh && this.listRefresh();
  }
  setListRefresh(listRefresh) {
    this.listRefresh = listRefresh;
  }
}
_class = ExploreStore;
(0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(ExploreStore, "exploreStore", void 0);
(0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(ExploreStore, "resolveItem", (item, client) => {
  var _item$space, _item$space3;
  if (item.bg) {
    // if (item.bg.startsWith("mxc://")) {
    //     item.bg = mediaFromMxc(item.bg, client).srcHttp;
    // } else if (!item.bg.includes("width=")) {
    //     item.bg += "&width=300&height=136";
    // }
    item.bg = (0,_customisations_Media__WEBPACK_IMPORTED_MODULE_2__/* .mediaFromMxc */ .TS)(item.bg, client).srcHttp;
  }
  if ((_item$space = item.space) !== null && _item$space !== void 0 && _item$space.background) {
    var _item$space2;
    // if (item.space?.background.startsWith("mxc://")) {
    //     item.space.background = mediaFromMxc(
    //         item.space?.background,
    //         client
    //     ).srcHttp;
    // } else if (!item.space?.background.includes("width=")) {
    //     item.space.background += "&width=300&height=136";
    // }
    item.space.background = (0,_customisations_Media__WEBPACK_IMPORTED_MODULE_2__/* .mediaFromMxc */ .TS)((_item$space2 = item.space) === null || _item$space2 === void 0 ? void 0 : _item$space2.background, client).srcHttp;
  }
  if ((_item$space3 = item.space) !== null && _item$space3 !== void 0 && _item$space3.avatar) {
    // if (item.space?.avatar.startsWith("mxc://")) {
    //     item.space.avatar = mediaFromMxc(item.space.avatar).srcHttp;
    // }
    item.space.avatar = (0,_customisations_Media__WEBPACK_IMPORTED_MODULE_2__/* .mediaFromMxc */ .TS)(item.space.avatar).srcHttp;
  }
  if (item.avatar) {
    // if (item.avatar.startsWith("mxc://")) {
    //     item.avatar = mediaFromMxc(item.avatar, client).srcHttp;
    // }
    item.avatar = (0,_customisations_Media__WEBPACK_IMPORTED_MODULE_2__/* .mediaFromMxc */ .TS)(item.avatar, client).srcHttp;
    // delete item.members;
    return item;
  }
  if (item.members) {
    const urls = item.members.map(cItem => {
      if (cItem.avatar_url_server && !cItem.avatar_url_server.includes("width=")) {
        cItem.avatar_url_server += "&width=120&height=120";
      }
      return {
        url: cItem.avatar_url_server || (0,_utils_avatar__WEBPACK_IMPORTED_MODULE_4__/* .getDefaultAvatar */ .W)({
          id: cItem.user_id
        }),
        name: ""
      };
      // const [imageUrl, setImageUrl] = useState(`${avatarUrl}/beam/70/${displayName}?square=true`);
    });

    if (urls.length === 1) {
      item.avatar = urls[0].url;
      // delete item.members;
      return item;
    }
    // delete item.members;
    return _objectSpread(_objectSpread({}, item), {}, {
      urls
    });
  }
  return item;
});

/***/ }),

/***/ 456564:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* unused harmony export PARTNER_UPDATE */
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(225259);
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(717187);
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(479697);
/* harmony import */ var _MatrixClientPeg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(933393);
/* harmony import */ var _components_structures_space_home_DappButtons__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(249135);

var _class;




const PARTNER_UPDATE = "partner_update";
class PartnerStore extends (events__WEBPACK_IMPORTED_MODULE_0___default()) {
  constructor() {
    super();
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(this, "_partners", void 0);
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(this, "task", void 0);
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(this, "fetchPartners", async () => {
      try {
        this.task = this.task || _MatrixClientPeg__WEBPACK_IMPORTED_MODULE_1__/* .MatrixClientPeg */ .p.get().getDapps("web", _components_structures_space_home_DappButtons__WEBPACK_IMPORTED_MODULE_2__/* .DisplayPosition */ .n.DISCOVER);
        return (await this.task).map(p => {
          return {
            name: p.app_name,
            url: p.app_url,
            avatar: p.app_logo
          };
        });
      } catch (error) {
        console.error(error);
        return [];
      }
    });
  }
  async getPartners(refresh) {
    if (refresh || (0,lodash_es__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this._partners)) {
      this._partners = await this.fetchPartners();
    }
    return this._partners;
  }
  get partners() {
    return this._partners;
  }
  static get instance() {
    if (!PartnerStore.internalInstance) {
      PartnerStore.internalInstance = new PartnerStore();
    }
    return PartnerStore.internalInstance;
  }
}
_class = PartnerStore;
(0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(PartnerStore, "internalInstance", void 0);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PartnerStore);

/***/ }),

/***/ 233685:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Xq: () => (/* binding */ SquadWidgetStoreAction),
/* harmony export */   ZP: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* unused harmony export LinkWalletListUpdated */
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(225259);
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(717187);
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _MatrixClientPeg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(933393);
/* harmony import */ var _Lifecycle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(729017);

var _class;



const LinkWalletListUpdated = "LinkWalletListUpdated";
let SquadWidgetStoreAction = /*#__PURE__*/function (SquadWidgetStoreAction) {
  SquadWidgetStoreAction["updateSquadWidgetHooksState"] = "updateSquadWidgetHooksState";
  return SquadWidgetStoreAction;
}({});
class SquadWidgetStore extends (events__WEBPACK_IMPORTED_MODULE_0___default()) {
  constructor() {
    super();
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(this, "squadWidgetConfigMap", new Map());
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(this, "generalWidgetList", void 0);
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(this, "loading", void 0);
    // refesh 
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(this, "refreshWidget", async () => {
      this.updateProtectionState();
    });
    // Full squad widget data
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(this, "getGeneralWidgetList", async () => {
      if (this.generalWidgetList) {
        return this.generalWidgetList;
      }
      const client = _MatrixClientPeg__WEBPACK_IMPORTED_MODULE_1__/* .MatrixClientPeg */ .p.get();
      const res = await client.getSquadGeneralConfig();
      this.generalWidgetList = Array.isArray(res) ? res : [];
      return this.generalWidgetList;
    });
    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(this, "updateProtectionState", () => {
      this.emit(SquadWidgetStoreAction.updateSquadWidgetHooksState, {
        generalWidgetList: SquadWidgetStore.instance.generalWidgetList,
        squadWidgetConfigMap: SquadWidgetStore.instance.squadWidgetConfigMap
      });
    });
  }
  static get instance() {
    if (!SquadWidgetStore.internalInstance) {
      SquadWidgetStore.internalInstance = new SquadWidgetStore();
    }
    return SquadWidgetStore.internalInstance;
  }
  // Get the widget sorting information configured under the current squad
  async getWidgetConfigListBySquadId(id, refesh) {
    var _res$data;
    if (!refesh && this.squadWidgetConfigMap.get(id)) {
      return this.squadWidgetConfigMap.get(id);
    }
    const client = _MatrixClientPeg__WEBPACK_IMPORTED_MODULE_1__/* .MatrixClientPeg */ .p.get();
    const res = await client.getSquadWidgetConfig(id);
    const widgetJson = (res === null || res === void 0 ? void 0 : (_res$data = res.data) === null || _res$data === void 0 ? void 0 : _res$data.widget_json) || [];
    this.squadWidgetConfigMap.set(id, widgetJson);
    return widgetJson;
  }

  // Save weiget sorting information
  async saveWidgetConfigList(squadId, data) {
    const client = _MatrixClientPeg__WEBPACK_IMPORTED_MODULE_1__/* .MatrixClientPeg */ .p.get();
    const networkNode = (0,_Lifecycle__WEBPACK_IMPORTED_MODULE_2__/* .getUserNetworkNode */ .JI)(_MatrixClientPeg__WEBPACK_IMPORTED_MODULE_1__/* .MatrixClientPeg */ .p.get().getUserId());
    const credentials = _MatrixClientPeg__WEBPACK_IMPORTED_MODULE_1__/* .MatrixClientPeg */ .p.getCredentials();
    const sdnToken = credentials.accessToken;
    const sdnUrl = credentials.homeserverUrl || networkNode.endpoint;
    const config = {
      widget_json: data,
      sdn_url: sdnUrl,
      sdn_token: sdnToken
    };
    await client.changeSquadWidgetConfig(squadId, config);
    await this.getWidgetConfigListBySquadId(squadId, true);
    this.updateProtectionState();
  }
  getState() {
    return {
      generalWidgetList: SquadWidgetStore.instance.generalWidgetList,
      squadWidgetConfigMap: SquadWidgetStore.instance.squadWidgetConfigMap
    };
  }
}
_class = SquadWidgetStore;
(0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(SquadWidgetStore, "internalInstance", void 0);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SquadWidgetStore);
const mockSortList = [{
  "code": "EVENTS",
  "name": "Events",
  "show": true
}, {
  "code": "QUESTS",
  "name": "Quests",
  "show": true
}, {
  "code": "Mentions message",
  "name": "Mentions message",
  "show": false
}];
const mockFullWidgetList = [{
  "code": "EVENTS",
  "name": "Events",
  "show": true
}, {
  "code": "QUESTS",
  "name": "Quests",
  "show": true
}, {
  "code": "Mentions message",
  "name": "Mentions message",
  "show": true
}, {
  "code": "NFT GO",
  "name": "NFT GO",
  "show": false
}, {
  "code": "Popular Tokens",
  "name": "Popular Tokens",
  "show": false
}];

/***/ }),

/***/ 336876:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   U: () => (/* binding */ upgradeRoom)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(225259);
/* harmony import */ var matrix_js_sdk_src_types_event__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(907977);
/* harmony import */ var _RoomInvite__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(106579);
/* harmony import */ var _Modal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(241648);
/* harmony import */ var _languageHandler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(867614);
/* harmony import */ var _components_views_dialogs_ErrorDialog__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(705636);
/* harmony import */ var _stores_SpaceStore__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(387579);
/* harmony import */ var _components_views_elements_Spinner__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(641542);

function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
/*
Copyright 2021 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/








async function upgradeRoom(room, targetVersion, inviteUsers = false, handleError = true, updateSpaces = true, awaitRoom = false) {
  const cli = room.client;
  const spinnerModal = _Modal__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z.createDialog(_components_views_elements_Spinner__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z, null, "mx_Dialog_spinner");
  let newRoomId;
  try {
    ({
      replacement_room: newRoomId
    } = await cli.upgradeRoom(room.roomId, targetVersion));
  } catch (e) {
    if (!handleError) throw e;
    console.error(e);
    _Modal__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z.createTrackedDialog("Room Upgrade Error", "", _components_views_dialogs_ErrorDialog__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z, {
      title: (0,_languageHandler__WEBPACK_IMPORTED_MODULE_4__._t)('Error upgrading room'),
      description: (0,_languageHandler__WEBPACK_IMPORTED_MODULE_4__._t)('Double check that your server supports the room version chosen and try again.')
    });
    throw e;
  }
  if (awaitRoom || inviteUsers) {
    await new Promise(resolve => {
      // already have the room
      if (room.client.getRoom(newRoomId)) {
        resolve();
        return;
      }

      // We have to wait for the js-sdk to give us the room back so
      // we can more effectively abuse the MultiInviter behaviour
      // which heavily relies on the Room object being available.
      const checkForRoomFn = newRoom => {
        if (newRoom.roomId !== newRoomId) return;
        resolve();
        cli.off("Room", checkForRoomFn);
      };
      cli.on("Room", checkForRoomFn);
    });
  }
  if (inviteUsers) {
    const toInvite = [...room.getMembersWithMembership("join"), ...room.getMembersWithMembership("invite")].map(m => m.userId).filter(m => m !== cli.getUserId());
    if (toInvite.length > 0) {
      // Errors are handled internally to this function
      await (0,_RoomInvite__WEBPACK_IMPORTED_MODULE_2__/* .inviteUsersToRoom */ .Ix)(newRoomId, toInvite);
    }
  }
  if (updateSpaces) {
    const parents = _stores_SpaceStore__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .ZP.instance.getKnownParents(room.roomId);
    try {
      for (const parentId of parents) {
        const parent = cli.getRoom(parentId);
        if (!(parent !== null && parent !== void 0 && parent.currentState.maySendStateEvent(matrix_js_sdk_src_types_event__WEBPACK_IMPORTED_MODULE_1__/* .EventType */ .tw.SpaceChild, cli.getUserId()))) continue;
        const currentEv = parent.currentState.getStateEvents(matrix_js_sdk_src_types_event__WEBPACK_IMPORTED_MODULE_1__/* .EventType */ .tw.SpaceChild, room.roomId);
        await cli.sendStateEvent(parentId, matrix_js_sdk_src_types_event__WEBPACK_IMPORTED_MODULE_1__/* .EventType */ .tw.SpaceChild, _objectSpread(_objectSpread({}, (currentEv === null || currentEv === void 0 ? void 0 : currentEv.getContent()) || {}), {}, {
          // copy existing attributes like suggested
          via: [cli.getDomain()]
        }), newRoomId);
        await cli.sendStateEvent(parentId, matrix_js_sdk_src_types_event__WEBPACK_IMPORTED_MODULE_1__/* .EventType */ .tw.SpaceChild, {}, room.roomId);
      }
    } catch (e) {
      // These errors are not critical to the room upgrade itself
      console.warn("Failed to update parent squads during room upgrade", e);
    }
  }
  spinnerModal.close();
  return newRoomId;
}

/***/ }),

/***/ 369012:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $K: () => (/* binding */ getProtectionManagePermission),
/* harmony export */   No: () => (/* binding */ getHostLivePermission)
/* harmony export */ });
/* unused harmony export isHasPermissionInSpaceRoom */
/* harmony import */ var matrix_js_sdk_src_types_event__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(907977);
/* harmony import */ var _MatrixClientPeg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(933393);
/* harmony import */ var _stores_PermissionStore__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(825291);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(216423);




const checkIsOwnerOrAdminInGroup = roomId => {
  const client = _MatrixClientPeg__WEBPACK_IMPORTED_MODULE_1__/* .MatrixClientPeg */ .p.get();
  if (!client) {
    return false;
  }
  const room = client.getRoom(roomId);
  if (!room) {
    return false;
  }
  const powerLevel = room.currentState.getStateEvents(matrix_js_sdk_src_types_event__WEBPACK_IMPORTED_MODULE_0__/* .EventType */ .tw.RoomPowerLevels, "");
  const powerLevels = powerLevel === null || powerLevel === void 0 ? void 0 : powerLevel.getContent();
  const {
    role_bindings
  } = powerLevels || {};
  const isOwner = (0,lodash_es__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(role_bindings, "Owner", []).some(userId => userId === client.getUserId());
  const isAdmin = (0,lodash_es__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(role_bindings, "SA", []).some(userId => userId === client.getUserId());
  return isOwner || isAdmin;
};

/**
 *
 * must offer a space room
 *
 * or u would always get a `false`
 *
 * @param roomId
 * @param permissions
 * @returns
 */
const isHasPermissionInSpaceRoom = (roomId, permissions) => {
  const client = _MatrixClientPeg__WEBPACK_IMPORTED_MODULE_1__/* .MatrixClientPeg */ .p.get();
  if (!client) {
    return false;
  }
  const room = client.getRoom(roomId);
  if (!room) {
    return false;
  }
  if (room.hasSpaceParent()) {
    // channel
    const result = _stores_PermissionStore__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .ZP.hasPermission(roomId, permissions);
    if (!Array.isArray(result)) {
      return false;
    }
    if (result.length === 0) {
      return false;
    }
    return result.every(item => Boolean(item));
  }
  return false;
};
const getProtectionManagePermission = ({
  roomId
}) => {
  const client = _MatrixClientPeg__WEBPACK_IMPORTED_MODULE_1__/* .MatrixClientPeg */ .p.get();
  if (!client) {
    return false;
  }
  const room = client.getRoom(roomId);
  if (!room) {
    return false;
  }
  if (room.hasSpaceParent()) {
    const result = isHasPermissionInSpaceRoom(roomId, [_stores_PermissionStore__WEBPACK_IMPORTED_MODULE_2__/* .PermissionMap */ .$W.ManageSquad, _stores_PermissionStore__WEBPACK_IMPORTED_MODULE_2__/* .PermissionMap */ .$W.SquadManageRoom]);
    return result;
  }
  const isOwnerOrAdmin = checkIsOwnerOrAdminInGroup(roomId);
  return isOwnerOrAdmin;
};
const getHostLivePermission = ({
  roomId
}) => {
  const client = _MatrixClientPeg__WEBPACK_IMPORTED_MODULE_1__/* .MatrixClientPeg */ .p.get();
  if (!client) {
    return false;
  }
  const room = client.getRoom(roomId);
  if (!room) {
    return false;
  }
  if (room.hasSpaceParent()) {
    const result = isHasPermissionInSpaceRoom(roomId, [_stores_PermissionStore__WEBPACK_IMPORTED_MODULE_2__/* .PermissionMap */ .$W.SpaceManageHostLiveState]);
    return result;
  }
  const isOwnerOrAdmin = checkIsOwnerOrAdminInGroup(roomId);
  return isOwnerOrAdmin;
};

/***/ }),

/***/ 44125:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var invariant = _interopDefault(__webpack_require__(426018));

var getRect = function getRect(_ref) {
  var top = _ref.top,
      right = _ref.right,
      bottom = _ref.bottom,
      left = _ref.left;
  var width = right - left;
  var height = bottom - top;
  var rect = {
    top: top,
    right: right,
    bottom: bottom,
    left: left,
    width: width,
    height: height,
    x: left,
    y: top,
    center: {
      x: (right + left) / 2,
      y: (bottom + top) / 2
    }
  };
  return rect;
};
var expand = function expand(target, expandBy) {
  return {
    top: target.top - expandBy.top,
    left: target.left - expandBy.left,
    bottom: target.bottom + expandBy.bottom,
    right: target.right + expandBy.right
  };
};
var shrink = function shrink(target, shrinkBy) {
  return {
    top: target.top + shrinkBy.top,
    left: target.left + shrinkBy.left,
    bottom: target.bottom - shrinkBy.bottom,
    right: target.right - shrinkBy.right
  };
};

var shift = function shift(target, shiftBy) {
  return {
    top: target.top + shiftBy.y,
    left: target.left + shiftBy.x,
    bottom: target.bottom + shiftBy.y,
    right: target.right + shiftBy.x
  };
};

var noSpacing = {
  top: 0,
  right: 0,
  bottom: 0,
  left: 0
};
var createBox = function createBox(_ref2) {
  var borderBox = _ref2.borderBox,
      _ref2$margin = _ref2.margin,
      margin = _ref2$margin === void 0 ? noSpacing : _ref2$margin,
      _ref2$border = _ref2.border,
      border = _ref2$border === void 0 ? noSpacing : _ref2$border,
      _ref2$padding = _ref2.padding,
      padding = _ref2$padding === void 0 ? noSpacing : _ref2$padding;
  var marginBox = getRect(expand(borderBox, margin));
  var paddingBox = getRect(shrink(borderBox, border));
  var contentBox = getRect(shrink(paddingBox, padding));
  return {
    marginBox: marginBox,
    borderBox: getRect(borderBox),
    paddingBox: paddingBox,
    contentBox: contentBox,
    margin: margin,
    border: border,
    padding: padding
  };
};

var parse = function parse(raw) {
  var value = raw.slice(0, -2);
  var suffix = raw.slice(-2);

  if (suffix !== 'px') {
    return 0;
  }

  var result = Number(value);
  !!isNaN(result) ?  false ? 0 : invariant(false) : void 0;
  return result;
};

var getWindowScroll = function getWindowScroll() {
  return {
    x: window.pageXOffset,
    y: window.pageYOffset
  };
};

var offset = function offset(original, change) {
  var borderBox = original.borderBox,
      border = original.border,
      margin = original.margin,
      padding = original.padding;
  var shifted = shift(borderBox, change);
  return createBox({
    borderBox: shifted,
    border: border,
    margin: margin,
    padding: padding
  });
};
var withScroll = function withScroll(original, scroll) {
  if (scroll === void 0) {
    scroll = getWindowScroll();
  }

  return offset(original, scroll);
};
var calculateBox = function calculateBox(borderBox, styles) {
  var margin = {
    top: parse(styles.marginTop),
    right: parse(styles.marginRight),
    bottom: parse(styles.marginBottom),
    left: parse(styles.marginLeft)
  };
  var padding = {
    top: parse(styles.paddingTop),
    right: parse(styles.paddingRight),
    bottom: parse(styles.paddingBottom),
    left: parse(styles.paddingLeft)
  };
  var border = {
    top: parse(styles.borderTopWidth),
    right: parse(styles.borderRightWidth),
    bottom: parse(styles.borderBottomWidth),
    left: parse(styles.borderLeftWidth)
  };
  return createBox({
    borderBox: borderBox,
    margin: margin,
    padding: padding,
    border: border
  });
};
var getBox = function getBox(el) {
  var borderBox = el.getBoundingClientRect();
  var styles = window.getComputedStyle(el);
  return calculateBox(borderBox, styles);
};

exports.calculateBox = calculateBox;
exports.createBox = createBox;
exports.expand = expand;
exports.getBox = getBox;
exports.getRect = getRect;
exports.offset = offset;
exports.shrink = shrink;
exports.withScroll = withScroll;


/***/ }),

/***/ 615619:
/***/ ((module) => {

module.exports = /[:=](?:\'(?:\-[\(\)DO\[\]o\{\}]|[\(\)DO\[\]o\{\}])|\{>|\-[#\$&\(-\*\/3<>-@B-EJLOPSXZ-\]cjlopsxz-\}]|[#\$&\(-\*\/3<>-@B-EJLOPSXZ-\]cjlopsxz\|\}])|[Oo][:=](?:\-[\)\]\}]|[\)\]\}])|>(?:[:=](?:\-[\(\)\/\[-\]\{\}]|[\(\)\/\[-\]\{\}])|0(?:\-[\)\]\}]|[\)\]\}]))|%(?:\-[\(\[\{]|[\(\[\{])|\\[Mm]\/|D(?:\-[:=Xx]|[:=Xx])|8(?:\-[#\)D\]\}]|[#\)D\]\}])|;(?:\-[\)P\]p\}]|[\)P\]p\}])|x(?:\-[\(D\[op\{]|[\(D\[op\{])|X(?:\-[\(DOP\[\{]|[\(DOP\[\{])|<\/?3|[:=]\{/;


/***/ }),

/***/ 112092:
/***/ ((module) => {

module.exports = "img/avatar_border.90c1c9e.png";

/***/ }),

/***/ 531497:
/***/ ((module) => {

module.exports = "img/cancel.4b9715b.svg";

/***/ }),

/***/ 466451:
/***/ ((module) => {

module.exports = "img/element-icons/activity-default.7e06f90.svg";

/***/ }),

/***/ 311317:
/***/ ((module) => {

module.exports = "img/element-icons/activity-share.511e2a5.png";

/***/ }),

/***/ 107467:
/***/ ((module) => {

module.exports = "img/element-icons/brands/ens.4d995d2.svg";

/***/ }),

/***/ 317523:
/***/ ((module) => {

module.exports = "img/element-icons/default-user.63dec0f.png";

/***/ }),

/***/ 533769:
/***/ ((module) => {

module.exports = "img/element-icons/message/file-message-icon.a8b0724.png";

/***/ }),

/***/ 996344:
/***/ ((module) => {

module.exports = "img/element-icons/room/live.c9ab4ec.gif";

/***/ }),

/***/ 211856:
/***/ ((module) => {

module.exports = "img/empty-cover/empty-data.49bd7b1.svg";

/***/ }),

/***/ 705947:
/***/ ((module) => {

module.exports = "img/event_summary_card.28d41ec.png";

/***/ }),

/***/ 570560:
/***/ ((module) => {

module.exports = "img/explore/exchange.1fcd49a.svg";

/***/ }),

/***/ 833250:
/***/ ((module) => {

module.exports = "img/explore/gray_nft.5e02273.png";

/***/ }),

/***/ 596395:
/***/ ((module) => {

module.exports = "img/explore/gray_vector.c908a99.png";

/***/ }),

/***/ 792540:
/***/ ((module) => {

module.exports = "img/icon-qualified.da2765a.svg";

/***/ }),

/***/ 530725:
/***/ ((module) => {

module.exports = "img/icons/clock.b37da8e.svg";

/***/ }),

/***/ 298121:
/***/ ((module) => {

module.exports = "img/icons/loudly-crying-face.06bc94e.png";

/***/ }),

/***/ 595448:
/***/ ((module) => {

module.exports = "img/icons/persevering-face.f723d65.png";

/***/ }),

/***/ 816996:
/***/ ((module) => {

module.exports = "img/icons/upside-down-face.18d73de.png";

/***/ }),

/***/ 661407:
/***/ ((module) => {

module.exports = "img/inviteGroupBg.4fad51e.png";

/***/ }),

/***/ 393988:
/***/ ((module) => {

module.exports = "img/points.97bcd13.svg";

/***/ }),

/***/ 295740:
/***/ ((module) => {

module.exports = "img/rocket.752cdb9.svg";

/***/ }),

/***/ 553090:
/***/ ((module) => {

module.exports = "img/room_replaced.80042bb.svg";

/***/ }),

/***/ 848168:
/***/ ((module) => {

module.exports = "img/stickers-picker/add.d85ef79.svg";

/***/ }),

/***/ 108679:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var reactIs = __webpack_require__(659864);

/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
var REACT_STATICS = {
  childContextTypes: true,
  contextType: true,
  contextTypes: true,
  defaultProps: true,
  displayName: true,
  getDefaultProps: true,
  getDerivedStateFromError: true,
  getDerivedStateFromProps: true,
  mixins: true,
  propTypes: true,
  type: true
};
var KNOWN_STATICS = {
  name: true,
  length: true,
  prototype: true,
  caller: true,
  callee: true,
  arguments: true,
  arity: true
};
var FORWARD_REF_STATICS = {
  '$$typeof': true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  '$$typeof': true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;

function getStatics(component) {
  // React v16.11 and below
  if (reactIs.isMemo(component)) {
    return MEMO_STATICS;
  } // React v16.12 and above


  return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;
}

var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = Object.prototype;
function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
  if (typeof sourceComponent !== 'string') {
    // don't hoist over string (html) components
    if (objectPrototype) {
      var inheritedComponent = getPrototypeOf(sourceComponent);

      if (inheritedComponent && inheritedComponent !== objectPrototype) {
        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
      }
    }

    var keys = getOwnPropertyNames(sourceComponent);

    if (getOwnPropertySymbols) {
      keys = keys.concat(getOwnPropertySymbols(sourceComponent));
    }

    var targetStatics = getStatics(targetComponent);
    var sourceStatics = getStatics(sourceComponent);

    for (var i = 0; i < keys.length; ++i) {
      var key = keys[i];

      if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);

        try {
          // Avoid failures from read-only properties
          defineProperty(targetComponent, key, descriptor);
        } catch (e) {}
      }
    }
  }

  return targetComponent;
}

module.exports = hoistNonReactStatics;


/***/ }),

/***/ 8765:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  createChart: () => (/* binding */ xs)
});

// UNUSED EXPORTS: ColorType, CrosshairMode, LasPriceAnimationMode, LastPriceAnimationMode, LineStyle, LineType, PriceLineSource, PriceScaleMode, TickMarkType, isBusinessDay, isUTCTimestamp, version

;// CONCATENATED MODULE: ./node_modules/fancy-canvas/coordinate-space.js
var defaultBindingOptions = {
    allowDownsampling: true,
};
function bindToDevicePixelRatio(canvas, options) {
    if (options === void 0) { options = defaultBindingOptions; }
    return new DevicePixelRatioBinding(canvas, options);
}
var DevicePixelRatioBinding = /** @class */ (function () {
    function DevicePixelRatioBinding(canvas, options) {
        var _this = this;
        this._resolutionMediaQueryList = null;
        this._resolutionListener = function (ev) { return _this._onResolutionChanged(); };
        this._canvasConfiguredListeners = [];
        this.canvas = canvas;
        this._canvasSize = {
            width: this.canvas.clientWidth,
            height: this.canvas.clientHeight,
        };
        this._options = options;
        this._configureCanvas();
        this._installResolutionListener();
    }
    DevicePixelRatioBinding.prototype.destroy = function () {
        this._canvasConfiguredListeners.length = 0;
        this._uninstallResolutionListener();
        this.canvas = null;
    };
    Object.defineProperty(DevicePixelRatioBinding.prototype, "canvasSize", {
        get: function () {
            return {
                width: this._canvasSize.width,
                height: this._canvasSize.height,
            };
        },
        enumerable: true,
        configurable: true
    });
    DevicePixelRatioBinding.prototype.resizeCanvas = function (size) {
        this._canvasSize = {
            width: size.width,
            height: size.height,
        };
        this._configureCanvas();
    };
    Object.defineProperty(DevicePixelRatioBinding.prototype, "pixelRatio", {
        get: function () {
            // According to DOM Level 2 Core specification, ownerDocument should never be null for HTMLCanvasElement
            // see https://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#node-ownerDoc
            var win = this.canvas.ownerDocument.defaultView;
            if (win == null) {
                throw new Error('No window is associated with the canvas');
            }
            return win.devicePixelRatio > 1 || this._options.allowDownsampling ? win.devicePixelRatio : 1;
        },
        enumerable: true,
        configurable: true
    });
    DevicePixelRatioBinding.prototype.subscribeCanvasConfigured = function (listener) {
        this._canvasConfiguredListeners.push(listener);
    };
    DevicePixelRatioBinding.prototype.unsubscribeCanvasConfigured = function (listener) {
        this._canvasConfiguredListeners = this._canvasConfiguredListeners.filter(function (l) { return l != listener; });
    };
    DevicePixelRatioBinding.prototype._configureCanvas = function () {
        var ratio = this.pixelRatio;
        this.canvas.style.width = this._canvasSize.width + "px";
        this.canvas.style.height = this._canvasSize.height + "px";
        this.canvas.width = this._canvasSize.width * ratio;
        this.canvas.height = this._canvasSize.height * ratio;
        this._emitCanvasConfigured();
    };
    DevicePixelRatioBinding.prototype._emitCanvasConfigured = function () {
        var _this = this;
        this._canvasConfiguredListeners.forEach(function (listener) { return listener.call(_this); });
    };
    DevicePixelRatioBinding.prototype._installResolutionListener = function () {
        if (this._resolutionMediaQueryList !== null) {
            throw new Error('Resolution listener is already installed');
        }
        // According to DOM Level 2 Core specification, ownerDocument should never be null for HTMLCanvasElement
        // see https://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#node-ownerDoc
        var win = this.canvas.ownerDocument.defaultView;
        if (win == null) {
            throw new Error('No window is associated with the canvas');
        }
        var dppx = win.devicePixelRatio;
        this._resolutionMediaQueryList = win.matchMedia("all and (resolution: " + dppx + "dppx)");
        // IE and some versions of Edge do not support addEventListener/removeEventListener, and we are going to use the deprecated addListener/removeListener
        this._resolutionMediaQueryList.addListener(this._resolutionListener);
    };
    DevicePixelRatioBinding.prototype._uninstallResolutionListener = function () {
        if (this._resolutionMediaQueryList !== null) {
            // IE and some versions of Edge do not support addEventListener/removeEventListener, and we are going to use the deprecated addListener/removeListener
            this._resolutionMediaQueryList.removeListener(this._resolutionListener);
            this._resolutionMediaQueryList = null;
        }
    };
    DevicePixelRatioBinding.prototype._reinstallResolutionListener = function () {
        this._uninstallResolutionListener();
        this._installResolutionListener();
    };
    DevicePixelRatioBinding.prototype._onResolutionChanged = function () {
        this._configureCanvas();
        this._reinstallResolutionListener();
    };
    return DevicePixelRatioBinding;
}());

;// CONCATENATED MODULE: ./node_modules/lightweight-charts/dist/lightweight-charts.esm.production.js
/*!
 * @license
 * TradingView Lightweight Charts v3.7.0
 * Copyright (c) 2020 TradingView, Inc.
 * Licensed under Apache License 2.0 https://www.apache.org/licenses/LICENSE-2.0
 */
var i,n;function s(t,i){var n,s=((n={})[0]=[],n[1]=[t.lineWidth,t.lineWidth],n[2]=[2*t.lineWidth,2*t.lineWidth],n[3]=[6*t.lineWidth,6*t.lineWidth],n[4]=[t.lineWidth,4*t.lineWidth],n)[i];t.setLineDash(s)}function h(t,i,n,s){t.beginPath();var h=t.lineWidth%2?.5:0;t.moveTo(n,i+h),t.lineTo(s,i+h),t.stroke()}!function(t){t[t.Simple=0]="Simple",t[t.WithSteps=1]="WithSteps"}(i||(i={})),function(t){t[t.Solid=0]="Solid",t[t.Dotted=1]="Dotted",t[t.Dashed=2]="Dashed",t[t.LargeDashed=3]="LargeDashed",t[t.SparseDotted=4]="SparseDotted"}(n||(n={}));var r=function(t,i){return r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,i){t.__proto__=i}||function(t,i){for(var n in i)Object.prototype.hasOwnProperty.call(i,n)&&(t[n]=i[n])},r(t,i)};function e(t,i){if("function"!=typeof i&&null!==i)throw new TypeError("Class extends value "+String(i)+" is not a constructor or null");function n(){this.constructor=t}r(t,i),t.prototype=null===i?Object.create(i):(n.prototype=i.prototype,new n)}var u=function(){return u=Object.assign||function(t){for(var i,n=1,s=arguments.length;n<s;n++)for(var h in i=arguments[n])Object.prototype.hasOwnProperty.call(i,h)&&(t[h]=i[h]);return t},u.apply(this,arguments)};function a(t,i,n){if(n||2===arguments.length)for(var s,h=0,r=i.length;h<r;h++)!s&&h in i||(s||(s=Array.prototype.slice.call(i,0,h)),s[h]=i[h]);return t.concat(s||Array.prototype.slice.call(i))}function o(t,i){if(!t)throw new Error("Assertion failed"+(i?": "+i:""))}function l(t){if(void 0===t)throw new Error("Value is undefined");return t}function f(t){if(null===t)throw new Error("Value is null");return t}function c(t){return f(l(t))}function v(t){for(var i=[],n=1;n<arguments.length;n++)i[n-1]=arguments[n];for(var s=0,h=i;s<h.length;s++){var r=h[s];for(var e in r)void 0!==r[e]&&("object"!=typeof r[e]||void 0===t[e]?t[e]=r[e]:v(t[e],r[e]))}return t}function _(t){return"number"==typeof t&&isFinite(t)}function d(t){return"number"==typeof t&&t%1==0}function w(t){return"string"==typeof t}function M(t){return"boolean"==typeof t}function b(t){var i,n,s,h=t;if(!h||"object"!=typeof h)return h;for(n in i=Array.isArray(h)?[]:{},h)h.hasOwnProperty(n)&&(s=h[n],i[n]=s&&"object"==typeof s?b(s):s);return i}function m(t){return null!==t}function p(t){return null===t?void 0:t}var g=function(){function t(){this.t=[]}return t.prototype.i=function(t){this.t=t},t.prototype.h=function(t,i,n,s){this.t.forEach((function(h){t.save(),h.h(t,i,n,s),t.restore()}))},t}(),y=function(){function t(){}return t.prototype.h=function(t,i,n,s){t.save(),t.scale(i,i),this.u(t,n,s),t.restore()},t.prototype.o=function(t,i,n,s){t.save(),t.scale(i,i),this.l(t,n,s),t.restore()},t.prototype.l=function(t,i,n){},t}(),k=function(t){function i(){var i=null!==t&&t.apply(this,arguments)||this;return i.v=null,i}return e(i,t),i.prototype._=function(t){this.v=t},i.prototype.u=function(t){if(null!==this.v&&null!==this.v.M){var i=this.v.M,n=this.v,s=function(s){t.beginPath();for(var h=i.to-1;h>=i.from;--h){var r=n.m[h];t.moveTo(r.p,r.g),t.arc(r.p,r.g,s,0,2*Math.PI)}t.fill()};t.fillStyle=n.k,s(n.C+2),t.fillStyle=n.N,s(n.C)}},i}(y);function C(){return{m:[{p:0,g:0,S:0,D:0}],N:"",k:"",C:0,M:null}}var N={from:0,to:1},x=function(){function t(t,i){this.A=new g,this.T=[],this.B=[],this.L=!0,this.F=t,this.V=i,this.A.i(this.T)}return t.prototype.O=function(t){var i=this.F.W();i.length!==this.T.length&&(this.B=i.map(C),this.T=this.B.map((function(t){var i=new k;return i._(t),i})),this.A.i(this.T)),this.L=!0},t.prototype.P=function(t,i,n){return this.L&&(this.R(t),this.L=!1),this.A},t.prototype.R=function(t){var i=this,n=this.F.W(),s=this.V.I(),h=this.F.j();n.forEach((function(n,r){var e,u=i.B[r],a=n.q(s);if(null!==a&&n.U()){var o=f(n.H());u.N=a.Y,u.C=a.C,u.m[0].D=a.D,u.m[0].g=n.$().K(a.D,o.X),u.k=null!==(e=a.Z)&&void 0!==e?e:i.F.J(u.m[0].g/t),u.m[0].S=s,u.m[0].p=h.G(s),u.M=N}else u.M=null}))},t}(),S=function(){function t(t){this.tt=t}return t.prototype.h=function(t,i,n,r){if(null!==this.tt){var e=this.tt.it.U,u=this.tt.nt.U;if(e||u){t.save();var a=Math.round(this.tt.p*i),o=Math.round(this.tt.g*i),l=Math.ceil(this.tt.st*i),f=Math.ceil(this.tt.ht*i);t.lineCap="butt",e&&a>=0&&(t.lineWidth=Math.floor(this.tt.it.rt*i),t.strokeStyle=this.tt.it.et,t.fillStyle=this.tt.it.et,s(t,this.tt.it.ut),function(t,i,n,s){t.beginPath();var h=t.lineWidth%2?.5:0;t.moveTo(i+h,n),t.lineTo(i+h,s),t.stroke()}(t,a,0,f)),u&&o>=0&&(t.lineWidth=Math.floor(this.tt.nt.rt*i),t.strokeStyle=this.tt.nt.et,t.fillStyle=this.tt.nt.et,s(t,this.tt.nt.ut),h(t,o,0,l)),t.restore()}}},t}(),D=function(){function t(t){this.L=!0,this.at={it:{rt:1,ut:0,et:"",U:!1},nt:{rt:1,ut:0,et:"",U:!1},st:0,ht:0,p:0,g:0},this.ot=new S(this.at),this.lt=t}return t.prototype.O=function(){this.L=!0},t.prototype.P=function(t,i){return this.L&&(this.R(),this.L=!1),this.ot},t.prototype.R=function(){var t=this.lt.U(),i=f(this.lt.ft()),n=i.vt().ct().crosshair,s=this.at;s.nt.U=t&&this.lt._t(i),s.it.U=t&&this.lt.dt(),s.nt.rt=n.horzLine.width,s.nt.ut=n.horzLine.style,s.nt.et=n.horzLine.color,s.it.rt=n.vertLine.width,s.it.ut=n.vertLine.style,s.it.et=n.vertLine.color,s.st=i.wt(),s.ht=i.Mt(),s.p=this.lt.bt(),s.g=this.lt.gt()},t}(),A={khaki:"#f0e68c",azure:"#f0ffff",aliceblue:"#f0f8ff",ghostwhite:"#f8f8ff",gold:"#ffd700",goldenrod:"#daa520",gainsboro:"#dcdcdc",gray:"#808080",green:"#008000",honeydew:"#f0fff0",floralwhite:"#fffaf0",lightblue:"#add8e6",lightcoral:"#f08080",lemonchiffon:"#fffacd",hotpink:"#ff69b4",lightyellow:"#ffffe0",greenyellow:"#adff2f",lightgoldenrodyellow:"#fafad2",limegreen:"#32cd32",linen:"#faf0e6",lightcyan:"#e0ffff",magenta:"#f0f",maroon:"#800000",olive:"#808000",orange:"#ffa500",oldlace:"#fdf5e6",mediumblue:"#0000cd",transparent:"#0000",lime:"#0f0",lightpink:"#ffb6c1",mistyrose:"#ffe4e1",moccasin:"#ffe4b5",midnightblue:"#191970",orchid:"#da70d6",mediumorchid:"#ba55d3",mediumturquoise:"#48d1cc",orangered:"#ff4500",royalblue:"#4169e1",powderblue:"#b0e0e6",red:"#f00",coral:"#ff7f50",turquoise:"#40e0d0",white:"#fff",whitesmoke:"#f5f5f5",wheat:"#f5deb3",teal:"#008080",steelblue:"#4682b4",bisque:"#ffe4c4",aquamarine:"#7fffd4",aqua:"#0ff",sienna:"#a0522d",silver:"#c0c0c0",springgreen:"#00ff7f",antiquewhite:"#faebd7",burlywood:"#deb887",brown:"#a52a2a",beige:"#f5f5dc",chocolate:"#d2691e",chartreuse:"#7fff00",cornflowerblue:"#6495ed",cornsilk:"#fff8dc",crimson:"#dc143c",cadetblue:"#5f9ea0",tomato:"#ff6347",fuchsia:"#f0f",blue:"#00f",salmon:"#fa8072",blanchedalmond:"#ffebcd",slateblue:"#6a5acd",slategray:"#708090",thistle:"#d8bfd8",tan:"#d2b48c",cyan:"#0ff",darkblue:"#00008b",darkcyan:"#008b8b",darkgoldenrod:"#b8860b",darkgray:"#a9a9a9",blueviolet:"#8a2be2",black:"#000",darkmagenta:"#8b008b",darkslateblue:"#483d8b",darkkhaki:"#bdb76b",darkorchid:"#9932cc",darkorange:"#ff8c00",darkgreen:"#006400",darkred:"#8b0000",dodgerblue:"#1e90ff",darkslategray:"#2f4f4f",dimgray:"#696969",deepskyblue:"#00bfff",firebrick:"#b22222",forestgreen:"#228b22",indigo:"#4b0082",ivory:"#fffff0",lavenderblush:"#fff0f5",feldspar:"#d19275",indianred:"#cd5c5c",lightgreen:"#90ee90",lightgrey:"#d3d3d3",lightskyblue:"#87cefa",lightslategray:"#789",lightslateblue:"#8470ff",snow:"#fffafa",lightseagreen:"#20b2aa",lightsalmon:"#ffa07a",darksalmon:"#e9967a",darkviolet:"#9400d3",mediumpurple:"#9370d8",mediumaquamarine:"#66cdaa",skyblue:"#87ceeb",lavender:"#e6e6fa",lightsteelblue:"#b0c4de",mediumvioletred:"#c71585",mintcream:"#f5fffa",navajowhite:"#ffdead",navy:"#000080",olivedrab:"#6b8e23",palevioletred:"#d87093",violetred:"#d02090",yellow:"#ff0",yellowgreen:"#9acd32",lawngreen:"#7cfc00",pink:"#ffc0cb",paleturquoise:"#afeeee",palegoldenrod:"#eee8aa",darkolivegreen:"#556b2f",darkseagreen:"#8fbc8f",darkturquoise:"#00ced1",peachpuff:"#ffdab9",deeppink:"#ff1493",violet:"#ee82ee",palegreen:"#98fb98",mediumseagreen:"#3cb371",peru:"#cd853f",saddlebrown:"#8b4513",sandybrown:"#f4a460",rosybrown:"#bc8f8f",purple:"#800080",seagreen:"#2e8b57",seashell:"#fff5ee",papayawhip:"#ffefd5",mediumslateblue:"#7b68ee",plum:"#dda0dd",mediumspringgreen:"#00fa9a"};function T(t){return t<0?0:t>255?255:Math.round(t)||0}function B(t){return t<=0||t>0?t<0?0:t>1?1:Math.round(1e4*t)/1e4:0}var L=/^#([0-9a-f])([0-9a-f])([0-9a-f])([0-9a-f])?$/i,F=/^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})?$/i,E=/^rgb\(\s*(-?\d{1,10})\s*,\s*(-?\d{1,10})\s*,\s*(-?\d{1,10})\s*\)$/,V=/^rgba\(\s*(-?\d{1,10})\s*,\s*(-?\d{1,10})\s*,\s*(-?\d{1,10})\s*,\s*(-?[\d]{0,10}(?:\.\d+)?)\s*\)$/;function O(t){var i;if((t=t.toLowerCase())in A&&(t=A[t]),i=V.exec(t)||E.exec(t))return[T(parseInt(i[1],10)),T(parseInt(i[2],10)),T(parseInt(i[3],10)),B(i.length<5?1:parseFloat(i[4]))];if(i=F.exec(t))return[T(parseInt(i[1],16)),T(parseInt(i[2],16)),T(parseInt(i[3],16)),1];if(i=L.exec(t))return[T(17*parseInt(i[1],16)),T(17*parseInt(i[2],16)),T(17*parseInt(i[3],16)),1];throw new Error("Cannot parse color: "+t)}function W(t){var i,n=O(t);return{yt:"rgb("+n[0]+", "+n[1]+", "+n[2]+")",kt:(i=n,.199*i[0]+.687*i[1]+.114*i[2]>160?"black":"white")}}function z(t,i,n,s,h,r){t.fillRect(i+r,n,s-2*r,r),t.fillRect(i+r,n+h-r,s-2*r,r),t.fillRect(i,n,r,h),t.fillRect(i+s-r,n,r,h)}function P(t,i,n){t.save(),t.scale(i,i),n(),t.restore()}function R(t,i,n,s,h,r){t.save(),t.globalCompositeOperation="copy",t.fillStyle=r,t.fillRect(i,n,s,h),t.restore()}function I(t,i,n,s,h,r,e){t.save(),t.globalCompositeOperation="copy";var u=t.createLinearGradient(0,0,0,h);u.addColorStop(0,r),u.addColorStop(1,e),t.fillStyle=u,t.fillRect(i,n,s,h),t.restore()}var j,q=function(){function t(t,i){this._(t,i)}return t.prototype._=function(t,i){this.tt=t,this.Ct=i},t.prototype.h=function(t,i,n,s,h,r){if(this.tt.U){t.font=i.Nt;var e=this.tt.xt||!this.tt.St?i.Dt:0,u=i.At,a=i.Tt,o=i.Bt,l=i.Lt,f=i.Ft,c=this.tt.Et,v=Math.ceil(n.Vt(t,c)),_=i.Ot,d=i.Wt+a+o,w=Math.ceil(.5*d),M=u+v+l+f+e,b=this.Ct.zt;this.Ct.Pt&&(b=this.Ct.Pt);var m,p,g=(b=Math.round(b))-w,y=g+d,k="right"===h,C=k?s:0,N=Math.ceil(s*r),x=C;if(t.fillStyle=this.Ct.yt,t.lineWidth=1,t.lineCap="butt",c){k?(m=C-e,p=(x=C-M)+f):(x=C+M,m=C+e,p=C+u+e+l);var S=Math.max(1,Math.floor(r)),D=Math.max(1,Math.floor(u*r)),A=k?N:0,T=Math.round(g*r),B=Math.round(x*r),L=Math.round(b*r)-Math.floor(.5*r),F=L+S+(L-T),E=Math.round(m*r);t.save(),t.beginPath(),t.moveTo(A,T),t.lineTo(B,T),t.lineTo(B,F),t.lineTo(A,F),t.fill(),t.fillStyle=this.tt.Z,t.fillRect(k?N-D:0,T,D,F-T),this.tt.xt&&(t.fillStyle=this.Ct.et,t.fillRect(A,L,E-A,S)),t.textAlign="left",t.fillStyle=this.Ct.et,P(t,r,(function(){t.fillText(c,p,y-o-_)})),t.restore()}}},t.prototype.Mt=function(t,i){return this.tt.U?t.Wt+t.Tt+t.Bt:0},t}(),U=function(){function t(t){this.Rt={zt:0,et:"#FFF",yt:"#000"},this.It={Et:"",U:!1,xt:!0,St:!1,Z:""},this.jt={Et:"",U:!1,xt:!1,St:!0,Z:""},this.L=!0,this.qt=new(t||q)(this.It,this.Rt),this.Ut=new(t||q)(this.jt,this.Rt)}return t.prototype.Et=function(){return this.It.Et},t.prototype.zt=function(){return this.Ht(),this.Rt.zt},t.prototype.O=function(){this.L=!0},t.prototype.Mt=function(t,i){return void 0===i&&(i=!1),Math.max(this.qt.Mt(t,i),this.Ut.Mt(t,i))},t.prototype.Yt=function(){return this.Rt.Pt||0},t.prototype.Kt=function(t){this.Rt.Pt=t},t.prototype.$t=function(){return this.Ht(),this.It.U||this.jt.U},t.prototype.Xt=function(){return this.Ht(),this.It.U},t.prototype.P=function(t){return this.Ht(),this.It.xt=this.It.xt&&t.ct().drawTicks,this.jt.xt=this.jt.xt&&t.ct().drawTicks,this.qt._(this.It,this.Rt),this.Ut._(this.jt,this.Rt),this.qt},t.prototype.Zt=function(){return this.Ht(),this.qt._(this.It,this.Rt),this.Ut._(this.jt,this.Rt),this.Ut},t.prototype.Ht=function(){this.L&&(this.It.xt=!0,this.jt.xt=!1,this.Jt(this.It,this.jt,this.Rt))},t}(),H=function(t){function i(i,n,s){var h=t.call(this)||this;return h.lt=i,h.Gt=n,h.Qt=s,h}return e(i,t),i.prototype.Jt=function(t,i,n){t.U=!1;var s=this.lt.ct().horzLine;if(s.labelVisible){var h=this.Gt.H();if(this.lt.U()&&!this.Gt.ti()&&null!==h){var r=W(s.labelBackgroundColor);n.yt=r.yt,n.et=r.kt;var e=this.Qt(this.Gt);n.zt=e.zt,t.Et=this.Gt.ii(e.D,h),t.U=!0}}},i}(U),Y=/[1-9]/g,K=function(){function t(){this.tt=null}return t.prototype._=function(t){this.tt=t},t.prototype.h=function(t,i,n){var s=this;if(null!==this.tt&&!1!==this.tt.U&&0!==this.tt.Et.length){t.font=i.Nt;var h=Math.round(i.ni.Vt(t,this.tt.Et,Y));if(!(h<=0)){t.save();var r=i.si,e=h+2*r,u=e/2,a=this.tt.wt,o=this.tt.zt,l=Math.floor(o-u)+.5;l<0?(o+=Math.abs(0-l),l=Math.floor(o-u)+.5):l+e>a&&(o-=Math.abs(a-(l+e)),l=Math.floor(o-u)+.5);var c=l+e,v=0+i.At+i.Tt+i.Wt+i.Bt;t.fillStyle=this.tt.yt;var _=Math.round(l*n),d=Math.round(0*n),w=Math.round(c*n),M=Math.round(v*n);t.fillRect(_,d,w-_,M-d);var b=Math.round(this.tt.zt*n),m=d,p=Math.round((m+i.At+i.Dt)*n);t.fillStyle=this.tt.et;var g=Math.max(1,Math.floor(n)),y=Math.floor(.5*n);t.fillRect(b-y,m,g,p-m);var k=v-i.Ot-i.Bt;t.textAlign="left",t.fillStyle=this.tt.et,P(t,n,(function(){t.fillText(f(s.tt).Et,l+r,k)})),t.restore()}}},t}(),$=function(){function t(t,i,n){this.L=!0,this.ot=new K,this.at={U:!1,yt:"#4c525e",et:"white",Et:"",wt:0,zt:NaN},this.V=t,this.hi=i,this.Qt=n}return t.prototype.O=function(){this.L=!0},t.prototype.P=function(){return this.L&&(this.R(),this.L=!1),this.ot._(this.at),this.ot},t.prototype.R=function(){var t=this.at;t.U=!1;var i=this.V.ct().vertLine;if(i.labelVisible){var n=this.hi.j();if(!n.ti()){var s=n.ri(this.V.I());t.wt=n.wt();var h=this.Qt();if(h.S){t.zt=h.zt,t.Et=n.ei(f(s)),t.U=!0;var r=W(i.labelBackgroundColor);t.yt=r.yt,t.et=r.kt}}}},t}(),X=function(){function t(){this.ui=null,this.ai=0}return t.prototype.oi=function(){return this.ai},t.prototype.li=function(t){this.ai=t},t.prototype.$=function(){return this.ui},t.prototype.fi=function(t){this.ui=t},t.prototype.ci=function(){return[]},t.prototype.U=function(){return!0},t}();!function(t){t[t.Normal=0]="Normal",t[t.Magnet=1]="Magnet"}(j||(j={}));var Z=function(t){function i(i,n){var s=t.call(this)||this;s.vi=null,s._i=NaN,s.di=0,s.wi=!0,s.Mi=new Map,s.bi=!1,s.mi=NaN,s.pi=NaN,s.gi=NaN,s.yi=NaN,s.hi=i,s.ki=n,s.Ci=new x(i,s);var h,r;s.Ni=(h=function(){return s._i},r=function(){return s.pi},function(t){var i=r(),n=h();if(t===f(s.vi).xi())return{D:n,zt:i};var e=f(t.H());return{D:t.Si(i,e),zt:i}});var e=function(t,i){return function(){return{S:s.hi.j().ri(t()),zt:i()}}}((function(){return s.di}),(function(){return s.bt()}));return s.Di=new $(s,i,e),s.Ai=new D(s),s}return e(i,t),i.prototype.ct=function(){return this.ki},i.prototype.Ti=function(t,i){this.gi=t,this.yi=i},i.prototype.Bi=function(){this.gi=NaN,this.yi=NaN},i.prototype.Li=function(){return this.gi},i.prototype.Fi=function(){return this.yi},i.prototype.Ei=function(t,i,n){this.bi||(this.bi=!0),this.wi=!0,this.Vi(t,i,n)},i.prototype.I=function(){return this.di},i.prototype.bt=function(){return this.mi},i.prototype.gt=function(){return this.pi},i.prototype.U=function(){return this.wi},i.prototype.Oi=function(){this.wi=!1,this.Wi(),this._i=NaN,this.mi=NaN,this.pi=NaN,this.vi=null,this.Bi()},i.prototype.zi=function(t){return null!==this.vi?[this.Ai,this.Ci]:[]},i.prototype._t=function(t){return t===this.vi&&this.ki.horzLine.visible},i.prototype.dt=function(){return this.ki.vertLine.visible},i.prototype.Pi=function(t,i){this.wi&&this.vi===t||this.Mi.clear();var n=[];return this.vi===t&&n.push(this.Ri(this.Mi,i,this.Ni)),n},i.prototype.ci=function(){return this.wi?[this.Di]:[]},i.prototype.ft=function(){return this.vi},i.prototype.Ii=function(){this.Ai.O(),this.Mi.forEach((function(t){return t.O()})),this.Di.O(),this.Ci.O()},i.prototype.ji=function(t){return t&&!t.xi().ti()?t.xi():null},i.prototype.Vi=function(t,i,n){this.qi(t,i,n)&&this.Ii()},i.prototype.qi=function(t,i,n){var s=this.mi,h=this.pi,r=this._i,e=this.di,u=this.vi,a=this.ji(n);this.di=t,this.mi=isNaN(t)?NaN:this.hi.j().G(t),this.vi=n;var o=null!==a?a.H():null;return null!==a&&null!==o?(this._i=i,this.pi=a.K(i,o)):(this._i=NaN,this.pi=NaN),s!==this.mi||h!==this.pi||e!==this.di||r!==this._i||u!==this.vi},i.prototype.Wi=function(){var t=this.hi.W().map((function(t){return t.Hi().Ui()})).filter(m),i=0===t.length?null:Math.max.apply(Math,t);this.di=null!==i?i:NaN},i.prototype.Ri=function(t,i,n){var s=t.get(i);return void 0===s&&(s=new H(this,i,n),t.set(i,s)),s},i}(X),J=".";function G(t,i){if(!_(t))return"n/a";if(!d(i))throw new TypeError("invalid length");if(i<0||i>16)throw new TypeError("invalid length");if(0===i)return t.toString();return("0000000000000000"+t.toString()).slice(-i)}var Q=function(){function t(t,i){if(i||(i=1),_(t)&&d(t)||(t=100),t<0)throw new TypeError("invalid base");this.Gt=t,this.Yi=i,this.Ki()}return t.prototype.format=function(t){var i=t<0?"−":"";return t=Math.abs(t),i+this.$i(t)},t.prototype.Ki=function(){if(this.Xi=0,this.Gt>0&&this.Yi>0)for(var t=this.Gt;t>1;)t/=10,this.Xi++},t.prototype.$i=function(t){var i=this.Gt/this.Yi,n=Math.floor(t),s="",h=void 0!==this.Xi?this.Xi:NaN;if(i>1){var r=+(Math.round(t*i)-n*i).toFixed(this.Xi);r>=i&&(r-=i,n+=1),s=J+G(+r.toFixed(this.Xi)*this.Yi,h)}else n=Math.round(n*i)/i,h>0&&(s=J+G(0,h));return n.toFixed(0)+s},t}(),tt=function(t){function i(i){return void 0===i&&(i=100),t.call(this,i)||this}return e(i,t),i.prototype.format=function(i){return t.prototype.format.call(this,i)+"%"},i}(Q),it=function(){function t(){this.Zi=[]}return t.prototype.Ji=function(t,i,n){var s={Gi:t,Qi:i,tn:!0===n};this.Zi.push(s)},t.prototype.nn=function(t){var i=this.Zi.findIndex((function(i){return t===i.Gi}));i>-1&&this.Zi.splice(i,1)},t.prototype.sn=function(t){this.Zi=this.Zi.filter((function(i){return i.Qi===t}))},t.prototype.hn=function(t,i){var n=a([],this.Zi,!0);this.Zi=this.Zi.filter((function(t){return!t.tn})),n.forEach((function(n){return n.Gi(t,i)}))},t.prototype.rn=function(){return this.Zi.length>0},t.prototype.en=function(){this.Zi=[]},t}(),nt=function(){function t(t,i){this.un=t,this.an=i}return t.prototype.on=function(t){return null!==t&&(this.un===t.un&&this.an===t.an)},t.prototype.ln=function(){return new t(this.un,this.an)},t.prototype.fn=function(){return this.un},t.prototype.cn=function(){return this.an},t.prototype.vn=function(){return this.an-this.un},t.prototype.ti=function(){return this.an===this.un||Number.isNaN(this.an)||Number.isNaN(this.un)},t.prototype._n=function(i){return null===i?this:new t(Math.min(this.fn(),i.fn()),Math.max(this.cn(),i.cn()))},t.prototype.dn=function(t){if(_(t)&&0!==this.an-this.un){var i=.5*(this.an+this.un),n=this.an-i,s=this.un-i;n*=t,s*=t,this.an=i+n,this.un=i+s}},t.prototype.wn=function(t){_(t)&&(this.an+=t,this.un+=t)},t.prototype.Mn=function(){return{minValue:this.un,maxValue:this.an}},t.bn=function(i){return null===i?null:new t(i.minValue,i.maxValue)},t}();function st(t,i,n){return Math.min(Math.max(t,i),n)}function ht(t,i,n){return i-t<=n}function rt(t){return t<=0?NaN:Math.log(t)/Math.log(10)}function et(t){var i=Math.ceil(t);return i%2!=0?i-1:i}function ut(t){var i=Math.ceil(t);return i%2==0?i-1:i}function at(t,i){var n=100*(t-i)/i;return i<0?-n:n}function ot(t,i){var n=at(t.fn(),i),s=at(t.cn(),i);return new nt(n,s)}function lt(t,i){var n=100*(t-i)/i+100;return i<0?-n:n}function ft(t,i){var n=lt(t.fn(),i),s=lt(t.cn(),i);return new nt(n,s)}function ct(t){var i=Math.abs(t);if(i<1e-8)return 0;var n=rt(i+1e-4)+4;return t<0?-n:n}function vt(t){var i=Math.abs(t);if(i<1e-8)return 0;var n=Math.pow(10,i-4)-1e-4;return t<0?-n:n}function _t(t){if(null===t)return null;var i=ct(t.fn()),n=ct(t.cn());return new nt(i,n)}var dt,wt=function(){function t(t,i){if(this.mn=t,this.pn=i,function(t){if(t<0)return!1;for(var i=t;i>1;i/=10)if(i%10!=0)return!1;return!0}(this.mn))this.gn=[2,2.5,2];else{this.gn=[];for(var n=this.mn;1!==n;){if(n%2==0)this.gn.push(2),n/=2;else{if(n%5!=0)throw new Error("unexpected base");this.gn.push(2,2.5),n/=5}if(this.gn.length>100)throw new Error("something wrong with base")}}}return t.prototype.yn=function(t,i,n){for(var s,h,r,e=0===this.mn?0:1/this.mn,u=Math.pow(10,Math.max(0,Math.ceil(rt(t-i)))),a=0,o=this.pn[0];;){var l=ht(u,e,1e-14)&&u>e+1e-14,f=ht(u,n*o,1e-14),c=ht(u,1,1e-14);if(!(l&&f&&c))break;u/=o,o=this.pn[++a%this.pn.length]}if(u<=e+1e-14&&(u=e),u=Math.max(1,u),this.gn.length>0&&(s=u,h=1,r=1e-14,Math.abs(s-h)<r))for(a=0,o=this.gn[0];ht(u,n*o,1e-14)&&u>e+1e-14;)u/=o,o=this.gn[++a%this.gn.length];return u},t}(),Mt=function(){function t(t,i,n,s){this.kn=[],this.Gt=t,this.mn=i,this.Cn=n,this.Nn=s}return t.prototype.yn=function(t,i){if(t<i)throw new Error("high < low");var n=this.Gt.Mt(),s=(t-i)*this.xn()/n,h=new wt(this.mn,[2,2.5,2]),r=new wt(this.mn,[2,2,2.5]),e=new wt(this.mn,[2.5,2,2]),u=[];return u.push(h.yn(t,i,s),r.yn(t,i,s),e.yn(t,i,s)),function(t){if(t.length<1)throw Error("array is empty");for(var i=t[0],n=1;n<t.length;++n)t[n]<i&&(i=t[n]);return i}(u)},t.prototype.Sn=function(){var t=this.Gt,i=t.H();if(null!==i){var n=t.Mt(),s=this.Cn(n-1,i),h=this.Cn(0,i),r=this.Gt.ct().entireTextOnly?this.Dn()/2:0,e=r,u=n-1-r,a=Math.max(s,h),o=Math.min(s,h);if(a!==o){for(var l=this.yn(a,o),f=a%l,c=a>=o?1:-1,v=null,_=0,d=a-(f+=f<0?l:0);d>o;d-=l){var w=this.Nn(d,i,!0);null!==v&&Math.abs(w-v)<this.xn()||(w<e||w>u||(_<this.kn.length?(this.kn[_].An=w,this.kn[_].Tn=t.Bn(d)):this.kn.push({An:w,Tn:t.Bn(d)}),_++,v=w,t.Ln()&&(l=this.yn(d*c,o))))}this.kn.length=_}else this.kn=[]}else this.kn=[]},t.prototype.Fn=function(){return this.kn},t.prototype.Dn=function(){return this.Gt.Wt()},t.prototype.xn=function(){return Math.ceil(2.5*this.Dn())},t}();function bt(t){return t.slice().sort((function(t,i){return f(t.oi())-f(i.oi())}))}!function(t){t[t.Normal=0]="Normal",t[t.Logarithmic=1]="Logarithmic",t[t.Percentage=2]="Percentage",t[t.IndexedTo100=3]="IndexedTo100"}(dt||(dt={}));var mt,pt,gt=new tt,yt=new Q(100,1),kt=function(){function t(t,i,n,s){this.En=0,this.Vn=null,this.On=null,this.Wn=null,this.zn={Pn:!1,Rn:null},this.In=0,this.jn=0,this.qn=new it,this.Un=new it,this.Hn=[],this.Yn=null,this.Kn=null,this.$n=null,this.Xn=null,this.Zn=yt,this.Jn=t,this.ki=i,this.Gn=n,this.Qn=s,this.ts=new Mt(this,100,this.ns.bind(this),this.ss.bind(this))}return t.prototype.hs=function(){return this.Jn},t.prototype.ct=function(){return this.ki},t.prototype.rs=function(t){if(v(this.ki,t),this.es(),void 0!==t.mode&&this.us({os:t.mode}),void 0!==t.scaleMargins){var i=l(t.scaleMargins.top),n=l(t.scaleMargins.bottom);if(i<0||i>1)throw new Error("Invalid top margin - expect value between 0 and 1, given="+i);if(n<0||n>1||i+n>1)throw new Error("Invalid bottom margin - expect value between 0 and 1, given="+n);if(i+n>1)throw new Error("Invalid margins - sum of margins must be less than 1, given="+(i+n));this.ls(),this.Kn=null}},t.prototype.fs=function(){return this.ki.autoScale},t.prototype.Ln=function(){return 1===this.ki.mode},t.prototype.cs=function(){return 2===this.ki.mode},t.prototype.vs=function(){return 3===this.ki.mode},t.prototype.os=function(){return{_s:this.ki.autoScale,ds:this.ki.invertScale,os:this.ki.mode}},t.prototype.us=function(t){var i=this.os(),n=null;void 0!==t._s&&(this.ki.autoScale=t._s),void 0!==t.os&&(this.ki.mode=t.os,2!==t.os&&3!==t.os||(this.ki.autoScale=!0),this.zn.Pn=!1),1===i.os&&t.os!==i.os&&(!function(t){if(null===t)return!1;var i=vt(t.fn()),n=vt(t.cn());return isFinite(i)&&isFinite(n)}(this.On)?this.ki.autoScale=!0:(n=function(t){if(null===t)return null;var i=vt(t.fn()),n=vt(t.cn());return new nt(i,n)}(this.On),null!==n&&this.ws(n))),1===t.os&&t.os!==i.os&&null!==(n=_t(this.On))&&this.ws(n);var s=i.os!==this.ki.mode;s&&(2===i.os||this.cs())&&this.es(),s&&(3===i.os||this.vs())&&this.es(),void 0!==t.ds&&i.ds!==t.ds&&(this.ki.invertScale=t.ds,this.Ms()),this.Un.hn(i,this.os())},t.prototype.bs=function(){return this.Un},t.prototype.Wt=function(){return this.Gn.fontSize},t.prototype.Mt=function(){return this.En},t.prototype.ps=function(t){this.En!==t&&(this.En=t,this.ls(),this.Kn=null)},t.prototype.gs=function(){if(this.Vn)return this.Vn;var t=this.Mt()-this.ys()-this.ks();return this.Vn=t,t},t.prototype.Cs=function(){return this.Ns(),this.On},t.prototype.ws=function(t,i){var n=this.On;(i||null===n&&null!==t||null!==n&&!n.on(t))&&(this.Kn=null,this.On=t)},t.prototype.ti=function(){return this.Ns(),0===this.En||!this.On||this.On.ti()},t.prototype.xs=function(t){return this.ds()?t:this.Mt()-1-t},t.prototype.K=function(t,i){return this.cs()?t=at(t,i):this.vs()&&(t=lt(t,i)),this.ss(t,i)},t.prototype.Ss=function(t,i,n){this.Ns();for(var s=this.ks(),h=f(this.Cs()),r=h.fn(),e=h.cn(),u=this.gs()-1,a=this.ds(),o=u/(e-r),l=void 0===n?0:n.from,c=void 0===n?t.length:n.to,v=this.Ds(),_=l;_<c;_++){var d=t[_],w=d.D;if(!isNaN(w)){var M=w;null!==v&&(M=v(d.D,i));var b=s+o*(M-r),m=a?b:this.En-1-b;d.g=m}}},t.prototype.As=function(t,i,n){this.Ns();for(var s=this.ks(),h=f(this.Cs()),r=h.fn(),e=h.cn(),u=this.gs()-1,a=this.ds(),o=u/(e-r),l=void 0===n?0:n.from,c=void 0===n?t.length:n.to,v=this.Ds(),_=l;_<c;_++){var d=t[_],w=d.open,M=d.high,b=d.low,m=d.close;null!==v&&(w=v(d.open,i),M=v(d.high,i),b=v(d.low,i),m=v(d.close,i));var p=s+o*(w-r),g=a?p:this.En-1-p;d.Ts=g,p=s+o*(M-r),g=a?p:this.En-1-p,d.Bs=g,p=s+o*(b-r),g=a?p:this.En-1-p,d.Ls=g,p=s+o*(m-r),g=a?p:this.En-1-p,d.Fs=g}},t.prototype.Si=function(t,i){var n=this.ns(t,i);return this.Es(n,i)},t.prototype.Es=function(t,i){var n=t;return this.cs()?n=function(t,i){return i<0&&(t=-t),t/100*i+i}(n,i):this.vs()&&(n=function(t,i){return t-=100,i<0&&(t=-t),t/100*i+i}(n,i)),n},t.prototype.Vs=function(){return this.Hn},t.prototype.Os=function(){if(this.Yn)return this.Yn;for(var t=[],i=0;i<this.Hn.length;i++){var n=this.Hn[i];null===n.oi()&&n.li(i+1),t.push(n)}return t=bt(t),this.Yn=t,this.Yn},t.prototype.Ws=function(t){-1===this.Hn.indexOf(t)&&(this.Hn.push(t),this.es(),this.zs())},t.prototype.Ps=function(t){var i=this.Hn.indexOf(t);if(-1===i)throw new Error("source is not attached to scale");this.Hn.splice(i,1),0===this.Hn.length&&(this.us({_s:!0}),this.ws(null)),this.es(),this.zs()},t.prototype.H=function(){for(var t=null,i=0,n=this.Hn;i<n.length;i++){var s=n[i].H();null!==s&&((null===t||s.Rs<t.Rs)&&(t=s))}return null===t?null:t.X},t.prototype.ds=function(){return this.ki.invertScale},t.prototype.Fn=function(){return this.Kn||(this.ts.Sn(),this.Kn=this.ts.Fn(),this.qn.hn()),this.Kn},t.prototype.Is=function(){return this.qn},t.prototype.js=function(t){this.cs()||this.vs()||null===this.$n&&null===this.Wn&&(this.ti()||(this.$n=this.En-t,this.Wn=f(this.Cs()).ln()))},t.prototype.qs=function(t){if(!this.cs()&&!this.vs()&&null!==this.$n){this.us({_s:!1}),(t=this.En-t)<0&&(t=0);var i=(this.$n+.2*(this.En-1))/(t+.2*(this.En-1)),n=f(this.Wn).ln();i=Math.max(i,.1),n.dn(i),this.ws(n)}},t.prototype.Us=function(){this.cs()||this.vs()||(this.$n=null,this.Wn=null)},t.prototype.Hs=function(t){this.fs()||null===this.Xn&&null===this.Wn&&(this.ti()||(this.Xn=t,this.Wn=f(this.Cs()).ln()))},t.prototype.Ys=function(t){if(!this.fs()&&null!==this.Xn){var i=f(this.Cs()).vn()/(this.gs()-1),n=t-this.Xn;this.ds()&&(n*=-1);var s=n*i,h=f(this.Wn).ln();h.wn(s),this.ws(h,!0),this.Kn=null}},t.prototype.Ks=function(){this.fs()||null!==this.Xn&&(this.Xn=null,this.Wn=null)},t.prototype.$s=function(){return this.Zn||this.es(),this.Zn},t.prototype.ii=function(t,i){switch(this.ki.mode){case 2:return this.$s().format(at(t,i));case 3:return this.$s().format(lt(t,i));default:return this.Xs(t)}},t.prototype.Bn=function(t){switch(this.ki.mode){case 2:case 3:return this.$s().format(t);default:return this.Xs(t)}},t.prototype.Zs=function(t){return this.Xs(t,f(this.Js()).$s())},t.prototype.Gs=function(t,i){return t=at(t,i),gt.format(t)},t.prototype.Qs=function(){return this.Hn},t.prototype.th=function(t){this.zn={Rn:t,Pn:!1}},t.prototype.Ii=function(){this.Hn.forEach((function(t){return t.Ii()}))},t.prototype.es=function(){this.Kn=null;var t=this.Js(),i=100;null!==t&&(i=Math.round(1/t.ih())),this.Zn=yt,this.cs()?(this.Zn=gt,i=100):this.vs()?(this.Zn=new Q(100,1),i=100):null!==t&&(this.Zn=t.$s()),this.ts=new Mt(this,i,this.ns.bind(this),this.ss.bind(this)),this.ts.Sn()},t.prototype.zs=function(){this.Yn=null},t.prototype.Js=function(){return this.Hn[0]||null},t.prototype.ys=function(){return this.ds()?this.ki.scaleMargins.bottom*this.Mt()+this.jn:this.ki.scaleMargins.top*this.Mt()+this.In},t.prototype.ks=function(){return this.ds()?this.ki.scaleMargins.top*this.Mt()+this.In:this.ki.scaleMargins.bottom*this.Mt()+this.jn},t.prototype.Ns=function(){this.zn.Pn||(this.zn.Pn=!0,this.nh())},t.prototype.ls=function(){this.Vn=null},t.prototype.ss=function(t,i){if(this.Ns(),this.ti())return 0;t=this.Ln()&&t?ct(t):t;var n=f(this.Cs()),s=this.ks()+(this.gs()-1)*(t-n.fn())/n.vn();return this.xs(s)},t.prototype.ns=function(t,i){if(this.Ns(),this.ti())return 0;var n=this.xs(t),s=f(this.Cs()),h=s.fn()+s.vn()*((n-this.ks())/(this.gs()-1));return this.Ln()?vt(h):h},t.prototype.Ms=function(){this.Kn=null,this.ts.Sn()},t.prototype.nh=function(){var t=this.zn.Rn;if(null!==t){for(var i=null,n=0,s=0,h=0,r=this.Qs();h<r.length;h++){var e=r[h];if(e.U()){var u=e.H();if(null!==u){var a=e.sh(t.hh(),t.rh()),o=a&&a.Cs();if(null!==o){switch(this.ki.mode){case 1:o=_t(o);break;case 2:o=ot(o,u.X);break;case 3:o=ft(o,u.X)}if(i=null===i?o:i._n(f(o)),null!==a){var l=a.eh();null!==l&&(n=Math.max(n,l.above),s=Math.max(n,l.below))}}}}}if(n===this.In&&s===this.jn||(this.In=n,this.jn=s,this.Kn=null,this.ls()),null!==i){if(i.fn()===i.cn()){var c=this.Js(),v=5*(null===c||this.cs()||this.vs()?1:c.ih());i=new nt(i.fn()-v,i.cn()+v)}this.ws(i)}else null===this.On&&this.ws(new nt(-.5,.5));this.zn.Pn=!0}},t.prototype.Ds=function(){return this.cs()?at:this.vs()?lt:this.Ln()?ct:null},t.prototype.Xs=function(t,i){return void 0===this.Qn.priceFormatter?(void 0===i&&(i=this.$s()),i.format(t)):this.Qn.priceFormatter(t)},t}();function Ct(t){void 0!==t.borderColor&&(t.borderUpColor=t.borderColor,t.borderDownColor=t.borderColor),void 0!==t.wickColor&&(t.wickUpColor=t.wickColor,t.wickDownColor=t.wickColor)}!function(t){t[t.Disabled=0]="Disabled",t[t.Continuous=1]="Continuous",t[t.OnDataUpdate=2]="OnDataUpdate"}(mt||(mt={})),function(t){t[t.LastBar=0]="LastBar",t[t.LastVisible=1]="LastVisible"}(pt||(pt={}));var Nt=function(t){return t.getUTCFullYear()};function xt(t,i,n){return i.replace(/yyyy/g,function(t){return G(Nt(t),4)}(t)).replace(/yy/g,function(t){return G(Nt(t)%100,2)}(t)).replace(/MMMM/g,function(t,i){return new Date(t.getUTCFullYear(),t.getUTCMonth(),1).toLocaleString(i,{month:"long"})}(t,n)).replace(/MMM/g,function(t,i){return new Date(t.getUTCFullYear(),t.getUTCMonth(),1).toLocaleString(i,{month:"short"})}(t,n)).replace(/MM/g,function(t){return G(function(t){return t.getUTCMonth()+1}(t),2)}(t)).replace(/dd/g,function(t){return G(function(t){return t.getUTCDate()}(t),2)}(t))}var St=function(){function t(t,i){void 0===t&&(t="yyyy-MM-dd"),void 0===i&&(i="default"),this.uh=t,this.ah=i}return t.prototype.oh=function(t){return xt(t,this.uh,this.ah)},t}(),Dt=function(){function t(t){this.lh=t||"%h:%m:%s"}return t.prototype.oh=function(t){return this.lh.replace("%h",G(t.getUTCHours(),2)).replace("%m",G(t.getUTCMinutes(),2)).replace("%s",G(t.getUTCSeconds(),2))},t}(),At={fh:"yyyy-MM-dd",_h:"%h:%m:%s",dh:" ",wh:"default"},Tt=function(){function t(t){void 0===t&&(t={});var i=u(u({},At),t);this.Mh=new St(i.fh,i.wh),this.bh=new Dt(i._h),this.mh=i.dh}return t.prototype.oh=function(t){return""+this.Mh.oh(t)+this.mh+this.bh.oh(t)},t}();function Bt(t,i,n,s,h){void 0===s&&(s=0),void 0===h&&(h=t.length);for(var r=h-s;0<r;){var e=r>>1,u=s+e;n(t[u],i)?(s=u+1,r-=e+1):r=e}return s}function Lt(t,i,n,s,h){void 0===s&&(s=0),void 0===h&&(h=t.length);for(var r=h-s;0<r;){var e=r>>1,u=s+e;n(i,t[u])?r=e:(s=u+1,r-=e+1)}return s}var Ft=function(){function t(t,i){void 0===i&&(i=50),this.ph=0,this.gh=1,this.yh=1,this.kh=new Map,this.Ch=new Map,this.Nh=t,this.xh=i}return t.prototype.oh=function(t){var i=void 0===t.Sh?new Date(1e3*t.Dh).getTime():new Date(Date.UTC(t.Sh.year,t.Sh.month-1,t.Sh.day)).getTime(),n=this.kh.get(i);if(void 0!==n)return n.Ah;if(this.ph===this.xh){var s=this.Ch.get(this.yh);this.Ch.delete(this.yh),this.kh.delete(l(s)),this.yh++,this.ph--}var h=this.Nh(t);return this.kh.set(i,{Ah:h,Th:this.gh}),this.Ch.set(this.gh,i),this.ph++,this.gh++,h},t}(),Et=function(){function t(t,i){o(t<=i,"right should be >= left"),this.Bh=t,this.Lh=i}return t.prototype.hh=function(){return this.Bh},t.prototype.rh=function(){return this.Lh},t.prototype.Fh=function(){return this.Lh-this.Bh+1},t.prototype.Eh=function(t){return this.Bh<=t&&t<=this.Lh},t.prototype.on=function(t){return this.Bh===t.hh()&&this.Lh===t.rh()},t}();function Vt(t,i){return null===t||null===i?t===i:t.on(i)}var Ot,Wt=function(){function t(){this.Vh=new Map,this.kh=null}return t.prototype.Oh=function(t,i){this.Wh(i),this.kh=null;for(var n=i;n<t.length;++n){var s=t[n],h=this.Vh.get(s.zh);void 0===h&&(h=[],this.Vh.set(s.zh,h)),h.push({Ph:n,S:s.S,Rh:s.zh})}},t.prototype.Ih=function(t,i){var n=Math.ceil(i/t);return null!==this.kh&&this.kh.jh===n||(this.kh={Fn:this.qh(n),jh:n}),this.kh.Fn},t.prototype.Wh=function(t){if(0!==t){var i=[];this.Vh.forEach((function(n,s){t<=n[0].Ph?i.push(s):n.splice(Bt(n,t,(function(i){return i.Ph<t})),1/0)}));for(var n=0,s=i;n<s.length;n++){var h=s[n];this.Vh.delete(h)}}else this.Vh.clear()},t.prototype.qh=function(t){for(var i=[],n=0,s=Array.from(this.Vh.keys()).sort((function(t,i){return i-t}));n<s.length;n++){var h=s[n];if(this.Vh.get(h)){var r=i;i=[];for(var e=r.length,u=0,a=l(this.Vh.get(h)),o=a.length,f=1/0,c=-1/0,v=0;v<o;v++){for(var _=a[v],d=_.Ph;u<e;){var w=r[u],M=w.Ph;if(!(M<d)){f=M;break}u++,i.push(w),c=M,f=1/0}f-d>=t&&d-c>=t&&(i.push(_),c=d)}for(;u<e;u++)i.push(r[u])}}return i},t}(),zt=function(){function t(t){this.Uh=t}return t.prototype.Hh=function(){return null===this.Uh?null:new Et(Math.floor(this.Uh.hh()),Math.ceil(this.Uh.rh()))},t.prototype.Yh=function(){return this.Uh},t.Kh=function(){return new t(null)},t}();!function(t){t[t.Year=0]="Year",t[t.Month=1]="Month",t[t.DayOfMonth=2]="DayOfMonth",t[t.Time=3]="Time",t[t.TimeWithSeconds=4]="TimeWithSeconds"}(Ot||(Ot={}));var Pt,Rt=function(){function t(t,i,n){this.$h=0,this.Xh=null,this.Zh=[],this.Xn=null,this.$n=null,this.Jh=new Wt,this.Gh=new Map,this.Qh=zt.Kh(),this.tr=!0,this.ir=new it,this.nr=new it,this.sr=new it,this.hr=null,this.rr=null,this.er=[],this.ki=i,this.Qn=n,this.ur=i.rightOffset,this.ar=i.barSpacing,this.hi=t,this.lr()}return t.prototype.ct=function(){return this.ki},t.prototype.cr=function(t){v(this.Qn,t),this.vr(),this.lr()},t.prototype.rs=function(t,i){var n;v(this.ki,t),this.ki.fixLeftEdge&&this._r(),this.ki.fixRightEdge&&this.dr(),void 0!==t.barSpacing&&this.hi.wr(t.barSpacing),void 0!==t.rightOffset&&this.hi.Mr(t.rightOffset),void 0!==t.minBarSpacing&&this.hi.wr(null!==(n=t.barSpacing)&&void 0!==n?n:this.ar),this.vr(),this.lr(),this.sr.hn()},t.prototype.ri=function(t){var i;return(null===(i=this.Zh[t])||void 0===i?void 0:i.S)||null},t.prototype.br=function(t,i){if(this.Zh.length<1)return null;if(t.Dh>this.Zh[this.Zh.length-1].S.Dh)return i?this.Zh.length-1:null;var n=Bt(this.Zh,t.Dh,(function(t,i){return t.S.Dh<i}));return t.Dh<this.Zh[n].S.Dh?i?n:null:n},t.prototype.ti=function(){return 0===this.$h||0===this.Zh.length},t.prototype.mr=function(){return this.pr(),this.Qh.Hh()},t.prototype.gr=function(){return this.pr(),this.Qh.Yh()},t.prototype.yr=function(){var t=this.mr();if(null===t)return null;var i={from:t.hh(),to:t.rh()};return this.kr(i)},t.prototype.kr=function(t){var i=Math.round(t.from),n=Math.round(t.to),s=f(this.Cr()),h=f(this.Nr());return{from:f(this.ri(Math.max(s,i))),to:f(this.ri(Math.min(h,n)))}},t.prototype.Sr=function(t){return{from:f(this.br(t.from,!0)),to:f(this.br(t.to,!0))}},t.prototype.wt=function(){return this.$h},t.prototype.Dr=function(t){if(isFinite(t)&&!(t<=0)&&this.$h!==t){if(this.ki.lockVisibleTimeRangeOnResize&&this.$h){var i=this.ar*t/this.$h;this.ar=i}if(this.ki.fixLeftEdge){var n=this.mr();if(null!==n)if(n.hh()<=0){var s=this.$h-t;this.ur-=Math.round(s/this.ar)+1}}this.$h=t,this.tr=!0,this.Ar(),this.Tr()}},t.prototype.G=function(t){if(this.ti()||!d(t))return 0;var i=this.Br()+this.ur-t;return this.$h-(i+.5)*this.ar-1},t.prototype.Lr=function(t,i){for(var n=this.Br(),s=void 0===i?0:i.from,h=void 0===i?t.length:i.to,r=s;r<h;r++){var e=t[r].S,u=n+this.ur-e,a=this.$h-(u+.5)*this.ar-1;t[r].p=a}},t.prototype.Fr=function(t){return Math.ceil(this.Er(t))},t.prototype.Mr=function(t){this.tr=!0,this.ur=t,this.Tr(),this.hi.Vr(),this.hi.Or()},t.prototype.Wr=function(){return this.ar},t.prototype.wr=function(t){this.zr(t),this.Tr(),this.hi.Vr(),this.hi.Or()},t.prototype.Pr=function(){return this.ur},t.prototype.Fn=function(){if(this.ti())return null;if(null!==this.rr)return this.rr;for(var t=this.ar,i=5*(this.hi.ct().layout.fontSize+4),n=Math.round(i/t),s=f(this.mr()),h=Math.max(s.hh(),s.hh()-n),r=Math.max(s.rh(),s.rh()-n),e=this.Jh.Ih(t,i),u=this.Cr()+n,a=this.Nr()-n,o=0,l=0,c=e;l<c.length;l++){var v=c[l];if(h<=v.Ph&&v.Ph<=r){var _=void 0;o<this.er.length?((_=this.er[o]).An=this.G(v.Ph),_.Tn=this.Rr(v.S,v.Rh),_.Rh=v.Rh):(_={Ir:!1,An:this.G(v.Ph),Tn:this.Rr(v.S,v.Rh),Rh:v.Rh},this.er.push(_)),this.ar>i/2?_.Ir=!1:_.Ir=this.ki.fixLeftEdge&&v.Ph<=u||this.ki.fixRightEdge&&v.Ph>=a,o++}}return this.er.length=o,this.rr=this.er,this.er},t.prototype.jr=function(){this.tr=!0,this.wr(this.ki.barSpacing),this.Mr(this.ki.rightOffset)},t.prototype.qr=function(t){this.tr=!0,this.Xh=t,this.Tr(),this._r()},t.prototype.Ur=function(t,i){var n=this.Er(t),s=this.Wr(),h=s+i*(s/10);this.wr(h),this.ki.rightBarStaysOnScroll||this.Mr(this.Pr()+(n-this.Er(t)))},t.prototype.js=function(t){this.Xn&&this.Ks(),null===this.$n&&null===this.hr&&(this.ti()||(this.$n=t,this.Hr()))},t.prototype.qs=function(t){if(null!==this.hr){var i=st(this.$h-t,0,this.$h),n=st(this.$h-f(this.$n),0,this.$h);0!==i&&0!==n&&this.wr(this.hr.Wr*i/n)}},t.prototype.Us=function(){null!==this.$n&&(this.$n=null,this.Yr())},t.prototype.Hs=function(t){null===this.Xn&&null===this.hr&&(this.ti()||(this.Xn=t,this.Hr()))},t.prototype.Ys=function(t){if(null!==this.Xn){var i=(this.Xn-t)/this.Wr();this.ur=f(this.hr).Pr+i,this.tr=!0,this.Tr()}},t.prototype.Ks=function(){null!==this.Xn&&(this.Xn=null,this.Yr())},t.prototype.Kr=function(){this.$r(this.ki.rightOffset)},t.prototype.$r=function(t,i){var n=this;if(void 0===i&&(i=400),!isFinite(t))throw new RangeError("offset is required and must be finite number");if(!isFinite(i)||i<=0)throw new RangeError("animationDuration (optional) must be finite positive number");var s=this.ur,h=performance.now(),r=function(){var e=(performance.now()-h)/i,u=e>=1,a=u?t:s+(t-s)*e;n.Mr(a),u||setTimeout(r,20)};r()},t.prototype.O=function(t,i){this.tr=!0,this.Zh=t,this.Jh.Oh(t,i),this.Tr()},t.prototype.Xr=function(){return this.ir},t.prototype.Zr=function(){return this.nr},t.prototype.Jr=function(){return this.sr},t.prototype.Br=function(){return this.Xh||0},t.prototype.Gr=function(t){var i=t.Fh();this.zr(this.$h/i),this.ur=t.rh()-this.Br(),this.Tr(),this.tr=!0,this.hi.Vr(),this.hi.Or()},t.prototype.Qr=function(){var t=this.Cr(),i=this.Nr();null!==t&&null!==i&&this.Gr(new Et(t,i+this.ki.rightOffset))},t.prototype.te=function(t){var i=new Et(t.from,t.to);this.Gr(i)},t.prototype.ei=function(t){return void 0!==this.Qn.timeFormatter?this.Qn.timeFormatter(t.Sh||t.Dh):this.ie.oh(new Date(1e3*t.Dh))},t.prototype.Cr=function(){return 0===this.Zh.length?null:0},t.prototype.Nr=function(){return 0===this.Zh.length?null:this.Zh.length-1},t.prototype.ne=function(t){return(this.$h-1-t)/this.ar},t.prototype.Er=function(t){var i=this.ne(t),n=this.Br()+this.ur-i;return Math.round(1e6*n)/1e6},t.prototype.zr=function(t){var i=this.ar;this.ar=t,this.Ar(),i!==this.ar&&(this.tr=!0,this.se())},t.prototype.pr=function(){if(this.tr)if(this.tr=!1,this.ti())this.he(zt.Kh());else{var t=this.Br(),i=this.$h/this.ar,n=this.ur+t,s=new Et(n-i+1,n);this.he(new zt(s))}},t.prototype.Ar=function(){var t=this.re();if(this.ar<t&&(this.ar=t,this.tr=!0),0!==this.$h){var i=.5*this.$h;this.ar>i&&(this.ar=i,this.tr=!0)}},t.prototype.re=function(){return this.ki.fixLeftEdge&&this.ki.fixRightEdge&&0!==this.Zh.length?this.$h/this.Zh.length:this.ki.minBarSpacing},t.prototype.Tr=function(){var t=this.ee();this.ur>t&&(this.ur=t,this.tr=!0);var i=this.ue();null!==i&&this.ur<i&&(this.ur=i,this.tr=!0)},t.prototype.ue=function(){var t=this.Cr(),i=this.Xh;return null===t||null===i?null:t-i-1+(this.ki.fixLeftEdge?this.$h/this.ar:Math.min(2,this.Zh.length))},t.prototype.ee=function(){return this.ki.fixRightEdge?0:this.$h/this.ar-Math.min(2,this.Zh.length)},t.prototype.Hr=function(){this.hr={Wr:this.Wr(),Pr:this.Pr()}},t.prototype.Yr=function(){this.hr=null},t.prototype.Rr=function(t,i){var n=this,s=this.Gh.get(i);return void 0===s&&(s=new Ft((function(t){return n.ae(t,i)})),this.Gh.set(i,s)),s.oh(t)},t.prototype.ae=function(t,i){var n,s=function(t,i,n){switch(t){case 0:case 10:return i?n?4:3:2;case 20:case 21:case 22:case 30:case 31:case 32:case 33:return i?3:2;case 50:return 2;case 60:return 1;case 70:return 0}}(i,this.ki.timeVisible,this.ki.secondsVisible);return void 0!==this.ki.tickMarkFormatter?this.ki.tickMarkFormatter(null!==(n=t.Sh)&&void 0!==n?n:t.Dh,s,this.Qn.locale):function(t,i,n){var s={};switch(i){case 0:s.year="numeric";break;case 1:s.month="short";break;case 2:s.day="numeric";break;case 3:s.hour12=!1,s.hour="2-digit",s.minute="2-digit";break;case 4:s.hour12=!1,s.hour="2-digit",s.minute="2-digit",s.second="2-digit"}var h=void 0===t.Sh?new Date(1e3*t.Dh):new Date(Date.UTC(t.Sh.year,t.Sh.month-1,t.Sh.day));return new Date(h.getUTCFullYear(),h.getUTCMonth(),h.getUTCDate(),h.getUTCHours(),h.getUTCMinutes(),h.getUTCSeconds(),h.getUTCMilliseconds()).toLocaleString(n,s)}(t,s,this.Qn.locale)},t.prototype.he=function(t){var i=this.Qh;this.Qh=t,Vt(i.Hh(),this.Qh.Hh())||this.ir.hn(),Vt(i.Yh(),this.Qh.Yh())||this.nr.hn(),this.se()},t.prototype.se=function(){this.rr=null},t.prototype.vr=function(){this.se(),this.Gh.clear()},t.prototype.lr=function(){var t=this.Qn.dateFormat;this.ki.timeVisible?this.ie=new Tt({fh:t,_h:this.ki.secondsVisible?"%h:%m:%s":"%h:%m",dh:"   ",wh:this.Qn.locale}):this.ie=new St(t,this.Qn.locale)},t.prototype._r=function(){if(this.ki.fixLeftEdge){var t=this.Cr();if(null!==t){var i=this.mr();if(null!==i){var n=i.hh()-t;if(n<0){var s=this.ur-n-1;this.Mr(s)}this.Ar()}}}},t.prototype.dr=function(){this.Tr(),this.Ar()},t}();function It(t){return!_(t)&&!w(t)}function jt(t){return _(t)}!function(t){t.Solid="solid",t.VerticalGradient="gradient"}(Pt||(Pt={}));var qt="'Trebuchet MS', Roboto, Ubuntu, sans-serif";function Ut(t,i,n){return void 0!==n?n+=" ":n="",void 0===i&&(i=qt),""+n+t+"px "+i}var Ht=function(){function t(t){this.oe={At:1,Dt:4,Wt:NaN,Nt:"",le:"",et:"",Bt:0,Lt:0,Ft:0,Tt:0,Ot:0},this.F=t}return t.prototype.ct=function(){var t=this.oe,i=this.fe(),n=this.ce();return t.Wt===i&&t.le===n||(t.Wt=i,t.le=n,t.Nt=Ut(i,n),t.Tt=Math.floor(i/3.5),t.Bt=t.Tt,t.Lt=Math.max(Math.ceil(i/2-t.Dt/2),0),t.Ft=Math.ceil(i/2+t.Dt/2),t.Ot=Math.round(i/10)),t.et=this.ve(),this.oe},t.prototype.ve=function(){return this.F.ct().layout.textColor},t.prototype.fe=function(){return this.F.ct().layout.fontSize},t.prototype.ce=function(){return this.F.ct().layout.fontFamily},t}();function Yt(t){return"left"===t||"right"===t}var Kt=function(){function t(t){this._e=new Map,this.de=!1,this.we=[],this.Me=t}return t.prototype.be=function(t,i){var n=function(t,i){return void 0===t?i:{me:Math.max(t.me,i.me),_s:t._s||i._s}}(this._e.get(t),i);this._e.set(t,n)},t.prototype.pe=function(){return this.Me},t.prototype.ge=function(t){var i=this._e.get(t);return void 0===i?{me:this.Me}:{me:Math.max(this.Me,i.me),_s:i._s}},t.prototype.ye=function(){this.we=[{ke:0}]},t.prototype.Ce=function(t){this.we=[{ke:1,X:t}]},t.prototype.Ne=function(){this.we=[{ke:4}]},t.prototype.wr=function(t){this.we.push({ke:2,X:t})},t.prototype.Mr=function(t){this.we.push({ke:3,X:t})},t.prototype.xe=function(){return this.we},t.prototype._n=function(t){var i=this;this.de=this.de||t.de,this.we=this.we.concat(t.we);for(var n=0,s=t.we;n<s.length;n++){var h=s[n];this.Se(h)}this.Me=Math.max(this.Me,t.Me),t._e.forEach((function(t,n){i.be(n,t)}))},t.prototype.Se=function(t){switch(t.ke){case 0:this.ye();break;case 1:this.Ce(t.X);break;case 2:this.wr(t.X);break;case 3:this.Mr(t.X);break;case 4:this.Ne()}},t}(),$t=function(){function t(t){this.De=t}return t.prototype.format=function(t){var i="";return t<0&&(i="-",t=-t),t<995?i+this.Ae(t):t<999995?i+this.Ae(t/1e3)+"K":t<999999995?(t=1e3*Math.round(t/1e3),i+this.Ae(t/1e6)+"M"):(t=1e6*Math.round(t/1e6),i+this.Ae(t/1e9)+"B")},t.prototype.Ae=function(t){var i=Math.pow(10,this.De);return((t=Math.round(t*i)/i)>=1e-15&&t<1?t.toFixed(this.De).replace(/\.?0+$/,""):String(t)).replace(/(\.[1-9]*)0+$/,(function(t,i){return i}))},t}();function Xt(t,i,n,s){if(0!==i.length){var h=i[s.from].p,r=i[s.from].g;t.moveTo(h,r);for(var e=s.from+1;e<s.to;++e){var u=i[e];if(1===n){var a=i[e-1].g,o=u.p;t.lineTo(o,a)}t.lineTo(u.p,u.g)}}}var Zt=function(t){function i(){var i=null!==t&&t.apply(this,arguments)||this;return i.v=null,i}return e(i,t),i.prototype._=function(t){this.v=t},i.prototype.u=function(t){if(null!==this.v&&0!==this.v.m.length&&null!==this.v.M){if(t.lineCap="butt",t.lineJoin="round",t.lineWidth=this.v.rt,s(t,this.v.ut),t.lineWidth=1,t.beginPath(),1===this.v.m.length){var i=this.v.m[0],n=this.v.Te/2;t.moveTo(i.p-n,this.v.Be),t.lineTo(i.p-n,i.g),t.lineTo(i.p+n,i.g),t.lineTo(i.p+n,this.v.Be)}else t.moveTo(this.v.m[this.v.M.from].p,this.v.Be),t.lineTo(this.v.m[this.v.M.from].p,this.v.m[this.v.M.from].g),Xt(t,this.v.m,this.v.Le,this.v.M),this.v.M.to>this.v.M.from&&(t.lineTo(this.v.m[this.v.M.to-1].p,this.v.Be),t.lineTo(this.v.m[this.v.M.from].p,this.v.Be));t.closePath(),t.fillStyle=this.Fe(t),t.fill()}},i}(y),Jt=function(t){function i(){return null!==t&&t.apply(this,arguments)||this}return e(i,t),i.prototype.Fe=function(t){var i=this.v,n=t.createLinearGradient(0,0,0,i.Ee);return n.addColorStop(0,i.Ve),n.addColorStop(1,i.Oe),n},i}(Zt),Gt=function(t){function i(){var i=null!==t&&t.apply(this,arguments)||this;return i.v=null,i}return e(i,t),i.prototype._=function(t){this.v=t},i.prototype.u=function(t){if(null!==this.v&&0!==this.v.m.length&&null!==this.v.M){if(t.lineCap="butt",t.lineWidth=this.v.rt,s(t,this.v.ut),t.strokeStyle=this.We(t),t.lineJoin="round",t.beginPath(),1===this.v.m.length){var i=this.v.m[0];t.moveTo(i.p-this.v.Te/2,i.g),t.lineTo(i.p+this.v.Te/2,i.g)}else Xt(t,this.v.m,this.v.Le,this.v.M);t.stroke()}},i}(y),Qt=function(t){function i(){return null!==t&&t.apply(this,arguments)||this}return e(i,t),i.prototype.We=function(){return this.v.N},i}(Gt);function ti(t,i){return t.S<i}function ii(t,i){return t<i.S}function ni(t,i,n){var s=i.hh(),h=i.rh(),r=Bt(t,s,ti),e=Lt(t,h,ii);if(!n)return{from:r,to:e};var u=r,a=e;return r>0&&r<t.length&&t[r].S>=s&&(u=r-1),e>0&&e<t.length&&t[e-1].S<=h&&(a=e+1),{from:u,to:a}}var si=function(){function t(t,i,n){this.ze=!0,this.Pe=!0,this.Re=!0,this.Ie=[],this.je=null,this.qe=t,this.Ue=i,this.He=n}return t.prototype.O=function(t){this.ze=!0,"data"===t&&(this.Pe=!0),"options"===t&&(this.Re=!0)},t.prototype.Ye=function(){this.Pe&&(this.Ke(),this.Pe=!1),this.ze&&(this.$e(),this.ze=!1),this.Re&&(this.Xe(),this.Re=!1)},t.prototype.Ze=function(){this.je=null},t.prototype.$e=function(){var t=this.qe.$(),i=this.Ue.j();if(this.Ze(),!i.ti()&&!t.ti()){var n=i.mr();if(null!==n&&0!==this.qe.Hi().Je()){var s=this.qe.H();null!==s&&(this.je=ni(this.Ie,n,this.He),this.Ge(t,i,s.X))}}},t}(),hi=function(t){function i(i,n){return t.call(this,i,n,!0)||this}return e(i,t),i.prototype.Ge=function(t,i,n){i.Lr(this.Ie,p(this.je)),t.Ss(this.Ie,n,p(this.je))},i.prototype.Qe=function(t,i){return{S:t,D:i,p:NaN,g:NaN}},i.prototype.Xe=function(){},i.prototype.Ke=function(){var t=this,i=this.qe.tu();this.Ie=this.qe.Hi().iu().map((function(n){var s=n.X[3];return t.nu(n.Ph,s,i)}))},i}(si),ri=function(t){function i(i,n){var s=t.call(this,i,n)||this;return s.ot=new g,s.su=new Jt,s.hu=new Qt,s.ot.i([s.su,s.hu]),s}return e(i,t),i.prototype.P=function(t,i){if(!this.qe.U())return null;var n=this.qe.ct();return this.Ye(),this.su._({Le:n.lineType,m:this.Ie,ut:n.lineStyle,rt:n.lineWidth,Ve:n.topColor,Oe:n.bottomColor,Be:t,Ee:t,M:this.je,Te:this.Ue.j().Wr()}),this.hu._({Le:n.lineType,m:this.Ie,N:n.lineColor,ut:n.lineStyle,rt:n.lineWidth,M:this.je,Te:this.Ue.j().Wr()}),this.ot},i.prototype.nu=function(t,i){return this.Qe(t,i)},i}(hi);var ei=function(){function t(){this.tt=null,this.ru=0,this.eu=0}return t.prototype._=function(t){this.tt=t},t.prototype.h=function(t,i,n,s){if(null!==this.tt&&0!==this.tt.Hi.length&&null!==this.tt.M){if(this.ru=this.uu(i),this.ru>=2)Math.max(1,Math.floor(i))%2!=this.ru%2&&this.ru--;this.eu=this.tt.au?Math.min(this.ru,Math.floor(i)):this.ru;for(var h=null,r=this.eu<=this.ru&&this.tt.Wr>=Math.floor(1.5*i),e=this.tt.M.from;e<this.tt.M.to;++e){var u=this.tt.Hi[e];h!==u.et&&(t.fillStyle=u.et,h=u.et);var a=Math.floor(.5*this.eu),o=Math.round(u.p*i),l=o-a,f=this.eu,c=l+f-1,v=Math.min(u.Bs,u.Ls),_=Math.max(u.Bs,u.Ls),d=Math.round(v*i)-a,w=Math.round(_*i)+a,M=Math.max(w-d,this.eu);t.fillRect(l,d,f,M);var b=Math.ceil(1.5*this.ru);if(r){if(this.tt.ou){var m=o-b,p=Math.max(d,Math.round(u.Ts*i)-a),g=p+f-1;g>d+M-1&&(p=(g=d+M-1)-f+1),t.fillRect(m,p,l-m,g-p+1)}var y=o+b,k=Math.max(d,Math.round(u.Fs*i)-a),C=k+f-1;C>d+M-1&&(k=(C=d+M-1)-f+1),t.fillRect(c+1,k,y-c,C-k+1)}}}},t.prototype.uu=function(t){var i=Math.floor(t);return Math.max(i,Math.floor(function(t,i){return Math.floor(.3*t*i)}(f(this.tt).Wr,t)))},t}(),ui=function(t){function i(i,n){return t.call(this,i,n,!1)||this}return e(i,t),i.prototype.Ge=function(t,i,n){i.Lr(this.Ie,p(this.je)),t.As(this.Ie,n,p(this.je))},i.prototype.lu=function(t,i,n){return{S:t,open:i.X[0],high:i.X[1],low:i.X[2],close:i.X[3],p:NaN,Ts:NaN,Bs:NaN,Ls:NaN,Fs:NaN}},i.prototype.Ke=function(){var t=this,i=this.qe.tu();this.Ie=this.qe.Hi().iu().map((function(n){return t.nu(n.Ph,n,i)}))},i}(si),ai=function(t){function i(){var i=null!==t&&t.apply(this,arguments)||this;return i.ot=new ei,i}return e(i,t),i.prototype.P=function(t,i){if(!this.qe.U())return null;var n=this.qe.ct();this.Ye();var s={Hi:this.Ie,Wr:this.Ue.j().Wr(),ou:n.openVisible,au:n.thinBars,M:this.je};return this.ot._(s),this.ot},i.prototype.Xe=function(){var t=this;this.Ie.forEach((function(i){i.et=t.qe.tu().cu(i.S).fu}))},i.prototype.nu=function(t,i,n){return u(u({},this.lu(t,i,n)),{et:n.cu(t).fu})},i}(ui),oi=function(t){function i(){return null!==t&&t.apply(this,arguments)||this}return e(i,t),i.prototype.Fe=function(t){var i=this.v,n=t.createLinearGradient(0,0,0,i.Ee),s=st(i.Be/i.Ee,0,1);return n.addColorStop(0,i.vu),n.addColorStop(s,i._u),n.addColorStop(s,i.du),n.addColorStop(1,i.wu),n},i}(Zt),li=function(t){function i(){return null!==t&&t.apply(this,arguments)||this}return e(i,t),i.prototype.We=function(t){var i=this.v,n=t.createLinearGradient(0,0,0,i.Ee),s=st(i.Be/i.Ee,0,1);return n.addColorStop(0,i.Ve),n.addColorStop(s,i.Ve),n.addColorStop(s,i.Oe),n.addColorStop(1,i.Oe),n},i}(Gt),fi=function(t){function i(i,n){var s=t.call(this,i,n)||this;return s.Mu=new oi,s.bu=new li,s.A=new g,s.A.i([s.Mu,s.bu]),s}return e(i,t),i.prototype.P=function(t,i){if(!this.qe.U())return null;var n=this.qe.H();if(null===n)return null;var s=this.qe.ct();this.Ye();var h=this.qe.$().K(s.baseValue.price,n.X),r=this.Ue.j().Wr();return this.Mu._({m:this.Ie,vu:s.topFillColor1,_u:s.topFillColor2,du:s.bottomFillColor1,wu:s.bottomFillColor2,rt:s.lineWidth,ut:s.lineStyle,Le:0,Be:h,Ee:t,M:this.je,Te:r}),this.bu._({m:this.Ie,Ve:s.topLineColor,Oe:s.bottomLineColor,rt:s.lineWidth,ut:s.lineStyle,Le:0,Be:h,Ee:t,M:this.je,Te:r}),this.A},i.prototype.nu=function(t,i){return this.Qe(t,i)},i}(hi),ci=function(){function t(){this.tt=null,this.ru=0}return t.prototype._=function(t){this.tt=t},t.prototype.h=function(t,i,n,s){if(null!==this.tt&&0!==this.tt.Hi.length&&null!==this.tt.M){if(this.ru=function(t,i){if(t>=2.5&&t<=4)return Math.floor(3*i);var n=1-.2*Math.atan(Math.max(4,t)-4)/(.5*Math.PI),s=Math.floor(t*n*i),h=Math.floor(t*i),r=Math.min(s,h);return Math.max(Math.floor(i),r)}(this.tt.Wr,i),this.ru>=2)Math.floor(i)%2!=this.ru%2&&this.ru--;var h=this.tt.Hi;this.tt.mu&&this.pu(t,h,this.tt.M,i),this.tt.gu&&this.yu(t,h,this.tt.M,this.tt.Wr,i);var r=this.ku(i);(!this.tt.gu||this.ru>2*r)&&this.Cu(t,h,this.tt.M,i)}},t.prototype.pu=function(t,i,n,s){if(null!==this.tt){var h="",r=Math.min(Math.floor(s),Math.floor(this.tt.Wr*s));r=Math.max(Math.floor(s),Math.min(r,this.ru));for(var e=Math.floor(.5*r),u=null,a=n.from;a<n.to;a++){var o=i[a];o.Nu!==h&&(t.fillStyle=o.Nu,h=o.Nu);var l=Math.round(Math.min(o.Ts,o.Fs)*s),f=Math.round(Math.max(o.Ts,o.Fs)*s),c=Math.round(o.Bs*s),v=Math.round(o.Ls*s),_=Math.round(s*o.p)-e,d=_+r-1;null!==u&&(_=Math.max(u+1,_),_=Math.min(_,d));var w=d-_+1;t.fillRect(_,c,w,l-c),t.fillRect(_,f+1,w,v-f),u=d}}},t.prototype.ku=function(t){var i=Math.floor(1*t);this.ru<=2*i&&(i=Math.floor(.5*(this.ru-1)));var n=Math.max(Math.floor(t),i);return this.ru<=2*n?Math.max(Math.floor(t),Math.floor(1*t)):n},t.prototype.yu=function(t,i,n,s,h){if(null!==this.tt)for(var r="",e=this.ku(h),u=null,a=n.from;a<n.to;a++){var o=i[a];o.Z!==r&&(t.fillStyle=o.Z,r=o.Z);var l=Math.round(o.p*h)-Math.floor(.5*this.ru),f=l+this.ru-1,c=Math.round(Math.min(o.Ts,o.Fs)*h),v=Math.round(Math.max(o.Ts,o.Fs)*h);if(null!==u&&(l=Math.max(u+1,l),l=Math.min(l,f)),this.tt.Wr*h>2*e)z(t,l,c,f-l+1,v-c+1,e);else{var _=f-l+1;t.fillRect(l,c,_,v-c+1)}u=f}},t.prototype.Cu=function(t,i,n,s){if(null!==this.tt)for(var h="",r=this.ku(s),e=n.from;e<n.to;e++){var u=i[e],a=Math.round(Math.min(u.Ts,u.Fs)*s),o=Math.round(Math.max(u.Ts,u.Fs)*s),l=Math.round(u.p*s)-Math.floor(.5*this.ru),f=l+this.ru-1;if(u.et!==h){var c=u.et;t.fillStyle=c,h=c}this.tt.gu&&(l+=r,a+=r,f-=r,o-=r),a>o||t.fillRect(l,a,f-l+1,o-a+1)}},t}(),vi=function(t){function i(){var i=null!==t&&t.apply(this,arguments)||this;return i.ot=new ci,i}return e(i,t),i.prototype.P=function(t,i){if(!this.qe.U())return null;var n=this.qe.ct();this.Ye();var s={Hi:this.Ie,Wr:this.Ue.j().Wr(),mu:n.wickVisible,gu:n.borderVisible,M:this.je};return this.ot._(s),this.ot},i.prototype.Xe=function(){var t=this;this.Ie.forEach((function(i){var n=t.qe.tu().cu(i.S);i.et=n.fu,i.Nu=n.xu,i.Z=n.Su}))},i.prototype.nu=function(t,i,n){var s=n.cu(t);return u(u({},this.lu(t,i,n)),{et:s.fu,Nu:s.xu,Z:s.Su})},i}(ui),_i=function(){function t(){this.tt=null,this.Du=[]}return t.prototype._=function(t){this.tt=t,this.Du=[]},t.prototype.h=function(t,i,n,s){if(null!==this.tt&&0!==this.tt.m.length&&null!==this.tt.M){this.Du.length||this.Au(i);for(var h=Math.max(1,Math.floor(i)),r=Math.round(this.tt.Tu*i)-Math.floor(h/2),e=r+h,u=this.tt.M.from;u<this.tt.M.to;u++){var a=this.tt.m[u],o=this.Du[u-this.tt.M.from],l=Math.round(a.g*i);t.fillStyle=a.et;var f=void 0,c=void 0;l<=r?(f=l,c=e):(f=r,c=l-Math.floor(h/2)+h),t.fillRect(o.hh,f,o.rh-o.hh+1,c-f)}}},t.prototype.Au=function(t){if(null!==this.tt&&0!==this.tt.m.length&&null!==this.tt.M){var i=Math.ceil(this.tt.Wr*t)<=1?0:Math.max(1,Math.floor(t)),n=Math.round(this.tt.Wr*t)-i;this.Du=new Array(this.tt.M.to-this.tt.M.from);for(var s=this.tt.M.from;s<this.tt.M.to;s++){var h,r=this.tt.m[s],e=Math.round(r.p*t),u=void 0,a=void 0;if(n%2)u=e-(h=(n-1)/2),a=e+h;else u=e-(h=n/2),a=e+h-1;this.Du[s-this.tt.M.from]={hh:u,rh:a,Bu:e,Lu:r.p*t,S:r.S}}for(s=this.tt.M.from+1;s<this.tt.M.to;s++){var o=this.Du[s-this.tt.M.from],l=this.Du[s-this.tt.M.from-1];o.S===l.S+1&&(o.hh-l.rh!==i+1&&(l.Bu>l.Lu?l.rh=o.hh-i-1:o.hh=l.rh+i+1))}var f=Math.ceil(this.tt.Wr*t);for(s=this.tt.M.from;s<this.tt.M.to;s++){(o=this.Du[s-this.tt.M.from]).rh<o.hh&&(o.rh=o.hh);var c=o.rh-o.hh+1;f=Math.min(c,f)}if(i>0&&f<4)for(s=this.tt.M.from;s<this.tt.M.to;s++){(c=(o=this.Du[s-this.tt.M.from]).rh-o.hh+1)>f&&(o.Bu>o.Lu?o.rh-=1:o.hh+=1)}}else this.Du=[]},t}();function di(t){return{m:[],Wr:t,Tu:NaN,M:null}}function wi(t,i,n){return{S:t,D:i,p:NaN,g:NaN,et:n}}var Mi=function(t){function i(i,n){var s=t.call(this,i,n,!1)||this;return s.A=new g,s.Fu=di(0),s.ot=new _i,s}return e(i,t),i.prototype.P=function(t,i){return this.qe.U()?(this.Ye(),this.A):null},i.prototype.Ke=function(){var t=this.Ue.j().Wr();this.Fu=di(t);for(var i=0,n=0,s=this.qe.ct().color,h=0,r=this.qe.Hi().iu();h<r.length;h++){var e=r[h],u=e.X[3],a=void 0!==e.et?e.et:s,o=wi(e.Ph,u,a);++i<this.Fu.m.length?this.Fu.m[i]=o:this.Fu.m.push(o),this.Ie[n++]={S:e.Ph,p:0}}this.ot._(this.Fu),this.A.i([this.ot])},i.prototype.Xe=function(){},i.prototype.Ze=function(){t.prototype.Ze.call(this),this.Fu.M=null},i.prototype.Ge=function(t,i,n){if(null!==this.je){var s=i.Wr(),h=f(i.mr()),r=t.K(this.qe.ct().base,n);i.Lr(this.Fu.m),t.Ss(this.Fu.m,n),this.Fu.Tu=r,this.Fu.M=ni(this.Fu.m,h,!1),this.Fu.Wr=s,this.ot._(this.Fu)}},i}(si),bi=function(t){function i(i,n){var s=t.call(this,i,n)||this;return s.hu=new Qt,s}return e(i,t),i.prototype.P=function(t,i){if(!this.qe.U())return null;var n=this.qe.ct();this.Ye();var s={m:this.Ie,N:n.color,ut:n.lineStyle,Le:n.lineType,rt:n.lineWidth,M:this.je,Te:this.Ue.j().Wr()};return this.hu._(s),this.hu},i.prototype.nu=function(t,i){return this.Qe(t,i)},i}(hi),mi=/[2-9]/g,pi=function(){function t(t){void 0===t&&(t=50),this.kh=new Map,this.Eu=0,this.Vu=Array.from(new Array(t))}return t.prototype.Ou=function(){this.kh.clear(),this.Vu.fill(void 0)},t.prototype.Vt=function(t,i,n){var s=n||mi,h=String(i).replace(s,"0"),r=this.kh.get(h);if(void 0===r){if(0===(r=t.measureText(h).width)&&0!==i.length)return 0;var e=this.Vu[this.Eu];void 0!==e&&this.kh.delete(e),this.Vu[this.Eu]=h,this.Eu=(this.Eu+1)%this.Vu.length,this.kh.set(h,r)}return r},t}(),gi=function(){function t(t){this.Wu=null,this.oe=null,this.zu="right",this.$h=0,this.Pu=t}return t.prototype.Ru=function(t,i,n,s){this.Wu=t,this.oe=i,this.$h=n,this.zu=s},t.prototype.h=function(t,i){null!==this.oe&&null!==this.Wu&&this.Wu.h(t,this.oe,this.Pu,this.$h,this.zu,i)},t}(),yi=function(){function t(t,i,n){this.Iu=t,this.Pu=new pi(50),this.ju=i,this.F=n,this.fe=-1,this.ot=new gi(this.Pu)}return t.prototype.P=function(t,i){var n=this.F.qu(this.ju);if(null===n)return null;var s=n.Uu(this.ju)?n.xi():this.ju.$();if(null===s)return null;var h=n.Hu(s);if("overlay"===h)return null;var r=this.F.Yu();return r.Wt!==this.fe&&(this.fe=r.Wt,this.Pu.Ou()),this.ot.Ru(this.Iu.Zt(),r,i,h),this.ot},t}(),ki=function(){function t(){this.tt=null}return t.prototype._=function(t){this.tt=t},t.prototype.h=function(t,i,n,r){if(null!==this.tt&&!1!==this.tt.U){var e=Math.round(this.tt.g*i);if(!(e<0||e>Math.ceil(this.tt.Mt*i))){var u=Math.ceil(this.tt.wt*i);t.lineCap="butt",t.strokeStyle=this.tt.et,t.lineWidth=Math.floor(this.tt.rt*i),s(t,this.tt.ut),h(t,e,0,u)}}},t}(),Ci=function(){function t(t){this.Ku={wt:0,Mt:0,g:0,et:"rgba(0, 0, 0, 0)",rt:1,ut:0,U:!1},this.$u=new ki,this.L=!0,this.qe=t,this.Ue=t.vt(),this.$u._(this.Ku)}return t.prototype.O=function(){this.L=!0},t.prototype.P=function(t,i){return this.qe.U()?(this.L&&(this.Xu(t,i),this.L=!1),this.$u):null},t}(),Ni=function(t){function i(i){return t.call(this,i)||this}return e(i,t),i.prototype.Xu=function(t,i){this.Ku.U=!1;var n=this.qe.$(),s=n.os().os;if(2===s||3===s){var h=this.qe.ct();if(h.baseLineVisible&&this.qe.U()){var r=this.qe.H();null!==r&&(this.Ku.U=!0,this.Ku.g=n.K(r.X,r.X),this.Ku.wt=i,this.Ku.Mt=t,this.Ku.et=h.baseLineColor,this.Ku.rt=h.baseLineWidth,this.Ku.ut=h.baseLineStyle)}}},i}(Ci),xi=function(){function t(){this.tt=null}return t.prototype._=function(t){this.tt=t},t.prototype.Zu=function(){return this.tt},t.prototype.h=function(t,i,n,s){var h=this.tt;if(null!==h){t.save();var r=Math.max(1,Math.floor(i)),e=r%2/2,u=Math.round(h.Lu.x*i)+e,a=h.Lu.y*i;t.fillStyle=h.Ju,t.beginPath();var o=Math.max(2,1.5*h.Gu)*i;t.arc(u,a,o,0,2*Math.PI,!1),t.fill(),t.fillStyle=h.Qu,t.beginPath(),t.arc(u,a,h.C*i,0,2*Math.PI,!1),t.fill(),t.lineWidth=r,t.strokeStyle=h.ta,t.beginPath(),t.arc(u,a,h.C*i+r/2,0,2*Math.PI,!1),t.stroke(),t.restore()}},t}(),Si=[{ia:0,na:.25,sa:4,ha:10,ra:.25,ea:0,ua:.4,aa:.8},{ia:.25,na:.525,sa:10,ha:14,ra:0,ea:0,ua:.8,aa:0},{ia:.525,na:1,sa:14,ha:14,ra:0,ea:0,ua:0,aa:0}];function Di(t,i,n,s){return function(t,i){if("transparent"===t)return t;var n=O(t),s=n[3];return"rgba("+n[0]+", "+n[1]+", "+n[2]+", "+i*s+")"}(t,n+(s-n)*i)}function Ai(t,i){for(var n,s=t%2600/2600,h=0,r=Si;h<r.length;h++){var e=r[h];if(s>=e.ia&&s<=e.na){n=e;break}}o(void 0!==n,"Last price animation internal logic error");var u,a,l,f=(s-n.ia)/(n.na-n.ia);return{Qu:Di(i,f,n.ra,n.ea),ta:Di(i,f,n.ua,n.aa),C:(u=f,a=n.sa,l=n.ha,a+(l-a)*u)}}var Ti=function(){function t(t){this.ot=new xi,this.L=!0,this.oa=!0,this.la=performance.now(),this.fa=this.la-1,this.ca=t}return t.prototype.O=function(t){if(this.L=!0,"data"===t&&2===this.ca.ct().lastPriceAnimation){var i=performance.now(),n=this.fa-i;if(n>0)return void(n<650&&(this.fa+=2600));this.la=i,this.fa=i+2600}},t.prototype.va=function(){this.oa=!0},t.prototype.U=function(){return 0!==this.ca.ct().lastPriceAnimation},t.prototype._a=function(){switch(this.ca.ct().lastPriceAnimation){case 0:return!1;case 1:return!0;case 2:return performance.now()<=this.fa}},t.prototype.P=function(t,i){return this.L?(this.R(t,i),this.L=!1,this.oa=!1):this.oa&&(this.da(),this.oa=!1),this.ot},t.prototype.R=function(t,i){this.ot._(null);var n=this.ca.vt().j(),s=n.mr(),h=this.ca.H();if(null!==s&&null!==h){var r=this.ca.wa(!0);if(!r.Ma&&s.Eh(r.Ph)){var e={x:n.G(r.Ph),y:this.ca.$().K(r.D,h.X)},u=r.et,a=this.ca.ct().lineWidth,o=Ai(this.ba(),u);this.ot._({Ju:u,Gu:a,Qu:o.Qu,ta:o.ta,C:o.C,Lu:e})}}},t.prototype.da=function(){var t=this.ot.Zu();if(null!==t){var i=Ai(this.ba(),t.Ju);t.Qu=i.Qu,t.ta=i.ta,t.C=i.C}},t.prototype.ba=function(){return this._a()?performance.now()-this.la:2599},t}();function Bi(t,i){return ut(Math.min(Math.max(t,12),30)*i)}function Li(t,i){switch(t){case"arrowDown":case"arrowUp":return Bi(i,1);case"circle":return Bi(i,.8);case"square":return Bi(i,.7)}}function Fi(t){return et(Bi(t,1))}function Ei(t){return Math.max(Bi(t,.1),3)}function Vi(t,i,n,s,h){var r=Li("square",n),e=(r-1)/2,u=t-e,a=i-e;return s>=u&&s<=u+r&&h>=a&&h<=a+r}function Oi(t,i,n,s,h){var r=(Li("arrowUp",h)-1)/2,e=(ut(h/2)-1)/2;i.beginPath(),t?(i.moveTo(n-r,s),i.lineTo(n,s-r),i.lineTo(n+r,s),i.lineTo(n+e,s),i.lineTo(n+e,s+r),i.lineTo(n-e,s+r),i.lineTo(n-e,s)):(i.moveTo(n-r,s),i.lineTo(n,s+r),i.lineTo(n+r,s),i.lineTo(n+e,s),i.lineTo(n+e,s-r),i.lineTo(n-e,s-r),i.lineTo(n-e,s)),i.fill()}function Wi(t,i,n,s,h,r){return Vi(i,n,s,h,r)}var zi=function(t){function i(){var i=null!==t&&t.apply(this,arguments)||this;return i.tt=null,i.Pu=new pi,i.fe=-1,i.ce="",i.ma="",i}return e(i,t),i.prototype._=function(t){this.tt=t},i.prototype.Ru=function(t,i){this.fe===t&&this.ce===i||(this.fe=t,this.ce=i,this.ma=Ut(t,i),this.Pu.Ou())},i.prototype.pa=function(t,i){if(null===this.tt||null===this.tt.M)return null;for(var n=this.tt.M.from;n<this.tt.M.to;n++){var s=this.tt.m[n];if(Ri(s,t,i))return{ga:s.ya,ka:s.ka}}return null},i.prototype.u=function(t,i,n){if(null!==this.tt&&null!==this.tt.M){t.textBaseline="middle",t.font=this.ma;for(var s=this.tt.M.from;s<this.tt.M.to;s++){var h=this.tt.m[s];void 0!==h.Et&&(h.Et.wt=this.Pu.Vt(t,h.Et.Ca),h.Et.Mt=this.fe),Pi(h,t)}}},i}(y);function Pi(t,i){i.fillStyle=t.et,void 0!==t.Et&&function(t,i,n,s){t.fillText(i,n,s)}(i,t.Et.Ca,t.p-t.Et.wt/2,t.Et.g),function(t,i){if(0===t.Je)return;switch(t.Na){case"arrowDown":return void Oi(!1,i,t.p,t.g,t.Je);case"arrowUp":return void Oi(!0,i,t.p,t.g,t.Je);case"circle":return void function(t,i,n,s){var h=(Li("circle",s)-1)/2;t.beginPath(),t.arc(i,n,h,0,2*Math.PI,!1),t.fill()}(i,t.p,t.g,t.Je);case"square":return void function(t,i,n,s){var h=Li("square",s),r=(h-1)/2,e=i-r,u=n-r;t.fillRect(e,u,h,h)}(i,t.p,t.g,t.Je)}t.Na}(t,i)}function Ri(t,i,n){return!(void 0===t.Et||!function(t,i,n,s,h,r){var e=s/2;return h>=t&&h<=t+n&&r>=i-e&&r<=i+e}(t.p,t.Et.g,t.Et.wt,t.Et.Mt,i,n))||function(t,i,n){if(0===t.Je)return!1;switch(t.Na){case"arrowDown":case"arrowUp":return Wi(0,t.p,t.g,t.Je,i,n);case"circle":return function(t,i,n,s,h){var r=2+Li("circle",n)/2,e=t-s,u=i-h;return Math.sqrt(e*e+u*u)<=r}(t.p,t.g,t.Je,i,n);case"square":return Vi(t.p,t.g,t.Je,i,n)}}(t,i,n)}function Ii(t,i,n,s,h,r,e,u,a){var o=_(n)?n:n.close,l=_(n)?n:n.high,f=_(n)?n:n.low,c=_(i.size)?Math.max(i.size,0):1,v=Fi(u.Wr())*c,d=v/2;switch(t.Je=v,i.position){case"inBar":return t.g=e.K(o,a),void(void 0!==t.Et&&(t.Et.g=t.g+d+r+.6*h));case"aboveBar":return t.g=e.K(l,a)-d-s.xa,void 0!==t.Et&&(t.Et.g=t.g-d-.6*h,s.xa+=1.2*h),void(s.xa+=v+r);case"belowBar":return t.g=e.K(f,a)+d+s.Sa,void 0!==t.Et&&(t.Et.g=t.g+d+r+.6*h,s.Sa+=1.2*h),void(s.Sa+=v+r)}i.position}var ji=function(){function t(t,i){this.L=!0,this.Da=!0,this.Aa=!0,this.Ta=null,this.ot=new zi,this.ca=t,this.hi=i,this.tt={m:[],M:null}}return t.prototype.O=function(t){this.L=!0,this.Aa=!0,"data"===t&&(this.Da=!0)},t.prototype.P=function(t,i,n){if(!this.ca.U())return null;this.L&&this.Ye();var s=this.hi.ct().layout;return this.ot.Ru(s.fontSize,s.fontFamily),this.ot._(this.tt),this.ot},t.prototype.Ba=function(){if(this.Aa){if(this.ca.La().length>0){var t=this.hi.j().Wr(),i=Ei(t),n=1.5*Fi(t)+2*i;this.Ta={above:n,below:n}}else this.Ta=null;this.Aa=!1}return this.Ta},t.prototype.Ye=function(){var t=this.ca.$(),i=this.hi.j(),n=this.ca.La();this.Da&&(this.tt.m=n.map((function(t){return{S:t.time,p:0,g:0,Je:0,Na:t.shape,et:t.color,ya:t.ya,ka:t.id,Et:void 0}})),this.Da=!1);var s=this.hi.ct().layout;this.tt.M=null;var h=i.mr();if(null!==h){var r=this.ca.H();if(null!==r&&0!==this.tt.m.length){var e=NaN,u=Ei(i.Wr()),a={xa:u,Sa:u};this.tt.M=ni(this.tt.m,h,!0);for(var o=this.tt.M.from;o<this.tt.M.to;o++){var l=n[o];l.time!==e&&(a.xa=u,a.Sa=u,e=l.time);var f=this.tt.m[o];f.p=i.G(l.time),void 0!==l.text&&l.text.length>0&&(f.Et={Ca:l.text,g:0,wt:0,Mt:0});var c=this.ca.Fa(l.time);null!==c&&Ii(f,l,c,a,s.fontSize,u,t,i,r.X)}this.L=!1}}},t}(),qi=function(t){function i(i){return t.call(this,i)||this}return e(i,t),i.prototype.Xu=function(t,i){var n=this.Ku;n.U=!1;var s=this.qe.ct();if(s.priceLineVisible&&this.qe.U()){var h=this.qe.wa(0===s.priceLineSource);h.Ma||(n.U=!0,n.g=h.zt,n.et=this.qe.Ea(h.et),n.wt=i,n.Mt=t,n.rt=s.priceLineWidth,n.ut=s.priceLineStyle)}},i}(Ci),Ui=function(t){function i(i){var n=t.call(this)||this;return n.lt=i,n}return e(i,t),i.prototype.Jt=function(t,i,n){t.U=!1,i.U=!1;var s=this.lt;if(s.U()){var h=s.ct(),r=h.lastValueVisible,e=""!==s.Va(),u=0===h.seriesLastValueMode,a=s.wa(!1);if(!a.Ma){r&&(t.Et=this.Oa(a,r,u),t.U=0!==t.Et.length),(e||u)&&(i.Et=this.Wa(a,r,e,u),i.U=i.Et.length>0);var o=s.Ea(a.et),l=W(o);n.yt=l.yt,n.et=l.kt,n.zt=a.zt,i.Z=s.vt().J(a.zt/s.$().Mt()),t.Z=o}}},i.prototype.Wa=function(t,i,n,s){var h="",r=this.lt.Va();return n&&0!==r.length&&(h+=r+" "),i&&s&&(h+=this.lt.$().cs()?t.za:t.Pa),h.trim()},i.prototype.Oa=function(t,i,n){return i?n?this.lt.$().cs()?t.Pa:t.za:t.Et:""},i}(U),Hi=function(){function t(t,i){this.On=t,this.Ra=i||null}return t.prototype.Cs=function(){return this.On},t.prototype.eh=function(){return this.Ra},t.prototype.Mn=function(){return null===this.On?null:{priceRange:this.On.Mn(),margins:this.Ra||void 0}},t.bn=function(i){return null===i?null:new t(nt.bn(i.priceRange),i.margins)},t}(),Yi=function(t){function i(i,n){var s=t.call(this,i)||this;return s.Ia=n,s}return e(i,t),i.prototype.Xu=function(t,i){var n=this.Ku;if(n.U=!1,this.qe.U()){var s=this.Ia.ja();if(null!==s){var h=this.Ia.ct();n.U=!0,n.g=s,n.et=h.color,n.wt=i,n.Mt=t,n.rt=h.lineWidth,n.ut=h.lineStyle}}},i}(Ci),Ki=function(t){function i(i,n){var s=t.call(this)||this;return s.ca=i,s.Ia=n,s}return e(i,t),i.prototype.Jt=function(t,i,n){t.U=!1,i.U=!1;var s=this.Ia.ct(),h=s.axisLabelVisible,r=""!==s.title,e=this.ca;if(h&&e.U()){var u=this.Ia.ja();if(null!==u){r&&(i.Et=s.title,i.U=!0),i.Z=e.vt().J(u/e.$().Mt()),t.Et=e.$().Zs(s.price),t.U=!0;var a=W(s.color);n.yt=a.yt,n.et=a.kt,n.zt=u}}},i}(U),$i=function(){function t(t,i){this.ca=t,this.ki=i,this.qa=new Yi(t,this),this.Iu=new Ki(t,this),this.Ua=new yi(this.Iu,t,t.vt())}return t.prototype.rs=function(t){v(this.ki,t),this.O(),this.ca.vt().Or()},t.prototype.ct=function(){return this.ki},t.prototype.zi=function(){return[this.qa,this.Ua]},t.prototype.Ha=function(){return this.Iu},t.prototype.O=function(){this.qa.O(),this.Iu.O()},t.prototype.ja=function(){var t=this.ca,i=t.$();if(t.vt().j().ti()||i.ti())return null;var n=t.H();return null===n?null:i.K(this.ki.price,n.X)},t}(),Xi=function(t){function i(i){var n=t.call(this)||this;return n.hi=i,n}return e(i,t),i.prototype.vt=function(){return this.hi},i}(X),Zi={fu:"",Su:"",xu:""},Ji=function(){function t(t){this.ca=t}return t.prototype.cu=function(t,i){var n=this.ca.Ya(),s=this.ca.ct();switch(n){case"Line":return this.Ka(s);case"Area":return this.$a(s);case"Baseline":return this.Xa(s,t,i);case"Bar":return this.Za(s,t,i);case"Candlestick":return this.Ja(s,t,i);case"Histogram":return this.Ga(s,t,i)}throw new Error("Unknown chart style")},t.prototype.Za=function(t,i,n){var s=u({},Zi),h=t.upColor,r=t.downColor,e=h,a=r,o=f(this.Qa(i,n)),l=c(o.X[0])<=c(o.X[3]);return s.fu=l?h:r,s.Su=l?e:a,s},t.prototype.Ja=function(t,i,n){var s=u({},Zi),h=t.upColor,r=t.downColor,e=t.borderUpColor,a=t.borderDownColor,o=t.wickUpColor,l=t.wickDownColor,v=f(this.Qa(i,n)),_=c(v.X[0])<=c(v.X[3]);return s.fu=_?h:r,s.Su=_?e:a,s.xu=_?o:l,s},t.prototype.$a=function(t){return u(u({},Zi),{fu:t.lineColor})},t.prototype.Xa=function(t,i,n){var s=f(this.Qa(i,n)).X[3]>=t.baseValue.price;return u(u({},Zi),{fu:s?t.topLineColor:t.bottomLineColor})},t.prototype.Ka=function(t){return u(u({},Zi),{fu:t.color})},t.prototype.Ga=function(t,i,n){var s=u({},Zi),h=f(this.Qa(i,n));return s.fu=void 0!==h.et?h.et:t.color,s},t.prototype.Qa=function(t,i){return void 0!==i?i.X:this.ca.Hi().io(t)},t}(),Gi=function(){function t(){this.no=[],this.so=new Map,this.ho=new Map}return t.prototype.ro=function(){return this.Je()>0?this.no[this.no.length-1]:null},t.prototype.eo=function(){return this.Je()>0?this.uo(0):null},t.prototype.Ui=function(){return this.Je()>0?this.uo(this.no.length-1):null},t.prototype.Je=function(){return this.no.length},t.prototype.ti=function(){return 0===this.Je()},t.prototype.Eh=function(t){return null!==this.ao(t,0)},t.prototype.io=function(t){return this.oo(t)},t.prototype.oo=function(t,i){void 0===i&&(i=0);var n=this.ao(t,i);return null===n?null:u(u({},this.lo(n)),{Ph:this.uo(n)})},t.prototype.iu=function(){return this.no},t.prototype.fo=function(t,i,n){if(this.ti())return null;for(var s=null,h=0,r=n;h<r.length;h++){var e=r[h];s=Qi(s,this.co(t,i,e))}return s},t.prototype._=function(t){this.ho.clear(),this.so.clear(),this.no=t},t.prototype.uo=function(t){return this.no[t].Ph},t.prototype.lo=function(t){return this.no[t]},t.prototype.ao=function(t,i){var n=this.vo(t);if(null===n&&0!==i)switch(i){case-1:return this._o(t);case 1:return this.do(t);default:throw new TypeError("Unknown search mode")}return n},t.prototype._o=function(t){var i=this.wo(t);return i>0&&(i-=1),i!==this.no.length&&this.uo(i)<t?i:null},t.prototype.do=function(t){var i=this.Mo(t);return i!==this.no.length&&t<this.uo(i)?i:null},t.prototype.vo=function(t){var i=this.wo(t);return i===this.no.length||t<this.no[i].Ph?null:i},t.prototype.wo=function(t){return Bt(this.no,t,(function(t,i){return t.Ph<i}))},t.prototype.Mo=function(t){return Lt(this.no,t,(function(t,i){return i.Ph>t}))},t.prototype.bo=function(t,i,n){for(var s=null,h=t;h<i;h++){var r=this.no[h].X[n];Number.isNaN(r)||(null===s?s={mo:r,po:r}:(r<s.mo&&(s.mo=r),r>s.po&&(s.po=r)))}return s},t.prototype.co=function(t,i,n){if(this.ti())return null;var s=null,h=f(this.eo()),r=f(this.Ui()),e=Math.max(t,h),u=Math.min(i,r),a=30*Math.ceil(e/30),o=Math.max(a,30*Math.floor(u/30)),l=this.wo(e),c=this.Mo(Math.min(u,a,i));s=Qi(s,this.bo(l,c,n));var v=this.so.get(n);void 0===v&&(v=new Map,this.so.set(n,v));for(var _=Math.max(a+1,e);_<o;_+=30){var d=Math.floor(_/30),w=v.get(d);if(void 0===w){var M=this.wo(30*d),b=this.Mo(30*(d+1)-1);w=this.bo(M,b,n),v.set(d,w)}s=Qi(s,w)}l=this.wo(o),c=this.Mo(u);return s=Qi(s,this.bo(l,c,n))},t}();function Qi(t,i){return null===t?i:null===i?t:{mo:Math.min(t.mo,i.mo),po:Math.max(t.po,i.po)}}var tn=function(t){function i(i,n,s){var h=t.call(this,i)||this;h.tt=new Gi,h.qa=new qi(h),h.yo=[],h.ko=new Ni(h),h.Co=null,h.No=null,h.xo=[],h.So=[],h.Do=null,h.ki=n,h.Ao=s;var r=new Ui(h);return h.Mi=[r],h.Ua=new yi(r,h,i),"Area"!==s&&"Line"!==s&&"Baseline"!==s||(h.Co=new Ti(h)),h.To(),h.Bo(),h}return e(i,t),i.prototype.en=function(){null!==this.Do&&clearTimeout(this.Do)},i.prototype.Ea=function(t){return this.ki.priceLineColor||t},i.prototype.wa=function(t){var i={Ma:!0},n=this.$();if(this.vt().j().ti()||n.ti()||this.tt.ti())return i;var s,h,r=this.vt().j().mr(),e=this.H();if(null===r||null===e)return i;if(t){var u=this.tt.ro();if(null===u)return i;s=u,h=u.Ph}else{var a=this.tt.oo(r.rh(),-1);if(null===a)return i;if(null===(s=this.tt.io(a.Ph)))return i;h=a.Ph}var o=s.X[3],l=this.tu().cu(h,{X:s}),f=n.K(o,e.X);return{Ma:!1,D:o,Et:n.ii(o,e.X),za:n.Zs(o),Pa:n.Gs(o,e.X),et:l.fu,zt:f,Ph:h}},i.prototype.tu=function(){return null!==this.No||(this.No=new Ji(this)),this.No},i.prototype.ct=function(){return this.ki},i.prototype.rs=function(t){var i=t.priceScaleId;void 0!==i&&i!==this.ki.priceScaleId&&this.vt().Lo(this,i),v(this.ki,t),null!==this.ui&&void 0!==t.scaleMargins&&this.ui.rs({scaleMargins:t.scaleMargins}),void 0!==t.priceFormat&&this.To(),this.vt().Fo(this),this.vt().Eo(),this.Ai.O("options")},i.prototype._=function(t){var i;this.tt._(t),this.Vo(),this.Ai.O("data"),this.Ci.O("data"),null===(i=this.Co)||void 0===i||i.O("data");var n=this.vt().qu(this);this.vt().Oo(n),this.vt().Fo(this),this.vt().Eo(),this.vt().Or()},i.prototype.Wo=function(t){this.xo=t.map((function(t){return u({},t)})),this.Vo();var i=this.vt().qu(this);this.Ci.O("data"),this.vt().Oo(i),this.vt().Fo(this),this.vt().Eo(),this.vt().Or()},i.prototype.La=function(){return this.So},i.prototype.zo=function(t){var i=new $i(this,t);return this.yo.push(i),this.vt().Fo(this),i},i.prototype.Po=function(t){var i=this.yo.indexOf(t);-1!==i&&this.yo.splice(i,1),this.vt().Fo(this)},i.prototype.Ya=function(){return this.Ao},i.prototype.H=function(){var t=this.Ro();return null===t?null:{X:t.X[3],Rs:t.S}},i.prototype.Ro=function(){var t=this.vt().j().mr();if(null===t)return null;var i=t.hh();return this.tt.oo(i,1)},i.prototype.Hi=function(){return this.tt},i.prototype.Fa=function(t){var i=this.tt.io(t);return null===i?null:"Bar"===this.Ao||"Candlestick"===this.Ao?{open:i.X[0],high:i.X[1],low:i.X[2],close:i.X[3]}:i.X[3]},i.prototype.Io=function(t){var i=this,n=this.Co;return null!==n&&n.U()?(null===this.Do&&n._a()&&(this.Do=setTimeout((function(){i.Do=null,i.vt().jo()}),0)),n.va(),[n]):[]},i.prototype.zi=function(){var t=[];this.qo()||t.push(this.ko);for(var i=0,n=this.yo;i<n.length;i++){var s=n[i];t.push.apply(t,s.zi())}return t.push(this.Ai,this.qa,this.Ua,this.Ci),t},i.prototype.Pi=function(t,i){if(i!==this.ui&&!this.qo())return[];for(var n=a([],this.Mi,!0),s=0,h=this.yo;s<h.length;s++){var r=h[s];n.push(r.Ha())}return n},i.prototype.sh=function(t,i){var n=this;if(void 0!==this.ki.autoscaleInfoProvider){var s=this.ki.autoscaleInfoProvider((function(){var s=n.Uo(t,i);return null===s?null:s.Mn()}));return Hi.bn(s)}return this.Uo(t,i)},i.prototype.ih=function(){return this.ki.priceFormat.minMove},i.prototype.$s=function(){return this.Zn},i.prototype.Ii=function(){var t;this.Ai.O(),this.Ci.O();for(var i=0,n=this.Mi;i<n.length;i++){n[i].O()}for(var s=0,h=this.yo;s<h.length;s++){h[s].O()}this.qa.O(),this.ko.O(),null===(t=this.Co)||void 0===t||t.O()},i.prototype.$=function(){return f(t.prototype.$.call(this))},i.prototype.q=function(t){if(!(("Line"===this.Ao||"Area"===this.Ao||"Baseline"===this.Ao)&&this.ki.crosshairMarkerVisible))return null;var i=this.tt.io(t);return null===i?null:{D:i.X[3],C:this.Ho(),Z:this.Yo(),Y:this.Ko(t)}},i.prototype.Va=function(){return this.ki.title},i.prototype.U=function(){return this.ki.visible},i.prototype.qo=function(){return!Yt(this.$().hs())},i.prototype.Uo=function(t,i){if(!d(t)||!d(i)||this.tt.ti())return null;var n="Line"===this.Ao||"Area"===this.Ao||"Baseline"===this.Ao||"Histogram"===this.Ao?[3]:[2,1],s=this.tt.fo(t,i,n),h=null!==s?new nt(s.mo,s.po):null;if("Histogram"===this.Ya()){var r=this.ki.base,e=new nt(r,r);h=null!==h?h._n(e):e}return new Hi(h,this.Ci.Ba())},i.prototype.Ho=function(){switch(this.Ao){case"Line":case"Area":case"Baseline":return this.ki.crosshairMarkerRadius}return 0},i.prototype.Yo=function(){switch(this.Ao){case"Line":case"Area":case"Baseline":var t=this.ki.crosshairMarkerBorderColor;if(0!==t.length)return t}return null},i.prototype.Ko=function(t){switch(this.Ao){case"Line":case"Area":case"Baseline":var i=this.ki.crosshairMarkerBackgroundColor;if(0!==i.length)return i}return this.tu().cu(t).fu},i.prototype.To=function(){switch(this.ki.priceFormat.type){case"custom":this.Zn={format:this.ki.priceFormat.formatter};break;case"volume":this.Zn=new $t(this.ki.priceFormat.precision);break;case"percent":this.Zn=new tt(this.ki.priceFormat.precision);break;default:var t=Math.pow(10,this.ki.priceFormat.precision);this.Zn=new Q(t,this.ki.priceFormat.minMove*t)}null!==this.ui&&this.ui.es()},i.prototype.Vo=function(){var t=this,i=this.vt().j();if(i.ti()||0===this.tt.Je())this.So=[];else{var n=f(this.tt.eo());this.So=this.xo.map((function(s,h){var r=f(i.br(s.time,!0)),e=r<n?1:-1;return{time:f(t.tt.oo(r,e)).Ph,position:s.position,shape:s.shape,color:s.color,id:s.id,ya:h,text:s.text,size:s.size}}))}},i.prototype.Bo=function(){switch(this.Ci=new ji(this,this.vt()),this.Ao){case"Bar":this.Ai=new ai(this,this.vt());break;case"Candlestick":this.Ai=new vi(this,this.vt());break;case"Line":this.Ai=new bi(this,this.vt());break;case"Area":this.Ai=new ri(this,this.vt());break;case"Baseline":this.Ai=new fi(this,this.vt());break;case"Histogram":this.Ai=new Mi(this,this.vt());break;default:throw Error("Unknown chart style assigned: "+this.Ao)}},i}(Xi),nn=function(){function t(t){this.ki=t}return t.prototype.$o=function(t,i,n){var s=t;if(0===this.ki.mode)return s;var h=n.xi(),r=h.H();if(null===r)return s;var e=h.K(t,r),u=n.Vs().filter((function(t){return t instanceof tn})).reduce((function(t,s){if(n.Uu(s)||!s.U())return t;var h=s.$(),r=s.Hi();if(h.ti()||!r.Eh(i))return t;var e=r.io(i);if(null===e)return t;var u=c(s.H());return t.concat([h.K(e.X[3],u.X)])}),[]);if(0===u.length)return s;u.sort((function(t,i){return Math.abs(t-e)-Math.abs(i-e)}));var a=u[0];return s=h.Si(a,r)},t}(),sn=function(){function t(){this.tt=null}return t.prototype._=function(t){this.tt=t},t.prototype.h=function(t,i,n,h){var r=this;if(null!==this.tt){var e=Math.max(1,Math.floor(i));t.lineWidth=e;var u=Math.ceil(this.tt.ht*i),a=Math.ceil(this.tt.st*i);!function(t,i){t.save(),t.lineWidth%2&&t.translate(.5,.5),i(),t.restore()}(t,(function(){var n=f(r.tt);if(n.Xo){t.strokeStyle=n.Zo,s(t,n.Jo),t.beginPath();for(var h=0,o=n.Go;h<o.length;h++){var l=o[h],c=Math.round(l.An*i);t.moveTo(c,-e),t.lineTo(c,u+e)}t.stroke()}if(n.Qo){t.strokeStyle=n.tl,s(t,n.il),t.beginPath();for(var v=0,_=n.nl;v<_.length;v++){var d=_[v],w=Math.round(d.An*i);t.moveTo(-e,w),t.lineTo(a+e,w)}t.stroke()}}))}},t}(),hn=function(){function t(t){this.ot=new sn,this.L=!0,this.vi=t}return t.prototype.O=function(){this.L=!0},t.prototype.P=function(t,i){if(this.L){var n=this.vi.vt().ct().grid,s={ht:t,st:i,Qo:n.horzLines.visible,Xo:n.vertLines.visible,tl:n.horzLines.color,Zo:n.vertLines.color,il:n.horzLines.style,Jo:n.vertLines.style,nl:this.vi.xi().Fn(),Go:this.vi.vt().j().Fn()||[]};this.ot._(s),this.L=!1}return this.ot},t}(),rn=function(){function t(t){this.Ai=new hn(t)}return t.prototype.sl=function(){return this.Ai},t}(),en=function(){function t(t,i){this.Hn=[],this.hl=new Map,this.En=0,this.$h=0,this.rl=1e3,this.Yn=null,this.el=new it,this.ul=t,this.hi=i,this.al=new rn(this);var n=i.ct();this.ol=this.ll("left",n.leftPriceScale),this.fl=this.ll("right",n.rightPriceScale),this.ol.bs().Ji(this.cl.bind(this,this.ol),this),this.fl.bs().Ji(this.cl.bind(this,this.ol),this),this.vl(n)}return t.prototype.vl=function(t){if(t.leftPriceScale&&this.ol.rs(t.leftPriceScale),t.rightPriceScale&&this.fl.rs(t.rightPriceScale),t.localization&&(this.ol.es(),this.fl.es()),t.overlayPriceScales)for(var i=0,n=Array.from(this.hl.values());i<n.length;i++){var s=f(n[i][0].$());s.rs(t.overlayPriceScales),t.localization&&s.es()}},t.prototype._l=function(t){switch(t){case"left":return this.ol;case"right":return this.fl}return this.hl.has(t)?l(this.hl.get(t))[0].$():null},t.prototype.en=function(){this.vt().dl().sn(this),this.ol.bs().sn(this),this.fl.bs().sn(this),this.Hn.forEach((function(t){t.en&&t.en()})),this.el.hn()},t.prototype.wl=function(){return this.rl},t.prototype.Ml=function(t){this.rl=t},t.prototype.vt=function(){return this.hi},t.prototype.wt=function(){return this.$h},t.prototype.Mt=function(){return this.En},t.prototype.Dr=function(t){this.$h=t,this.bl()},t.prototype.ps=function(t){var i=this;this.En=t,this.ol.ps(t),this.fl.ps(t),this.Hn.forEach((function(n){if(i.Uu(n)){var s=n.$();null!==s&&s.ps(t)}})),this.bl()},t.prototype.Vs=function(){return this.Hn},t.prototype.Uu=function(t){var i=t.$();return null===i||this.ol!==i&&this.fl!==i},t.prototype.Ws=function(t,i,n){var s=void 0!==n?n:this.pl().ml+1;this.gl(t,i,s)},t.prototype.Ps=function(t){var i=this.Hn.indexOf(t);o(-1!==i,"removeDataSource: invalid data source"),this.Hn.splice(i,1);var n=f(t.$()).hs();if(this.hl.has(n)){var s=l(this.hl.get(n)),h=s.indexOf(t);-1!==h&&(s.splice(h,1),0===s.length&&this.hl.delete(n))}var r=t.$();r&&r.Vs().indexOf(t)>=0&&r.Ps(t),null!==r&&(r.zs(),this.yl(r)),this.Yn=null},t.prototype.Hu=function(t){return t===this.ol?"left":t===this.fl?"right":"overlay"},t.prototype.kl=function(){return this.ol},t.prototype.Cl=function(){return this.fl},t.prototype.Nl=function(t,i){t.js(i)},t.prototype.xl=function(t,i){t.qs(i),this.bl()},t.prototype.Sl=function(t){t.Us()},t.prototype.Dl=function(t,i){t.Hs(i)},t.prototype.Al=function(t,i){t.Ys(i),this.bl()},t.prototype.Tl=function(t){t.Ks()},t.prototype.bl=function(){this.Hn.forEach((function(t){t.Ii()}))},t.prototype.xi=function(){var t=null;return this.hi.ct().rightPriceScale.visible&&0!==this.fl.Vs().length?t=this.fl:this.hi.ct().leftPriceScale.visible&&0!==this.ol.Vs().length?t=this.ol:0!==this.Hn.length&&(t=this.Hn[0].$()),null===t&&(t=this.fl),t},t.prototype.yl=function(t){null!==t&&t.fs()&&this.Bl(t)},t.prototype.Ll=function(t){var i=this.ul.mr();t.us({_s:!0}),null!==i&&t.th(i),this.bl()},t.prototype.Fl=function(){this.Bl(this.ol),this.Bl(this.fl)},t.prototype.El=function(){var t=this;this.yl(this.ol),this.yl(this.fl),this.Hn.forEach((function(i){t.Uu(i)&&t.yl(i.$())})),this.bl(),this.hi.Or()},t.prototype.Os=function(){return null===this.Yn&&(this.Yn=bt(this.Hn)),this.Yn},t.prototype.Vl=function(){return this.el},t.prototype.Ol=function(){return this.al},t.prototype.Bl=function(t){var i=t.Qs();if(i&&i.length>0&&!this.ul.ti()){var n=this.ul.mr();null!==n&&t.th(n)}t.Ii()},t.prototype.pl=function(){var t=this.Os();if(0===t.length)return{Wl:0,ml:0};for(var i=0,n=0,s=0;s<t.length;s++){var h=t[s].oi();null!==h&&(h<i&&(i=h),h>n&&(n=h))}return{Wl:i,ml:n}},t.prototype.gl=function(t,i,n){var s=this._l(i);if(null===s&&(s=this.ll(i,this.hi.ct().overlayPriceScales)),this.Hn.push(t),!Yt(i)){var h=this.hl.get(i)||[];h.push(t),this.hl.set(i,h)}s.Ws(t),t.fi(s),t.li(n),this.yl(s),this.Yn=null},t.prototype.cl=function(t,i,n){i.os!==n.os&&this.Bl(t)},t.prototype.ll=function(t,i){var n=u({visible:!0,autoScale:!0},b(i)),s=new kt(t,n,this.hi.ct().layout,this.hi.ct().localization);return s.ps(this.Mt()),s},t}(),un=function(t){function i(i){var n=t.call(this)||this;return n.zl=new Map,n.tt=i,n}return e(i,t),i.prototype.u=function(t){},i.prototype.l=function(t){if(this.tt.U){t.save();for(var i=0,n=0,s=this.tt.Pl;n<s.length;n++){if(0!==(a=s[n]).Et.length){t.font=a.Nt;var h=this.Rl(t,a.Et);h>this.tt.wt?a.Ur=this.tt.wt/h:a.Ur=1,i+=a.Il*a.Ur}}var r=0;switch(this.tt.jl){case"top":r=0;break;case"center":r=Math.max((this.tt.Mt-i)/2,0);break;case"bottom":r=Math.max(this.tt.Mt-i,0)}t.fillStyle=this.tt.et;for(var e=0,u=this.tt.Pl;e<u.length;e++){var a=u[e];t.save();var o=0;switch(this.tt.ql){case"left":t.textAlign="left",o=a.Il/2;break;case"center":t.textAlign="center",o=this.tt.wt/2;break;case"right":t.textAlign="right",o=this.tt.wt-1-a.Il/2}t.translate(o,r),t.textBaseline="top",t.font=a.Nt,t.scale(a.Ur,a.Ur),t.fillText(a.Et,0,a.Ul),t.restore(),r+=a.Il*a.Ur}t.restore()}},i.prototype.Rl=function(t,i){var n=this.Hl(t.font),s=n.get(i);return void 0===s&&(s=t.measureText(i).width,n.set(i,s)),s},i.prototype.Hl=function(t){var i=this.zl.get(t);return void 0===i&&(i=new Map,this.zl.set(t,i)),i},i}(y),an=function(){function t(t){this.L=!0,this.at={U:!1,et:"",Mt:0,wt:0,Pl:[],jl:"center",ql:"center"},this.ot=new un(this.at),this.lt=t}return t.prototype.O=function(){this.L=!0},t.prototype.P=function(t,i){return this.L&&(this.R(t,i),this.L=!1),this.ot},t.prototype.R=function(t,i){var n=this.lt.ct(),s=this.at;s.U=n.visible,s.U&&(s.et=n.color,s.wt=i,s.Mt=t,s.ql=n.horzAlign,s.jl=n.vertAlign,s.Pl=[{Et:n.text,Nt:Ut(n.fontSize,n.fontFamily,n.fontStyle),Il:1.2*n.fontSize,Ul:0,Ur:0}])},t}(),on=function(t){function i(i,n){var s=t.call(this)||this;return s.ki=n,s.Ai=new an(s),s}return e(i,t),i.prototype.Pi=function(){return[]},i.prototype.zi=function(){return[this.Ai]},i.prototype.ct=function(){return this.ki},i.prototype.Ii=function(){this.Ai.O()},i}(X),ln=function(){function t(t,i){this.Yl=[],this.Kl=[],this.$h=0,this.$l=null,this.Xl=null,this.Zl=new it,this.Jl=new it,this.Gl=null,this.Ql=t,this.ki=i,this.tf=new Ht(this),this.ul=new Rt(this,i.timeScale,this.ki.localization),this.V=new Z(this,i.crosshair),this.if=new nn(i.crosshair),this.nf=new on(this,i.watermark),this.sf(),this.Yl[0].Ml(2e3),this.hf=this.rf(0),this.ef=this.rf(1)}return t.prototype.uf=function(){this.af(new Kt(3))},t.prototype.Or=function(){this.af(new Kt(2))},t.prototype.jo=function(){this.af(new Kt(1))},t.prototype.Fo=function(t){var i=this.lf(t);this.af(i)},t.prototype.ff=function(){return this.Xl},t.prototype.cf=function(t){var i=this.Xl;this.Xl=t,null!==i&&this.Fo(i.vf),null!==t&&this.Fo(t.vf)},t.prototype.ct=function(){return this.ki},t.prototype.rs=function(t){v(this.ki,t),this.Yl.forEach((function(i){return i.vl(t)})),void 0!==t.timeScale&&this.ul.rs(t.timeScale),void 0!==t.localization&&this.ul.cr(t.localization),(t.leftPriceScale||t.rightPriceScale)&&this.Zl.hn(),this.hf=this.rf(0),this.ef=this.rf(1),this.uf()},t.prototype._f=function(t,i){var n=this.df(t);null!==n&&(n.$.rs(i),this.Zl.hn())},t.prototype.df=function(t){for(var i=0,n=this.Yl;i<n.length;i++){var s=n[i],h=s._l(t);if(null!==h)return{ft:s,$:h}}return null},t.prototype.j=function(){return this.ul},t.prototype.wf=function(){return this.Yl},t.prototype.Mf=function(){return this.nf},t.prototype.bf=function(){return this.V},t.prototype.mf=function(){return this.Jl},t.prototype.pf=function(t,i){t.ps(i),this.Vr()},t.prototype.Dr=function(t){this.$h=t,this.ul.Dr(this.$h),this.Yl.forEach((function(i){return i.Dr(t)})),this.Vr()},t.prototype.sf=function(t){var i=new en(this.ul,this);void 0!==t?this.Yl.splice(t,0,i):this.Yl.push(i);var n=void 0===t?this.Yl.length-1:t,s=new Kt(3);return s.be(n,{me:0,_s:!0}),this.af(s),i},t.prototype.Nl=function(t,i,n){t.Nl(i,n)},t.prototype.xl=function(t,i,n){t.xl(i,n),this.Eo(),this.af(this.gf(t,2))},t.prototype.Sl=function(t,i){t.Sl(i),this.af(this.gf(t,2))},t.prototype.Dl=function(t,i,n){i.fs()||t.Dl(i,n)},t.prototype.Al=function(t,i,n){i.fs()||(t.Al(i,n),this.Eo(),this.af(this.gf(t,2)))},t.prototype.Tl=function(t,i){i.fs()||(t.Tl(i),this.af(this.gf(t,2)))},t.prototype.Ll=function(t,i){t.Ll(i),this.af(this.gf(t,2))},t.prototype.yf=function(t){this.ul.js(t)},t.prototype.kf=function(t,i){var n=this.j();if(!n.ti()&&0!==i){var s=n.wt();t=Math.max(1,Math.min(t,s)),n.Ur(t,i),this.Vr()}},t.prototype.Cf=function(t){this.Nf(0),this.xf(t),this.Sf()},t.prototype.Df=function(t){this.ul.qs(t),this.Vr()},t.prototype.Af=function(){this.ul.Us(),this.Or()},t.prototype.Nf=function(t){this.$l=t,this.ul.Hs(t)},t.prototype.xf=function(t){var i=!1;return null!==this.$l&&Math.abs(t-this.$l)>20&&(this.$l=null,i=!0),this.ul.Ys(t),this.Vr(),i},t.prototype.Sf=function(){this.ul.Ks(),this.Or(),this.$l=null},t.prototype.W=function(){return this.Kl},t.prototype.Tf=function(t,i,n){this.V.Ti(t,i);var s=NaN,h=this.ul.Fr(t),r=this.ul.mr();null!==r&&(h=Math.min(Math.max(r.hh(),h),r.rh()));var e=n.xi(),u=e.H();null!==u&&(s=e.Si(i,u)),s=this.if.$o(s,h,n),this.V.Ei(h,s,n),this.jo(),this.Jl.hn(this.V.I(),{x:t,y:i})},t.prototype.Bf=function(){this.bf().Oi(),this.jo(),this.Jl.hn(null,null)},t.prototype.Eo=function(){var t=this.V.ft();if(null!==t){var i=this.V.Li(),n=this.V.Fi();this.Tf(i,n,t)}this.V.Ii()},t.prototype.Lf=function(t,i,n){var s=this.ul.ri(0);void 0!==i&&void 0!==n&&this.ul.O(i,n);var h=this.ul.ri(0),r=this.ul.Br(),e=this.ul.mr();if(null!==e&&null!==s&&null!==h){var u=e.Eh(r),a=s.Dh>h.Dh,o=null!==t&&t>r&&!a,l=u&&this.ul.ct().shiftVisibleRangeOnNewBar;if(o&&!l){var f=t-r;this.ul.Mr(this.ul.Pr()-f)}}this.ul.qr(t)},t.prototype.Oo=function(t){null!==t&&t.El()},t.prototype.qu=function(t){var i=this.Yl.find((function(i){return i.Os().includes(t)}));return void 0===i?null:i},t.prototype.Vr=function(){this.nf.Ii(),this.Yl.forEach((function(t){return t.El()})),this.Eo()},t.prototype.en=function(){this.Yl.forEach((function(t){return t.en()})),this.Yl.length=0,this.ki.localization.priceFormatter=void 0,this.ki.localization.timeFormatter=void 0},t.prototype.Ff=function(){return this.tf},t.prototype.Yu=function(){return this.tf.ct()},t.prototype.dl=function(){return this.Zl},t.prototype.Ef=function(t,i){var n=this.Yl[0],s=this.Vf(i,t,n);return this.Kl.push(s),1===this.Kl.length?this.uf():this.Or(),s},t.prototype.Of=function(t){var i=this.qu(t),n=this.Kl.indexOf(t);o(-1!==n,"Series not found"),this.Kl.splice(n,1),f(i).Ps(t),t.en&&t.en()},t.prototype.Lo=function(t,i){var n=f(this.qu(t));n.Ps(t);var s=this.df(i);if(null===s){var h=t.oi();n.Ws(t,i,h)}else{h=s.ft===n?t.oi():void 0;s.ft.Ws(t,i,h)}},t.prototype.Qr=function(){var t=new Kt(2);t.ye(),this.af(t)},t.prototype.Wf=function(t){var i=new Kt(2);i.Ce(t),this.af(i)},t.prototype.Ne=function(){var t=new Kt(2);t.Ne(),this.af(t)},t.prototype.wr=function(t){var i=new Kt(2);i.wr(t),this.af(i)},t.prototype.Mr=function(t){var i=new Kt(2);i.Mr(t),this.af(i)},t.prototype.zf=function(){return this.ki.rightPriceScale.visible?"right":"left"},t.prototype.Pf=function(){return this.ef},t.prototype.Rf=function(){return this.hf},t.prototype.J=function(t){var i=this.ef,n=this.hf;if(i===n)return i;if(t=Math.max(0,Math.min(100,Math.round(100*t))),null===this.Gl||this.Gl.Ve!==n||this.Gl.Oe!==i)this.Gl={Ve:n,Oe:i,If:new Map};else{var s=this.Gl.If.get(t);if(void 0!==s)return s}var h=function(t,i,n){var s=O(t),h=s[0],r=s[1],e=s[2],u=s[3],a=O(i),o=a[0],l=a[1],f=a[2],c=a[3],v=[T(h+n*(o-h)),T(r+n*(l-r)),T(e+n*(f-e)),B(u+n*(c-u))];return"rgba("+v[0]+", "+v[1]+", "+v[2]+", "+v[3]+")"}(n,i,t/100);return this.Gl.If.set(t,h),h},t.prototype.gf=function(t,i){var n=new Kt(i);if(null!==t){var s=this.Yl.indexOf(t);n.be(s,{me:i})}return n},t.prototype.lf=function(t,i){return void 0===i&&(i=2),this.gf(this.qu(t),i)},t.prototype.af=function(t){this.Ql&&this.Ql(t),this.Yl.forEach((function(t){return t.Ol().sl().O()}))},t.prototype.Vf=function(t,i,n){var s=new tn(this,t,i),h=void 0!==t.priceScaleId?t.priceScaleId:this.zf();return n.Ws(s,h),Yt(h)||s.rs(t),s},t.prototype.rf=function(t){var i=this.ki.layout;return"gradient"===i.background.type?0===t?i.background.topColor:i.background.bottomColor:i.background.color},t}(),fn=function(){function t(t,i){this.st=t,this.ht=i}return t.prototype.on=function(t){return this.st===t.st&&this.ht===t.ht},t}();function cn(t){return t.ownerDocument&&t.ownerDocument.defaultView&&t.ownerDocument.defaultView.devicePixelRatio||1}function vn(t){var i=f(t.getContext("2d"));return i.setTransform(1,0,0,1,0,0),i}function _n(t,i){var n=t.createElement("canvas"),s=cn(n);return n.style.width=i.st+"px",n.style.height=i.ht+"px",n.width=i.st*s,n.height=i.ht*s,n}function dn(i,n){var s=f(i.ownerDocument).createElement("canvas");i.appendChild(s);var h=bindToDevicePixelRatio(s);return h.resizeCanvas({width:n.st,height:n.ht}),h}function wn(t,i){return t.jf-i.jf}function Mn(t,i,n){var s=(t.jf-i.jf)/(t.S-i.S);return Math.sign(s)*Math.min(Math.abs(s),n)}var bn=function(){function t(t,i,n,s){this.qf=null,this.Uf=null,this.Hf=null,this.Yf=null,this.Kf=null,this.$f=0,this.Xf=0,this.Zf=!1,this.Jf=t,this.Gf=i,this.Qf=n,this.Yi=s}return t.prototype.tc=function(t,i){if(null!==this.qf){if(this.qf.S===i)return void(this.qf.jf=t);if(Math.abs(this.qf.jf-t)<this.Yi)return}this.Yf=this.Hf,this.Hf=this.Uf,this.Uf=this.qf,this.qf={S:i,jf:t}},t.prototype.ia=function(t,i){if(null!==this.qf&&null!==this.Uf&&!(i-this.qf.S>50)){var n=0,s=Mn(this.qf,this.Uf,this.Gf),h=wn(this.qf,this.Uf),r=[s],e=[h];if(n+=h,null!==this.Hf){var u=Mn(this.Uf,this.Hf,this.Gf);if(Math.sign(u)===Math.sign(s)){var a=wn(this.Uf,this.Hf);if(r.push(u),e.push(a),n+=a,null!==this.Yf){var o=Mn(this.Hf,this.Yf,this.Gf);if(Math.sign(o)===Math.sign(s)){var l=wn(this.Hf,this.Yf);r.push(o),e.push(l),n+=l}}}}for(var f,c,v,_=0,d=0;d<r.length;++d)_+=e[d]/n*r[d];if(!(Math.abs(_)<this.Jf))this.Kf={jf:t,S:i},this.Xf=_,this.$f=(f=Math.abs(_),c=this.Qf,v=Math.log(c),Math.log(1*v/-f)/v)}},t.prototype.ic=function(t){var i=f(this.Kf),n=t-i.S;return i.jf+this.Xf*(Math.pow(this.Qf,n)-1)/Math.log(this.Qf)},t.prototype.nc=function(t){return null===this.Kf||this.sc(t)===this.$f},t.prototype.hc=function(){return this.Zf},t.prototype.rc=function(){this.Zf=!0},t.prototype.sc=function(t){var i=t-f(this.Kf).S;return Math.min(i,this.$f)},t}(),mn="undefined"!=typeof window;var pn=function(){if(!mn)return!1;var t=!!navigator.maxTouchPoints||!!navigator.msMaxTouchPoints||!!mn&&("ontouchstart"in window||Boolean(window.DocumentTouch&&document instanceof window.DocumentTouch));return"onorientationchange"in window&&t}();var gn=function(){if(!mn)return!1;var t=/Android/i.test(navigator.userAgent),i=/iPhone|iPad|iPod|AppleWebKit.+Mobile/i.test(navigator.userAgent);return t||i}(),yn=function(){function t(t,i,n){this.ec=0,this.uc=null,this.ac=null,this.oc=!1,this.lc=null,this.fc=!1,this.cc=!1,this.vc=null,this._c=null,this.dc=null,this.wc=null,this.Mc=0,this.bc=!1,this.mc=!1,this.gc=!1,this.yc=t,this.kc=i,this.ki=n,this.Cc()}return t.prototype.en=function(){null!==this.vc&&(this.vc(),this.vc=null),null!==this._c&&(this._c(),this._c=null),null!==this.dc&&(this.dc(),this.dc=null),this.Nc(),this.xc()},t.prototype.Sc=function(t){var i=this;this._c&&this._c();var n=this.Dc.bind(this);this._c=function(){i.yc.removeEventListener("mousemove",n)},this.yc.addEventListener("mousemove",n),Nn(t)&&this.Dc(t);var s=this.Ac(t);this.Tc(s,this.kc.Bc)},t.prototype.xc=function(){null!==this.uc&&clearTimeout(this.uc),this.ec=0,this.uc=null},t.prototype.Dc=function(t){if(!this.gc||Nn(t)){var i=this.Ac(t);this.Tc(i,this.kc.Lc)}},t.prototype.Fc=function(t){if((!("button"in t)||0===t.button)&&null===this.wc){var i=Nn(t);if(!this.mc||!i){this.bc=!0;var n=this.Ac(t),s=c(this.lc),h=Math.abs(s.p-n.Ec),r=Math.abs(s.g-n.Vc),e=h+r>5;if(e||!i){if(e&&!this.fc&&i){var u=.5*h,a=r>=u&&!this.ki.Oc,o=u>r&&!this.ki.Wc;a||o||(this.mc=!0)}e&&(this.fc=!0,this.cc=!0,i&&this.Nc()),this.mc||(this.Tc(n,this.kc.zc),i&&xn(t))}}}},t.prototype.Pc=function(t){if(!("button"in t)||0===t.button){var i=this.Ac(t);this.Nc(),this.lc=null,this.gc=!1,this.dc&&(this.dc(),this.dc=null),Nn(t)&&this.Rc(t),this.Tc(i,this.kc.Ic),++this.ec,this.uc&&this.ec>1?(this.Tc(i,this.kc.jc),this.xc()):this.cc||this.Tc(i,this.kc.qc),Nn(t)&&(xn(t),this.Rc(t),0===t.touches.length&&(this.oc=!1))}},t.prototype.Nc=function(){null!==this.ac&&(clearTimeout(this.ac),this.ac=null)},t.prototype.Uc=function(t){if(!("button"in t)||0===t.button){var i=this.Ac(t);this.cc=!1,this.fc=!1,this.mc=!1,Nn(t)&&this.Sc(t),this.lc={p:i.Ec,g:i.Vc},this.dc&&(this.dc(),this.dc=null);var n=this.Fc.bind(this),s=this.Pc.bind(this),h=this.yc.ownerDocument.documentElement;this.dc=function(){h.removeEventListener("touchmove",n),h.removeEventListener("touchend",s),h.removeEventListener("mousemove",n),h.removeEventListener("mouseup",s)},h.addEventListener("touchmove",n,{passive:!1}),h.addEventListener("touchend",s,{passive:!1}),this.Nc(),Nn(t)&&1===t.touches.length?this.ac=setTimeout(this.Hc.bind(this,t),240):(h.addEventListener("mousemove",n),h.addEventListener("mouseup",s)),this.gc=!0,this.Tc(i,this.kc.Yc),this.uc||(this.ec=0,this.uc=setTimeout(this.xc.bind(this),500))}},t.prototype.Cc=function(){var t=this;this.yc.addEventListener("mouseenter",this.Sc.bind(this)),this.yc.addEventListener("touchcancel",this.Nc.bind(this));var i=this.yc.ownerDocument,n=function(i){t.kc.Kc&&(i.composed&&t.yc.contains(i.composedPath()[0])||i.target&&t.yc.contains(i.target)||t.kc.Kc())};this.vc=function(){i.removeEventListener("mousedown",n),i.removeEventListener("touchstart",n)},i.addEventListener("mousedown",n),i.addEventListener("touchstart",n,{passive:!0}),this.yc.addEventListener("mouseleave",this.Rc.bind(this)),this.yc.addEventListener("touchstart",this.Uc.bind(this),{passive:!0}),pn||this.yc.addEventListener("mousedown",this.Uc.bind(this)),this.$c(),this.yc.addEventListener("touchmove",(function(){}),{passive:!1})},t.prototype.$c=function(){var t=this;void 0===this.kc.Xc&&void 0===this.kc.Zc&&void 0===this.kc.Jc||(this.yc.addEventListener("touchstart",(function(i){return t.Gc(i.touches)}),{passive:!0}),this.yc.addEventListener("touchmove",(function(i){if(2===i.touches.length&&null!==t.wc&&void 0!==t.kc.Zc){var n=Cn(i.touches[0],i.touches[1])/t.Mc;t.kc.Zc(t.wc,n),xn(i)}}),{passive:!1}),this.yc.addEventListener("touchend",(function(i){t.Gc(i.touches)})))},t.prototype.Gc=function(t){1===t.length&&(this.bc=!1),2!==t.length||this.bc||this.oc?this.Qc():this.tv(t)},t.prototype.tv=function(t){var i=kn(this.yc);this.wc={p:(t[0].clientX-i.left+(t[1].clientX-i.left))/2,g:(t[0].clientY-i.top+(t[1].clientY-i.top))/2},this.Mc=Cn(t[0],t[1]),void 0!==this.kc.Xc&&this.kc.Xc(),this.Nc()},t.prototype.Qc=function(){null!==this.wc&&(this.wc=null,void 0!==this.kc.Jc&&this.kc.Jc())},t.prototype.Rc=function(t){this._c&&this._c();var i=this.Ac(t);this.Tc(i,this.kc.iv)},t.prototype.Hc=function(t){var i=this.Ac(t);this.Tc(i,this.kc.nv),this.cc=!0,this.oc=!0},t.prototype.Tc=function(t,i){i&&i.call(this.kc,t)},t.prototype.Ac=function(t){var i;i="touches"in t&&t.touches.length?t.touches[0]:"changedTouches"in t&&t.changedTouches.length?t.changedTouches[0]:t;var n=kn(this.yc);return{sv:i.clientX,hv:i.clientY,Ec:i.pageX,Vc:i.pageY,rv:i.screenX,ev:i.screenY,uv:i.clientX-n.left,av:i.clientY-n.top,ov:t.ctrlKey,lv:t.altKey,fv:t.shiftKey,cv:t.metaKey,ke:t.type.startsWith("mouse")?"mouse":"touch",vv:t.view}},t}();function kn(t){return t.getBoundingClientRect()||{left:0,top:0}}function Cn(t,i){var n=t.clientX-i.clientX,s=t.clientY-i.clientY;return Math.sqrt(n*n+s*s)}function Nn(t){return Boolean(t.touches)}function xn(t){t.cancelable&&t.preventDefault()}var Sn=function(){function t(t,i,n,s){this.Pu=new pi(200),this.fe=0,this._v="",this.ma="",this.Vu=[],this.dv=new Map,this.fe=t,this._v=i,this.ma=Ut(t,n,s)}return t.prototype.en=function(){this.Pu.Ou(),this.Vu=[],this.dv.clear()},t.prototype.wv=function(t,i,n,s,h){var r=this.Mv(t,i);if("left"!==h){var e=cn(t.canvas);n-=Math.floor(r.bv*e)}s-=Math.floor(r.Mt/2),t.drawImage(r.mv,n,s,r.wt,r.Mt)},t.prototype.Mv=function(t,i){var n,s=this;if(this.dv.has(i))n=l(this.dv.get(i));else{if(this.Vu.length>=200){var h=l(this.Vu.shift());this.dv.delete(h)}var r=cn(t.canvas),e=Math.ceil(this.fe/4.5),u=Math.round(this.fe/10),a=Math.ceil(this.Pu.Vt(t,i)),o=et(Math.round(a+2*e)),f=et(this.fe+2*e),c=_n(document,new fn(o,f));n={Et:i,bv:Math.round(Math.max(1,a)),wt:Math.ceil(o*r),Mt:Math.ceil(f*r),mv:c},0!==a&&(this.Vu.push(n.Et),this.dv.set(n.Et,n)),P(t=vn(n.mv),r,(function(){t.font=s.ma,t.fillStyle=s._v,t.fillText(i,0,f-e-u)}))}return n},t}(),Dn=function(){function t(t,i,n,s){var h=this;this.Gt=null,this.pv=null,this.gv=null,this.yv=!1,this.kv=new pi(50),this.Cv=new Sn(11,"#000"),this._v=null,this.ma=null,this.Nv=0,this.xv=function(){h.Sv(h.tf.ct()),h.vi.Dv().vt().Or()},this.Av=function(){h.vi.Dv().vt().Or()},this.vi=t,this.ki=i,this.tf=n,this.Tv="left"===s,this.Bv=document.createElement("div"),this.Bv.style.height="100%",this.Bv.style.overflow="hidden",this.Bv.style.width="25px",this.Bv.style.left="0",this.Bv.style.position="relative",this.Lv=dn(this.Bv,new fn(16,16)),this.Lv.subscribeCanvasConfigured(this.xv);var r=this.Lv.canvas;r.style.position="absolute",r.style.zIndex="1",r.style.left="0",r.style.top="0",this.Fv=dn(this.Bv,new fn(16,16)),this.Fv.subscribeCanvasConfigured(this.Av);var e=this.Fv.canvas;e.style.position="absolute",e.style.zIndex="2",e.style.left="0",e.style.top="0";var u={Yc:this.Ev.bind(this),zc:this.Vv.bind(this),Kc:this.Ov.bind(this),Ic:this.Wv.bind(this),jc:this.zv.bind(this),Bc:this.Pv.bind(this),iv:this.Rv.bind(this)};this.Iv=new yn(this.Fv.canvas,u,{Oc:!1,Wc:!0})}return t.prototype.en=function(){this.Iv.en(),this.Fv.unsubscribeCanvasConfigured(this.Av),this.Fv.destroy(),this.Lv.unsubscribeCanvasConfigured(this.xv),this.Lv.destroy(),null!==this.Gt&&this.Gt.Is().sn(this),this.Gt=null,null!==this.gv&&(clearTimeout(this.gv),this.gv=null),this.Cv.en()},t.prototype.jv=function(){return this.Bv},t.prototype.N=function(){return f(this.Gt).ct().borderColor},t.prototype.qv=function(){return this.ki.textColor},t.prototype.Wt=function(){return this.ki.fontSize},t.prototype.Uv=function(){return Ut(this.Wt(),this.ki.fontFamily)},t.prototype.Hv=function(){var t=this.tf.ct(),i=this._v!==t.et,n=this.ma!==t.Nt;return(i||n)&&(this.Sv(t),this._v=t.et),n&&(this.kv.Ou(),this.ma=t.Nt),t},t.prototype.Yv=function(){if(null===this.Gt)return 0;var t=34,i=this.Hv(),n=vn(this.Lv.canvas),s=this.Gt.Fn();n.font=this.Uv(),s.length>0&&(t=Math.max(this.kv.Vt(n,s[0].Tn),this.kv.Vt(n,s[s.length-1].Tn)));for(var h=this.Kv(),r=h.length;r--;){var e=this.kv.Vt(n,h[r].Et());e>t&&(t=e)}var u=this.Gt.H();if(null!==u&&null!==this.pv){var a=this.Gt.Si(1,u),o=this.Gt.Si(this.pv.ht-2,u);t=Math.max(t,this.kv.Vt(n,this.Gt.ii(Math.floor(Math.min(a,o))+.11111111111111,u)),this.kv.Vt(n,this.Gt.ii(Math.ceil(Math.max(a,o))-.11111111111111,u)))}var l=Math.ceil(i.At+i.Dt+i.Lt+i.Ft+t);return l+=l%2},t.prototype.$v=function(t){if(t.st<0||t.ht<0)throw new Error("Try to set invalid size to PriceAxisWidget "+JSON.stringify(t));null!==this.pv&&this.pv.on(t)||(this.pv=t,this.Lv.resizeCanvas({width:t.st,height:t.ht}),this.Fv.resizeCanvas({width:t.st,height:t.ht}),this.Bv.style.width=t.st+"px",this.Bv.style.height=t.ht+"px",this.Bv.style.minWidth=t.st+"px")},t.prototype.Xv=function(){return f(this.pv).st},t.prototype.fi=function(t){this.Gt!==t&&(null!==this.Gt&&this.Gt.Is().sn(this),this.Gt=t,t.Is().Ji(this.qn.bind(this),this))},t.prototype.$=function(){return this.Gt},t.prototype.Ou=function(){var t=this.vi.Zv();this.vi.Dv().vt().Ll(t,f(this.$()))},t.prototype.Jv=function(t){if(null!==this.pv){if(1!==t){var i=vn(this.Lv.canvas);this.Gv(),this.Qv(i,this.Lv.pixelRatio),this.yu(i,this.Lv.pixelRatio),this.t_(i,this.Lv.pixelRatio),this.i_(i,this.Lv.pixelRatio)}var n=vn(this.Fv.canvas),s=this.pv.st,h=this.pv.ht;P(n,this.Fv.pixelRatio,(function(){n.clearRect(0,0,s,h)})),this.n_(n,this.Fv.pixelRatio)}},t.prototype.s_=function(){return this.Lv.canvas},t.prototype.Ev=function(t){if(null!==this.Gt&&!this.Gt.ti()&&this.vi.Dv().ct().handleScale.axisPressedMouseMove.price){var i=this.vi.Dv().vt(),n=this.vi.Zv();this.yv=!0,i.Nl(n,this.Gt,t.av)}},t.prototype.Vv=function(t){if(null!==this.Gt&&this.vi.Dv().ct().handleScale.axisPressedMouseMove.price){var i=this.vi.Dv().vt(),n=this.vi.Zv(),s=this.Gt;i.xl(n,s,t.av)}},t.prototype.Ov=function(){if(null!==this.Gt&&this.vi.Dv().ct().handleScale.axisPressedMouseMove.price){var t=this.vi.Dv().vt(),i=this.vi.Zv(),n=this.Gt;this.yv&&(this.yv=!1,t.Sl(i,n))}},t.prototype.Wv=function(t){if(null!==this.Gt&&this.vi.Dv().ct().handleScale.axisPressedMouseMove.price){var i=this.vi.Dv().vt(),n=this.vi.Zv();this.yv=!1,i.Sl(n,this.Gt)}},t.prototype.zv=function(t){this.vi.Dv().ct().handleScale.axisDoubleClickReset&&this.Ou()},t.prototype.Pv=function(t){null!==this.Gt&&(!this.vi.Dv().vt().ct().handleScale.axisPressedMouseMove.price||this.Gt.cs()||this.Gt.vs()||this.h_(1))},t.prototype.Rv=function(t){this.h_(0)},t.prototype.Kv=function(){var t=this,i=[],n=null===this.Gt?void 0:this.Gt;return function(s){for(var h=0;h<s.length;++h)for(var r=s[h].Pi(t.vi.Zv(),n),e=0;e<r.length;e++)i.push(r[e])}(this.vi.Zv().Os()),i},t.prototype.Qv=function(t,i){var n=this;if(null!==this.pv){var s=this.pv.st,h=this.pv.ht;P(t,i,(function(){var i=n.vi.Zv().vt(),r=i.Rf(),e=i.Pf();r===e?R(t,0,0,s,h,r):I(t,0,0,s,h,r,e)}))}},t.prototype.yu=function(t,i){if(null!==this.pv&&null!==this.Gt&&this.Gt.ct().borderVisible){t.save(),t.fillStyle=this.N();var n,s=Math.max(1,Math.floor(this.Hv().At*i));n=this.Tv?Math.floor(this.pv.st*i)-s:0,t.fillRect(n,0,s,Math.ceil(this.pv.ht*i)),t.restore()}},t.prototype.t_=function(t,i){if(null!==this.pv&&null!==this.Gt){var n=this.Gt.Fn();t.save(),t.strokeStyle=this.N(),t.font=this.Uv(),t.fillStyle=this.N();var s=this.Hv(),h=this.Gt.ct().borderVisible&&this.Gt.ct().drawTicks,r=this.Tv?Math.floor((this.pv.st-s.Dt)*i-s.At*i):Math.floor(s.At*i),e=this.Tv?Math.round(r-s.Lt*i):Math.round(r+s.Dt*i+s.Lt*i),u=this.Tv?"right":"left",a=Math.max(1,Math.floor(i)),o=Math.floor(.5*i);if(h){var l=Math.round(s.Dt*i);t.beginPath();for(var f=0,c=n;f<c.length;f++){var v=c[f];t.rect(r,Math.round(v.An*i)-o,l,a)}t.fill()}t.fillStyle=this.qv();for(var _=0,d=n;_<d.length;_++){v=d[_];this.Cv.wv(t,v.Tn,e,Math.round(v.An*i),u)}t.restore()}},t.prototype.Gv=function(){if(null!==this.pv&&null!==this.Gt){var t=this.pv.ht/2,i=[],n=this.Gt.Os().slice(),s=this.vi.Zv(),h=this.Hv();this.Gt===s.xi()&&this.vi.Zv().Os().forEach((function(t){s.Uu(t)&&n.push(t)}));var r=this.Gt.Vs()[0],e=this.Gt;n.forEach((function(n){var h=n.Pi(s,e);h.forEach((function(t){t.Kt(null),t.$t()&&i.push(t)})),r===n&&h.length>0&&(t=h[0].zt())}));var u=i.filter((function(i){return i.zt()<=t})),a=i.filter((function(i){return i.zt()>t}));if(u.sort((function(t,i){return i.zt()-t.zt()})),u.length&&a.length&&a.push(u[0]),a.sort((function(t,i){return t.zt()-i.zt()})),i.forEach((function(t){return t.Kt(t.zt())})),this.Gt.ct().alignLabels){for(var o=1;o<u.length;o++){var l=u[o],f=(v=u[o-1]).Mt(h,!1);l.zt()>(_=v.Yt())-f&&l.Kt(_-f)}for(var c=1;c<a.length;c++){var v,_;l=a[c],f=(v=a[c-1]).Mt(h,!0);l.zt()<(_=v.Yt())+f&&l.Kt(_+f)}}}},t.prototype.i_=function(t,i){var n=this;if(null!==this.pv){t.save();var s=this.pv,h=this.Kv(),r=this.Hv(),e=this.Tv?"right":"left";h.forEach((function(h){if(h.Xt()){var u=h.P(f(n.Gt));t.save(),u.h(t,r,n.kv,s.st,e,i),t.restore()}})),t.restore()}},t.prototype.n_=function(t,i){var n=this;if(null!==this.pv&&null!==this.Gt){t.save();var s=this.pv,h=this.vi.Dv().vt(),r=[],e=this.vi.Zv(),u=h.bf().Pi(e,this.Gt);u.length&&r.push(u);var a=this.Hv(),o=this.Tv?"right":"left";r.forEach((function(h){h.forEach((function(h){t.save(),h.P(f(n.Gt)).h(t,a,n.kv,s.st,o,i),t.restore()}))})),t.restore()}},t.prototype.h_=function(t){this.Bv.style.cursor=1===t?"ns-resize":"default"},t.prototype.qn=function(){var t=this,i=this.Yv();if(this.Nv<i){var n=this.vi.Dv();null===this.gv&&(this.gv=setTimeout((function(){n&&n.vt().uf(),t.gv=null}),100))}this.Nv=i},t.prototype.Sv=function(t){this.Cv.en(),this.Cv=new Sn(t.Wt,t.et,t.le)},t}(),An=gn;function Tn(t,i,n,s,h){t.o&&t.o(i,n,s,h)}function Bn(t,i,n,s,h){t.h(i,n,s,h)}function Ln(t,i){return t.zi(i)}function Fn(t,i){return void 0!==t.Io?t.Io(i):[]}var En=function(){function t(t,i){var n=this;this.pv=new fn(0,0),this.r_=null,this.e_=null,this.u_=null,this.a_=!1,this.o_=new it,this.l_=0,this.f_=!1,this.c_=null,this.v_=!1,this.__=null,this.d_=null,this.xv=function(){return n.w_&&n.hi().Or()},this.Av=function(){return n.w_&&n.hi().Or()},this.M_=t,this.w_=i,this.w_.Vl().Ji(this.b_.bind(this),this,!0),this.m_=document.createElement("td"),this.m_.style.padding="0",this.m_.style.position="relative";var s=document.createElement("div");s.style.width="100%",s.style.height="100%",s.style.position="relative",s.style.overflow="hidden",this.p_=document.createElement("td"),this.p_.style.padding="0",this.g_=document.createElement("td"),this.g_.style.padding="0",this.m_.appendChild(s),this.Lv=dn(s,new fn(16,16)),this.Lv.subscribeCanvasConfigured(this.xv);var h=this.Lv.canvas;h.style.position="absolute",h.style.zIndex="1",h.style.left="0",h.style.top="0",this.Fv=dn(s,new fn(16,16)),this.Fv.subscribeCanvasConfigured(this.Av);var r=this.Fv.canvas;r.style.position="absolute",r.style.zIndex="2",r.style.left="0",r.style.top="0",this.y_=document.createElement("tr"),this.y_.appendChild(this.p_),this.y_.appendChild(this.m_),this.y_.appendChild(this.g_),this.k_();var e=this.Dv().ct().handleScroll;this.Iv=new yn(this.Fv.canvas,this,{Oc:!e.vertTouchDrag,Wc:!e.horzTouchDrag})}return t.prototype.en=function(){null!==this.r_&&this.r_.en(),null!==this.e_&&this.e_.en(),this.Fv.unsubscribeCanvasConfigured(this.Av),this.Fv.destroy(),this.Lv.unsubscribeCanvasConfigured(this.xv),this.Lv.destroy(),null!==this.w_&&this.w_.Vl().sn(this),this.Iv.en()},t.prototype.Zv=function(){return f(this.w_)},t.prototype.C_=function(i){null!==this.w_&&this.w_.Vl().sn(this),this.w_=i,null!==this.w_&&this.w_.Vl().Ji(t.prototype.b_.bind(this),this,!0),this.k_()},t.prototype.Dv=function(){return this.M_},t.prototype.jv=function(){return this.y_},t.prototype.k_=function(){if(null!==this.w_&&(this.N_(),0!==this.hi().W().length)){if(null!==this.r_){var t=this.w_.kl();this.r_.fi(f(t))}if(null!==this.e_){var i=this.w_.Cl();this.e_.fi(f(i))}}},t.prototype.wl=function(){return null!==this.w_?this.w_.wl():0},t.prototype.Ml=function(t){this.w_&&this.w_.Ml(t)},t.prototype.Bc=function(t){if(this.w_){var i=t.uv,n=t.av;pn||this.x_(i,n)}},t.prototype.Yc=function(t){if(this.f_=!1,this.v_=null!==this.c_,this.w_){if(this.S_(),document.activeElement!==document.body&&document.activeElement!==document.documentElement)f(document.activeElement).blur();else{var i=document.getSelection();null!==i&&i.removeAllRanges()}var n=this.hi();if(!this.w_.xi().ti()&&!n.j().ti()){if(null!==this.c_){var s=n.bf();this.__={x:s.bt(),y:s.gt()},this.c_={x:t.uv,y:t.av}}pn||this.x_(t.uv,t.av)}}},t.prototype.Lc=function(t){if(this.w_){var i=t.uv,n=t.av;if(this.D_()&&this.A_(),!pn){this.x_(i,n);var s=this.pa(i,n);this.hi().cf(s&&{vf:s.vf,T_:s.T_})}}},t.prototype.qc=function(t){if(null!==this.w_){var i=t.uv,n=t.av;if(this.o_.rn()){var s=this.hi().bf().I();this.o_.hn(s,{x:i,y:n})}this.B_()}},t.prototype.zc=function(t){if(null!==this.w_){var i=this.hi(),n=t.uv,s=t.av;if(null!==this.c_){this.v_=!1;var h=f(this.__),r=h.x+(n-this.c_.x),e=h.y+(s-this.c_.y);this.x_(r,e)}else this.D_()||this.x_(n,s);if(!i.j().ti()){var u=this.M_.ct(),a=u.handleScroll,o=u.kineticScroll;if(a.pressedMouseMove&&"touch"!==t.ke||(a.horzTouchDrag||a.vertTouchDrag)&&"mouse"!==t.ke){var l=this.w_.xi(),c=performance.now();null!==this.u_||this.L_()||(this.u_={x:t.sv,y:t.hv,Dh:c,uv:t.uv,av:t.av}),null!==this.d_&&this.d_.tc(t.uv,c),null===this.u_||this.a_||this.u_.x===t.sv&&this.u_.y===t.hv||(null===this.d_&&("touch"===t.ke&&o.touch||"mouse"===t.ke&&o.mouse)&&(this.d_=new bn(.2,7,.997,15),this.d_.tc(this.u_.uv,this.u_.Dh),this.d_.tc(t.uv,c)),l.ti()||i.Dl(this.w_,l,t.av),i.Nf(t.uv),this.a_=!0),this.a_&&(l.ti()||i.Al(this.w_,l,t.av),i.xf(t.uv))}}}},t.prototype.Ic=function(t){null!==this.w_&&(this.f_=!1,this.F_(t))},t.prototype.nv=function(t){if(this.f_=!0,null===this.c_&&An){var i={x:t.uv,y:t.av};this.E_(i,i)}},t.prototype.iv=function(t){null!==this.w_&&(this.w_.vt().cf(null),gn||this.A_())},t.prototype.V_=function(){return this.o_},t.prototype.Xc=function(){this.l_=1,this.S_()},t.prototype.Zc=function(t,i){if(this.M_.ct().handleScale.pinch){var n=5*(i-this.l_);this.l_=i,this.hi().kf(t.p,n)}},t.prototype.pa=function(t,i){var n=this.w_;if(null===n)return null;for(var s=0,h=n.Os();s<h.length;s++){var r=h[s],e=this.O_(r.zi(n),t,i);if(null!==e)return{vf:r,vv:e.vv,T_:e.T_}}return null},t.prototype.W_=function(t,i){f("left"===i?this.r_:this.e_).$v(new fn(t,this.pv.ht))},t.prototype.z_=function(){return this.pv},t.prototype.$v=function(t){if(t.st<0||t.ht<0)throw new Error("Try to set invalid size to PaneWidget "+JSON.stringify(t));this.pv.on(t)||(this.pv=t,this.Lv.resizeCanvas({width:t.st,height:t.ht}),this.Fv.resizeCanvas({width:t.st,height:t.ht}),this.m_.style.width=t.st+"px",this.m_.style.height=t.ht+"px")},t.prototype.P_=function(){var t=f(this.w_);t.yl(t.kl()),t.yl(t.Cl());for(var i=0,n=t.Vs();i<n.length;i++){var s=n[i];if(t.Uu(s)){var h=s.$();null!==h&&t.yl(h),s.Ii()}}},t.prototype.s_=function(){return this.Lv.canvas},t.prototype.Jv=function(t){if(0!==t&&null!==this.w_){if(t>1&&this.P_(),null!==this.r_&&this.r_.Jv(t),null!==this.e_&&this.e_.Jv(t),1!==t){var i=vn(this.Lv.canvas);i.save(),this.Qv(i,this.Lv.pixelRatio),this.w_&&(this.R_(i,this.Lv.pixelRatio),this.I_(i,this.Lv.pixelRatio),this.j_(i,this.Lv.pixelRatio,Ln)),i.restore()}var n=vn(this.Fv.canvas);n.clearRect(0,0,Math.ceil(this.pv.st*this.Fv.pixelRatio),Math.ceil(this.pv.ht*this.Fv.pixelRatio)),this.j_(n,this.Lv.pixelRatio,Fn),this.q_(n,this.Fv.pixelRatio)}},t.prototype.U_=function(){return this.r_},t.prototype.H_=function(){return this.e_},t.prototype.b_=function(){null!==this.w_&&this.w_.Vl().sn(this),this.w_=null},t.prototype.Qv=function(t,i){var n=this;P(t,i,(function(){var i=n.hi(),s=i.Rf(),h=i.Pf();s===h?R(t,0,0,n.pv.st,n.pv.ht,h):I(t,0,0,n.pv.st,n.pv.ht,s,h)}))},t.prototype.R_=function(t,i){var n=f(this.w_),s=n.Ol().sl().P(n.Mt(),n.wt());null!==s&&(t.save(),s.h(t,i,!1),t.restore())},t.prototype.I_=function(t,i){var n=this.hi().Mf();this.Y_(t,i,Ln,Tn,n),this.Y_(t,i,Ln,Bn,n)},t.prototype.q_=function(t,i){this.Y_(t,i,Ln,Bn,this.hi().bf())},t.prototype.j_=function(t,i,n){for(var s=f(this.w_).Os(),h=0,r=s;h<r.length;h++){var e=r[h];this.Y_(t,i,n,Tn,e)}for(var u=0,a=s;u<a.length;u++){e=a[u];this.Y_(t,i,n,Bn,e)}},t.prototype.Y_=function(t,i,n,s,h){for(var r=f(this.w_),e=n(h,r),u=r.Mt(),a=r.wt(),o=r.vt().ff(),l=null!==o&&o.vf===h,c=null!==o&&l&&void 0!==o.T_?o.T_.ga:void 0,v=0,_=e;v<_.length;v++){var d=_[v].P(u,a);null!==d&&(t.save(),s(d,t,i,l,c),t.restore())}},t.prototype.O_=function(t,i,n){for(var s=0,h=t;s<h.length;s++){var r=h[s],e=r.P(this.pv.ht,this.pv.st);if(null!==e&&e.pa){var u=e.pa(i,n);if(null!==u)return{vv:r,T_:u}}}return null},t.prototype.N_=function(){if(null!==this.w_){var t=this.M_,i=this.w_.kl().ct().visible,n=this.w_.Cl().ct().visible;i||null===this.r_||(this.p_.removeChild(this.r_.jv()),this.r_.en(),this.r_=null),n||null===this.e_||(this.g_.removeChild(this.e_.jv()),this.e_.en(),this.e_=null);var s=t.vt().Ff();i&&null===this.r_&&(this.r_=new Dn(this,t.ct().layout,s,"left"),this.p_.appendChild(this.r_.jv())),n&&null===this.e_&&(this.e_=new Dn(this,t.ct().layout,s,"right"),this.g_.appendChild(this.e_.jv()))}},t.prototype.D_=function(){return An&&null===this.c_},t.prototype.L_=function(){return An&&this.f_||null!==this.c_},t.prototype.K_=function(t){return Math.max(0,Math.min(t,this.pv.st-1))},t.prototype.X_=function(t){return Math.max(0,Math.min(t,this.pv.ht-1))},t.prototype.x_=function(t,i){this.hi().Tf(this.K_(t),this.X_(i),f(this.w_))},t.prototype.A_=function(){this.hi().Bf()},t.prototype.B_=function(){this.v_&&(this.c_=null,this.A_())},t.prototype.E_=function(t,i){this.c_=t,this.v_=!1,this.x_(i.x,i.y);var n=this.hi().bf();this.__={x:n.bt(),y:n.gt()}},t.prototype.hi=function(){return this.M_.vt()},t.prototype.Z_=function(){var t=this.hi(),i=this.Zv(),n=i.xi();t.Tl(i,n),t.Sf(),this.u_=null,this.a_=!1},t.prototype.F_=function(t){var i=this;if(this.a_){var n=performance.now();if(null!==this.d_&&this.d_.ia(t.uv,n),null===this.d_||this.d_.nc(n))this.Z_();else{var s=this.hi(),h=s.j(),r=this.d_,e=function(){if(!r.hc()){var t=performance.now(),n=r.nc(t);if(!r.hc()){var u=h.Pr();s.xf(r.ic(t)),u===h.Pr()&&(n=!0,i.d_=null)}n?i.Z_():requestAnimationFrame(e)}};requestAnimationFrame(e)}}},t.prototype.S_=function(){var t=performance.now(),i=null===this.d_||this.d_.nc(t);null!==this.d_&&(i||this.Z_()),null!==this.d_&&(this.d_.rc(),this.d_=null)},t}(),Vn=function(){function t(t,i,n,s,h){var r=this;this.L=!0,this.pv=new fn(0,0),this.xv=function(){return r.Jv(3)},this.Tv="left"===t,this.tf=n.Ff,this.ki=i,this.J_=s,this.G_=h,this.Bv=document.createElement("div"),this.Bv.style.width="25px",this.Bv.style.height="100%",this.Bv.style.overflow="hidden",this.Lv=dn(this.Bv,new fn(16,16)),this.Lv.subscribeCanvasConfigured(this.xv)}return t.prototype.en=function(){this.Lv.unsubscribeCanvasConfigured(this.xv),this.Lv.destroy()},t.prototype.jv=function(){return this.Bv},t.prototype.z_=function(){return this.pv},t.prototype.$v=function(t){if(t.st<0||t.ht<0)throw new Error("Try to set invalid size to PriceAxisStub "+JSON.stringify(t));this.pv.on(t)||(this.pv=t,this.Lv.resizeCanvas({width:t.st,height:t.ht}),this.Bv.style.width=t.st+"px",this.Bv.style.minWidth=t.st+"px",this.Bv.style.height=t.ht+"px",this.L=!0)},t.prototype.Jv=function(t){if((!(t<3)||this.L)&&0!==this.pv.st&&0!==this.pv.ht){this.L=!1;var i=vn(this.Lv.canvas);this.Qv(i,this.Lv.pixelRatio),this.yu(i,this.Lv.pixelRatio)}},t.prototype.s_=function(){return this.Lv.canvas},t.prototype.yu=function(t,i){if(this.J_()){var n=this.pv.st;t.save(),t.fillStyle=this.ki.timeScale.borderColor;var s=Math.floor(this.tf.ct().At*i),h=this.Tv?Math.round(n*i)-s:0;t.fillRect(h,0,s,s),t.restore()}},t.prototype.Qv=function(t,i){var n=this;P(t,i,(function(){R(t,0,0,n.pv.st,n.pv.ht,n.G_())}))},t}();function On(t,i){return t.Rh>i.Rh?t:i}var Wn=function(){function t(t){var i=this;this.Q_=null,this.td=null,this.oe=null,this.nd=!1,this.pv=new fn(0,0),this.sd=new it,this.kv=new pi(5),this.xv=function(){return i.M_.vt().Or()},this.Av=function(){return i.M_.vt().Or()},this.M_=t,this.ki=t.ct().layout,this.hd=document.createElement("tr"),this.rd=document.createElement("td"),this.rd.style.padding="0",this.ed=document.createElement("td"),this.ed.style.padding="0",this.Bv=document.createElement("td"),this.Bv.style.height="25px",this.Bv.style.padding="0",this.ud=document.createElement("div"),this.ud.style.width="100%",this.ud.style.height="100%",this.ud.style.position="relative",this.ud.style.overflow="hidden",this.Bv.appendChild(this.ud),this.Lv=dn(this.ud,new fn(16,16)),this.Lv.subscribeCanvasConfigured(this.xv);var n=this.Lv.canvas;n.style.position="absolute",n.style.zIndex="1",n.style.left="0",n.style.top="0",this.Fv=dn(this.ud,new fn(16,16)),this.Fv.subscribeCanvasConfigured(this.Av);var s=this.Fv.canvas;s.style.position="absolute",s.style.zIndex="2",s.style.left="0",s.style.top="0",this.hd.appendChild(this.rd),this.hd.appendChild(this.Bv),this.hd.appendChild(this.ed),this.ad(),this.M_.vt().dl().Ji(this.ad.bind(this),this),this.Iv=new yn(this.Fv.canvas,this,{Oc:!0,Wc:!1})}return t.prototype.en=function(){this.Iv.en(),null!==this.Q_&&this.Q_.en(),null!==this.td&&this.td.en(),this.Fv.unsubscribeCanvasConfigured(this.Av),this.Fv.destroy(),this.Lv.unsubscribeCanvasConfigured(this.xv),this.Lv.destroy()},t.prototype.jv=function(){return this.hd},t.prototype.od=function(){return this.Q_},t.prototype.ld=function(){return this.td},t.prototype.Yc=function(t){if(!this.nd){this.nd=!0;var i=this.M_.vt();!i.j().ti()&&this.M_.ct().handleScale.axisPressedMouseMove.time&&i.yf(t.uv)}},t.prototype.Kc=function(){var t=this.M_.vt();!t.j().ti()&&this.nd&&(this.nd=!1,this.M_.ct().handleScale.axisPressedMouseMove.time&&t.Af())},t.prototype.zc=function(t){var i=this.M_.vt();!i.j().ti()&&this.M_.ct().handleScale.axisPressedMouseMove.time&&i.Df(t.uv)},t.prototype.Ic=function(t){this.nd=!1;var i=this.M_.vt();i.j().ti()&&!this.M_.ct().handleScale.axisPressedMouseMove.time||i.Af()},t.prototype.jc=function(){this.M_.ct().handleScale.axisDoubleClickReset&&this.M_.vt().Ne()},t.prototype.Bc=function(t){this.M_.vt().ct().handleScale.axisPressedMouseMove.time&&this.h_(1)},t.prototype.iv=function(t){this.h_(0)},t.prototype.z_=function(){return this.pv},t.prototype.fd=function(){return this.sd},t.prototype.vd=function(t,i,n){this.pv&&this.pv.on(t)||(this.pv=t,this.Lv.resizeCanvas({width:t.st,height:t.ht}),this.Fv.resizeCanvas({width:t.st,height:t.ht}),this.Bv.style.width=t.st+"px",this.Bv.style.height=t.ht+"px",this.sd.hn(t)),null!==this.Q_&&this.Q_.$v(new fn(i,t.ht)),null!==this.td&&this.td.$v(new fn(n,t.ht))},t.prototype._d=function(){var t=this.dd();return Math.ceil(t.At+t.Dt+t.Wt+t.Tt+t.Bt)},t.prototype.O=function(){this.M_.vt().j().Fn()},t.prototype.s_=function(){return this.Lv.canvas},t.prototype.Jv=function(t){if(0!==t){if(1!==t){var i=vn(this.Lv.canvas);this.Qv(i,this.Lv.pixelRatio),this.yu(i,this.Lv.pixelRatio),this.t_(i,this.Lv.pixelRatio),null!==this.Q_&&this.Q_.Jv(t),null!==this.td&&this.td.Jv(t)}var n=vn(this.Fv.canvas),s=this.Fv.pixelRatio;n.clearRect(0,0,Math.ceil(this.pv.st*s),Math.ceil(this.pv.ht*s)),this.wd([this.M_.vt().bf()],n,s)}},t.prototype.Qv=function(t,i){var n=this;P(t,i,(function(){R(t,0,0,n.pv.st,n.pv.ht,n.M_.vt().Pf())}))},t.prototype.yu=function(t,i){if(this.M_.ct().timeScale.borderVisible){t.save(),t.fillStyle=this.Md();var n=Math.max(1,Math.floor(this.dd().At*i));t.fillRect(0,0,Math.ceil(this.pv.st*i),n),t.restore()}},t.prototype.t_=function(t,i){var n=this,s=this.M_.vt().j().Fn();if(s&&0!==s.length){var h=s.reduce(On,s[0]).Rh;h>30&&h<50&&(h=30),t.save(),t.strokeStyle=this.Md();var r=this.dd(),e=r.At+r.Dt+r.Tt+r.Wt-r.Ot;t.textAlign="center",t.fillStyle=this.Md();var u=Math.floor(this.dd().At*i),a=Math.max(1,Math.floor(i)),o=Math.floor(.5*i);if(this.M_.vt().j().ct().borderVisible){t.beginPath();for(var l=Math.round(r.Dt*i),f=s.length;f--;){var c=Math.round(s[f].An*i);t.rect(c-o,u,a,l)}t.fill()}t.fillStyle=this.ve(),P(t,i,(function(){t.font=n.bd();for(var i=0,r=s;i<r.length;i++){if((l=r[i]).Rh<h){var u=l.Ir?n.md(t,l.An,l.Tn):l.An;t.fillText(l.Tn,u,e)}}t.font=n.pd();for(var a=0,o=s;a<o.length;a++){var l;if((l=o[a]).Rh>=h){u=l.Ir?n.md(t,l.An,l.Tn):l.An;t.fillText(l.Tn,u,e)}}}))}},t.prototype.md=function(t,i,n){var s=this.kv.Vt(t,n),h=s/2,r=Math.floor(i-h)+.5;return r<0?i+=Math.abs(0-r):r+s>this.pv.st&&(i-=Math.abs(this.pv.st-(r+s))),i},t.prototype.wd=function(t,i,n){for(var s=this.dd(),h=0,r=t;h<r.length;h++)for(var e=0,u=r[h].ci();e<u.length;e++){var a=u[e];i.save(),a.P().h(i,s,n),i.restore()}},t.prototype.Md=function(){return this.M_.ct().timeScale.borderColor},t.prototype.ve=function(){return this.ki.textColor},t.prototype.fe=function(){return this.ki.fontSize},t.prototype.bd=function(){return Ut(this.fe(),this.ki.fontFamily)},t.prototype.pd=function(){return Ut(this.fe(),this.ki.fontFamily,"bold")},t.prototype.dd=function(){null===this.oe&&(this.oe={At:1,Ot:NaN,Tt:NaN,Bt:NaN,si:NaN,Dt:3,Wt:NaN,Nt:"",ni:new pi});var t=this.oe,i=this.bd();if(t.Nt!==i){var n=this.fe();t.Wt=n,t.Nt=i,t.Tt=Math.ceil(n/2.5),t.Bt=t.Tt,t.si=Math.ceil(n/2),t.Ot=Math.round(this.fe()/5),t.ni.Ou()}return this.oe},t.prototype.h_=function(t){this.Bv.style.cursor=1===t?"ew-resize":"default"},t.prototype.ad=function(){var t=this.M_.vt(),i=t.ct();i.leftPriceScale.visible||null===this.Q_||(this.rd.removeChild(this.Q_.jv()),this.Q_.en(),this.Q_=null),i.rightPriceScale.visible||null===this.td||(this.ed.removeChild(this.td.jv()),this.td.en(),this.td=null);var n={Ff:this.M_.vt().Ff()},s=function(){return i.leftPriceScale.borderVisible&&t.j().ct().borderVisible},h=function(){return t.Pf()};i.leftPriceScale.visible&&null===this.Q_&&(this.Q_=new Vn("left",i,n,s,h),this.rd.appendChild(this.Q_.jv())),i.rightPriceScale.visible&&null===this.td&&(this.td=new Vn("right",i,n,s,h),this.ed.appendChild(this.td.jv()))},t}(),zn=function(){function t(t,i){var n;this.gd=[],this.yd=0,this.En=0,this.$h=0,this.kd=0,this.Cd=0,this.Nd=null,this.xd=!1,this.o_=new it,this.Jl=new it,this.ki=i,this.hd=document.createElement("div"),this.hd.classList.add("tv-lightweight-charts"),this.hd.style.overflow="hidden",this.hd.style.width="100%",this.hd.style.height="100%",(n=this.hd).style.userSelect="none",n.style.webkitUserSelect="none",n.style.msUserSelect="none",n.style.MozUserSelect="none",n.style.webkitTapHighlightColor="transparent",this.Sd=document.createElement("table"),this.Sd.setAttribute("cellspacing","0"),this.hd.appendChild(this.Sd),this.Dd=this.Ad.bind(this),this.hd.addEventListener("wheel",this.Dd,{passive:!1}),this.hi=new ln(this.Ql.bind(this),this.ki),this.vt().mf().Ji(this.Td.bind(this),this),this.Bd=new Wn(this),this.Sd.appendChild(this.Bd.jv());var s=this.ki.width,h=this.ki.height;if(0===s||0===h){var r=t.getBoundingClientRect();0===s&&(s=Math.floor(r.width),s-=s%2),0===h&&(h=Math.floor(r.height),h-=h%2)}this.Ld(s,h),this.Fd(),t.appendChild(this.hd),this.Ed(),this.hi.j().Jr().Ji(this.hi.uf.bind(this.hi),this),this.hi.dl().Ji(this.hi.uf.bind(this.hi),this)}return t.prototype.vt=function(){return this.hi},t.prototype.ct=function(){return this.ki},t.prototype.Vd=function(){return this.gd},t.prototype.Od=function(){return this.Bd},t.prototype.en=function(){this.hd.removeEventListener("wheel",this.Dd),0!==this.yd&&window.cancelAnimationFrame(this.yd),this.hi.mf().sn(this),this.hi.j().Jr().sn(this),this.hi.dl().sn(this),this.hi.en();for(var t=0,i=this.gd;t<i.length;t++){var n=i[t];this.Sd.removeChild(n.jv()),n.V_().sn(this),n.en()}this.gd=[],f(this.Bd).en(),null!==this.hd.parentElement&&this.hd.parentElement.removeChild(this.hd),this.Jl.en(),this.o_.en()},t.prototype.Ld=function(t,i,n){if(void 0===n&&(n=!1),this.En!==i||this.$h!==t){this.En=i,this.$h=t;var s=i+"px",h=t+"px";f(this.hd).style.height=s,f(this.hd).style.width=h,this.Sd.style.height=s,this.Sd.style.width=h,n?this.Wd(new Kt(3)):this.hi.uf()}},t.prototype.Jv=function(t){void 0===t&&(t=new Kt(3));for(var i=0;i<this.gd.length;i++)this.gd[i].Jv(t.ge(i).me);this.ki.timeScale.visible&&this.Bd.Jv(t.pe())},t.prototype.rs=function(t){this.hi.rs(t),this.Ed();var i=t.width||this.$h,n=t.height||this.En;this.Ld(i,n)},t.prototype.V_=function(){return this.o_},t.prototype.mf=function(){return this.Jl},t.prototype.zd=function(){var t=this;null!==this.Nd&&(this.Wd(this.Nd),this.Nd=null);var i=this.gd[0],n=_n(document,new fn(this.$h,this.En)),s=vn(n),h=cn(n);return P(s,h,(function(){var n=0,h=0,r=function(i){for(var r=0;r<t.gd.length;r++){var e=t.gd[r],u=e.z_().ht,a=f("left"===i?e.U_():e.H_()),o=a.s_();s.drawImage(o,n,h,a.Xv(),u),h+=u}};t.Pd()&&(r("left"),n=f(i.U_()).Xv()),h=0;for(var e=0;e<t.gd.length;e++){var u=t.gd[e],a=u.z_(),o=u.s_();s.drawImage(o,n,h,a.st,a.ht),h+=a.ht}n+=i.z_().st,t.Rd()&&(h=0,r("right"));var l=function(i){var r=f("left"===i?t.Bd.od():t.Bd.ld()),e=r.z_(),u=r.s_();s.drawImage(u,n,h,e.st,e.ht)};if(t.ki.timeScale.visible){n=0,t.Pd()&&(l("left"),n=f(i.U_()).Xv());var c=t.Bd.z_();o=t.Bd.s_();s.drawImage(o,n,h,c.st,c.ht),t.Rd()&&(n+=i.z_().st,l("right"),s.restore())}})),n},t.prototype.Id=function(t){return"none"===t?0:("left"!==t||this.Pd())&&("right"!==t||this.Rd())?0===this.gd.length?0:f("left"===t?this.gd[0].U_():this.gd[0].H_()).Xv():0},t.prototype.jd=function(){for(var t=0,i=0,n=0,s=0,h=this.gd;s<h.length;s++){var r=h[s];this.Pd()&&(i=Math.max(i,f(r.U_()).Yv())),this.Rd()&&(n=Math.max(n,f(r.H_()).Yv())),t+=r.wl()}var e=this.$h,u=this.En,a=Math.max(e-i-n,0),o=this.ki.timeScale.visible,l=o?this.Bd._d():0;l%2&&(l+=1);for(var c=0+l,v=u<c?0:u-c,_=v/t,d=0,w=0;w<this.gd.length;++w){(r=this.gd[w]).C_(this.hi.wf()[w]);var M,b=0;b=w===this.gd.length-1?v-d:Math.round(r.wl()*_),d+=M=Math.max(b,2),r.$v(new fn(a,M)),this.Pd()&&r.W_(i,"left"),this.Rd()&&r.W_(n,"right"),r.Zv()&&this.hi.pf(r.Zv(),M)}this.Bd.vd(new fn(o?a:0,l),o?i:0,o?n:0),this.hi.Dr(a),this.kd!==i&&(this.kd=i),this.Cd!==n&&(this.Cd=n)},t.prototype.Ad=function(t){var i=t.deltaX/100,n=-t.deltaY/100;if(0!==i&&this.ki.handleScroll.mouseWheel||0!==n&&this.ki.handleScale.mouseWheel){switch(t.cancelable&&t.preventDefault(),t.deltaMode){case t.DOM_DELTA_PAGE:i*=120,n*=120;break;case t.DOM_DELTA_LINE:i*=32,n*=32}if(0!==n&&this.ki.handleScale.mouseWheel){var s=Math.sign(n)*Math.min(1,Math.abs(n)),h=t.clientX-this.hd.getBoundingClientRect().left;this.vt().kf(h,s)}0!==i&&this.ki.handleScroll.mouseWheel&&this.vt().Cf(-80*i)}},t.prototype.Wd=function(t){var i=t.pe();if(3===i&&this.qd(),3===i||2===i){for(var n=this.hi.wf(),s=0;s<n.length;s++)t.ge(s)._s&&n[s].Fl();for(var h=t.xe(),r=0,e=h;r<e.length;r++){var u=e[r];this.Se(u)}h.length>0&&(this.hi.Vr(),this.hi.Eo(),this.hi.Or()),this.Bd.O()}this.Jv(t)},t.prototype.Se=function(t){var i=this.hi.j();switch(t.ke){case 0:i.Qr();break;case 1:i.te(t.X);break;case 2:i.wr(t.X);break;case 3:i.Mr(t.X);break;case 4:i.jr()}},t.prototype.Ql=function(t){var i=this;null!==this.Nd?this.Nd._n(t):this.Nd=t,this.xd||(this.xd=!0,this.yd=window.requestAnimationFrame((function(){i.xd=!1,i.yd=0,null!==i.Nd&&(i.Wd(i.Nd),i.Nd=null)})))},t.prototype.qd=function(){this.Fd()},t.prototype.Fd=function(){for(var t=this.hi.wf(),i=t.length,n=this.gd.length,s=i;s<n;s++){var h=l(this.gd.pop());this.Sd.removeChild(h.jv()),h.V_().sn(this),h.en()}for(s=n;s<i;s++){(h=new En(this,t[s])).V_().Ji(this.Ud.bind(this),this),this.gd.push(h),this.Sd.insertBefore(h.jv(),this.Bd.jv())}for(s=0;s<i;s++){var r=t[s];(h=this.gd[s]).Zv()!==r?h.C_(r):h.k_()}this.Ed(),this.jd()},t.prototype.Hd=function(t,i){var n,s=new Map;null!==t&&this.hi.W().forEach((function(i){var n=i.Fa(t);null!==n&&s.set(i,n)}));if(null!==t){var h=this.hi.j().ri(t);null!==h&&(n=h)}var r=this.vt().ff(),e=null!==r&&r.vf instanceof tn?r.vf:void 0,u=null!==r&&void 0!==r.T_?r.T_.ka:void 0;return{S:n,Yd:i||void 0,Kd:e,$d:s,Xd:u}},t.prototype.Ud=function(t,i){var n=this;this.o_.hn((function(){return n.Hd(t,i)}))},t.prototype.Td=function(t,i){var n=this;this.Jl.hn((function(){return n.Hd(t,i)}))},t.prototype.Ed=function(){var t=this.ki.timeScale.visible?"":"none";this.Bd.jv().style.display=t},t.prototype.Pd=function(){return this.gd[0].Zv().kl().ct().visible},t.prototype.Rd=function(){return this.gd[0].Zv().Cl().ct().visible},t}();function Pn(t,i,n){var s=n.value,h={Ph:i,S:t,X:[s,s,s,s]};return"color"in n&&void 0!==n.color&&(h.et=n.color),h}function Rn(t,i,n){return{Ph:i,S:t,X:[n.open,n.high,n.low,n.close]}}function In(t){return void 0!==t.X}function jn(t){return function(i,n,s){return void 0===(h=s).open&&void 0===h.value?{S:i,Ph:n}:t(i,n,s);var h}}var qn={Candlestick:jn(Rn),Bar:jn(Rn),Area:jn(Pn),Baseline:jn(Pn),Histogram:jn(Pn),Line:jn(Pn)};function Un(t){return qn[t]}function Hn(t){return 60*t*60*1e3}function Yn(t){return 60*t*1e3}var Kn,$n=[{Zd:(Kn=1,1e3*Kn),Rh:10},{Zd:Yn(1),Rh:20},{Zd:Yn(5),Rh:21},{Zd:Yn(30),Rh:22},{Zd:Hn(1),Rh:30},{Zd:Hn(3),Rh:31},{Zd:Hn(6),Rh:32},{Zd:Hn(12),Rh:33}];function Xn(t,i){if(t.getUTCFullYear()!==i.getUTCFullYear())return 70;if(t.getUTCMonth()!==i.getUTCMonth())return 60;if(t.getUTCDate()!==i.getUTCDate())return 50;for(var n=$n.length-1;n>=0;--n)if(Math.floor(i.getTime()/$n[n].Zd)!==Math.floor(t.getTime()/$n[n].Zd))return $n[n].Rh;return 0}function Zn(t,i){if(void 0===i&&(i=0),0!==t.length){for(var n=0===i?null:t[i-1].S.Dh,s=null!==n?new Date(1e3*n):null,h=0,r=i;r<t.length;++r){var e=t[r],u=new Date(1e3*e.S.Dh);null!==s&&(e.zh=Xn(u,s)),h+=e.S.Dh-(n||e.S.Dh),n=e.S.Dh,s=u}if(0===i&&t.length>1){var a=Math.ceil(h/(t.length-1)),o=new Date(1e3*(t[0].S.Dh-a));t[0].zh=Xn(new Date(1e3*t[0].S.Dh),o)}}}function Jn(t){if(!It(t))throw new Error("time must be of type BusinessDay");var i=new Date(Date.UTC(t.year,t.month-1,t.day,0,0,0,0));return{Dh:Math.round(i.getTime()/1e3),Sh:t}}function Gn(t){if(!jt(t))throw new Error("time must be of type isUTCTimestamp");return{Dh:t}}function Qn(t){return 0===t.length?null:It(t[0].time)?Jn:Gn}function ts(t){return jt(t)?Gn(t):It(t)?Jn(t):Jn(is(t))}function is(t){var i=new Date(t);if(isNaN(i.getTime()))throw new Error("Invalid date string="+t+", expected format=yyyy-mm-dd");return{day:i.getUTCDate(),month:i.getUTCMonth()+1,year:i.getUTCFullYear()}}function ns(t){w(t.time)&&(t.time=is(t.time))}function ss(t){return{Ph:0,Jd:new Map,Rs:t}}var hs=function(){function t(){this.Gd=new Map,this.Qd=new Map,this.tw=new Map,this.iw=[]}return t.prototype.en=function(){this.Gd.clear(),this.Qd.clear(),this.tw.clear(),this.iw=[]},t.prototype.nw=function(t,i){var n=this,s=0!==this.Gd.size,h=!1;if(this.Qd.has(t))if(1===this.Qd.size)s=!1,h=!0,this.Gd.clear();else for(var r=0,e=this.iw;r<e.length;r++){e[r].pointData.Jd.delete(t)&&(h=!0)}var u=[];if(0!==i.length){!function(t){t.forEach(ns)}(i);var a=f(Qn(i)),o=Un(t.Ya());u=i.map((function(i){var s=a(i.time),r=n.Gd.get(s.Dh);void 0===r&&(r=ss(s),n.Gd.set(s.Dh,r),h=!0);var e=o(s,r.Ph,i);return r.Jd.set(t,e),e}))}s&&this.sw(),this.hw(t,u);var l=-1;if(h){var c=[];this.Gd.forEach((function(t){c.push({zh:0,S:t.Rs,pointData:t})})),c.sort((function(t,i){return t.S.Dh-i.S.Dh})),l=this.rw(c)}return this.ew(t,l)},t.prototype.Of=function(t){return this.nw(t,[])},t.prototype.uw=function(t,i){ns(i);var n=f(Qn([i]))(i.time),s=this.tw.get(t);if(void 0!==s&&n.Dh<s.Dh)throw new Error("Cannot update oldest data, last time="+s.Dh+", new time="+n.Dh);var h=this.Gd.get(n.Dh),r=void 0===h;void 0===h&&(h=ss(n),this.Gd.set(n.Dh,h));var e=Un(t.Ya())(n,h.Ph,i);if(h.Jd.set(t,e),this.aw(t,e),!r)return this.ew(t,-1);var u={zh:0,S:h.Rs,pointData:h},a=Bt(this.iw,u.S.Dh,(function(t,i){return t.S.Dh<i}));this.iw.splice(a,0,u);for(var o=a;o<this.iw.length;++o)rs(this.iw[o].pointData,o);return Zn(this.iw,a),this.ew(t,a)},t.prototype.aw=function(t,i){var n=this.Qd.get(t);void 0===n&&(n=[],this.Qd.set(t,n));var s=0!==n.length?n[n.length-1]:null;null===s||i.S.Dh>s.S.Dh?In(i)&&n.push(i):In(i)?n[n.length-1]=i:n.splice(-1,1),this.tw.set(t,i.S)},t.prototype.hw=function(t,i){0!==i.length?(this.Qd.set(t,i.filter(In)),this.tw.set(t,i[i.length-1].S)):(this.Qd.delete(t),this.tw.delete(t))},t.prototype.sw=function(){for(var t=0,i=this.iw;t<i.length;t++){var n=i[t];0===n.pointData.Jd.size&&this.Gd.delete(n.S.Dh)}},t.prototype.rw=function(t){for(var i=-1,n=0;n<this.iw.length&&n<t.length;++n){var s=this.iw[n],h=t[n];if(s.S.Dh!==h.S.Dh){i=n;break}h.zh=s.zh,rs(h.pointData,n)}if(-1===i&&this.iw.length!==t.length&&(i=Math.min(this.iw.length,t.length)),-1===i)return-1;for(n=i;n<t.length;++n)rs(t[n].pointData,n);return Zn(t,i),this.iw=t,i},t.prototype.ow=function(){if(0===this.Qd.size)return null;var t=0;return this.Qd.forEach((function(i){0!==i.length&&(t=Math.max(t,i[i.length-1].Ph))})),t},t.prototype.ew=function(t,i){var n={lw:new Map,j:{Br:this.ow()}};if(-1!==i)this.Qd.forEach((function(t,i){n.lw.set(i,{Zu:t})})),this.Qd.has(t)||n.lw.set(t,{Zu:[]}),n.j.fw=this.iw,n.j.cw=i;else{var s=this.Qd.get(t);n.lw.set(t,{Zu:s||[]})}return n},t}();function rs(t,i){t.Ph=i,t.Jd.forEach((function(t){t.Ph=i}))}var es={color:"#FF0000",price:0,lineStyle:2,lineWidth:1,axisLabelVisible:!0,title:""},us=function(){function t(t){this.Ia=t}return t.prototype.applyOptions=function(t){this.Ia.rs(t)},t.prototype.options=function(){return this.Ia.ct()},t.prototype._w=function(){return this.Ia},t}();function as(t){var i=t.overlay,n=function(t,i){var n={};for(var s in t)Object.prototype.hasOwnProperty.call(t,s)&&i.indexOf(s)<0&&(n[s]=t[s]);if(null!=t&&"function"==typeof Object.getOwnPropertySymbols){var h=0;for(s=Object.getOwnPropertySymbols(t);h<s.length;h++)i.indexOf(s[h])<0&&Object.prototype.propertyIsEnumerable.call(t,s[h])&&(n[s[h]]=t[s[h]])}return n}(t,["overlay"]);return i&&(n.priceScaleId=""),n}var os=function(){function t(t,i,n){this.qe=t,this.dw=i,this.ww=n}return t.prototype.priceFormatter=function(){return this.qe.$s()},t.prototype.priceToCoordinate=function(t){var i=this.qe.H();return null===i?null:this.qe.$().K(t,i.X)},t.prototype.coordinateToPrice=function(t){var i=this.qe.H();return null===i?null:this.qe.$().Si(t,i.X)},t.prototype.barsInLogicalRange=function(t){if(null===t)return null;var i=new zt(new Et(t.from,t.to)).Hh(),n=this.qe.Hi();if(n.ti())return null;var s=n.oo(i.hh(),1),h=n.oo(i.rh(),-1),r=f(n.eo()),e=f(n.Ui());if(null!==s&&null!==h&&s.Ph>h.Ph)return{barsBefore:t.from-r,barsAfter:e-t.to};var u={barsBefore:null===s||s.Ph===r?t.from-r:s.Ph-r,barsAfter:null===h||h.Ph===e?e-t.to:e-h.Ph};return null!==s&&null!==h&&(u.from=s.S.Sh||s.S.Dh,u.to=h.S.Sh||h.S.Dh),u},t.prototype.setData=function(t){this.qe.Ya(),this.dw.Mw(this.qe,t)},t.prototype.update=function(t){this.qe.Ya(),this.dw.bw(this.qe,t)},t.prototype.setMarkers=function(t){var i=t.map((function(t){return u(u({},t),{time:ts(t.time)})}));this.qe.Wo(i)},t.prototype.applyOptions=function(t){var i=as(t);this.qe.rs(i)},t.prototype.options=function(){return b(this.qe.ct())},t.prototype.priceScale=function(){return this.ww.priceScale(this.qe.$().hs())},t.prototype.createPriceLine=function(t){var i=v(b(es),t),n=this.qe.zo(i);return new us(n)},t.prototype.removePriceLine=function(t){this.qe.Po(t._w())},t.prototype.seriesType=function(){return this.qe.Ya()},t}(),ls=function(t){function i(){return null!==t&&t.apply(this,arguments)||this}return e(i,t),i.prototype.applyOptions=function(i){Ct(i),t.prototype.applyOptions.call(this,i)},i}(os),fs={autoScale:!0,mode:0,invertScale:!1,alignLabels:!0,borderVisible:!0,borderColor:"#2B2B43",entireTextOnly:!1,visible:!1,drawTicks:!0,scaleMargins:{bottom:.1,top:.2}},cs={color:"rgba(0, 0, 0, 0)",visible:!1,fontSize:48,fontFamily:qt,fontStyle:"",text:"",horzAlign:"center",vertAlign:"center"},vs={width:0,height:0,layout:{background:{type:"solid",color:"#FFFFFF"},textColor:"#191919",fontSize:11,fontFamily:qt},crosshair:{vertLine:{color:"#758696",width:1,style:3,visible:!0,labelVisible:!0,labelBackgroundColor:"#4c525e"},horzLine:{color:"#758696",width:1,style:3,visible:!0,labelVisible:!0,labelBackgroundColor:"#4c525e"},mode:1},grid:{vertLines:{color:"#D6DCDE",style:0,visible:!0},horzLines:{color:"#D6DCDE",style:0,visible:!0}},overlayPriceScales:u({},fs),leftPriceScale:u(u({},fs),{visible:!1}),rightPriceScale:u(u({},fs),{visible:!0}),timeScale:{rightOffset:0,barSpacing:6,minBarSpacing:.5,fixLeftEdge:!1,fixRightEdge:!1,lockVisibleTimeRangeOnResize:!1,rightBarStaysOnScroll:!1,borderVisible:!0,borderColor:"#2B2B43",visible:!0,timeVisible:!1,secondsVisible:!0,shiftVisibleRangeOnNewBar:!0},watermark:cs,localization:{locale:mn?navigator.language:"",dateFormat:"dd MMM 'yy"},handleScroll:{mouseWheel:!0,pressedMouseMove:!0,horzTouchDrag:!0,vertTouchDrag:!0},handleScale:{axisPressedMouseMove:{time:!0,price:!0},axisDoubleClickReset:!0,mouseWheel:!0,pinch:!0},kineticScroll:{mouse:!1,touch:!0}},_s={upColor:"#26a69a",downColor:"#ef5350",wickVisible:!0,borderVisible:!0,borderColor:"#378658",borderUpColor:"#26a69a",borderDownColor:"#ef5350",wickColor:"#737375",wickUpColor:"#26a69a",wickDownColor:"#ef5350"},ds={upColor:"#26a69a",downColor:"#ef5350",openVisible:!0,thinBars:!0},ws={color:"#2196f3",lineStyle:0,lineWidth:3,lineType:0,crosshairMarkerVisible:!0,crosshairMarkerRadius:4,crosshairMarkerBorderColor:"",crosshairMarkerBackgroundColor:"",lastPriceAnimation:0},Ms={topColor:"rgba( 46, 220, 135, 0.4)",bottomColor:"rgba( 40, 221, 100, 0)",lineColor:"#33D778",lineStyle:0,lineWidth:3,lineType:0,crosshairMarkerVisible:!0,crosshairMarkerRadius:4,crosshairMarkerBorderColor:"",crosshairMarkerBackgroundColor:"",lastPriceAnimation:0},bs={baseValue:{type:"price",price:0},topFillColor1:"rgba(38, 166, 154, 0.28)",topFillColor2:"rgba(38, 166, 154, 0.05)",topLineColor:"rgba(38, 166, 154, 1)",bottomFillColor1:"rgba(239, 83, 80, 0.05)",bottomFillColor2:"rgba(239, 83, 80, 0.28)",bottomLineColor:"rgba(239, 83, 80, 1)",lineWidth:3,lineStyle:0,crosshairMarkerVisible:!0,crosshairMarkerRadius:4,crosshairMarkerBorderColor:"",crosshairMarkerBackgroundColor:"",lastPriceAnimation:0},ms={color:"#26a69a",base:0},ps={title:"",visible:!0,lastValueVisible:!0,priceLineVisible:!0,priceLineSource:0,priceLineWidth:1,priceLineColor:"",priceLineStyle:2,baseLineVisible:!0,baseLineWidth:1,baseLineColor:"#B2B5BE",baseLineStyle:0,priceFormat:{type:"price",precision:2,minMove:.01}},gs=function(){function t(t,i){this.mw=t,this.pw=i}return t.prototype.applyOptions=function(t){this.mw.vt()._f(this.pw,t)},t.prototype.options=function(){return this.Gt().ct()},t.prototype.width=function(){return Yt(this.pw)?this.mw.Id("left"===this.pw?"left":"right"):0},t.prototype.Gt=function(){return f(this.mw.vt().df(this.pw)).$},t}(),ys=function(){function t(t,i){this.gw=new it,this.nr=new it,this.sd=new it,this.hi=t,this.ul=t.j(),this.Bd=i,this.ul.Xr().Ji(this.yw.bind(this)),this.ul.Zr().Ji(this.kw.bind(this)),this.Bd.fd().Ji(this.Cw.bind(this))}return t.prototype.en=function(){this.ul.Xr().sn(this),this.ul.Zr().sn(this),this.Bd.fd().sn(this),this.gw.en(),this.nr.en(),this.sd.en()},t.prototype.scrollPosition=function(){return this.ul.Pr()},t.prototype.scrollToPosition=function(t,i){i?this.ul.$r(t,1e3):this.hi.Mr(t)},t.prototype.scrollToRealTime=function(){this.ul.Kr()},t.prototype.getVisibleRange=function(){var t,i,n=this.ul.yr();return null===n?null:{from:null!==(t=n.from.Sh)&&void 0!==t?t:n.from.Dh,to:null!==(i=n.to.Sh)&&void 0!==i?i:n.to.Dh}},t.prototype.setVisibleRange=function(t){var i={from:ts(t.from),to:ts(t.to)},n=this.ul.Sr(i);this.hi.Wf(n)},t.prototype.getVisibleLogicalRange=function(){var t=this.ul.gr();return null===t?null:{from:t.hh(),to:t.rh()}},t.prototype.setVisibleLogicalRange=function(t){o(t.from<=t.to,"The from index cannot be after the to index."),this.hi.Wf(t)},t.prototype.resetTimeScale=function(){this.hi.Ne()},t.prototype.fitContent=function(){this.hi.Qr()},t.prototype.logicalToCoordinate=function(t){var i=this.hi.j();return i.ti()?null:i.G(t)},t.prototype.coordinateToLogical=function(t){return this.ul.ti()?null:this.ul.Fr(t)},t.prototype.timeToCoordinate=function(t){var i=ts(t),n=this.ul.br(i,!1);return null===n?null:this.ul.G(n)},t.prototype.coordinateToTime=function(t){var i,n=this.hi.j(),s=n.Fr(t),h=n.ri(s);return null===h?null:null!==(i=h.Sh)&&void 0!==i?i:h.Dh},t.prototype.width=function(){return this.Bd.z_().st},t.prototype.height=function(){return this.Bd.z_().ht},t.prototype.subscribeVisibleTimeRangeChange=function(t){this.gw.Ji(t)},t.prototype.unsubscribeVisibleTimeRangeChange=function(t){this.gw.nn(t)},t.prototype.subscribeVisibleLogicalRangeChange=function(t){this.nr.Ji(t)},t.prototype.unsubscribeVisibleLogicalRangeChange=function(t){this.nr.nn(t)},t.prototype.subscribeSizeChange=function(t){this.sd.Ji(t)},t.prototype.unsubscribeSizeChange=function(t){this.sd.nn(t)},t.prototype.applyOptions=function(t){this.ul.rs(t)},t.prototype.options=function(){return b(this.ul.ct())},t.prototype.yw=function(){this.gw.rn()&&this.gw.hn(this.getVisibleRange())},t.prototype.kw=function(){this.nr.rn()&&this.nr.hn(this.getVisibleLogicalRange())},t.prototype.Cw=function(t){this.sd.hn(t.st,t.ht)},t}();function ks(t){if(void 0!==t&&"custom"!==t.type){var i=t;void 0!==i.minMove&&void 0===i.precision&&(i.precision=function(t){if(t>=1)return 0;for(var i=0;i<8;i++){var n=Math.round(t);if(Math.abs(n-t)<1e-8)return i;t*=10}return i}(i.minMove))}}function Cs(t){return function(t){if(M(t.handleScale)){var i=t.handleScale;t.handleScale={axisDoubleClickReset:i,axisPressedMouseMove:{time:i,price:i},mouseWheel:i,pinch:i}}else if(void 0!==t.handleScale&&M(t.handleScale.axisPressedMouseMove)){var n=t.handleScale.axisPressedMouseMove;t.handleScale.axisPressedMouseMove={time:n,price:n}}var s=t.handleScroll;M(s)&&(t.handleScroll={horzTouchDrag:s,vertTouchDrag:s,mouseWheel:s,pressedMouseMove:s})}(t),function(t){if(t.priceScale){t.leftPriceScale=t.leftPriceScale||{},t.rightPriceScale=t.rightPriceScale||{};var i=t.priceScale.position;delete t.priceScale.position,t.leftPriceScale=v(t.leftPriceScale,t.priceScale),t.rightPriceScale=v(t.rightPriceScale,t.priceScale),"left"===i&&(t.leftPriceScale.visible=!0,t.rightPriceScale.visible=!1),"right"===i&&(t.leftPriceScale.visible=!1,t.rightPriceScale.visible=!0),"none"===i&&(t.leftPriceScale.visible=!1,t.rightPriceScale.visible=!1),t.overlayPriceScales=t.overlayPriceScales||{},void 0!==t.priceScale.invertScale&&(t.overlayPriceScales.invertScale=t.priceScale.invertScale),void 0!==t.priceScale.scaleMargins&&(t.overlayPriceScales.scaleMargins=t.priceScale.scaleMargins)}}(t),function(t){t.layout&&t.layout.backgroundColor&&!t.layout.background&&(t.layout.background={type:"solid",color:t.layout.backgroundColor})}(t),t}var Ns=function(){function t(t,i){var n=this;this.Nw=new hs,this.xw=new Map,this.Sw=new Map,this.Dw=new it,this.Aw=new it;var s=void 0===i?b(vs):v(b(vs),Cs(i));this.mw=new zn(t,s),this.mw.V_().Ji((function(t){n.Dw.rn()&&n.Dw.hn(n.Tw(t()))}),this),this.mw.mf().Ji((function(t){n.Aw.rn()&&n.Aw.hn(n.Tw(t()))}),this);var h=this.mw.vt();this.Bw=new ys(h,this.mw.Od())}return t.prototype.remove=function(){this.mw.V_().sn(this),this.mw.mf().sn(this),this.Bw.en(),this.mw.en(),this.xw.clear(),this.Sw.clear(),this.Dw.en(),this.Aw.en(),this.Nw.en()},t.prototype.resize=function(t,i,n){this.mw.Ld(t,i,n)},t.prototype.addAreaSeries=function(t){void 0===t&&(t={}),ks((t=as(t)).priceFormat);var i=v(b(ps),Ms,t),n=this.mw.vt().Ef("Area",i),s=new os(n,this,this);return this.xw.set(s,n),this.Sw.set(n,s),s},t.prototype.addBaselineSeries=function(t){void 0===t&&(t={}),ks((t=as(t)).priceFormat);var i=v(b(ps),bs,t),n=this.mw.vt().Ef("Baseline",i),s=new os(n,this,this);return this.xw.set(s,n),this.Sw.set(n,s),s},t.prototype.addBarSeries=function(t){void 0===t&&(t={}),ks((t=as(t)).priceFormat);var i=v(b(ps),ds,t),n=this.mw.vt().Ef("Bar",i),s=new os(n,this,this);return this.xw.set(s,n),this.Sw.set(n,s),s},t.prototype.addCandlestickSeries=function(t){void 0===t&&(t={}),Ct(t=as(t)),ks(t.priceFormat);var i=v(b(ps),_s,t),n=this.mw.vt().Ef("Candlestick",i),s=new ls(n,this,this);return this.xw.set(s,n),this.Sw.set(n,s),s},t.prototype.addHistogramSeries=function(t){void 0===t&&(t={}),ks((t=as(t)).priceFormat);var i=v(b(ps),ms,t),n=this.mw.vt().Ef("Histogram",i),s=new os(n,this,this);return this.xw.set(s,n),this.Sw.set(n,s),s},t.prototype.addLineSeries=function(t){void 0===t&&(t={}),ks((t=as(t)).priceFormat);var i=v(b(ps),ws,t),n=this.mw.vt().Ef("Line",i),s=new os(n,this,this);return this.xw.set(s,n),this.Sw.set(n,s),s},t.prototype.removeSeries=function(t){var i=l(this.xw.get(t)),n=this.Nw.Of(i);this.mw.vt().Of(i),this.Lw(n),this.xw.delete(t),this.Sw.delete(i)},t.prototype.Mw=function(t,i){this.Lw(this.Nw.nw(t,i))},t.prototype.bw=function(t,i){this.Lw(this.Nw.uw(t,i))},t.prototype.subscribeClick=function(t){this.Dw.Ji(t)},t.prototype.unsubscribeClick=function(t){this.Dw.nn(t)},t.prototype.subscribeCrosshairMove=function(t){this.Aw.Ji(t)},t.prototype.unsubscribeCrosshairMove=function(t){this.Aw.nn(t)},t.prototype.priceScale=function(t){return void 0===t&&(t=this.mw.vt().zf()),new gs(this.mw,t)},t.prototype.timeScale=function(){return this.Bw},t.prototype.applyOptions=function(t){this.mw.rs(Cs(t))},t.prototype.options=function(){return this.mw.ct()},t.prototype.takeScreenshot=function(){return this.mw.zd()},t.prototype.Lw=function(t){var i=this.mw.vt();i.Lf(t.j.Br,t.j.fw,t.j.cw),t.lw.forEach((function(t,i){return i._(t.Zu)})),i.Vr()},t.prototype.Fw=function(t){return l(this.Sw.get(t))},t.prototype.Tw=function(t){var i=this,n=new Map;t.$d.forEach((function(t,s){n.set(i.Fw(s),t)}));var s=void 0===t.Kd?void 0:this.Fw(t.Kd);return{time:t.S&&(t.S.Sh||t.S.Dh),point:t.Yd,hoveredSeries:s,hoveredMarkerId:t.Xd,seriesPrices:n}},t}();function xs(t,i){var n;if(w(t)){var s=document.getElementById(t);o(null!==s,"Cannot find element in DOM with id="+t),n=s}else n=t;return new Ns(n,i)}function Ss(){return"3.7.0"}


/***/ }),

/***/ 530301:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (true) {
	module.exports = __webpack_require__(8765);
} else {}


/***/ }),

/***/ 839275:
/***/ ((module) => {

"use strict";


var safeIsNaN = Number.isNaN ||
    function ponyfill(value) {
        return typeof value === 'number' && value !== value;
    };
function isEqual(first, second) {
    if (first === second) {
        return true;
    }
    if (safeIsNaN(first) && safeIsNaN(second)) {
        return true;
    }
    return false;
}
function areInputsEqual(newInputs, lastInputs) {
    if (newInputs.length !== lastInputs.length) {
        return false;
    }
    for (var i = 0; i < newInputs.length; i++) {
        if (!isEqual(newInputs[i], lastInputs[i])) {
            return false;
        }
    }
    return true;
}

function memoizeOne(resultFn, isEqual) {
    if (isEqual === void 0) { isEqual = areInputsEqual; }
    var lastThis;
    var lastArgs = [];
    var lastResult;
    var calledOnce = false;
    function memoized() {
        var newArgs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            newArgs[_i] = arguments[_i];
        }
        if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) {
            return lastResult;
        }
        lastResult = resultFn.apply(this, newArgs);
        calledOnce = true;
        lastThis = this;
        lastArgs = newArgs;
        return lastResult;
    }
    return memoized;
}

module.exports = memoizeOne;


/***/ }),

/***/ 158361:
/***/ ((module) => {

"use strict";


var rafSchd = function rafSchd(fn) {
  var lastArgs = [];
  var frameId = null;

  var wrapperFn = function wrapperFn() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    lastArgs = args;

    if (frameId) {
      return;
    }

    frameId = requestAnimationFrame(function () {
      frameId = null;
      fn.apply(void 0, lastArgs);
    });
  };

  wrapperFn.cancel = function () {
    if (!frameId) {
      return;
    }

    cancelAnimationFrame(frameId);
    frameId = null;
  };

  return wrapperFn;
};

module.exports = rafSchd;


/***/ }),

/***/ 323605:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;


__webpack_unused_export__ = ({ value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = __webpack_require__(667294);
var React__default = _interopDefault(React);
var _inheritsLoose = _interopDefault(__webpack_require__(617357));
var _extends = _interopDefault(__webpack_require__(880615));
var redux = __webpack_require__(535281);
var reactRedux = __webpack_require__(837424);
var useMemoOne = __webpack_require__(335185);
var cssBoxModel = __webpack_require__(44125);
var memoizeOne = _interopDefault(__webpack_require__(839275));
var rafSchd = _interopDefault(__webpack_require__(158361));
var ReactDOM = _interopDefault(__webpack_require__(973935));

var isProduction = "production" === 'production';
var spacesAndTabs = /[ \t]{2,}/g;
var lineStartWithSpaces = /^[ \t]*/gm;

var clean = function clean(value) {
  return value.replace(spacesAndTabs, ' ').replace(lineStartWithSpaces, '').trim();
};

var getDevMessage = function getDevMessage(message) {
  return clean("\n  %creact-beautiful-dnd\n\n  %c" + clean(message) + "\n\n  %c\uD83D\uDC77\u200D This is a development only message. It will be removed in production builds.\n");
};

var getFormattedMessage = function getFormattedMessage(message) {
  return [getDevMessage(message), 'color: #00C584; font-size: 1.2em; font-weight: bold;', 'line-height: 1.5', 'color: #723874;'];
};
var isDisabledFlag = '__react-beautiful-dnd-disable-dev-warnings';
function log(type, message) {
  var _console;

  if (isProduction) {
    return;
  }

  if (typeof window !== 'undefined' && window[isDisabledFlag]) {
    return;
  }

  (_console = console)[type].apply(_console, getFormattedMessage(message));
}
var warning = log.bind(null, 'warn');
var error = log.bind(null, 'error');

function noop() {}

function getOptions(shared, fromBinding) {
  return _extends({}, shared, {}, fromBinding);
}

function bindEvents(el, bindings, sharedOptions) {
  var unbindings = bindings.map(function (binding) {
    var options = getOptions(sharedOptions, binding.options);
    el.addEventListener(binding.eventName, binding.fn, options);
    return function unbind() {
      el.removeEventListener(binding.eventName, binding.fn, options);
    };
  });
  return function unbindAll() {
    unbindings.forEach(function (unbind) {
      unbind();
    });
  };
}

var isProduction$1 = "production" === 'production';
var prefix = 'Invariant failed';
function RbdInvariant(message) {
  this.message = message;
}

RbdInvariant.prototype.toString = function toString() {
  return this.message;
};

function invariant(condition, message) {
  if (condition) {
    return;
  }

  if (isProduction$1) {
    throw new RbdInvariant(prefix);
  } else {
    throw new RbdInvariant(prefix + ": " + (message || ''));
  }
}

var ErrorBoundary = function (_React$Component) {
  _inheritsLoose(ErrorBoundary, _React$Component);

  function ErrorBoundary() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.callbacks = null;
    _this.unbind = noop;

    _this.onWindowError = function (event) {
      var callbacks = _this.getCallbacks();

      if (callbacks.isDragging()) {
        callbacks.tryAbort();
         false ? 0 : void 0;
      }

      var err = event.error;

      if (err instanceof RbdInvariant) {
        event.preventDefault();

        if (false) {}
      }
    };

    _this.getCallbacks = function () {
      if (!_this.callbacks) {
        throw new Error('Unable to find AppCallbacks in <ErrorBoundary/>');
      }

      return _this.callbacks;
    };

    _this.setCallbacks = function (callbacks) {
      _this.callbacks = callbacks;
    };

    return _this;
  }

  var _proto = ErrorBoundary.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.unbind = bindEvents(window, [{
      eventName: 'error',
      fn: this.onWindowError
    }]);
  };

  _proto.componentDidCatch = function componentDidCatch(err) {
    if (err instanceof RbdInvariant) {
      if (false) {}

      this.setState({});
      return;
    }

    throw err;
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.unbind();
  };

  _proto.render = function render() {
    return this.props.children(this.setCallbacks);
  };

  return ErrorBoundary;
}(React__default.Component);

var dragHandleUsageInstructions = "\n  Press space bar to start a drag.\n  When dragging you can use the arrow keys to move the item around and escape to cancel.\n  Some screen readers may require you to be in focus mode or to use your pass through key\n";

var position = function position(index) {
  return index + 1;
};

var onDragStart = function onDragStart(start) {
  return "\n  You have lifted an item in position " + position(start.source.index) + "\n";
};

var withLocation = function withLocation(source, destination) {
  var isInHomeList = source.droppableId === destination.droppableId;
  var startPosition = position(source.index);
  var endPosition = position(destination.index);

  if (isInHomeList) {
    return "\n      You have moved the item from position " + startPosition + "\n      to position " + endPosition + "\n    ";
  }

  return "\n    You have moved the item from position " + startPosition + "\n    in list " + source.droppableId + "\n    to list " + destination.droppableId + "\n    in position " + endPosition + "\n  ";
};

var withCombine = function withCombine(id, source, combine) {
  var inHomeList = source.droppableId === combine.droppableId;

  if (inHomeList) {
    return "\n      The item " + id + "\n      has been combined with " + combine.draggableId;
  }

  return "\n      The item " + id + "\n      in list " + source.droppableId + "\n      has been combined with " + combine.draggableId + "\n      in list " + combine.droppableId + "\n    ";
};

var onDragUpdate = function onDragUpdate(update) {
  var location = update.destination;

  if (location) {
    return withLocation(update.source, location);
  }

  var combine = update.combine;

  if (combine) {
    return withCombine(update.draggableId, update.source, combine);
  }

  return 'You are over an area that cannot be dropped on';
};

var returnedToStart = function returnedToStart(source) {
  return "\n  The item has returned to its starting position\n  of " + position(source.index) + "\n";
};

var onDragEnd = function onDragEnd(result) {
  if (result.reason === 'CANCEL') {
    return "\n      Movement cancelled.\n      " + returnedToStart(result.source) + "\n    ";
  }

  var location = result.destination;
  var combine = result.combine;

  if (location) {
    return "\n      You have dropped the item.\n      " + withLocation(result.source, location) + "\n    ";
  }

  if (combine) {
    return "\n      You have dropped the item.\n      " + withCombine(result.draggableId, result.source, combine) + "\n    ";
  }

  return "\n    The item has been dropped while not over a drop area.\n    " + returnedToStart(result.source) + "\n  ";
};

var preset = {
  dragHandleUsageInstructions: dragHandleUsageInstructions,
  onDragStart: onDragStart,
  onDragUpdate: onDragUpdate,
  onDragEnd: onDragEnd
};

var origin = {
  x: 0,
  y: 0
};
var add = function add(point1, point2) {
  return {
    x: point1.x + point2.x,
    y: point1.y + point2.y
  };
};
var subtract = function subtract(point1, point2) {
  return {
    x: point1.x - point2.x,
    y: point1.y - point2.y
  };
};
var isEqual = function isEqual(point1, point2) {
  return point1.x === point2.x && point1.y === point2.y;
};
var negate = function negate(point) {
  return {
    x: point.x !== 0 ? -point.x : 0,
    y: point.y !== 0 ? -point.y : 0
  };
};
var patch = function patch(line, value, otherValue) {
  var _ref;

  if (otherValue === void 0) {
    otherValue = 0;
  }

  return _ref = {}, _ref[line] = value, _ref[line === 'x' ? 'y' : 'x'] = otherValue, _ref;
};
var distance = function distance(point1, point2) {
  return Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2));
};
var closest = function closest(target, points) {
  return Math.min.apply(Math, points.map(function (point) {
    return distance(target, point);
  }));
};
var apply = function apply(fn) {
  return function (point) {
    return {
      x: fn(point.x),
      y: fn(point.y)
    };
  };
};

var executeClip = (function (frame, subject) {
  var result = cssBoxModel.getRect({
    top: Math.max(subject.top, frame.top),
    right: Math.min(subject.right, frame.right),
    bottom: Math.min(subject.bottom, frame.bottom),
    left: Math.max(subject.left, frame.left)
  });

  if (result.width <= 0 || result.height <= 0) {
    return null;
  }

  return result;
});

var offsetByPosition = function offsetByPosition(spacing, point) {
  return {
    top: spacing.top + point.y,
    left: spacing.left + point.x,
    bottom: spacing.bottom + point.y,
    right: spacing.right + point.x
  };
};
var getCorners = function getCorners(spacing) {
  return [{
    x: spacing.left,
    y: spacing.top
  }, {
    x: spacing.right,
    y: spacing.top
  }, {
    x: spacing.left,
    y: spacing.bottom
  }, {
    x: spacing.right,
    y: spacing.bottom
  }];
};
var noSpacing = {
  top: 0,
  right: 0,
  bottom: 0,
  left: 0
};

var scroll = function scroll(target, frame) {
  if (!frame) {
    return target;
  }

  return offsetByPosition(target, frame.scroll.diff.displacement);
};

var increase = function increase(target, axis, withPlaceholder) {
  if (withPlaceholder && withPlaceholder.increasedBy) {
    var _extends2;

    return _extends({}, target, (_extends2 = {}, _extends2[axis.end] = target[axis.end] + withPlaceholder.increasedBy[axis.line], _extends2));
  }

  return target;
};

var clip = function clip(target, frame) {
  if (frame && frame.shouldClipSubject) {
    return executeClip(frame.pageMarginBox, target);
  }

  return cssBoxModel.getRect(target);
};

var getSubject = (function (_ref) {
  var page = _ref.page,
      withPlaceholder = _ref.withPlaceholder,
      axis = _ref.axis,
      frame = _ref.frame;
  var scrolled = scroll(page.marginBox, frame);
  var increased = increase(scrolled, axis, withPlaceholder);
  var clipped = clip(increased, frame);
  return {
    page: page,
    withPlaceholder: withPlaceholder,
    active: clipped
  };
});

var scrollDroppable = (function (droppable, newScroll) {
  !droppable.frame ?  false ? 0 : invariant(false) : void 0;
  var scrollable = droppable.frame;
  var scrollDiff = subtract(newScroll, scrollable.scroll.initial);
  var scrollDisplacement = negate(scrollDiff);

  var frame = _extends({}, scrollable, {
    scroll: {
      initial: scrollable.scroll.initial,
      current: newScroll,
      diff: {
        value: scrollDiff,
        displacement: scrollDisplacement
      },
      max: scrollable.scroll.max
    }
  });

  var subject = getSubject({
    page: droppable.subject.page,
    withPlaceholder: droppable.subject.withPlaceholder,
    axis: droppable.axis,
    frame: frame
  });

  var result = _extends({}, droppable, {
    frame: frame,
    subject: subject
  });

  return result;
});

function isInteger(value) {
  if (Number.isInteger) {
    return Number.isInteger(value);
  }

  return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;
}
function values(map) {
  if (Object.values) {
    return Object.values(map);
  }

  return Object.keys(map).map(function (key) {
    return map[key];
  });
}
function findIndex(list, predicate) {
  if (list.findIndex) {
    return list.findIndex(predicate);
  }

  for (var i = 0; i < list.length; i++) {
    if (predicate(list[i])) {
      return i;
    }
  }

  return -1;
}
function find(list, predicate) {
  if (list.find) {
    return list.find(predicate);
  }

  var index = findIndex(list, predicate);

  if (index !== -1) {
    return list[index];
  }

  return undefined;
}
function toArray(list) {
  return Array.prototype.slice.call(list);
}

var toDroppableMap = memoizeOne(function (droppables) {
  return droppables.reduce(function (previous, current) {
    previous[current.descriptor.id] = current;
    return previous;
  }, {});
});
var toDraggableMap = memoizeOne(function (draggables) {
  return draggables.reduce(function (previous, current) {
    previous[current.descriptor.id] = current;
    return previous;
  }, {});
});
var toDroppableList = memoizeOne(function (droppables) {
  return values(droppables);
});
var toDraggableList = memoizeOne(function (draggables) {
  return values(draggables);
});

var getDraggablesInsideDroppable = memoizeOne(function (droppableId, draggables) {
  var result = toDraggableList(draggables).filter(function (draggable) {
    return droppableId === draggable.descriptor.droppableId;
  }).sort(function (a, b) {
    return a.descriptor.index - b.descriptor.index;
  });
  return result;
});

function tryGetDestination(impact) {
  if (impact.at && impact.at.type === 'REORDER') {
    return impact.at.destination;
  }

  return null;
}
function tryGetCombine(impact) {
  if (impact.at && impact.at.type === 'COMBINE') {
    return impact.at.combine;
  }

  return null;
}

var removeDraggableFromList = memoizeOne(function (remove, list) {
  return list.filter(function (item) {
    return item.descriptor.id !== remove.descriptor.id;
  });
});

var moveToNextCombine = (function (_ref) {
  var isMovingForward = _ref.isMovingForward,
      draggable = _ref.draggable,
      destination = _ref.destination,
      insideDestination = _ref.insideDestination,
      previousImpact = _ref.previousImpact;

  if (!destination.isCombineEnabled) {
    return null;
  }

  var location = tryGetDestination(previousImpact);

  if (!location) {
    return null;
  }

  function getImpact(target) {
    var at = {
      type: 'COMBINE',
      combine: {
        draggableId: target,
        droppableId: destination.descriptor.id
      }
    };
    return _extends({}, previousImpact, {
      at: at
    });
  }

  var all = previousImpact.displaced.all;
  var closestId = all.length ? all[0] : null;

  if (isMovingForward) {
    return closestId ? getImpact(closestId) : null;
  }

  var withoutDraggable = removeDraggableFromList(draggable, insideDestination);

  if (!closestId) {
    if (!withoutDraggable.length) {
      return null;
    }

    var last = withoutDraggable[withoutDraggable.length - 1];
    return getImpact(last.descriptor.id);
  }

  var indexOfClosest = findIndex(withoutDraggable, function (d) {
    return d.descriptor.id === closestId;
  });
  !(indexOfClosest !== -1) ?  false ? 0 : invariant(false) : void 0;
  var proposedIndex = indexOfClosest - 1;

  if (proposedIndex < 0) {
    return null;
  }

  var before = withoutDraggable[proposedIndex];
  return getImpact(before.descriptor.id);
});

var isHomeOf = (function (draggable, destination) {
  return draggable.descriptor.droppableId === destination.descriptor.id;
});

var noDisplacedBy = {
  point: origin,
  value: 0
};
var emptyGroups = {
  invisible: {},
  visible: {},
  all: []
};
var noImpact = {
  displaced: emptyGroups,
  displacedBy: noDisplacedBy,
  at: null
};

var isWithin = (function (lowerBound, upperBound) {
  return function (value) {
    return lowerBound <= value && value <= upperBound;
  };
});

var isPartiallyVisibleThroughFrame = (function (frame) {
  var isWithinVertical = isWithin(frame.top, frame.bottom);
  var isWithinHorizontal = isWithin(frame.left, frame.right);
  return function (subject) {
    var isContained = isWithinVertical(subject.top) && isWithinVertical(subject.bottom) && isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);

    if (isContained) {
      return true;
    }

    var isPartiallyVisibleVertically = isWithinVertical(subject.top) || isWithinVertical(subject.bottom);
    var isPartiallyVisibleHorizontally = isWithinHorizontal(subject.left) || isWithinHorizontal(subject.right);
    var isPartiallyContained = isPartiallyVisibleVertically && isPartiallyVisibleHorizontally;

    if (isPartiallyContained) {
      return true;
    }

    var isBiggerVertically = subject.top < frame.top && subject.bottom > frame.bottom;
    var isBiggerHorizontally = subject.left < frame.left && subject.right > frame.right;
    var isTargetBiggerThanFrame = isBiggerVertically && isBiggerHorizontally;

    if (isTargetBiggerThanFrame) {
      return true;
    }

    var isTargetBiggerOnOneAxis = isBiggerVertically && isPartiallyVisibleHorizontally || isBiggerHorizontally && isPartiallyVisibleVertically;
    return isTargetBiggerOnOneAxis;
  };
});

var isTotallyVisibleThroughFrame = (function (frame) {
  var isWithinVertical = isWithin(frame.top, frame.bottom);
  var isWithinHorizontal = isWithin(frame.left, frame.right);
  return function (subject) {
    var isContained = isWithinVertical(subject.top) && isWithinVertical(subject.bottom) && isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);
    return isContained;
  };
});

var vertical = {
  direction: 'vertical',
  line: 'y',
  crossAxisLine: 'x',
  start: 'top',
  end: 'bottom',
  size: 'height',
  crossAxisStart: 'left',
  crossAxisEnd: 'right',
  crossAxisSize: 'width'
};
var horizontal = {
  direction: 'horizontal',
  line: 'x',
  crossAxisLine: 'y',
  start: 'left',
  end: 'right',
  size: 'width',
  crossAxisStart: 'top',
  crossAxisEnd: 'bottom',
  crossAxisSize: 'height'
};

var isTotallyVisibleThroughFrameOnAxis = (function (axis) {
  return function (frame) {
    var isWithinVertical = isWithin(frame.top, frame.bottom);
    var isWithinHorizontal = isWithin(frame.left, frame.right);
    return function (subject) {
      if (axis === vertical) {
        return isWithinVertical(subject.top) && isWithinVertical(subject.bottom);
      }

      return isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);
    };
  };
});

var getDroppableDisplaced = function getDroppableDisplaced(target, destination) {
  var displacement = destination.frame ? destination.frame.scroll.diff.displacement : origin;
  return offsetByPosition(target, displacement);
};

var isVisibleInDroppable = function isVisibleInDroppable(target, destination, isVisibleThroughFrameFn) {
  if (!destination.subject.active) {
    return false;
  }

  return isVisibleThroughFrameFn(destination.subject.active)(target);
};

var isVisibleInViewport = function isVisibleInViewport(target, viewport, isVisibleThroughFrameFn) {
  return isVisibleThroughFrameFn(viewport)(target);
};

var isVisible = function isVisible(_ref) {
  var toBeDisplaced = _ref.target,
      destination = _ref.destination,
      viewport = _ref.viewport,
      withDroppableDisplacement = _ref.withDroppableDisplacement,
      isVisibleThroughFrameFn = _ref.isVisibleThroughFrameFn;
  var displacedTarget = withDroppableDisplacement ? getDroppableDisplaced(toBeDisplaced, destination) : toBeDisplaced;
  return isVisibleInDroppable(displacedTarget, destination, isVisibleThroughFrameFn) && isVisibleInViewport(displacedTarget, viewport, isVisibleThroughFrameFn);
};

var isPartiallyVisible = function isPartiallyVisible(args) {
  return isVisible(_extends({}, args, {
    isVisibleThroughFrameFn: isPartiallyVisibleThroughFrame
  }));
};
var isTotallyVisible = function isTotallyVisible(args) {
  return isVisible(_extends({}, args, {
    isVisibleThroughFrameFn: isTotallyVisibleThroughFrame
  }));
};
var isTotallyVisibleOnAxis = function isTotallyVisibleOnAxis(args) {
  return isVisible(_extends({}, args, {
    isVisibleThroughFrameFn: isTotallyVisibleThroughFrameOnAxis(args.destination.axis)
  }));
};

var getShouldAnimate = function getShouldAnimate(id, last, forceShouldAnimate) {
  if (typeof forceShouldAnimate === 'boolean') {
    return forceShouldAnimate;
  }

  if (!last) {
    return true;
  }

  var invisible = last.invisible,
      visible = last.visible;

  if (invisible[id]) {
    return false;
  }

  var previous = visible[id];
  return previous ? previous.shouldAnimate : true;
};

function getTarget(draggable, displacedBy) {
  var marginBox = draggable.page.marginBox;
  var expandBy = {
    top: displacedBy.point.y,
    right: 0,
    bottom: 0,
    left: displacedBy.point.x
  };
  return cssBoxModel.getRect(cssBoxModel.expand(marginBox, expandBy));
}

function getDisplacementGroups(_ref) {
  var afterDragging = _ref.afterDragging,
      destination = _ref.destination,
      displacedBy = _ref.displacedBy,
      viewport = _ref.viewport,
      forceShouldAnimate = _ref.forceShouldAnimate,
      last = _ref.last;
  return afterDragging.reduce(function process(groups, draggable) {
    var target = getTarget(draggable, displacedBy);
    var id = draggable.descriptor.id;
    groups.all.push(id);
    var isVisible = isPartiallyVisible({
      target: target,
      destination: destination,
      viewport: viewport,
      withDroppableDisplacement: true
    });

    if (!isVisible) {
      groups.invisible[draggable.descriptor.id] = true;
      return groups;
    }

    var shouldAnimate = getShouldAnimate(id, last, forceShouldAnimate);
    var displacement = {
      draggableId: id,
      shouldAnimate: shouldAnimate
    };
    groups.visible[id] = displacement;
    return groups;
  }, {
    all: [],
    visible: {},
    invisible: {}
  });
}

function getIndexOfLastItem(draggables, options) {
  if (!draggables.length) {
    return 0;
  }

  var indexOfLastItem = draggables[draggables.length - 1].descriptor.index;
  return options.inHomeList ? indexOfLastItem : indexOfLastItem + 1;
}

function goAtEnd(_ref) {
  var insideDestination = _ref.insideDestination,
      inHomeList = _ref.inHomeList,
      displacedBy = _ref.displacedBy,
      destination = _ref.destination;
  var newIndex = getIndexOfLastItem(insideDestination, {
    inHomeList: inHomeList
  });
  return {
    displaced: emptyGroups,
    displacedBy: displacedBy,
    at: {
      type: 'REORDER',
      destination: {
        droppableId: destination.descriptor.id,
        index: newIndex
      }
    }
  };
}

function calculateReorderImpact(_ref2) {
  var draggable = _ref2.draggable,
      insideDestination = _ref2.insideDestination,
      destination = _ref2.destination,
      viewport = _ref2.viewport,
      displacedBy = _ref2.displacedBy,
      last = _ref2.last,
      index = _ref2.index,
      forceShouldAnimate = _ref2.forceShouldAnimate;
  var inHomeList = isHomeOf(draggable, destination);

  if (index == null) {
    return goAtEnd({
      insideDestination: insideDestination,
      inHomeList: inHomeList,
      displacedBy: displacedBy,
      destination: destination
    });
  }

  var match = find(insideDestination, function (item) {
    return item.descriptor.index === index;
  });

  if (!match) {
    return goAtEnd({
      insideDestination: insideDestination,
      inHomeList: inHomeList,
      displacedBy: displacedBy,
      destination: destination
    });
  }

  var withoutDragging = removeDraggableFromList(draggable, insideDestination);
  var sliceFrom = insideDestination.indexOf(match);
  var impacted = withoutDragging.slice(sliceFrom);
  var displaced = getDisplacementGroups({
    afterDragging: impacted,
    destination: destination,
    displacedBy: displacedBy,
    last: last,
    viewport: viewport.frame,
    forceShouldAnimate: forceShouldAnimate
  });
  return {
    displaced: displaced,
    displacedBy: displacedBy,
    at: {
      type: 'REORDER',
      destination: {
        droppableId: destination.descriptor.id,
        index: index
      }
    }
  };
}

function didStartAfterCritical(draggableId, afterCritical) {
  return Boolean(afterCritical.effected[draggableId]);
}

var fromCombine = (function (_ref) {
  var isMovingForward = _ref.isMovingForward,
      destination = _ref.destination,
      draggables = _ref.draggables,
      combine = _ref.combine,
      afterCritical = _ref.afterCritical;

  if (!destination.isCombineEnabled) {
    return null;
  }

  var combineId = combine.draggableId;
  var combineWith = draggables[combineId];
  var combineWithIndex = combineWith.descriptor.index;
  var didCombineWithStartAfterCritical = didStartAfterCritical(combineId, afterCritical);

  if (didCombineWithStartAfterCritical) {
    if (isMovingForward) {
      return combineWithIndex;
    }

    return combineWithIndex - 1;
  }

  if (isMovingForward) {
    return combineWithIndex + 1;
  }

  return combineWithIndex;
});

var fromReorder = (function (_ref) {
  var isMovingForward = _ref.isMovingForward,
      isInHomeList = _ref.isInHomeList,
      insideDestination = _ref.insideDestination,
      location = _ref.location;

  if (!insideDestination.length) {
    return null;
  }

  var currentIndex = location.index;
  var proposedIndex = isMovingForward ? currentIndex + 1 : currentIndex - 1;
  var firstIndex = insideDestination[0].descriptor.index;
  var lastIndex = insideDestination[insideDestination.length - 1].descriptor.index;
  var upperBound = isInHomeList ? lastIndex : lastIndex + 1;

  if (proposedIndex < firstIndex) {
    return null;
  }

  if (proposedIndex > upperBound) {
    return null;
  }

  return proposedIndex;
});

var moveToNextIndex = (function (_ref) {
  var isMovingForward = _ref.isMovingForward,
      isInHomeList = _ref.isInHomeList,
      draggable = _ref.draggable,
      draggables = _ref.draggables,
      destination = _ref.destination,
      insideDestination = _ref.insideDestination,
      previousImpact = _ref.previousImpact,
      viewport = _ref.viewport,
      afterCritical = _ref.afterCritical;
  var wasAt = previousImpact.at;
  !wasAt ?  false ? 0 : invariant(false) : void 0;

  if (wasAt.type === 'REORDER') {
    var _newIndex = fromReorder({
      isMovingForward: isMovingForward,
      isInHomeList: isInHomeList,
      location: wasAt.destination,
      insideDestination: insideDestination
    });

    if (_newIndex == null) {
      return null;
    }

    return calculateReorderImpact({
      draggable: draggable,
      insideDestination: insideDestination,
      destination: destination,
      viewport: viewport,
      last: previousImpact.displaced,
      displacedBy: previousImpact.displacedBy,
      index: _newIndex
    });
  }

  var newIndex = fromCombine({
    isMovingForward: isMovingForward,
    destination: destination,
    displaced: previousImpact.displaced,
    draggables: draggables,
    combine: wasAt.combine,
    afterCritical: afterCritical
  });

  if (newIndex == null) {
    return null;
  }

  return calculateReorderImpact({
    draggable: draggable,
    insideDestination: insideDestination,
    destination: destination,
    viewport: viewport,
    last: previousImpact.displaced,
    displacedBy: previousImpact.displacedBy,
    index: newIndex
  });
});

var getCombinedItemDisplacement = (function (_ref) {
  var displaced = _ref.displaced,
      afterCritical = _ref.afterCritical,
      combineWith = _ref.combineWith,
      displacedBy = _ref.displacedBy;
  var isDisplaced = Boolean(displaced.visible[combineWith] || displaced.invisible[combineWith]);

  if (didStartAfterCritical(combineWith, afterCritical)) {
    return isDisplaced ? origin : negate(displacedBy.point);
  }

  return isDisplaced ? displacedBy.point : origin;
});

var whenCombining = (function (_ref) {
  var afterCritical = _ref.afterCritical,
      impact = _ref.impact,
      draggables = _ref.draggables;
  var combine = tryGetCombine(impact);
  !combine ?  false ? 0 : invariant(false) : void 0;
  var combineWith = combine.draggableId;
  var center = draggables[combineWith].page.borderBox.center;
  var displaceBy = getCombinedItemDisplacement({
    displaced: impact.displaced,
    afterCritical: afterCritical,
    combineWith: combineWith,
    displacedBy: impact.displacedBy
  });
  return add(center, displaceBy);
});

var distanceFromStartToBorderBoxCenter = function distanceFromStartToBorderBoxCenter(axis, box) {
  return box.margin[axis.start] + box.borderBox[axis.size] / 2;
};

var distanceFromEndToBorderBoxCenter = function distanceFromEndToBorderBoxCenter(axis, box) {
  return box.margin[axis.end] + box.borderBox[axis.size] / 2;
};

var getCrossAxisBorderBoxCenter = function getCrossAxisBorderBoxCenter(axis, target, isMoving) {
  return target[axis.crossAxisStart] + isMoving.margin[axis.crossAxisStart] + isMoving.borderBox[axis.crossAxisSize] / 2;
};

var goAfter = function goAfter(_ref) {
  var axis = _ref.axis,
      moveRelativeTo = _ref.moveRelativeTo,
      isMoving = _ref.isMoving;
  return patch(axis.line, moveRelativeTo.marginBox[axis.end] + distanceFromStartToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving));
};
var goBefore = function goBefore(_ref2) {
  var axis = _ref2.axis,
      moveRelativeTo = _ref2.moveRelativeTo,
      isMoving = _ref2.isMoving;
  return patch(axis.line, moveRelativeTo.marginBox[axis.start] - distanceFromEndToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving));
};
var goIntoStart = function goIntoStart(_ref3) {
  var axis = _ref3.axis,
      moveInto = _ref3.moveInto,
      isMoving = _ref3.isMoving;
  return patch(axis.line, moveInto.contentBox[axis.start] + distanceFromStartToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveInto.contentBox, isMoving));
};

var whenReordering = (function (_ref) {
  var impact = _ref.impact,
      draggable = _ref.draggable,
      draggables = _ref.draggables,
      droppable = _ref.droppable,
      afterCritical = _ref.afterCritical;
  var insideDestination = getDraggablesInsideDroppable(droppable.descriptor.id, draggables);
  var draggablePage = draggable.page;
  var axis = droppable.axis;

  if (!insideDestination.length) {
    return goIntoStart({
      axis: axis,
      moveInto: droppable.page,
      isMoving: draggablePage
    });
  }

  var displaced = impact.displaced,
      displacedBy = impact.displacedBy;
  var closestAfter = displaced.all[0];

  if (closestAfter) {
    var closest = draggables[closestAfter];

    if (didStartAfterCritical(closestAfter, afterCritical)) {
      return goBefore({
        axis: axis,
        moveRelativeTo: closest.page,
        isMoving: draggablePage
      });
    }

    var withDisplacement = cssBoxModel.offset(closest.page, displacedBy.point);
    return goBefore({
      axis: axis,
      moveRelativeTo: withDisplacement,
      isMoving: draggablePage
    });
  }

  var last = insideDestination[insideDestination.length - 1];

  if (last.descriptor.id === draggable.descriptor.id) {
    return draggablePage.borderBox.center;
  }

  if (didStartAfterCritical(last.descriptor.id, afterCritical)) {
    var page = cssBoxModel.offset(last.page, negate(afterCritical.displacedBy.point));
    return goAfter({
      axis: axis,
      moveRelativeTo: page,
      isMoving: draggablePage
    });
  }

  return goAfter({
    axis: axis,
    moveRelativeTo: last.page,
    isMoving: draggablePage
  });
});

var withDroppableDisplacement = (function (droppable, point) {
  var frame = droppable.frame;

  if (!frame) {
    return point;
  }

  return add(point, frame.scroll.diff.displacement);
});

var getResultWithoutDroppableDisplacement = function getResultWithoutDroppableDisplacement(_ref) {
  var impact = _ref.impact,
      draggable = _ref.draggable,
      droppable = _ref.droppable,
      draggables = _ref.draggables,
      afterCritical = _ref.afterCritical;
  var original = draggable.page.borderBox.center;
  var at = impact.at;

  if (!droppable) {
    return original;
  }

  if (!at) {
    return original;
  }

  if (at.type === 'REORDER') {
    return whenReordering({
      impact: impact,
      draggable: draggable,
      draggables: draggables,
      droppable: droppable,
      afterCritical: afterCritical
    });
  }

  return whenCombining({
    impact: impact,
    draggables: draggables,
    afterCritical: afterCritical
  });
};

var getPageBorderBoxCenterFromImpact = (function (args) {
  var withoutDisplacement = getResultWithoutDroppableDisplacement(args);
  var droppable = args.droppable;
  var withDisplacement = droppable ? withDroppableDisplacement(droppable, withoutDisplacement) : withoutDisplacement;
  return withDisplacement;
});

var scrollViewport = (function (viewport, newScroll) {
  var diff = subtract(newScroll, viewport.scroll.initial);
  var displacement = negate(diff);
  var frame = cssBoxModel.getRect({
    top: newScroll.y,
    bottom: newScroll.y + viewport.frame.height,
    left: newScroll.x,
    right: newScroll.x + viewport.frame.width
  });
  var updated = {
    frame: frame,
    scroll: {
      initial: viewport.scroll.initial,
      max: viewport.scroll.max,
      current: newScroll,
      diff: {
        value: diff,
        displacement: displacement
      }
    }
  };
  return updated;
});

function getDraggables(ids, draggables) {
  return ids.map(function (id) {
    return draggables[id];
  });
}

function tryGetVisible(id, groups) {
  for (var i = 0; i < groups.length; i++) {
    var displacement = groups[i].visible[id];

    if (displacement) {
      return displacement;
    }
  }

  return null;
}

var speculativelyIncrease = (function (_ref) {
  var impact = _ref.impact,
      viewport = _ref.viewport,
      destination = _ref.destination,
      draggables = _ref.draggables,
      maxScrollChange = _ref.maxScrollChange;
  var scrolledViewport = scrollViewport(viewport, add(viewport.scroll.current, maxScrollChange));
  var scrolledDroppable = destination.frame ? scrollDroppable(destination, add(destination.frame.scroll.current, maxScrollChange)) : destination;
  var last = impact.displaced;
  var withViewportScroll = getDisplacementGroups({
    afterDragging: getDraggables(last.all, draggables),
    destination: destination,
    displacedBy: impact.displacedBy,
    viewport: scrolledViewport.frame,
    last: last,
    forceShouldAnimate: false
  });
  var withDroppableScroll = getDisplacementGroups({
    afterDragging: getDraggables(last.all, draggables),
    destination: scrolledDroppable,
    displacedBy: impact.displacedBy,
    viewport: viewport.frame,
    last: last,
    forceShouldAnimate: false
  });
  var invisible = {};
  var visible = {};
  var groups = [last, withViewportScroll, withDroppableScroll];
  last.all.forEach(function (id) {
    var displacement = tryGetVisible(id, groups);

    if (displacement) {
      visible[id] = displacement;
      return;
    }

    invisible[id] = true;
  });

  var newImpact = _extends({}, impact, {
    displaced: {
      all: last.all,
      invisible: invisible,
      visible: visible
    }
  });

  return newImpact;
});

var withViewportDisplacement = (function (viewport, point) {
  return add(viewport.scroll.diff.displacement, point);
});

var getClientFromPageBorderBoxCenter = (function (_ref) {
  var pageBorderBoxCenter = _ref.pageBorderBoxCenter,
      draggable = _ref.draggable,
      viewport = _ref.viewport;
  var withoutPageScrollChange = withViewportDisplacement(viewport, pageBorderBoxCenter);
  var offset = subtract(withoutPageScrollChange, draggable.page.borderBox.center);
  return add(draggable.client.borderBox.center, offset);
});

var isTotallyVisibleInNewLocation = (function (_ref) {
  var draggable = _ref.draggable,
      destination = _ref.destination,
      newPageBorderBoxCenter = _ref.newPageBorderBoxCenter,
      viewport = _ref.viewport,
      withDroppableDisplacement = _ref.withDroppableDisplacement,
      _ref$onlyOnMainAxis = _ref.onlyOnMainAxis,
      onlyOnMainAxis = _ref$onlyOnMainAxis === void 0 ? false : _ref$onlyOnMainAxis;
  var changeNeeded = subtract(newPageBorderBoxCenter, draggable.page.borderBox.center);
  var shifted = offsetByPosition(draggable.page.borderBox, changeNeeded);
  var args = {
    target: shifted,
    destination: destination,
    withDroppableDisplacement: withDroppableDisplacement,
    viewport: viewport
  };
  return onlyOnMainAxis ? isTotallyVisibleOnAxis(args) : isTotallyVisible(args);
});

var moveToNextPlace = (function (_ref) {
  var isMovingForward = _ref.isMovingForward,
      draggable = _ref.draggable,
      destination = _ref.destination,
      draggables = _ref.draggables,
      previousImpact = _ref.previousImpact,
      viewport = _ref.viewport,
      previousPageBorderBoxCenter = _ref.previousPageBorderBoxCenter,
      previousClientSelection = _ref.previousClientSelection,
      afterCritical = _ref.afterCritical;

  if (!destination.isEnabled) {
    return null;
  }

  var insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);
  var isInHomeList = isHomeOf(draggable, destination);
  var impact = moveToNextCombine({
    isMovingForward: isMovingForward,
    draggable: draggable,
    destination: destination,
    insideDestination: insideDestination,
    previousImpact: previousImpact
  }) || moveToNextIndex({
    isMovingForward: isMovingForward,
    isInHomeList: isInHomeList,
    draggable: draggable,
    draggables: draggables,
    destination: destination,
    insideDestination: insideDestination,
    previousImpact: previousImpact,
    viewport: viewport,
    afterCritical: afterCritical
  });

  if (!impact) {
    return null;
  }

  var pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({
    impact: impact,
    draggable: draggable,
    droppable: destination,
    draggables: draggables,
    afterCritical: afterCritical
  });
  var isVisibleInNewLocation = isTotallyVisibleInNewLocation({
    draggable: draggable,
    destination: destination,
    newPageBorderBoxCenter: pageBorderBoxCenter,
    viewport: viewport.frame,
    withDroppableDisplacement: false,
    onlyOnMainAxis: true
  });

  if (isVisibleInNewLocation) {
    var clientSelection = getClientFromPageBorderBoxCenter({
      pageBorderBoxCenter: pageBorderBoxCenter,
      draggable: draggable,
      viewport: viewport
    });
    return {
      clientSelection: clientSelection,
      impact: impact,
      scrollJumpRequest: null
    };
  }

  var distance = subtract(pageBorderBoxCenter, previousPageBorderBoxCenter);
  var cautious = speculativelyIncrease({
    impact: impact,
    viewport: viewport,
    destination: destination,
    draggables: draggables,
    maxScrollChange: distance
  });
  return {
    clientSelection: previousClientSelection,
    impact: cautious,
    scrollJumpRequest: distance
  };
});

var getKnownActive = function getKnownActive(droppable) {
  var rect = droppable.subject.active;
  !rect ?  false ? 0 : invariant(false) : void 0;
  return rect;
};

var getBestCrossAxisDroppable = (function (_ref) {
  var isMovingForward = _ref.isMovingForward,
      pageBorderBoxCenter = _ref.pageBorderBoxCenter,
      source = _ref.source,
      droppables = _ref.droppables,
      viewport = _ref.viewport;
  var active = source.subject.active;

  if (!active) {
    return null;
  }

  var axis = source.axis;
  var isBetweenSourceClipped = isWithin(active[axis.start], active[axis.end]);
  var candidates = toDroppableList(droppables).filter(function (droppable) {
    return droppable !== source;
  }).filter(function (droppable) {
    return droppable.isEnabled;
  }).filter(function (droppable) {
    return Boolean(droppable.subject.active);
  }).filter(function (droppable) {
    return isPartiallyVisibleThroughFrame(viewport.frame)(getKnownActive(droppable));
  }).filter(function (droppable) {
    var activeOfTarget = getKnownActive(droppable);

    if (isMovingForward) {
      return active[axis.crossAxisEnd] < activeOfTarget[axis.crossAxisEnd];
    }

    return activeOfTarget[axis.crossAxisStart] < active[axis.crossAxisStart];
  }).filter(function (droppable) {
    var activeOfTarget = getKnownActive(droppable);
    var isBetweenDestinationClipped = isWithin(activeOfTarget[axis.start], activeOfTarget[axis.end]);
    return isBetweenSourceClipped(activeOfTarget[axis.start]) || isBetweenSourceClipped(activeOfTarget[axis.end]) || isBetweenDestinationClipped(active[axis.start]) || isBetweenDestinationClipped(active[axis.end]);
  }).sort(function (a, b) {
    var first = getKnownActive(a)[axis.crossAxisStart];
    var second = getKnownActive(b)[axis.crossAxisStart];

    if (isMovingForward) {
      return first - second;
    }

    return second - first;
  }).filter(function (droppable, index, array) {
    return getKnownActive(droppable)[axis.crossAxisStart] === getKnownActive(array[0])[axis.crossAxisStart];
  });

  if (!candidates.length) {
    return null;
  }

  if (candidates.length === 1) {
    return candidates[0];
  }

  var contains = candidates.filter(function (droppable) {
    var isWithinDroppable = isWithin(getKnownActive(droppable)[axis.start], getKnownActive(droppable)[axis.end]);
    return isWithinDroppable(pageBorderBoxCenter[axis.line]);
  });

  if (contains.length === 1) {
    return contains[0];
  }

  if (contains.length > 1) {
    return contains.sort(function (a, b) {
      return getKnownActive(a)[axis.start] - getKnownActive(b)[axis.start];
    })[0];
  }

  return candidates.sort(function (a, b) {
    var first = closest(pageBorderBoxCenter, getCorners(getKnownActive(a)));
    var second = closest(pageBorderBoxCenter, getCorners(getKnownActive(b)));

    if (first !== second) {
      return first - second;
    }

    return getKnownActive(a)[axis.start] - getKnownActive(b)[axis.start];
  })[0];
});

var getCurrentPageBorderBoxCenter = function getCurrentPageBorderBoxCenter(draggable, afterCritical) {
  var original = draggable.page.borderBox.center;
  return didStartAfterCritical(draggable.descriptor.id, afterCritical) ? subtract(original, afterCritical.displacedBy.point) : original;
};
var getCurrentPageBorderBox = function getCurrentPageBorderBox(draggable, afterCritical) {
  var original = draggable.page.borderBox;
  return didStartAfterCritical(draggable.descriptor.id, afterCritical) ? offsetByPosition(original, negate(afterCritical.displacedBy.point)) : original;
};

var getClosestDraggable = (function (_ref) {
  var pageBorderBoxCenter = _ref.pageBorderBoxCenter,
      viewport = _ref.viewport,
      destination = _ref.destination,
      insideDestination = _ref.insideDestination,
      afterCritical = _ref.afterCritical;
  var sorted = insideDestination.filter(function (draggable) {
    return isTotallyVisible({
      target: getCurrentPageBorderBox(draggable, afterCritical),
      destination: destination,
      viewport: viewport.frame,
      withDroppableDisplacement: true
    });
  }).sort(function (a, b) {
    var distanceToA = distance(pageBorderBoxCenter, withDroppableDisplacement(destination, getCurrentPageBorderBoxCenter(a, afterCritical)));
    var distanceToB = distance(pageBorderBoxCenter, withDroppableDisplacement(destination, getCurrentPageBorderBoxCenter(b, afterCritical)));

    if (distanceToA < distanceToB) {
      return -1;
    }

    if (distanceToB < distanceToA) {
      return 1;
    }

    return a.descriptor.index - b.descriptor.index;
  });
  return sorted[0] || null;
});

var getDisplacedBy = memoizeOne(function getDisplacedBy(axis, displaceBy) {
  var displacement = displaceBy[axis.line];
  return {
    value: displacement,
    point: patch(axis.line, displacement)
  };
});

var getRequiredGrowthForPlaceholder = function getRequiredGrowthForPlaceholder(droppable, placeholderSize, draggables) {
  var axis = droppable.axis;

  if (droppable.descriptor.mode === 'virtual') {
    return patch(axis.line, placeholderSize[axis.line]);
  }

  var availableSpace = droppable.subject.page.contentBox[axis.size];
  var insideDroppable = getDraggablesInsideDroppable(droppable.descriptor.id, draggables);
  var spaceUsed = insideDroppable.reduce(function (sum, dimension) {
    return sum + dimension.client.marginBox[axis.size];
  }, 0);
  var requiredSpace = spaceUsed + placeholderSize[axis.line];
  var needsToGrowBy = requiredSpace - availableSpace;

  if (needsToGrowBy <= 0) {
    return null;
  }

  return patch(axis.line, needsToGrowBy);
};

var withMaxScroll = function withMaxScroll(frame, max) {
  return _extends({}, frame, {
    scroll: _extends({}, frame.scroll, {
      max: max
    })
  });
};

var addPlaceholder = function addPlaceholder(droppable, draggable, draggables) {
  var frame = droppable.frame;
  !!isHomeOf(draggable, droppable) ?  false ? 0 : invariant(false) : void 0;
  !!droppable.subject.withPlaceholder ?  false ? 0 : invariant(false) : void 0;
  var placeholderSize = getDisplacedBy(droppable.axis, draggable.displaceBy).point;
  var requiredGrowth = getRequiredGrowthForPlaceholder(droppable, placeholderSize, draggables);
  var added = {
    placeholderSize: placeholderSize,
    increasedBy: requiredGrowth,
    oldFrameMaxScroll: droppable.frame ? droppable.frame.scroll.max : null
  };

  if (!frame) {
    var _subject = getSubject({
      page: droppable.subject.page,
      withPlaceholder: added,
      axis: droppable.axis,
      frame: droppable.frame
    });

    return _extends({}, droppable, {
      subject: _subject
    });
  }

  var maxScroll = requiredGrowth ? add(frame.scroll.max, requiredGrowth) : frame.scroll.max;
  var newFrame = withMaxScroll(frame, maxScroll);
  var subject = getSubject({
    page: droppable.subject.page,
    withPlaceholder: added,
    axis: droppable.axis,
    frame: newFrame
  });
  return _extends({}, droppable, {
    subject: subject,
    frame: newFrame
  });
};
var removePlaceholder = function removePlaceholder(droppable) {
  var added = droppable.subject.withPlaceholder;
  !added ?  false ? 0 : invariant(false) : void 0;
  var frame = droppable.frame;

  if (!frame) {
    var _subject2 = getSubject({
      page: droppable.subject.page,
      axis: droppable.axis,
      frame: null,
      withPlaceholder: null
    });

    return _extends({}, droppable, {
      subject: _subject2
    });
  }

  var oldMaxScroll = added.oldFrameMaxScroll;
  !oldMaxScroll ?  false ? 0 : invariant(false) : void 0;
  var newFrame = withMaxScroll(frame, oldMaxScroll);
  var subject = getSubject({
    page: droppable.subject.page,
    axis: droppable.axis,
    frame: newFrame,
    withPlaceholder: null
  });
  return _extends({}, droppable, {
    subject: subject,
    frame: newFrame
  });
};

var moveToNewDroppable = (function (_ref) {
  var previousPageBorderBoxCenter = _ref.previousPageBorderBoxCenter,
      moveRelativeTo = _ref.moveRelativeTo,
      insideDestination = _ref.insideDestination,
      draggable = _ref.draggable,
      draggables = _ref.draggables,
      destination = _ref.destination,
      viewport = _ref.viewport,
      afterCritical = _ref.afterCritical;

  if (!moveRelativeTo) {
    if (insideDestination.length) {
      return null;
    }

    var proposed = {
      displaced: emptyGroups,
      displacedBy: noDisplacedBy,
      at: {
        type: 'REORDER',
        destination: {
          droppableId: destination.descriptor.id,
          index: 0
        }
      }
    };
    var proposedPageBorderBoxCenter = getPageBorderBoxCenterFromImpact({
      impact: proposed,
      draggable: draggable,
      droppable: destination,
      draggables: draggables,
      afterCritical: afterCritical
    });
    var withPlaceholder = isHomeOf(draggable, destination) ? destination : addPlaceholder(destination, draggable, draggables);
    var isVisibleInNewLocation = isTotallyVisibleInNewLocation({
      draggable: draggable,
      destination: withPlaceholder,
      newPageBorderBoxCenter: proposedPageBorderBoxCenter,
      viewport: viewport.frame,
      withDroppableDisplacement: false,
      onlyOnMainAxis: true
    });
    return isVisibleInNewLocation ? proposed : null;
  }

  var isGoingBeforeTarget = Boolean(previousPageBorderBoxCenter[destination.axis.line] <= moveRelativeTo.page.borderBox.center[destination.axis.line]);

  var proposedIndex = function () {
    var relativeTo = moveRelativeTo.descriptor.index;

    if (moveRelativeTo.descriptor.id === draggable.descriptor.id) {
      return relativeTo;
    }

    if (isGoingBeforeTarget) {
      return relativeTo;
    }

    return relativeTo + 1;
  }();

  var displacedBy = getDisplacedBy(destination.axis, draggable.displaceBy);
  return calculateReorderImpact({
    draggable: draggable,
    insideDestination: insideDestination,
    destination: destination,
    viewport: viewport,
    displacedBy: displacedBy,
    last: emptyGroups,
    index: proposedIndex
  });
});

var moveCrossAxis = (function (_ref) {
  var isMovingForward = _ref.isMovingForward,
      previousPageBorderBoxCenter = _ref.previousPageBorderBoxCenter,
      draggable = _ref.draggable,
      isOver = _ref.isOver,
      draggables = _ref.draggables,
      droppables = _ref.droppables,
      viewport = _ref.viewport,
      afterCritical = _ref.afterCritical;
  var destination = getBestCrossAxisDroppable({
    isMovingForward: isMovingForward,
    pageBorderBoxCenter: previousPageBorderBoxCenter,
    source: isOver,
    droppables: droppables,
    viewport: viewport
  });

  if (!destination) {
    return null;
  }

  var insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);
  var moveRelativeTo = getClosestDraggable({
    pageBorderBoxCenter: previousPageBorderBoxCenter,
    viewport: viewport,
    destination: destination,
    insideDestination: insideDestination,
    afterCritical: afterCritical
  });
  var impact = moveToNewDroppable({
    previousPageBorderBoxCenter: previousPageBorderBoxCenter,
    destination: destination,
    draggable: draggable,
    draggables: draggables,
    moveRelativeTo: moveRelativeTo,
    insideDestination: insideDestination,
    viewport: viewport,
    afterCritical: afterCritical
  });

  if (!impact) {
    return null;
  }

  var pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({
    impact: impact,
    draggable: draggable,
    droppable: destination,
    draggables: draggables,
    afterCritical: afterCritical
  });
  var clientSelection = getClientFromPageBorderBoxCenter({
    pageBorderBoxCenter: pageBorderBoxCenter,
    draggable: draggable,
    viewport: viewport
  });
  return {
    clientSelection: clientSelection,
    impact: impact,
    scrollJumpRequest: null
  };
});

var whatIsDraggedOver = (function (impact) {
  var at = impact.at;

  if (!at) {
    return null;
  }

  if (at.type === 'REORDER') {
    return at.destination.droppableId;
  }

  return at.combine.droppableId;
});

var getDroppableOver = function getDroppableOver(impact, droppables) {
  var id = whatIsDraggedOver(impact);
  return id ? droppables[id] : null;
};

var moveInDirection = (function (_ref) {
  var state = _ref.state,
      type = _ref.type;
  var isActuallyOver = getDroppableOver(state.impact, state.dimensions.droppables);
  var isMainAxisMovementAllowed = Boolean(isActuallyOver);
  var home = state.dimensions.droppables[state.critical.droppable.id];
  var isOver = isActuallyOver || home;
  var direction = isOver.axis.direction;
  var isMovingOnMainAxis = direction === 'vertical' && (type === 'MOVE_UP' || type === 'MOVE_DOWN') || direction === 'horizontal' && (type === 'MOVE_LEFT' || type === 'MOVE_RIGHT');

  if (isMovingOnMainAxis && !isMainAxisMovementAllowed) {
    return null;
  }

  var isMovingForward = type === 'MOVE_DOWN' || type === 'MOVE_RIGHT';
  var draggable = state.dimensions.draggables[state.critical.draggable.id];
  var previousPageBorderBoxCenter = state.current.page.borderBoxCenter;
  var _state$dimensions = state.dimensions,
      draggables = _state$dimensions.draggables,
      droppables = _state$dimensions.droppables;
  return isMovingOnMainAxis ? moveToNextPlace({
    isMovingForward: isMovingForward,
    previousPageBorderBoxCenter: previousPageBorderBoxCenter,
    draggable: draggable,
    destination: isOver,
    draggables: draggables,
    viewport: state.viewport,
    previousClientSelection: state.current.client.selection,
    previousImpact: state.impact,
    afterCritical: state.afterCritical
  }) : moveCrossAxis({
    isMovingForward: isMovingForward,
    previousPageBorderBoxCenter: previousPageBorderBoxCenter,
    draggable: draggable,
    isOver: isOver,
    draggables: draggables,
    droppables: droppables,
    viewport: state.viewport,
    afterCritical: state.afterCritical
  });
});

function isMovementAllowed(state) {
  return state.phase === 'DRAGGING' || state.phase === 'COLLECTING';
}

function isPositionInFrame(frame) {
  var isWithinVertical = isWithin(frame.top, frame.bottom);
  var isWithinHorizontal = isWithin(frame.left, frame.right);
  return function run(point) {
    return isWithinVertical(point.y) && isWithinHorizontal(point.x);
  };
}

function getHasOverlap(first, second) {
  return first.left < second.right && first.right > second.left && first.top < second.bottom && first.bottom > second.top;
}

function getFurthestAway(_ref) {
  var pageBorderBox = _ref.pageBorderBox,
      draggable = _ref.draggable,
      candidates = _ref.candidates;
  var startCenter = draggable.page.borderBox.center;
  var sorted = candidates.map(function (candidate) {
    var axis = candidate.axis;
    var target = patch(candidate.axis.line, pageBorderBox.center[axis.line], candidate.page.borderBox.center[axis.crossAxisLine]);
    return {
      id: candidate.descriptor.id,
      distance: distance(startCenter, target)
    };
  }).sort(function (a, b) {
    return b.distance - a.distance;
  });
  return sorted[0] ? sorted[0].id : null;
}

function getDroppableOver$1(_ref2) {
  var pageBorderBox = _ref2.pageBorderBox,
      draggable = _ref2.draggable,
      droppables = _ref2.droppables;
  var candidates = toDroppableList(droppables).filter(function (item) {
    if (!item.isEnabled) {
      return false;
    }

    var active = item.subject.active;

    if (!active) {
      return false;
    }

    if (!getHasOverlap(pageBorderBox, active)) {
      return false;
    }

    if (isPositionInFrame(active)(pageBorderBox.center)) {
      return true;
    }

    var axis = item.axis;
    var childCenter = active.center[axis.crossAxisLine];
    var crossAxisStart = pageBorderBox[axis.crossAxisStart];
    var crossAxisEnd = pageBorderBox[axis.crossAxisEnd];
    var isContained = isWithin(active[axis.crossAxisStart], active[axis.crossAxisEnd]);
    var isStartContained = isContained(crossAxisStart);
    var isEndContained = isContained(crossAxisEnd);

    if (!isStartContained && !isEndContained) {
      return true;
    }

    if (isStartContained) {
      return crossAxisStart < childCenter;
    }

    return crossAxisEnd > childCenter;
  });

  if (!candidates.length) {
    return null;
  }

  if (candidates.length === 1) {
    return candidates[0].descriptor.id;
  }

  return getFurthestAway({
    pageBorderBox: pageBorderBox,
    draggable: draggable,
    candidates: candidates
  });
}

var offsetRectByPosition = function offsetRectByPosition(rect, point) {
  return cssBoxModel.getRect(offsetByPosition(rect, point));
};

var withDroppableScroll = (function (droppable, area) {
  var frame = droppable.frame;

  if (!frame) {
    return area;
  }

  return offsetRectByPosition(area, frame.scroll.diff.value);
});

function getIsDisplaced(_ref) {
  var displaced = _ref.displaced,
      id = _ref.id;
  return Boolean(displaced.visible[id] || displaced.invisible[id]);
}

function atIndex(_ref) {
  var draggable = _ref.draggable,
      closest = _ref.closest,
      inHomeList = _ref.inHomeList;

  if (!closest) {
    return null;
  }

  if (!inHomeList) {
    return closest.descriptor.index;
  }

  if (closest.descriptor.index > draggable.descriptor.index) {
    return closest.descriptor.index - 1;
  }

  return closest.descriptor.index;
}

var getReorderImpact = (function (_ref2) {
  var targetRect = _ref2.pageBorderBoxWithDroppableScroll,
      draggable = _ref2.draggable,
      destination = _ref2.destination,
      insideDestination = _ref2.insideDestination,
      last = _ref2.last,
      viewport = _ref2.viewport,
      afterCritical = _ref2.afterCritical;
  var axis = destination.axis;
  var displacedBy = getDisplacedBy(destination.axis, draggable.displaceBy);
  var displacement = displacedBy.value;
  var targetStart = targetRect[axis.start];
  var targetEnd = targetRect[axis.end];
  var withoutDragging = removeDraggableFromList(draggable, insideDestination);
  var closest = find(withoutDragging, function (child) {
    var id = child.descriptor.id;
    var childCenter = child.page.borderBox.center[axis.line];
    var didStartAfterCritical$1 = didStartAfterCritical(id, afterCritical);
    var isDisplaced = getIsDisplaced({
      displaced: last,
      id: id
    });

    if (didStartAfterCritical$1) {
      if (isDisplaced) {
        return targetEnd <= childCenter;
      }

      return targetStart < childCenter - displacement;
    }

    if (isDisplaced) {
      return targetEnd <= childCenter + displacement;
    }

    return targetStart < childCenter;
  });
  var newIndex = atIndex({
    draggable: draggable,
    closest: closest,
    inHomeList: isHomeOf(draggable, destination)
  });
  return calculateReorderImpact({
    draggable: draggable,
    insideDestination: insideDestination,
    destination: destination,
    viewport: viewport,
    last: last,
    displacedBy: displacedBy,
    index: newIndex
  });
});

var combineThresholdDivisor = 4;
var getCombineImpact = (function (_ref) {
  var draggable = _ref.draggable,
      targetRect = _ref.pageBorderBoxWithDroppableScroll,
      previousImpact = _ref.previousImpact,
      destination = _ref.destination,
      insideDestination = _ref.insideDestination,
      afterCritical = _ref.afterCritical;

  if (!destination.isCombineEnabled) {
    return null;
  }

  var axis = destination.axis;
  var displacedBy = getDisplacedBy(destination.axis, draggable.displaceBy);
  var displacement = displacedBy.value;
  var targetStart = targetRect[axis.start];
  var targetEnd = targetRect[axis.end];
  var withoutDragging = removeDraggableFromList(draggable, insideDestination);
  var combineWith = find(withoutDragging, function (child) {
    var id = child.descriptor.id;
    var childRect = child.page.borderBox;
    var childSize = childRect[axis.size];
    var threshold = childSize / combineThresholdDivisor;
    var didStartAfterCritical$1 = didStartAfterCritical(id, afterCritical);
    var isDisplaced = getIsDisplaced({
      displaced: previousImpact.displaced,
      id: id
    });

    if (didStartAfterCritical$1) {
      if (isDisplaced) {
        return targetEnd > childRect[axis.start] + threshold && targetEnd < childRect[axis.end] - threshold;
      }

      return targetStart > childRect[axis.start] - displacement + threshold && targetStart < childRect[axis.end] - displacement - threshold;
    }

    if (isDisplaced) {
      return targetEnd > childRect[axis.start] + displacement + threshold && targetEnd < childRect[axis.end] + displacement - threshold;
    }

    return targetStart > childRect[axis.start] + threshold && targetStart < childRect[axis.end] - threshold;
  });

  if (!combineWith) {
    return null;
  }

  var impact = {
    displacedBy: displacedBy,
    displaced: previousImpact.displaced,
    at: {
      type: 'COMBINE',
      combine: {
        draggableId: combineWith.descriptor.id,
        droppableId: destination.descriptor.id
      }
    }
  };
  return impact;
});

var getDragImpact = (function (_ref) {
  var pageOffset = _ref.pageOffset,
      draggable = _ref.draggable,
      draggables = _ref.draggables,
      droppables = _ref.droppables,
      previousImpact = _ref.previousImpact,
      viewport = _ref.viewport,
      afterCritical = _ref.afterCritical;
  var pageBorderBox = offsetRectByPosition(draggable.page.borderBox, pageOffset);
  var destinationId = getDroppableOver$1({
    pageBorderBox: pageBorderBox,
    draggable: draggable,
    droppables: droppables
  });

  if (!destinationId) {
    return noImpact;
  }

  var destination = droppables[destinationId];
  var insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);
  var pageBorderBoxWithDroppableScroll = withDroppableScroll(destination, pageBorderBox);
  return getCombineImpact({
    pageBorderBoxWithDroppableScroll: pageBorderBoxWithDroppableScroll,
    draggable: draggable,
    previousImpact: previousImpact,
    destination: destination,
    insideDestination: insideDestination,
    afterCritical: afterCritical
  }) || getReorderImpact({
    pageBorderBoxWithDroppableScroll: pageBorderBoxWithDroppableScroll,
    draggable: draggable,
    destination: destination,
    insideDestination: insideDestination,
    last: previousImpact.displaced,
    viewport: viewport,
    afterCritical: afterCritical
  });
});

var patchDroppableMap = (function (droppables, updated) {
  var _extends2;

  return _extends({}, droppables, (_extends2 = {}, _extends2[updated.descriptor.id] = updated, _extends2));
});

var clearUnusedPlaceholder = function clearUnusedPlaceholder(_ref) {
  var previousImpact = _ref.previousImpact,
      impact = _ref.impact,
      droppables = _ref.droppables;
  var last = whatIsDraggedOver(previousImpact);
  var now = whatIsDraggedOver(impact);

  if (!last) {
    return droppables;
  }

  if (last === now) {
    return droppables;
  }

  var lastDroppable = droppables[last];

  if (!lastDroppable.subject.withPlaceholder) {
    return droppables;
  }

  var updated = removePlaceholder(lastDroppable);
  return patchDroppableMap(droppables, updated);
};

var recomputePlaceholders = (function (_ref2) {
  var draggable = _ref2.draggable,
      draggables = _ref2.draggables,
      droppables = _ref2.droppables,
      previousImpact = _ref2.previousImpact,
      impact = _ref2.impact;
  var cleaned = clearUnusedPlaceholder({
    previousImpact: previousImpact,
    impact: impact,
    droppables: droppables
  });
  var isOver = whatIsDraggedOver(impact);

  if (!isOver) {
    return cleaned;
  }

  var droppable = droppables[isOver];

  if (isHomeOf(draggable, droppable)) {
    return cleaned;
  }

  if (droppable.subject.withPlaceholder) {
    return cleaned;
  }

  var patched = addPlaceholder(droppable, draggable, draggables);
  return patchDroppableMap(cleaned, patched);
});

var update = (function (_ref) {
  var state = _ref.state,
      forcedClientSelection = _ref.clientSelection,
      forcedDimensions = _ref.dimensions,
      forcedViewport = _ref.viewport,
      forcedImpact = _ref.impact,
      scrollJumpRequest = _ref.scrollJumpRequest;
  var viewport = forcedViewport || state.viewport;
  var dimensions = forcedDimensions || state.dimensions;
  var clientSelection = forcedClientSelection || state.current.client.selection;
  var offset = subtract(clientSelection, state.initial.client.selection);
  var client = {
    offset: offset,
    selection: clientSelection,
    borderBoxCenter: add(state.initial.client.borderBoxCenter, offset)
  };
  var page = {
    selection: add(client.selection, viewport.scroll.current),
    borderBoxCenter: add(client.borderBoxCenter, viewport.scroll.current),
    offset: add(client.offset, viewport.scroll.diff.value)
  };
  var current = {
    client: client,
    page: page
  };

  if (state.phase === 'COLLECTING') {
    return _extends({
      phase: 'COLLECTING'
    }, state, {
      dimensions: dimensions,
      viewport: viewport,
      current: current
    });
  }

  var draggable = dimensions.draggables[state.critical.draggable.id];
  var newImpact = forcedImpact || getDragImpact({
    pageOffset: page.offset,
    draggable: draggable,
    draggables: dimensions.draggables,
    droppables: dimensions.droppables,
    previousImpact: state.impact,
    viewport: viewport,
    afterCritical: state.afterCritical
  });
  var withUpdatedPlaceholders = recomputePlaceholders({
    draggable: draggable,
    impact: newImpact,
    previousImpact: state.impact,
    draggables: dimensions.draggables,
    droppables: dimensions.droppables
  });

  var result = _extends({}, state, {
    current: current,
    dimensions: {
      draggables: dimensions.draggables,
      droppables: withUpdatedPlaceholders
    },
    impact: newImpact,
    viewport: viewport,
    scrollJumpRequest: scrollJumpRequest || null,
    forceShouldAnimate: scrollJumpRequest ? false : null
  });

  return result;
});

function getDraggables$1(ids, draggables) {
  return ids.map(function (id) {
    return draggables[id];
  });
}

var recompute = (function (_ref) {
  var impact = _ref.impact,
      viewport = _ref.viewport,
      draggables = _ref.draggables,
      destination = _ref.destination,
      forceShouldAnimate = _ref.forceShouldAnimate;
  var last = impact.displaced;
  var afterDragging = getDraggables$1(last.all, draggables);
  var displaced = getDisplacementGroups({
    afterDragging: afterDragging,
    destination: destination,
    displacedBy: impact.displacedBy,
    viewport: viewport.frame,
    forceShouldAnimate: forceShouldAnimate,
    last: last
  });
  return _extends({}, impact, {
    displaced: displaced
  });
});

var getClientBorderBoxCenter = (function (_ref) {
  var impact = _ref.impact,
      draggable = _ref.draggable,
      droppable = _ref.droppable,
      draggables = _ref.draggables,
      viewport = _ref.viewport,
      afterCritical = _ref.afterCritical;
  var pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({
    impact: impact,
    draggable: draggable,
    draggables: draggables,
    droppable: droppable,
    afterCritical: afterCritical
  });
  return getClientFromPageBorderBoxCenter({
    pageBorderBoxCenter: pageBorderBoxCenter,
    draggable: draggable,
    viewport: viewport
  });
});

var refreshSnap = (function (_ref) {
  var state = _ref.state,
      forcedDimensions = _ref.dimensions,
      forcedViewport = _ref.viewport;
  !(state.movementMode === 'SNAP') ?  false ? 0 : invariant(false) : void 0;
  var needsVisibilityCheck = state.impact;
  var viewport = forcedViewport || state.viewport;
  var dimensions = forcedDimensions || state.dimensions;
  var draggables = dimensions.draggables,
      droppables = dimensions.droppables;
  var draggable = draggables[state.critical.draggable.id];
  var isOver = whatIsDraggedOver(needsVisibilityCheck);
  !isOver ?  false ? 0 : invariant(false) : void 0;
  var destination = droppables[isOver];
  var impact = recompute({
    impact: needsVisibilityCheck,
    viewport: viewport,
    destination: destination,
    draggables: draggables
  });
  var clientSelection = getClientBorderBoxCenter({
    impact: impact,
    draggable: draggable,
    droppable: destination,
    draggables: draggables,
    viewport: viewport,
    afterCritical: state.afterCritical
  });
  return update({
    impact: impact,
    clientSelection: clientSelection,
    state: state,
    dimensions: dimensions,
    viewport: viewport
  });
});

var getHomeLocation = (function (descriptor) {
  return {
    index: descriptor.index,
    droppableId: descriptor.droppableId
  };
});

var getLiftEffect = (function (_ref) {
  var draggable = _ref.draggable,
      home = _ref.home,
      draggables = _ref.draggables,
      viewport = _ref.viewport;
  var displacedBy = getDisplacedBy(home.axis, draggable.displaceBy);
  var insideHome = getDraggablesInsideDroppable(home.descriptor.id, draggables);
  var rawIndex = insideHome.indexOf(draggable);
  !(rawIndex !== -1) ?  false ? 0 : invariant(false) : void 0;
  var afterDragging = insideHome.slice(rawIndex + 1);
  var effected = afterDragging.reduce(function (previous, item) {
    previous[item.descriptor.id] = true;
    return previous;
  }, {});
  var afterCritical = {
    inVirtualList: home.descriptor.mode === 'virtual',
    displacedBy: displacedBy,
    effected: effected
  };
  var displaced = getDisplacementGroups({
    afterDragging: afterDragging,
    destination: home,
    displacedBy: displacedBy,
    last: null,
    viewport: viewport.frame,
    forceShouldAnimate: false
  });
  var impact = {
    displaced: displaced,
    displacedBy: displacedBy,
    at: {
      type: 'REORDER',
      destination: getHomeLocation(draggable.descriptor)
    }
  };
  return {
    impact: impact,
    afterCritical: afterCritical
  };
});

var patchDimensionMap = (function (dimensions, updated) {
  return {
    draggables: dimensions.draggables,
    droppables: patchDroppableMap(dimensions.droppables, updated)
  };
});

var start = function start(key) {
  if (false) {}
};
var finish = function finish(key) {
  if (false) {}
};

var offsetDraggable = (function (_ref) {
  var draggable = _ref.draggable,
      offset = _ref.offset,
      initialWindowScroll = _ref.initialWindowScroll;
  var client = cssBoxModel.offset(draggable.client, offset);
  var page = cssBoxModel.withScroll(client, initialWindowScroll);

  var moved = _extends({}, draggable, {
    placeholder: _extends({}, draggable.placeholder, {
      client: client
    }),
    client: client,
    page: page
  });

  return moved;
});

var getFrame = (function (droppable) {
  var frame = droppable.frame;
  !frame ?  false ? 0 : invariant(false) : void 0;
  return frame;
});

var adjustAdditionsForScrollChanges = (function (_ref) {
  var additions = _ref.additions,
      updatedDroppables = _ref.updatedDroppables,
      viewport = _ref.viewport;
  var windowScrollChange = viewport.scroll.diff.value;
  return additions.map(function (draggable) {
    var droppableId = draggable.descriptor.droppableId;
    var modified = updatedDroppables[droppableId];
    var frame = getFrame(modified);
    var droppableScrollChange = frame.scroll.diff.value;
    var totalChange = add(windowScrollChange, droppableScrollChange);
    var moved = offsetDraggable({
      draggable: draggable,
      offset: totalChange,
      initialWindowScroll: viewport.scroll.initial
    });
    return moved;
  });
});

var publishWhileDraggingInVirtual = (function (_ref) {
  var state = _ref.state,
      published = _ref.published;
  start();
  var withScrollChange = published.modified.map(function (update) {
    var existing = state.dimensions.droppables[update.droppableId];
    var scrolled = scrollDroppable(existing, update.scroll);
    return scrolled;
  });

  var droppables = _extends({}, state.dimensions.droppables, {}, toDroppableMap(withScrollChange));

  var updatedAdditions = toDraggableMap(adjustAdditionsForScrollChanges({
    additions: published.additions,
    updatedDroppables: droppables,
    viewport: state.viewport
  }));

  var draggables = _extends({}, state.dimensions.draggables, {}, updatedAdditions);

  published.removals.forEach(function (id) {
    delete draggables[id];
  });
  var dimensions = {
    droppables: droppables,
    draggables: draggables
  };
  var wasOverId = whatIsDraggedOver(state.impact);
  var wasOver = wasOverId ? dimensions.droppables[wasOverId] : null;
  var draggable = dimensions.draggables[state.critical.draggable.id];
  var home = dimensions.droppables[state.critical.droppable.id];

  var _getLiftEffect = getLiftEffect({
    draggable: draggable,
    home: home,
    draggables: draggables,
    viewport: state.viewport
  }),
      onLiftImpact = _getLiftEffect.impact,
      afterCritical = _getLiftEffect.afterCritical;

  var previousImpact = wasOver && wasOver.isCombineEnabled ? state.impact : onLiftImpact;
  var impact = getDragImpact({
    pageOffset: state.current.page.offset,
    draggable: dimensions.draggables[state.critical.draggable.id],
    draggables: dimensions.draggables,
    droppables: dimensions.droppables,
    previousImpact: previousImpact,
    viewport: state.viewport,
    afterCritical: afterCritical
  });
  finish();

  var draggingState = _extends({
    phase: 'DRAGGING'
  }, state, {
    phase: 'DRAGGING',
    impact: impact,
    onLiftImpact: onLiftImpact,
    dimensions: dimensions,
    afterCritical: afterCritical,
    forceShouldAnimate: false
  });

  if (state.phase === 'COLLECTING') {
    return draggingState;
  }

  var dropPending = _extends({
    phase: 'DROP_PENDING'
  }, draggingState, {
    phase: 'DROP_PENDING',
    reason: state.reason,
    isWaiting: false
  });

  return dropPending;
});

var isSnapping = function isSnapping(state) {
  return state.movementMode === 'SNAP';
};

var postDroppableChange = function postDroppableChange(state, updated, isEnabledChanging) {
  var dimensions = patchDimensionMap(state.dimensions, updated);

  if (!isSnapping(state) || isEnabledChanging) {
    return update({
      state: state,
      dimensions: dimensions
    });
  }

  return refreshSnap({
    state: state,
    dimensions: dimensions
  });
};

function removeScrollJumpRequest(state) {
  if (state.isDragging && state.movementMode === 'SNAP') {
    return _extends({
      phase: 'DRAGGING'
    }, state, {
      scrollJumpRequest: null
    });
  }

  return state;
}

var idle = {
  phase: 'IDLE',
  completed: null,
  shouldFlush: false
};
var reducer = (function (state, action) {
  if (state === void 0) {
    state = idle;
  }

  if (action.type === 'FLUSH') {
    return _extends({}, idle, {
      shouldFlush: true
    });
  }

  if (action.type === 'INITIAL_PUBLISH') {
    !(state.phase === 'IDLE') ?  false ? 0 : invariant(false) : void 0;
    var _action$payload = action.payload,
        critical = _action$payload.critical,
        clientSelection = _action$payload.clientSelection,
        viewport = _action$payload.viewport,
        dimensions = _action$payload.dimensions,
        movementMode = _action$payload.movementMode;
    var draggable = dimensions.draggables[critical.draggable.id];
    var home = dimensions.droppables[critical.droppable.id];
    var client = {
      selection: clientSelection,
      borderBoxCenter: draggable.client.borderBox.center,
      offset: origin
    };
    var initial = {
      client: client,
      page: {
        selection: add(client.selection, viewport.scroll.initial),
        borderBoxCenter: add(client.selection, viewport.scroll.initial),
        offset: add(client.selection, viewport.scroll.diff.value)
      }
    };
    var isWindowScrollAllowed = toDroppableList(dimensions.droppables).every(function (item) {
      return !item.isFixedOnPage;
    });

    var _getLiftEffect = getLiftEffect({
      draggable: draggable,
      home: home,
      draggables: dimensions.draggables,
      viewport: viewport
    }),
        impact = _getLiftEffect.impact,
        afterCritical = _getLiftEffect.afterCritical;

    var result = {
      phase: 'DRAGGING',
      isDragging: true,
      critical: critical,
      movementMode: movementMode,
      dimensions: dimensions,
      initial: initial,
      current: initial,
      isWindowScrollAllowed: isWindowScrollAllowed,
      impact: impact,
      afterCritical: afterCritical,
      onLiftImpact: impact,
      viewport: viewport,
      scrollJumpRequest: null,
      forceShouldAnimate: null
    };
    return result;
  }

  if (action.type === 'COLLECTION_STARTING') {
    if (state.phase === 'COLLECTING' || state.phase === 'DROP_PENDING') {
      return state;
    }

    !(state.phase === 'DRAGGING') ?  false ? 0 : invariant(false) : void 0;

    var _result = _extends({
      phase: 'COLLECTING'
    }, state, {
      phase: 'COLLECTING'
    });

    return _result;
  }

  if (action.type === 'PUBLISH_WHILE_DRAGGING') {
    !(state.phase === 'COLLECTING' || state.phase === 'DROP_PENDING') ?  false ? 0 : invariant(false) : void 0;
    return publishWhileDraggingInVirtual({
      state: state,
      published: action.payload
    });
  }

  if (action.type === 'MOVE') {
    if (state.phase === 'DROP_PENDING') {
      return state;
    }

    !isMovementAllowed(state) ?  false ? 0 : invariant(false) : void 0;
    var _clientSelection = action.payload.client;

    if (isEqual(_clientSelection, state.current.client.selection)) {
      return state;
    }

    return update({
      state: state,
      clientSelection: _clientSelection,
      impact: isSnapping(state) ? state.impact : null
    });
  }

  if (action.type === 'UPDATE_DROPPABLE_SCROLL') {
    if (state.phase === 'DROP_PENDING') {
      return removeScrollJumpRequest(state);
    }

    if (state.phase === 'COLLECTING') {
      return removeScrollJumpRequest(state);
    }

    !isMovementAllowed(state) ?  false ? 0 : invariant(false) : void 0;
    var _action$payload2 = action.payload,
        id = _action$payload2.id,
        newScroll = _action$payload2.newScroll;
    var target = state.dimensions.droppables[id];

    if (!target) {
      return state;
    }

    var scrolled = scrollDroppable(target, newScroll);
    return postDroppableChange(state, scrolled, false);
  }

  if (action.type === 'UPDATE_DROPPABLE_IS_ENABLED') {
    if (state.phase === 'DROP_PENDING') {
      return state;
    }

    !isMovementAllowed(state) ?  false ? 0 : invariant(false) : void 0;
    var _action$payload3 = action.payload,
        _id = _action$payload3.id,
        isEnabled = _action$payload3.isEnabled;
    var _target = state.dimensions.droppables[_id];
    !_target ?  false ? 0 : invariant(false) : void 0;
    !(_target.isEnabled !== isEnabled) ?  false ? 0 : invariant(false) : void 0;

    var updated = _extends({}, _target, {
      isEnabled: isEnabled
    });

    return postDroppableChange(state, updated, true);
  }

  if (action.type === 'UPDATE_DROPPABLE_IS_COMBINE_ENABLED') {
    if (state.phase === 'DROP_PENDING') {
      return state;
    }

    !isMovementAllowed(state) ?  false ? 0 : invariant(false) : void 0;
    var _action$payload4 = action.payload,
        _id2 = _action$payload4.id,
        isCombineEnabled = _action$payload4.isCombineEnabled;
    var _target2 = state.dimensions.droppables[_id2];
    !_target2 ?  false ? 0 : invariant(false) : void 0;
    !(_target2.isCombineEnabled !== isCombineEnabled) ?  false ? 0 : invariant(false) : void 0;

    var _updated = _extends({}, _target2, {
      isCombineEnabled: isCombineEnabled
    });

    return postDroppableChange(state, _updated, true);
  }

  if (action.type === 'MOVE_BY_WINDOW_SCROLL') {
    if (state.phase === 'DROP_PENDING' || state.phase === 'DROP_ANIMATING') {
      return state;
    }

    !isMovementAllowed(state) ?  false ? 0 : invariant(false) : void 0;
    !state.isWindowScrollAllowed ?  false ? 0 : invariant(false) : void 0;
    var _newScroll = action.payload.newScroll;

    if (isEqual(state.viewport.scroll.current, _newScroll)) {
      return removeScrollJumpRequest(state);
    }

    var _viewport = scrollViewport(state.viewport, _newScroll);

    if (isSnapping(state)) {
      return refreshSnap({
        state: state,
        viewport: _viewport
      });
    }

    return update({
      state: state,
      viewport: _viewport
    });
  }

  if (action.type === 'UPDATE_VIEWPORT_MAX_SCROLL') {
    if (!isMovementAllowed(state)) {
      return state;
    }

    var maxScroll = action.payload.maxScroll;

    if (isEqual(maxScroll, state.viewport.scroll.max)) {
      return state;
    }

    var withMaxScroll = _extends({}, state.viewport, {
      scroll: _extends({}, state.viewport.scroll, {
        max: maxScroll
      })
    });

    return _extends({
      phase: 'DRAGGING'
    }, state, {
      viewport: withMaxScroll
    });
  }

  if (action.type === 'MOVE_UP' || action.type === 'MOVE_DOWN' || action.type === 'MOVE_LEFT' || action.type === 'MOVE_RIGHT') {
    if (state.phase === 'COLLECTING' || state.phase === 'DROP_PENDING') {
      return state;
    }

    !(state.phase === 'DRAGGING') ?  false ? 0 : invariant(false) : void 0;

    var _result2 = moveInDirection({
      state: state,
      type: action.type
    });

    if (!_result2) {
      return state;
    }

    return update({
      state: state,
      impact: _result2.impact,
      clientSelection: _result2.clientSelection,
      scrollJumpRequest: _result2.scrollJumpRequest
    });
  }

  if (action.type === 'DROP_PENDING') {
    var reason = action.payload.reason;
    !(state.phase === 'COLLECTING') ?  false ? 0 : invariant(false) : void 0;

    var newState = _extends({
      phase: 'DROP_PENDING'
    }, state, {
      phase: 'DROP_PENDING',
      isWaiting: true,
      reason: reason
    });

    return newState;
  }

  if (action.type === 'DROP_ANIMATE') {
    var _action$payload5 = action.payload,
        completed = _action$payload5.completed,
        dropDuration = _action$payload5.dropDuration,
        newHomeClientOffset = _action$payload5.newHomeClientOffset;
    !(state.phase === 'DRAGGING' || state.phase === 'DROP_PENDING') ?  false ? 0 : invariant(false) : void 0;
    var _result3 = {
      phase: 'DROP_ANIMATING',
      completed: completed,
      dropDuration: dropDuration,
      newHomeClientOffset: newHomeClientOffset,
      dimensions: state.dimensions
    };
    return _result3;
  }

  if (action.type === 'DROP_COMPLETE') {
    var _completed = action.payload.completed;
    return {
      phase: 'IDLE',
      completed: _completed,
      shouldFlush: false
    };
  }

  return state;
});

var beforeInitialCapture = function beforeInitialCapture(args) {
  return {
    type: 'BEFORE_INITIAL_CAPTURE',
    payload: args
  };
};
var lift = function lift(args) {
  return {
    type: 'LIFT',
    payload: args
  };
};
var initialPublish = function initialPublish(args) {
  return {
    type: 'INITIAL_PUBLISH',
    payload: args
  };
};
var publishWhileDragging = function publishWhileDragging(args) {
  return {
    type: 'PUBLISH_WHILE_DRAGGING',
    payload: args
  };
};
var collectionStarting = function collectionStarting() {
  return {
    type: 'COLLECTION_STARTING',
    payload: null
  };
};
var updateDroppableScroll = function updateDroppableScroll(args) {
  return {
    type: 'UPDATE_DROPPABLE_SCROLL',
    payload: args
  };
};
var updateDroppableIsEnabled = function updateDroppableIsEnabled(args) {
  return {
    type: 'UPDATE_DROPPABLE_IS_ENABLED',
    payload: args
  };
};
var updateDroppableIsCombineEnabled = function updateDroppableIsCombineEnabled(args) {
  return {
    type: 'UPDATE_DROPPABLE_IS_COMBINE_ENABLED',
    payload: args
  };
};
var move = function move(args) {
  return {
    type: 'MOVE',
    payload: args
  };
};
var moveByWindowScroll = function moveByWindowScroll(args) {
  return {
    type: 'MOVE_BY_WINDOW_SCROLL',
    payload: args
  };
};
var updateViewportMaxScroll = function updateViewportMaxScroll(args) {
  return {
    type: 'UPDATE_VIEWPORT_MAX_SCROLL',
    payload: args
  };
};
var moveUp = function moveUp() {
  return {
    type: 'MOVE_UP',
    payload: null
  };
};
var moveDown = function moveDown() {
  return {
    type: 'MOVE_DOWN',
    payload: null
  };
};
var moveRight = function moveRight() {
  return {
    type: 'MOVE_RIGHT',
    payload: null
  };
};
var moveLeft = function moveLeft() {
  return {
    type: 'MOVE_LEFT',
    payload: null
  };
};
var flush = function flush() {
  return {
    type: 'FLUSH',
    payload: null
  };
};
var animateDrop = function animateDrop(args) {
  return {
    type: 'DROP_ANIMATE',
    payload: args
  };
};
var completeDrop = function completeDrop(args) {
  return {
    type: 'DROP_COMPLETE',
    payload: args
  };
};
var drop = function drop(args) {
  return {
    type: 'DROP',
    payload: args
  };
};
var dropPending = function dropPending(args) {
  return {
    type: 'DROP_PENDING',
    payload: args
  };
};
var dropAnimationFinished = function dropAnimationFinished() {
  return {
    type: 'DROP_ANIMATION_FINISHED',
    payload: null
  };
};

function checkIndexes(insideDestination) {
  if (insideDestination.length <= 1) {
    return;
  }

  var indexes = insideDestination.map(function (d) {
    return d.descriptor.index;
  });
  var errors = {};

  for (var i = 1; i < indexes.length; i++) {
    var current = indexes[i];
    var previous = indexes[i - 1];

    if (current !== previous + 1) {
      errors[current] = true;
    }
  }

  if (!Object.keys(errors).length) {
    return;
  }

  var formatted = indexes.map(function (index) {
    var hasError = Boolean(errors[index]);
    return hasError ? "[\uD83D\uDD25" + index + "]" : "" + index;
  }).join(', ');
   false ? 0 : void 0;
}

function validateDimensions(critical, dimensions) {
  if (false) { var insideDestination; }
}

var lift$1 = (function (marshal) {
  return function (_ref) {
    var getState = _ref.getState,
        dispatch = _ref.dispatch;
    return function (next) {
      return function (action) {
        if (action.type !== 'LIFT') {
          next(action);
          return;
        }

        var _action$payload = action.payload,
            id = _action$payload.id,
            clientSelection = _action$payload.clientSelection,
            movementMode = _action$payload.movementMode;
        var initial = getState();

        if (initial.phase === 'DROP_ANIMATING') {
          dispatch(completeDrop({
            completed: initial.completed
          }));
        }

        !(getState().phase === 'IDLE') ?  false ? 0 : invariant(false) : void 0;
        dispatch(flush());
        dispatch(beforeInitialCapture({
          draggableId: id,
          movementMode: movementMode
        }));
        var scrollOptions = {
          shouldPublishImmediately: movementMode === 'SNAP'
        };
        var request = {
          draggableId: id,
          scrollOptions: scrollOptions
        };

        var _marshal$startPublish = marshal.startPublishing(request),
            critical = _marshal$startPublish.critical,
            dimensions = _marshal$startPublish.dimensions,
            viewport = _marshal$startPublish.viewport;

        validateDimensions(critical, dimensions);
        dispatch(initialPublish({
          critical: critical,
          dimensions: dimensions,
          clientSelection: clientSelection,
          movementMode: movementMode,
          viewport: viewport
        }));
      };
    };
  };
});

var style = (function (marshal) {
  return function () {
    return function (next) {
      return function (action) {
        if (action.type === 'INITIAL_PUBLISH') {
          marshal.dragging();
        }

        if (action.type === 'DROP_ANIMATE') {
          marshal.dropping(action.payload.completed.result.reason);
        }

        if (action.type === 'FLUSH' || action.type === 'DROP_COMPLETE') {
          marshal.resting();
        }

        next(action);
      };
    };
  };
});

var curves = {
  outOfTheWay: 'cubic-bezier(0.2, 0, 0, 1)',
  drop: 'cubic-bezier(.2,1,.1,1)'
};
var combine = {
  opacity: {
    drop: 0,
    combining: 0.7
  },
  scale: {
    drop: 0.75
  }
};
var timings = {
  outOfTheWay: 0.2,
  minDropTime: 0.33,
  maxDropTime: 0.55
};
var outOfTheWayTiming = timings.outOfTheWay + "s " + curves.outOfTheWay;
var transitions = {
  fluid: "opacity " + outOfTheWayTiming,
  snap: "transform " + outOfTheWayTiming + ", opacity " + outOfTheWayTiming,
  drop: function drop(duration) {
    var timing = duration + "s " + curves.drop;
    return "transform " + timing + ", opacity " + timing;
  },
  outOfTheWay: "transform " + outOfTheWayTiming,
  placeholder: "height " + outOfTheWayTiming + ", width " + outOfTheWayTiming + ", margin " + outOfTheWayTiming
};

var moveTo = function moveTo(offset) {
  return isEqual(offset, origin) ? null : "translate(" + offset.x + "px, " + offset.y + "px)";
};

var transforms = {
  moveTo: moveTo,
  drop: function drop(offset, isCombining) {
    var translate = moveTo(offset);

    if (!translate) {
      return null;
    }

    if (!isCombining) {
      return translate;
    }

    return translate + " scale(" + combine.scale.drop + ")";
  }
};

var minDropTime = timings.minDropTime,
    maxDropTime = timings.maxDropTime;
var dropTimeRange = maxDropTime - minDropTime;
var maxDropTimeAtDistance = 1500;
var cancelDropModifier = 0.6;
var getDropDuration = (function (_ref) {
  var current = _ref.current,
      destination = _ref.destination,
      reason = _ref.reason;
  var distance$1 = distance(current, destination);

  if (distance$1 <= 0) {
    return minDropTime;
  }

  if (distance$1 >= maxDropTimeAtDistance) {
    return maxDropTime;
  }

  var percentage = distance$1 / maxDropTimeAtDistance;
  var duration = minDropTime + dropTimeRange * percentage;
  var withDuration = reason === 'CANCEL' ? duration * cancelDropModifier : duration;
  return Number(withDuration.toFixed(2));
});

var getNewHomeClientOffset = (function (_ref) {
  var impact = _ref.impact,
      draggable = _ref.draggable,
      dimensions = _ref.dimensions,
      viewport = _ref.viewport,
      afterCritical = _ref.afterCritical;
  var draggables = dimensions.draggables,
      droppables = dimensions.droppables;
  var droppableId = whatIsDraggedOver(impact);
  var destination = droppableId ? droppables[droppableId] : null;
  var home = droppables[draggable.descriptor.droppableId];
  var newClientCenter = getClientBorderBoxCenter({
    impact: impact,
    draggable: draggable,
    draggables: draggables,
    afterCritical: afterCritical,
    droppable: destination || home,
    viewport: viewport
  });
  var offset = subtract(newClientCenter, draggable.client.borderBox.center);
  return offset;
});

var getDropImpact = (function (_ref) {
  var draggables = _ref.draggables,
      reason = _ref.reason,
      lastImpact = _ref.lastImpact,
      home = _ref.home,
      viewport = _ref.viewport,
      onLiftImpact = _ref.onLiftImpact;

  if (!lastImpact.at || reason !== 'DROP') {
    var recomputedHomeImpact = recompute({
      draggables: draggables,
      impact: onLiftImpact,
      destination: home,
      viewport: viewport,
      forceShouldAnimate: true
    });
    return {
      impact: recomputedHomeImpact,
      didDropInsideDroppable: false
    };
  }

  if (lastImpact.at.type === 'REORDER') {
    return {
      impact: lastImpact,
      didDropInsideDroppable: true
    };
  }

  var withoutMovement = _extends({}, lastImpact, {
    displaced: emptyGroups
  });

  return {
    impact: withoutMovement,
    didDropInsideDroppable: true
  };
});

var drop$1 = (function (_ref) {
  var getState = _ref.getState,
      dispatch = _ref.dispatch;
  return function (next) {
    return function (action) {
      if (action.type !== 'DROP') {
        next(action);
        return;
      }

      var state = getState();
      var reason = action.payload.reason;

      if (state.phase === 'COLLECTING') {
        dispatch(dropPending({
          reason: reason
        }));
        return;
      }

      if (state.phase === 'IDLE') {
        return;
      }

      var isWaitingForDrop = state.phase === 'DROP_PENDING' && state.isWaiting;
      !!isWaitingForDrop ?  false ? 0 : invariant(false) : void 0;
      !(state.phase === 'DRAGGING' || state.phase === 'DROP_PENDING') ?  false ? 0 : invariant(false) : void 0;
      var critical = state.critical;
      var dimensions = state.dimensions;
      var draggable = dimensions.draggables[state.critical.draggable.id];

      var _getDropImpact = getDropImpact({
        reason: reason,
        lastImpact: state.impact,
        afterCritical: state.afterCritical,
        onLiftImpact: state.onLiftImpact,
        home: state.dimensions.droppables[state.critical.droppable.id],
        viewport: state.viewport,
        draggables: state.dimensions.draggables
      }),
          impact = _getDropImpact.impact,
          didDropInsideDroppable = _getDropImpact.didDropInsideDroppable;

      var destination = didDropInsideDroppable ? tryGetDestination(impact) : null;
      var combine = didDropInsideDroppable ? tryGetCombine(impact) : null;
      var source = {
        index: critical.draggable.index,
        droppableId: critical.droppable.id
      };
      var result = {
        draggableId: draggable.descriptor.id,
        type: draggable.descriptor.type,
        source: source,
        reason: reason,
        mode: state.movementMode,
        destination: destination,
        combine: combine
      };
      var newHomeClientOffset = getNewHomeClientOffset({
        impact: impact,
        draggable: draggable,
        dimensions: dimensions,
        viewport: state.viewport,
        afterCritical: state.afterCritical
      });
      var completed = {
        critical: state.critical,
        afterCritical: state.afterCritical,
        result: result,
        impact: impact
      };
      var isAnimationRequired = !isEqual(state.current.client.offset, newHomeClientOffset) || Boolean(result.combine);

      if (!isAnimationRequired) {
        dispatch(completeDrop({
          completed: completed
        }));
        return;
      }

      var dropDuration = getDropDuration({
        current: state.current.client.offset,
        destination: newHomeClientOffset,
        reason: reason
      });
      var args = {
        newHomeClientOffset: newHomeClientOffset,
        dropDuration: dropDuration,
        completed: completed
      };
      dispatch(animateDrop(args));
    };
  };
});

var getWindowScroll = (function () {
  return {
    x: window.pageXOffset,
    y: window.pageYOffset
  };
});

function getWindowScrollBinding(update) {
  return {
    eventName: 'scroll',
    options: {
      passive: true,
      capture: false
    },
    fn: function fn(event) {
      if (event.target !== window && event.target !== window.document) {
        return;
      }

      update();
    }
  };
}

function getScrollListener(_ref) {
  var onWindowScroll = _ref.onWindowScroll;

  function updateScroll() {
    onWindowScroll(getWindowScroll());
  }

  var scheduled = rafSchd(updateScroll);
  var binding = getWindowScrollBinding(scheduled);
  var unbind = noop;

  function isActive() {
    return unbind !== noop;
  }

  function start() {
    !!isActive() ?  false ? 0 : invariant(false) : void 0;
    unbind = bindEvents(window, [binding]);
  }

  function stop() {
    !isActive() ?  false ? 0 : invariant(false) : void 0;
    scheduled.cancel();
    unbind();
    unbind = noop;
  }

  return {
    start: start,
    stop: stop,
    isActive: isActive
  };
}

var shouldEnd = function shouldEnd(action) {
  return action.type === 'DROP_COMPLETE' || action.type === 'DROP_ANIMATE' || action.type === 'FLUSH';
};

var scrollListener = (function (store) {
  var listener = getScrollListener({
    onWindowScroll: function onWindowScroll(newScroll) {
      store.dispatch(moveByWindowScroll({
        newScroll: newScroll
      }));
    }
  });
  return function (next) {
    return function (action) {
      if (!listener.isActive() && action.type === 'INITIAL_PUBLISH') {
        listener.start();
      }

      if (listener.isActive() && shouldEnd(action)) {
        listener.stop();
      }

      next(action);
    };
  };
});

var getExpiringAnnounce = (function (announce) {
  var wasCalled = false;
  var isExpired = false;
  var timeoutId = setTimeout(function () {
    isExpired = true;
  });

  var result = function result(message) {
    if (wasCalled) {
       false ? 0 : void 0;
      return;
    }

    if (isExpired) {
       false ? 0 : void 0;
      return;
    }

    wasCalled = true;
    announce(message);
    clearTimeout(timeoutId);
  };

  result.wasCalled = function () {
    return wasCalled;
  };

  return result;
});

var getAsyncMarshal = (function () {
  var entries = [];

  var execute = function execute(timerId) {
    var index = findIndex(entries, function (item) {
      return item.timerId === timerId;
    });
    !(index !== -1) ?  false ? 0 : invariant(false) : void 0;

    var _entries$splice = entries.splice(index, 1),
        entry = _entries$splice[0];

    entry.callback();
  };

  var add = function add(fn) {
    var timerId = setTimeout(function () {
      return execute(timerId);
    });
    var entry = {
      timerId: timerId,
      callback: fn
    };
    entries.push(entry);
  };

  var flush = function flush() {
    if (!entries.length) {
      return;
    }

    var shallow = [].concat(entries);
    entries.length = 0;
    shallow.forEach(function (entry) {
      clearTimeout(entry.timerId);
      entry.callback();
    });
  };

  return {
    add: add,
    flush: flush
  };
});

var areLocationsEqual = function areLocationsEqual(first, second) {
  if (first == null && second == null) {
    return true;
  }

  if (first == null || second == null) {
    return false;
  }

  return first.droppableId === second.droppableId && first.index === second.index;
};
var isCombineEqual = function isCombineEqual(first, second) {
  if (first == null && second == null) {
    return true;
  }

  if (first == null || second == null) {
    return false;
  }

  return first.draggableId === second.draggableId && first.droppableId === second.droppableId;
};
var isCriticalEqual = function isCriticalEqual(first, second) {
  if (first === second) {
    return true;
  }

  var isDraggableEqual = first.draggable.id === second.draggable.id && first.draggable.droppableId === second.draggable.droppableId && first.draggable.type === second.draggable.type && first.draggable.index === second.draggable.index;
  var isDroppableEqual = first.droppable.id === second.droppable.id && first.droppable.type === second.droppable.type;
  return isDraggableEqual && isDroppableEqual;
};

var withTimings = function withTimings(key, fn) {
  start();
  fn();
  finish();
};

var getDragStart = function getDragStart(critical, mode) {
  return {
    draggableId: critical.draggable.id,
    type: critical.droppable.type,
    source: {
      droppableId: critical.droppable.id,
      index: critical.draggable.index
    },
    mode: mode
  };
};

var execute = function execute(responder, data, announce, getDefaultMessage) {
  if (!responder) {
    announce(getDefaultMessage(data));
    return;
  }

  var willExpire = getExpiringAnnounce(announce);
  var provided = {
    announce: willExpire
  };
  responder(data, provided);

  if (!willExpire.wasCalled()) {
    announce(getDefaultMessage(data));
  }
};

var getPublisher = (function (getResponders, announce) {
  var asyncMarshal = getAsyncMarshal();
  var dragging = null;

  var beforeCapture = function beforeCapture(draggableId, mode) {
    !!dragging ?  false ? 0 : invariant(false) : void 0;
    withTimings('onBeforeCapture', function () {
      var fn = getResponders().onBeforeCapture;

      if (fn) {
        var before = {
          draggableId: draggableId,
          mode: mode
        };
        fn(before);
      }
    });
  };

  var beforeStart = function beforeStart(critical, mode) {
    !!dragging ?  false ? 0 : invariant(false) : void 0;
    withTimings('onBeforeDragStart', function () {
      var fn = getResponders().onBeforeDragStart;

      if (fn) {
        fn(getDragStart(critical, mode));
      }
    });
  };

  var start = function start(critical, mode) {
    !!dragging ?  false ? 0 : invariant(false) : void 0;
    var data = getDragStart(critical, mode);
    dragging = {
      mode: mode,
      lastCritical: critical,
      lastLocation: data.source,
      lastCombine: null
    };
    asyncMarshal.add(function () {
      withTimings('onDragStart', function () {
        return execute(getResponders().onDragStart, data, announce, preset.onDragStart);
      });
    });
  };

  var update = function update(critical, impact) {
    var location = tryGetDestination(impact);
    var combine = tryGetCombine(impact);
    !dragging ?  false ? 0 : invariant(false) : void 0;
    var hasCriticalChanged = !isCriticalEqual(critical, dragging.lastCritical);

    if (hasCriticalChanged) {
      dragging.lastCritical = critical;
    }

    var hasLocationChanged = !areLocationsEqual(dragging.lastLocation, location);

    if (hasLocationChanged) {
      dragging.lastLocation = location;
    }

    var hasGroupingChanged = !isCombineEqual(dragging.lastCombine, combine);

    if (hasGroupingChanged) {
      dragging.lastCombine = combine;
    }

    if (!hasCriticalChanged && !hasLocationChanged && !hasGroupingChanged) {
      return;
    }

    var data = _extends({}, getDragStart(critical, dragging.mode), {
      combine: combine,
      destination: location
    });

    asyncMarshal.add(function () {
      withTimings('onDragUpdate', function () {
        return execute(getResponders().onDragUpdate, data, announce, preset.onDragUpdate);
      });
    });
  };

  var flush = function flush() {
    !dragging ?  false ? 0 : invariant(false) : void 0;
    asyncMarshal.flush();
  };

  var drop = function drop(result) {
    !dragging ?  false ? 0 : invariant(false) : void 0;
    dragging = null;
    withTimings('onDragEnd', function () {
      return execute(getResponders().onDragEnd, result, announce, preset.onDragEnd);
    });
  };

  var abort = function abort() {
    if (!dragging) {
      return;
    }

    var result = _extends({}, getDragStart(dragging.lastCritical, dragging.mode), {
      combine: null,
      destination: null,
      reason: 'CANCEL'
    });

    drop(result);
  };

  return {
    beforeCapture: beforeCapture,
    beforeStart: beforeStart,
    start: start,
    update: update,
    flush: flush,
    drop: drop,
    abort: abort
  };
});

var responders = (function (getResponders, announce) {
  var publisher = getPublisher(getResponders, announce);
  return function (store) {
    return function (next) {
      return function (action) {
        if (action.type === 'BEFORE_INITIAL_CAPTURE') {
          publisher.beforeCapture(action.payload.draggableId, action.payload.movementMode);
          return;
        }

        if (action.type === 'INITIAL_PUBLISH') {
          var critical = action.payload.critical;
          publisher.beforeStart(critical, action.payload.movementMode);
          next(action);
          publisher.start(critical, action.payload.movementMode);
          return;
        }

        if (action.type === 'DROP_COMPLETE') {
          var result = action.payload.completed.result;
          publisher.flush();
          next(action);
          publisher.drop(result);
          return;
        }

        next(action);

        if (action.type === 'FLUSH') {
          publisher.abort();
          return;
        }

        var state = store.getState();

        if (state.phase === 'DRAGGING') {
          publisher.update(state.critical, state.impact);
        }
      };
    };
  };
});

var dropAnimationFinish = (function (store) {
  return function (next) {
    return function (action) {
      if (action.type !== 'DROP_ANIMATION_FINISHED') {
        next(action);
        return;
      }

      var state = store.getState();
      !(state.phase === 'DROP_ANIMATING') ?  false ? 0 : invariant(false) : void 0;
      store.dispatch(completeDrop({
        completed: state.completed
      }));
    };
  };
});

var dropAnimationFlushOnScroll = (function (store) {
  var unbind = null;
  var frameId = null;

  function clear() {
    if (frameId) {
      cancelAnimationFrame(frameId);
      frameId = null;
    }

    if (unbind) {
      unbind();
      unbind = null;
    }
  }

  return function (next) {
    return function (action) {
      if (action.type === 'FLUSH' || action.type === 'DROP_COMPLETE' || action.type === 'DROP_ANIMATION_FINISHED') {
        clear();
      }

      next(action);

      if (action.type !== 'DROP_ANIMATE') {
        return;
      }

      var binding = {
        eventName: 'scroll',
        options: {
          capture: true,
          passive: false,
          once: true
        },
        fn: function flushDropAnimation() {
          var state = store.getState();

          if (state.phase === 'DROP_ANIMATING') {
            store.dispatch(dropAnimationFinished());
          }
        }
      };
      frameId = requestAnimationFrame(function () {
        frameId = null;
        unbind = bindEvents(window, [binding]);
      });
    };
  };
});

var dimensionMarshalStopper = (function (marshal) {
  return function () {
    return function (next) {
      return function (action) {
        if (action.type === 'DROP_COMPLETE' || action.type === 'FLUSH' || action.type === 'DROP_ANIMATE') {
          marshal.stopPublishing();
        }

        next(action);
      };
    };
  };
});

var focus = (function (marshal) {
  var isWatching = false;
  return function () {
    return function (next) {
      return function (action) {
        if (action.type === 'INITIAL_PUBLISH') {
          isWatching = true;
          marshal.tryRecordFocus(action.payload.critical.draggable.id);
          next(action);
          marshal.tryRestoreFocusRecorded();
          return;
        }

        next(action);

        if (!isWatching) {
          return;
        }

        if (action.type === 'FLUSH') {
          isWatching = false;
          marshal.tryRestoreFocusRecorded();
          return;
        }

        if (action.type === 'DROP_COMPLETE') {
          isWatching = false;
          var result = action.payload.completed.result;

          if (result.combine) {
            marshal.tryShiftRecord(result.draggableId, result.combine.draggableId);
          }

          marshal.tryRestoreFocusRecorded();
        }
      };
    };
  };
});

var shouldStop = function shouldStop(action) {
  return action.type === 'DROP_COMPLETE' || action.type === 'DROP_ANIMATE' || action.type === 'FLUSH';
};

var autoScroll = (function (autoScroller) {
  return function (store) {
    return function (next) {
      return function (action) {
        if (shouldStop(action)) {
          autoScroller.stop();
          next(action);
          return;
        }

        if (action.type === 'INITIAL_PUBLISH') {
          next(action);
          var state = store.getState();
          !(state.phase === 'DRAGGING') ?  false ? 0 : invariant(false) : void 0;
          autoScroller.start(state);
          return;
        }

        next(action);
        autoScroller.scroll(store.getState());
      };
    };
  };
});

var pendingDrop = (function (store) {
  return function (next) {
    return function (action) {
      next(action);

      if (action.type !== 'PUBLISH_WHILE_DRAGGING') {
        return;
      }

      var postActionState = store.getState();

      if (postActionState.phase !== 'DROP_PENDING') {
        return;
      }

      if (postActionState.isWaiting) {
        return;
      }

      store.dispatch(drop({
        reason: postActionState.reason
      }));
    };
  };
});

var composeEnhancers =  false ? 0 : redux.compose;
var createStore = (function (_ref) {
  var dimensionMarshal = _ref.dimensionMarshal,
      focusMarshal = _ref.focusMarshal,
      styleMarshal = _ref.styleMarshal,
      getResponders = _ref.getResponders,
      announce = _ref.announce,
      autoScroller = _ref.autoScroller;
  return redux.createStore(reducer, composeEnhancers(redux.applyMiddleware(style(styleMarshal), dimensionMarshalStopper(dimensionMarshal), lift$1(dimensionMarshal), drop$1, dropAnimationFinish, dropAnimationFlushOnScroll, pendingDrop, autoScroll(autoScroller), scrollListener, focus(focusMarshal), responders(getResponders, announce))));
});

var clean$1 = function clean() {
  return {
    additions: {},
    removals: {},
    modified: {}
  };
};
function createPublisher(_ref) {
  var registry = _ref.registry,
      callbacks = _ref.callbacks;
  var staging = clean$1();
  var frameId = null;

  var collect = function collect() {
    if (frameId) {
      return;
    }

    callbacks.collectionStarting();
    frameId = requestAnimationFrame(function () {
      frameId = null;
      start();
      var _staging = staging,
          additions = _staging.additions,
          removals = _staging.removals,
          modified = _staging.modified;
      var added = Object.keys(additions).map(function (id) {
        return registry.draggable.getById(id).getDimension(origin);
      }).sort(function (a, b) {
        return a.descriptor.index - b.descriptor.index;
      });
      var updated = Object.keys(modified).map(function (id) {
        var entry = registry.droppable.getById(id);
        var scroll = entry.callbacks.getScrollWhileDragging();
        return {
          droppableId: id,
          scroll: scroll
        };
      });
      var result = {
        additions: added,
        removals: Object.keys(removals),
        modified: updated
      };
      staging = clean$1();
      finish();
      callbacks.publish(result);
    });
  };

  var add = function add(entry) {
    var id = entry.descriptor.id;
    staging.additions[id] = entry;
    staging.modified[entry.descriptor.droppableId] = true;

    if (staging.removals[id]) {
      delete staging.removals[id];
    }

    collect();
  };

  var remove = function remove(entry) {
    var descriptor = entry.descriptor;
    staging.removals[descriptor.id] = true;
    staging.modified[descriptor.droppableId] = true;

    if (staging.additions[descriptor.id]) {
      delete staging.additions[descriptor.id];
    }

    collect();
  };

  var stop = function stop() {
    if (!frameId) {
      return;
    }

    cancelAnimationFrame(frameId);
    frameId = null;
    staging = clean$1();
  };

  return {
    add: add,
    remove: remove,
    stop: stop
  };
}

var getMaxScroll = (function (_ref) {
  var scrollHeight = _ref.scrollHeight,
      scrollWidth = _ref.scrollWidth,
      height = _ref.height,
      width = _ref.width;
  var maxScroll = subtract({
    x: scrollWidth,
    y: scrollHeight
  }, {
    x: width,
    y: height
  });
  var adjustedMaxScroll = {
    x: Math.max(0, maxScroll.x),
    y: Math.max(0, maxScroll.y)
  };
  return adjustedMaxScroll;
});

var getDocumentElement = (function () {
  var doc = document.documentElement;
  !doc ?  false ? 0 : invariant(false) : void 0;
  return doc;
});

var getMaxWindowScroll = (function () {
  var doc = getDocumentElement();
  var maxScroll = getMaxScroll({
    scrollHeight: doc.scrollHeight,
    scrollWidth: doc.scrollWidth,
    width: doc.clientWidth,
    height: doc.clientHeight
  });
  return maxScroll;
});

var getViewport = (function () {
  var scroll = getWindowScroll();
  var maxScroll = getMaxWindowScroll();
  var top = scroll.y;
  var left = scroll.x;
  var doc = getDocumentElement();
  var width = doc.clientWidth;
  var height = doc.clientHeight;
  var right = left + width;
  var bottom = top + height;
  var frame = cssBoxModel.getRect({
    top: top,
    left: left,
    right: right,
    bottom: bottom
  });
  var viewport = {
    frame: frame,
    scroll: {
      initial: scroll,
      current: scroll,
      max: maxScroll,
      diff: {
        value: origin,
        displacement: origin
      }
    }
  };
  return viewport;
});

var getInitialPublish = (function (_ref) {
  var critical = _ref.critical,
      scrollOptions = _ref.scrollOptions,
      registry = _ref.registry;
  start();
  var viewport = getViewport();
  var windowScroll = viewport.scroll.current;
  var home = critical.droppable;
  var droppables = registry.droppable.getAllByType(home.type).map(function (entry) {
    return entry.callbacks.getDimensionAndWatchScroll(windowScroll, scrollOptions);
  });
  var draggables = registry.draggable.getAllByType(critical.draggable.type).map(function (entry) {
    return entry.getDimension(windowScroll);
  });
  var dimensions = {
    draggables: toDraggableMap(draggables),
    droppables: toDroppableMap(droppables)
  };
  finish();
  var result = {
    dimensions: dimensions,
    critical: critical,
    viewport: viewport
  };
  return result;
});

function shouldPublishUpdate(registry, dragging, entry) {
  if (entry.descriptor.id === dragging.id) {
    return false;
  }

  if (entry.descriptor.type !== dragging.type) {
    return false;
  }

  var home = registry.droppable.getById(entry.descriptor.droppableId);

  if (home.descriptor.mode !== 'virtual') {
     false ? 0 : void 0;
    return false;
  }

  return true;
}

var createDimensionMarshal = (function (registry, callbacks) {
  var collection = null;
  var publisher = createPublisher({
    callbacks: {
      publish: callbacks.publishWhileDragging,
      collectionStarting: callbacks.collectionStarting
    },
    registry: registry
  });

  var updateDroppableIsEnabled = function updateDroppableIsEnabled(id, isEnabled) {
    !registry.droppable.exists(id) ?  false ? 0 : invariant(false) : void 0;

    if (!collection) {
      return;
    }

    callbacks.updateDroppableIsEnabled({
      id: id,
      isEnabled: isEnabled
    });
  };

  var updateDroppableIsCombineEnabled = function updateDroppableIsCombineEnabled(id, isCombineEnabled) {
    if (!collection) {
      return;
    }

    !registry.droppable.exists(id) ?  false ? 0 : invariant(false) : void 0;
    callbacks.updateDroppableIsCombineEnabled({
      id: id,
      isCombineEnabled: isCombineEnabled
    });
  };

  var updateDroppableScroll = function updateDroppableScroll(id, newScroll) {
    if (!collection) {
      return;
    }

    !registry.droppable.exists(id) ?  false ? 0 : invariant(false) : void 0;
    callbacks.updateDroppableScroll({
      id: id,
      newScroll: newScroll
    });
  };

  var scrollDroppable = function scrollDroppable(id, change) {
    if (!collection) {
      return;
    }

    registry.droppable.getById(id).callbacks.scroll(change);
  };

  var stopPublishing = function stopPublishing() {
    if (!collection) {
      return;
    }

    publisher.stop();
    var home = collection.critical.droppable;
    registry.droppable.getAllByType(home.type).forEach(function (entry) {
      return entry.callbacks.dragStopped();
    });
    collection.unsubscribe();
    collection = null;
  };

  var subscriber = function subscriber(event) {
    !collection ?  false ? 0 : invariant(false) : void 0;
    var dragging = collection.critical.draggable;

    if (event.type === 'ADDITION') {
      if (shouldPublishUpdate(registry, dragging, event.value)) {
        publisher.add(event.value);
      }
    }

    if (event.type === 'REMOVAL') {
      if (shouldPublishUpdate(registry, dragging, event.value)) {
        publisher.remove(event.value);
      }
    }
  };

  var startPublishing = function startPublishing(request) {
    !!collection ?  false ? 0 : invariant(false) : void 0;
    var entry = registry.draggable.getById(request.draggableId);
    var home = registry.droppable.getById(entry.descriptor.droppableId);
    var critical = {
      draggable: entry.descriptor,
      droppable: home.descriptor
    };
    var unsubscribe = registry.subscribe(subscriber);
    collection = {
      critical: critical,
      unsubscribe: unsubscribe
    };
    return getInitialPublish({
      critical: critical,
      registry: registry,
      scrollOptions: request.scrollOptions
    });
  };

  var marshal = {
    updateDroppableIsEnabled: updateDroppableIsEnabled,
    updateDroppableIsCombineEnabled: updateDroppableIsCombineEnabled,
    scrollDroppable: scrollDroppable,
    updateDroppableScroll: updateDroppableScroll,
    startPublishing: startPublishing,
    stopPublishing: stopPublishing
  };
  return marshal;
});

var canStartDrag = (function (state, id) {
  if (state.phase === 'IDLE') {
    return true;
  }

  if (state.phase !== 'DROP_ANIMATING') {
    return false;
  }

  if (state.completed.result.draggableId === id) {
    return false;
  }

  return state.completed.result.reason === 'DROP';
});

var scrollWindow = (function (change) {
  window.scrollBy(change.x, change.y);
});

var getScrollableDroppables = memoizeOne(function (droppables) {
  return toDroppableList(droppables).filter(function (droppable) {
    if (!droppable.isEnabled) {
      return false;
    }

    if (!droppable.frame) {
      return false;
    }

    return true;
  });
});

var getScrollableDroppableOver = function getScrollableDroppableOver(target, droppables) {
  var maybe = find(getScrollableDroppables(droppables), function (droppable) {
    !droppable.frame ?  false ? 0 : invariant(false) : void 0;
    return isPositionInFrame(droppable.frame.pageMarginBox)(target);
  });
  return maybe;
};

var getBestScrollableDroppable = (function (_ref) {
  var center = _ref.center,
      destination = _ref.destination,
      droppables = _ref.droppables;

  if (destination) {
    var _dimension = droppables[destination];

    if (!_dimension.frame) {
      return null;
    }

    return _dimension;
  }

  var dimension = getScrollableDroppableOver(center, droppables);
  return dimension;
});

var config = {
  startFromPercentage: 0.25,
  maxScrollAtPercentage: 0.05,
  maxPixelScroll: 28,
  ease: function ease(percentage) {
    return Math.pow(percentage, 2);
  },
  durationDampening: {
    stopDampeningAt: 1200,
    accelerateAt: 360
  }
};

var getDistanceThresholds = (function (container, axis) {
  var startScrollingFrom = container[axis.size] * config.startFromPercentage;
  var maxScrollValueAt = container[axis.size] * config.maxScrollAtPercentage;
  var thresholds = {
    startScrollingFrom: startScrollingFrom,
    maxScrollValueAt: maxScrollValueAt
  };
  return thresholds;
});

var getPercentage = (function (_ref) {
  var startOfRange = _ref.startOfRange,
      endOfRange = _ref.endOfRange,
      current = _ref.current;
  var range = endOfRange - startOfRange;

  if (range === 0) {
     false ? 0 : void 0;
    return 0;
  }

  var currentInRange = current - startOfRange;
  var percentage = currentInRange / range;
  return percentage;
});

var minScroll = 1;

var getValueFromDistance = (function (distanceToEdge, thresholds) {
  if (distanceToEdge > thresholds.startScrollingFrom) {
    return 0;
  }

  if (distanceToEdge <= thresholds.maxScrollValueAt) {
    return config.maxPixelScroll;
  }

  if (distanceToEdge === thresholds.startScrollingFrom) {
    return minScroll;
  }

  var percentageFromMaxScrollValueAt = getPercentage({
    startOfRange: thresholds.maxScrollValueAt,
    endOfRange: thresholds.startScrollingFrom,
    current: distanceToEdge
  });
  var percentageFromStartScrollingFrom = 1 - percentageFromMaxScrollValueAt;
  var scroll = config.maxPixelScroll * config.ease(percentageFromStartScrollingFrom);
  return Math.ceil(scroll);
});

var accelerateAt = config.durationDampening.accelerateAt;
var stopAt = config.durationDampening.stopDampeningAt;
var dampenValueByTime = (function (proposedScroll, dragStartTime) {
  var startOfRange = dragStartTime;
  var endOfRange = stopAt;
  var now = Date.now();
  var runTime = now - startOfRange;

  if (runTime >= stopAt) {
    return proposedScroll;
  }

  if (runTime < accelerateAt) {
    return minScroll;
  }

  var betweenAccelerateAtAndStopAtPercentage = getPercentage({
    startOfRange: accelerateAt,
    endOfRange: endOfRange,
    current: runTime
  });
  var scroll = proposedScroll * config.ease(betweenAccelerateAtAndStopAtPercentage);
  return Math.ceil(scroll);
});

var getValue = (function (_ref) {
  var distanceToEdge = _ref.distanceToEdge,
      thresholds = _ref.thresholds,
      dragStartTime = _ref.dragStartTime,
      shouldUseTimeDampening = _ref.shouldUseTimeDampening;
  var scroll = getValueFromDistance(distanceToEdge, thresholds);

  if (scroll === 0) {
    return 0;
  }

  if (!shouldUseTimeDampening) {
    return scroll;
  }

  return Math.max(dampenValueByTime(scroll, dragStartTime), minScroll);
});

var getScrollOnAxis = (function (_ref) {
  var container = _ref.container,
      distanceToEdges = _ref.distanceToEdges,
      dragStartTime = _ref.dragStartTime,
      axis = _ref.axis,
      shouldUseTimeDampening = _ref.shouldUseTimeDampening;
  var thresholds = getDistanceThresholds(container, axis);
  var isCloserToEnd = distanceToEdges[axis.end] < distanceToEdges[axis.start];

  if (isCloserToEnd) {
    return getValue({
      distanceToEdge: distanceToEdges[axis.end],
      thresholds: thresholds,
      dragStartTime: dragStartTime,
      shouldUseTimeDampening: shouldUseTimeDampening
    });
  }

  return -1 * getValue({
    distanceToEdge: distanceToEdges[axis.start],
    thresholds: thresholds,
    dragStartTime: dragStartTime,
    shouldUseTimeDampening: shouldUseTimeDampening
  });
});

var adjustForSizeLimits = (function (_ref) {
  var container = _ref.container,
      subject = _ref.subject,
      proposedScroll = _ref.proposedScroll;
  var isTooBigVertically = subject.height > container.height;
  var isTooBigHorizontally = subject.width > container.width;

  if (!isTooBigHorizontally && !isTooBigVertically) {
    return proposedScroll;
  }

  if (isTooBigHorizontally && isTooBigVertically) {
    return null;
  }

  return {
    x: isTooBigHorizontally ? 0 : proposedScroll.x,
    y: isTooBigVertically ? 0 : proposedScroll.y
  };
});

var clean$2 = apply(function (value) {
  return value === 0 ? 0 : value;
});
var getScroll = (function (_ref) {
  var dragStartTime = _ref.dragStartTime,
      container = _ref.container,
      subject = _ref.subject,
      center = _ref.center,
      shouldUseTimeDampening = _ref.shouldUseTimeDampening;
  var distanceToEdges = {
    top: center.y - container.top,
    right: container.right - center.x,
    bottom: container.bottom - center.y,
    left: center.x - container.left
  };
  var y = getScrollOnAxis({
    container: container,
    distanceToEdges: distanceToEdges,
    dragStartTime: dragStartTime,
    axis: vertical,
    shouldUseTimeDampening: shouldUseTimeDampening
  });
  var x = getScrollOnAxis({
    container: container,
    distanceToEdges: distanceToEdges,
    dragStartTime: dragStartTime,
    axis: horizontal,
    shouldUseTimeDampening: shouldUseTimeDampening
  });
  var required = clean$2({
    x: x,
    y: y
  });

  if (isEqual(required, origin)) {
    return null;
  }

  var limited = adjustForSizeLimits({
    container: container,
    subject: subject,
    proposedScroll: required
  });

  if (!limited) {
    return null;
  }

  return isEqual(limited, origin) ? null : limited;
});

var smallestSigned = apply(function (value) {
  if (value === 0) {
    return 0;
  }

  return value > 0 ? 1 : -1;
});
var getOverlap = function () {
  var getRemainder = function getRemainder(target, max) {
    if (target < 0) {
      return target;
    }

    if (target > max) {
      return target - max;
    }

    return 0;
  };

  return function (_ref) {
    var current = _ref.current,
        max = _ref.max,
        change = _ref.change;
    var targetScroll = add(current, change);
    var overlap = {
      x: getRemainder(targetScroll.x, max.x),
      y: getRemainder(targetScroll.y, max.y)
    };

    if (isEqual(overlap, origin)) {
      return null;
    }

    return overlap;
  };
}();
var canPartiallyScroll = function canPartiallyScroll(_ref2) {
  var rawMax = _ref2.max,
      current = _ref2.current,
      change = _ref2.change;
  var max = {
    x: Math.max(current.x, rawMax.x),
    y: Math.max(current.y, rawMax.y)
  };
  var smallestChange = smallestSigned(change);
  var overlap = getOverlap({
    max: max,
    current: current,
    change: smallestChange
  });

  if (!overlap) {
    return true;
  }

  if (smallestChange.x !== 0 && overlap.x === 0) {
    return true;
  }

  if (smallestChange.y !== 0 && overlap.y === 0) {
    return true;
  }

  return false;
};
var canScrollWindow = function canScrollWindow(viewport, change) {
  return canPartiallyScroll({
    current: viewport.scroll.current,
    max: viewport.scroll.max,
    change: change
  });
};
var getWindowOverlap = function getWindowOverlap(viewport, change) {
  if (!canScrollWindow(viewport, change)) {
    return null;
  }

  var max = viewport.scroll.max;
  var current = viewport.scroll.current;
  return getOverlap({
    current: current,
    max: max,
    change: change
  });
};
var canScrollDroppable = function canScrollDroppable(droppable, change) {
  var frame = droppable.frame;

  if (!frame) {
    return false;
  }

  return canPartiallyScroll({
    current: frame.scroll.current,
    max: frame.scroll.max,
    change: change
  });
};
var getDroppableOverlap = function getDroppableOverlap(droppable, change) {
  var frame = droppable.frame;

  if (!frame) {
    return null;
  }

  if (!canScrollDroppable(droppable, change)) {
    return null;
  }

  return getOverlap({
    current: frame.scroll.current,
    max: frame.scroll.max,
    change: change
  });
};

var getWindowScrollChange = (function (_ref) {
  var viewport = _ref.viewport,
      subject = _ref.subject,
      center = _ref.center,
      dragStartTime = _ref.dragStartTime,
      shouldUseTimeDampening = _ref.shouldUseTimeDampening;
  var scroll = getScroll({
    dragStartTime: dragStartTime,
    container: viewport.frame,
    subject: subject,
    center: center,
    shouldUseTimeDampening: shouldUseTimeDampening
  });
  return scroll && canScrollWindow(viewport, scroll) ? scroll : null;
});

var getDroppableScrollChange = (function (_ref) {
  var droppable = _ref.droppable,
      subject = _ref.subject,
      center = _ref.center,
      dragStartTime = _ref.dragStartTime,
      shouldUseTimeDampening = _ref.shouldUseTimeDampening;
  var frame = droppable.frame;

  if (!frame) {
    return null;
  }

  var scroll = getScroll({
    dragStartTime: dragStartTime,
    container: frame.pageMarginBox,
    subject: subject,
    center: center,
    shouldUseTimeDampening: shouldUseTimeDampening
  });
  return scroll && canScrollDroppable(droppable, scroll) ? scroll : null;
});

var scroll$1 = (function (_ref) {
  var state = _ref.state,
      dragStartTime = _ref.dragStartTime,
      shouldUseTimeDampening = _ref.shouldUseTimeDampening,
      scrollWindow = _ref.scrollWindow,
      scrollDroppable = _ref.scrollDroppable;
  var center = state.current.page.borderBoxCenter;
  var draggable = state.dimensions.draggables[state.critical.draggable.id];
  var subject = draggable.page.marginBox;

  if (state.isWindowScrollAllowed) {
    var viewport = state.viewport;

    var _change = getWindowScrollChange({
      dragStartTime: dragStartTime,
      viewport: viewport,
      subject: subject,
      center: center,
      shouldUseTimeDampening: shouldUseTimeDampening
    });

    if (_change) {
      scrollWindow(_change);
      return;
    }
  }

  var droppable = getBestScrollableDroppable({
    center: center,
    destination: whatIsDraggedOver(state.impact),
    droppables: state.dimensions.droppables
  });

  if (!droppable) {
    return;
  }

  var change = getDroppableScrollChange({
    dragStartTime: dragStartTime,
    droppable: droppable,
    subject: subject,
    center: center,
    shouldUseTimeDampening: shouldUseTimeDampening
  });

  if (change) {
    scrollDroppable(droppable.descriptor.id, change);
  }
});

var createFluidScroller = (function (_ref) {
  var scrollWindow = _ref.scrollWindow,
      scrollDroppable = _ref.scrollDroppable;
  var scheduleWindowScroll = rafSchd(scrollWindow);
  var scheduleDroppableScroll = rafSchd(scrollDroppable);
  var dragging = null;

  var tryScroll = function tryScroll(state) {
    !dragging ?  false ? 0 : invariant(false) : void 0;
    var _dragging = dragging,
        shouldUseTimeDampening = _dragging.shouldUseTimeDampening,
        dragStartTime = _dragging.dragStartTime;
    scroll$1({
      state: state,
      scrollWindow: scheduleWindowScroll,
      scrollDroppable: scheduleDroppableScroll,
      dragStartTime: dragStartTime,
      shouldUseTimeDampening: shouldUseTimeDampening
    });
  };

  var start$1 = function start$1(state) {
    start();
    !!dragging ?  false ? 0 : invariant(false) : void 0;
    var dragStartTime = Date.now();
    var wasScrollNeeded = false;

    var fakeScrollCallback = function fakeScrollCallback() {
      wasScrollNeeded = true;
    };

    scroll$1({
      state: state,
      dragStartTime: 0,
      shouldUseTimeDampening: false,
      scrollWindow: fakeScrollCallback,
      scrollDroppable: fakeScrollCallback
    });
    dragging = {
      dragStartTime: dragStartTime,
      shouldUseTimeDampening: wasScrollNeeded
    };
    finish();

    if (wasScrollNeeded) {
      tryScroll(state);
    }
  };

  var stop = function stop() {
    if (!dragging) {
      return;
    }

    scheduleWindowScroll.cancel();
    scheduleDroppableScroll.cancel();
    dragging = null;
  };

  return {
    start: start$1,
    stop: stop,
    scroll: tryScroll
  };
});

var createJumpScroller = (function (_ref) {
  var move = _ref.move,
      scrollDroppable = _ref.scrollDroppable,
      scrollWindow = _ref.scrollWindow;

  var moveByOffset = function moveByOffset(state, offset) {
    var client = add(state.current.client.selection, offset);
    move({
      client: client
    });
  };

  var scrollDroppableAsMuchAsItCan = function scrollDroppableAsMuchAsItCan(droppable, change) {
    if (!canScrollDroppable(droppable, change)) {
      return change;
    }

    var overlap = getDroppableOverlap(droppable, change);

    if (!overlap) {
      scrollDroppable(droppable.descriptor.id, change);
      return null;
    }

    var whatTheDroppableCanScroll = subtract(change, overlap);
    scrollDroppable(droppable.descriptor.id, whatTheDroppableCanScroll);
    var remainder = subtract(change, whatTheDroppableCanScroll);
    return remainder;
  };

  var scrollWindowAsMuchAsItCan = function scrollWindowAsMuchAsItCan(isWindowScrollAllowed, viewport, change) {
    if (!isWindowScrollAllowed) {
      return change;
    }

    if (!canScrollWindow(viewport, change)) {
      return change;
    }

    var overlap = getWindowOverlap(viewport, change);

    if (!overlap) {
      scrollWindow(change);
      return null;
    }

    var whatTheWindowCanScroll = subtract(change, overlap);
    scrollWindow(whatTheWindowCanScroll);
    var remainder = subtract(change, whatTheWindowCanScroll);
    return remainder;
  };

  var jumpScroller = function jumpScroller(state) {
    var request = state.scrollJumpRequest;

    if (!request) {
      return;
    }

    var destination = whatIsDraggedOver(state.impact);
    !destination ?  false ? 0 : invariant(false) : void 0;
    var droppableRemainder = scrollDroppableAsMuchAsItCan(state.dimensions.droppables[destination], request);

    if (!droppableRemainder) {
      return;
    }

    var viewport = state.viewport;
    var windowRemainder = scrollWindowAsMuchAsItCan(state.isWindowScrollAllowed, viewport, droppableRemainder);

    if (!windowRemainder) {
      return;
    }

    moveByOffset(state, windowRemainder);
  };

  return jumpScroller;
});

var createAutoScroller = (function (_ref) {
  var scrollDroppable = _ref.scrollDroppable,
      scrollWindow = _ref.scrollWindow,
      move = _ref.move;
  var fluidScroller = createFluidScroller({
    scrollWindow: scrollWindow,
    scrollDroppable: scrollDroppable
  });
  var jumpScroll = createJumpScroller({
    move: move,
    scrollWindow: scrollWindow,
    scrollDroppable: scrollDroppable
  });

  var scroll = function scroll(state) {
    if (state.phase !== 'DRAGGING') {
      return;
    }

    if (state.movementMode === 'FLUID') {
      fluidScroller.scroll(state);
      return;
    }

    if (!state.scrollJumpRequest) {
      return;
    }

    jumpScroll(state);
  };

  var scroller = {
    scroll: scroll,
    start: fluidScroller.start,
    stop: fluidScroller.stop
  };
  return scroller;
});

var prefix$1 = 'data-rbd';
var dragHandle = function () {
  var base = prefix$1 + "-drag-handle";
  return {
    base: base,
    draggableId: base + "-draggable-id",
    contextId: base + "-context-id"
  };
}();
var draggable = function () {
  var base = prefix$1 + "-draggable";
  return {
    base: base,
    contextId: base + "-context-id",
    id: base + "-id"
  };
}();
var droppable = function () {
  var base = prefix$1 + "-droppable";
  return {
    base: base,
    contextId: base + "-context-id",
    id: base + "-id"
  };
}();
var scrollContainer = {
  contextId: prefix$1 + "-scroll-container-context-id"
};

var makeGetSelector = function makeGetSelector(context) {
  return function (attribute) {
    return "[" + attribute + "=\"" + context + "\"]";
  };
};

var getStyles = function getStyles(rules, property) {
  return rules.map(function (rule) {
    var value = rule.styles[property];

    if (!value) {
      return '';
    }

    return rule.selector + " { " + value + " }";
  }).join(' ');
};

var noPointerEvents = 'pointer-events: none;';
var getStyles$1 = (function (contextId) {
  var getSelector = makeGetSelector(contextId);

  var dragHandle$1 = function () {
    var grabCursor = "\n      cursor: -webkit-grab;\n      cursor: grab;\n    ";
    return {
      selector: getSelector(dragHandle.contextId),
      styles: {
        always: "\n          -webkit-touch-callout: none;\n          -webkit-tap-highlight-color: rgba(0,0,0,0);\n          touch-action: manipulation;\n        ",
        resting: grabCursor,
        dragging: noPointerEvents,
        dropAnimating: grabCursor
      }
    };
  }();

  var draggable$1 = function () {
    var transition = "\n      transition: " + transitions.outOfTheWay + ";\n    ";
    return {
      selector: getSelector(draggable.contextId),
      styles: {
        dragging: transition,
        dropAnimating: transition,
        userCancel: transition
      }
    };
  }();

  var droppable$1 = {
    selector: getSelector(droppable.contextId),
    styles: {
      always: "overflow-anchor: none;"
    }
  };
  var body = {
    selector: 'body',
    styles: {
      dragging: "\n        cursor: grabbing;\n        cursor: -webkit-grabbing;\n        user-select: none;\n        -webkit-user-select: none;\n        -moz-user-select: none;\n        -ms-user-select: none;\n        overflow-anchor: none;\n      "
    }
  };
  var rules = [draggable$1, dragHandle$1, droppable$1, body];
  return {
    always: getStyles(rules, 'always'),
    resting: getStyles(rules, 'resting'),
    dragging: getStyles(rules, 'dragging'),
    dropAnimating: getStyles(rules, 'dropAnimating'),
    userCancel: getStyles(rules, 'userCancel')
  };
});

var useIsomorphicLayoutEffect = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined' ? React.useLayoutEffect : React.useEffect;

var getHead = function getHead() {
  var head = document.querySelector('head');
  !head ?  false ? 0 : invariant(false) : void 0;
  return head;
};

var createStyleEl = function createStyleEl(nonce) {
  var el = document.createElement('style');

  if (nonce) {
    el.setAttribute('nonce', nonce);
  }

  el.type = 'text/css';
  return el;
};

function useStyleMarshal(contextId, nonce) {
  var styles = useMemoOne.useMemo(function () {
    return getStyles$1(contextId);
  }, [contextId]);
  var alwaysRef = React.useRef(null);
  var dynamicRef = React.useRef(null);
  var setDynamicStyle = useMemoOne.useCallback(memoizeOne(function (proposed) {
    var el = dynamicRef.current;
    !el ?  false ? 0 : invariant(false) : void 0;
    el.textContent = proposed;
  }), []);
  var setAlwaysStyle = useMemoOne.useCallback(function (proposed) {
    var el = alwaysRef.current;
    !el ?  false ? 0 : invariant(false) : void 0;
    el.textContent = proposed;
  }, []);
  useIsomorphicLayoutEffect(function () {
    !(!alwaysRef.current && !dynamicRef.current) ?  false ? 0 : invariant(false) : void 0;
    var always = createStyleEl(nonce);
    var dynamic = createStyleEl(nonce);
    alwaysRef.current = always;
    dynamicRef.current = dynamic;
    always.setAttribute(prefix$1 + "-always", contextId);
    dynamic.setAttribute(prefix$1 + "-dynamic", contextId);
    getHead().appendChild(always);
    getHead().appendChild(dynamic);
    setAlwaysStyle(styles.always);
    setDynamicStyle(styles.resting);
    return function () {
      var remove = function remove(ref) {
        var current = ref.current;
        !current ?  false ? 0 : invariant(false) : void 0;
        getHead().removeChild(current);
        ref.current = null;
      };

      remove(alwaysRef);
      remove(dynamicRef);
    };
  }, [nonce, setAlwaysStyle, setDynamicStyle, styles.always, styles.resting, contextId]);
  var dragging = useMemoOne.useCallback(function () {
    return setDynamicStyle(styles.dragging);
  }, [setDynamicStyle, styles.dragging]);
  var dropping = useMemoOne.useCallback(function (reason) {
    if (reason === 'DROP') {
      setDynamicStyle(styles.dropAnimating);
      return;
    }

    setDynamicStyle(styles.userCancel);
  }, [setDynamicStyle, styles.dropAnimating, styles.userCancel]);
  var resting = useMemoOne.useCallback(function () {
    if (!dynamicRef.current) {
      return;
    }

    setDynamicStyle(styles.resting);
  }, [setDynamicStyle, styles.resting]);
  var marshal = useMemoOne.useMemo(function () {
    return {
      dragging: dragging,
      dropping: dropping,
      resting: resting
    };
  }, [dragging, dropping, resting]);
  return marshal;
}

var getWindowFromEl = (function (el) {
  return el && el.ownerDocument ? el.ownerDocument.defaultView : window;
});

function isHtmlElement(el) {
  return el instanceof getWindowFromEl(el).HTMLElement;
}

function findDragHandle(contextId, draggableId) {
  var selector = "[" + dragHandle.contextId + "=\"" + contextId + "\"]";
  var possible = toArray(document.querySelectorAll(selector));

  if (!possible.length) {
     false ? 0 : void 0;
    return null;
  }

  var handle = find(possible, function (el) {
    return el.getAttribute(dragHandle.draggableId) === draggableId;
  });

  if (!handle) {
     false ? 0 : void 0;
    return null;
  }

  if (!isHtmlElement(handle)) {
     false ? 0 : void 0;
    return null;
  }

  return handle;
}

function useFocusMarshal(contextId) {
  var entriesRef = React.useRef({});
  var recordRef = React.useRef(null);
  var restoreFocusFrameRef = React.useRef(null);
  var isMountedRef = React.useRef(false);
  var register = useMemoOne.useCallback(function register(id, focus) {
    var entry = {
      id: id,
      focus: focus
    };
    entriesRef.current[id] = entry;
    return function unregister() {
      var entries = entriesRef.current;
      var current = entries[id];

      if (current !== entry) {
        delete entries[id];
      }
    };
  }, []);
  var tryGiveFocus = useMemoOne.useCallback(function tryGiveFocus(tryGiveFocusTo) {
    var handle = findDragHandle(contextId, tryGiveFocusTo);

    if (handle && handle !== document.activeElement) {
      handle.focus();
    }
  }, [contextId]);
  var tryShiftRecord = useMemoOne.useCallback(function tryShiftRecord(previous, redirectTo) {
    if (recordRef.current === previous) {
      recordRef.current = redirectTo;
    }
  }, []);
  var tryRestoreFocusRecorded = useMemoOne.useCallback(function tryRestoreFocusRecorded() {
    if (restoreFocusFrameRef.current) {
      return;
    }

    if (!isMountedRef.current) {
      return;
    }

    restoreFocusFrameRef.current = requestAnimationFrame(function () {
      restoreFocusFrameRef.current = null;
      var record = recordRef.current;

      if (record) {
        tryGiveFocus(record);
      }
    });
  }, [tryGiveFocus]);
  var tryRecordFocus = useMemoOne.useCallback(function tryRecordFocus(id) {
    recordRef.current = null;
    var focused = document.activeElement;

    if (!focused) {
      return;
    }

    if (focused.getAttribute(dragHandle.draggableId) !== id) {
      return;
    }

    recordRef.current = id;
  }, []);
  useIsomorphicLayoutEffect(function () {
    isMountedRef.current = true;
    return function clearFrameOnUnmount() {
      isMountedRef.current = false;
      var frameId = restoreFocusFrameRef.current;

      if (frameId) {
        cancelAnimationFrame(frameId);
      }
    };
  }, []);
  var marshal = useMemoOne.useMemo(function () {
    return {
      register: register,
      tryRecordFocus: tryRecordFocus,
      tryRestoreFocusRecorded: tryRestoreFocusRecorded,
      tryShiftRecord: tryShiftRecord
    };
  }, [register, tryRecordFocus, tryRestoreFocusRecorded, tryShiftRecord]);
  return marshal;
}

function createRegistry() {
  var entries = {
    draggables: {},
    droppables: {}
  };
  var subscribers = [];

  function subscribe(cb) {
    subscribers.push(cb);
    return function unsubscribe() {
      var index = subscribers.indexOf(cb);

      if (index === -1) {
        return;
      }

      subscribers.splice(index, 1);
    };
  }

  function notify(event) {
    if (subscribers.length) {
      subscribers.forEach(function (cb) {
        return cb(event);
      });
    }
  }

  function findDraggableById(id) {
    return entries.draggables[id] || null;
  }

  function getDraggableById(id) {
    var entry = findDraggableById(id);
    !entry ?  false ? 0 : invariant(false) : void 0;
    return entry;
  }

  var draggableAPI = {
    register: function register(entry) {
      entries.draggables[entry.descriptor.id] = entry;
      notify({
        type: 'ADDITION',
        value: entry
      });
    },
    update: function update(entry, last) {
      var current = entries.draggables[last.descriptor.id];

      if (!current) {
        return;
      }

      if (current.uniqueId !== entry.uniqueId) {
        return;
      }

      delete entries.draggables[last.descriptor.id];
      entries.draggables[entry.descriptor.id] = entry;
    },
    unregister: function unregister(entry) {
      var draggableId = entry.descriptor.id;
      var current = findDraggableById(draggableId);

      if (!current) {
        return;
      }

      if (entry.uniqueId !== current.uniqueId) {
        return;
      }

      delete entries.draggables[draggableId];
      notify({
        type: 'REMOVAL',
        value: entry
      });
    },
    getById: getDraggableById,
    findById: findDraggableById,
    exists: function exists(id) {
      return Boolean(findDraggableById(id));
    },
    getAllByType: function getAllByType(type) {
      return values(entries.draggables).filter(function (entry) {
        return entry.descriptor.type === type;
      });
    }
  };

  function findDroppableById(id) {
    return entries.droppables[id] || null;
  }

  function getDroppableById(id) {
    var entry = findDroppableById(id);
    !entry ?  false ? 0 : invariant(false) : void 0;
    return entry;
  }

  var droppableAPI = {
    register: function register(entry) {
      entries.droppables[entry.descriptor.id] = entry;
    },
    unregister: function unregister(entry) {
      var current = findDroppableById(entry.descriptor.id);

      if (!current) {
        return;
      }

      if (entry.uniqueId !== current.uniqueId) {
        return;
      }

      delete entries.droppables[entry.descriptor.id];
    },
    getById: getDroppableById,
    findById: findDroppableById,
    exists: function exists(id) {
      return Boolean(findDroppableById(id));
    },
    getAllByType: function getAllByType(type) {
      return values(entries.droppables).filter(function (entry) {
        return entry.descriptor.type === type;
      });
    }
  };

  function clean() {
    entries.draggables = {};
    entries.droppables = {};
    subscribers.length = 0;
  }

  return {
    draggable: draggableAPI,
    droppable: droppableAPI,
    subscribe: subscribe,
    clean: clean
  };
}

function useRegistry() {
  var registry = useMemoOne.useMemo(createRegistry, []);
  React.useEffect(function () {
    return function unmount() {
      requestAnimationFrame(registry.clean);
    };
  }, [registry]);
  return registry;
}

var StoreContext = React__default.createContext(null);

var getBodyElement = (function () {
  var body = document.body;
  !body ?  false ? 0 : invariant(false) : void 0;
  return body;
});

var visuallyHidden = {
  position: 'absolute',
  width: '1px',
  height: '1px',
  margin: '-1px',
  border: '0',
  padding: '0',
  overflow: 'hidden',
  clip: 'rect(0 0 0 0)',
  'clip-path': 'inset(100%)'
};

var getId = function getId(contextId) {
  return "rbd-announcement-" + contextId;
};
function useAnnouncer(contextId) {
  var id = useMemoOne.useMemo(function () {
    return getId(contextId);
  }, [contextId]);
  var ref = React.useRef(null);
  React.useEffect(function setup() {
    var el = document.createElement('div');
    ref.current = el;
    el.id = id;
    el.setAttribute('aria-live', 'assertive');
    el.setAttribute('aria-atomic', 'true');

    _extends(el.style, visuallyHidden);

    getBodyElement().appendChild(el);
    return function cleanup() {
      setTimeout(function remove() {
        var body = getBodyElement();

        if (body.contains(el)) {
          body.removeChild(el);
        }

        if (el === ref.current) {
          ref.current = null;
        }
      });
    };
  }, [id]);
  var announce = useMemoOne.useCallback(function (message) {
    var el = ref.current;

    if (el) {
      el.textContent = message;
      return;
    }

     false ? 0 : void 0;
  }, []);
  return announce;
}

var count = 0;
var defaults = {
  separator: '::'
};
function reset() {
  count = 0;
}
function useUniqueId(prefix, options) {
  if (options === void 0) {
    options = defaults;
  }

  return useMemoOne.useMemo(function () {
    return "" + prefix + options.separator + count++;
  }, [options.separator, prefix]);
}

function getElementId(_ref) {
  var contextId = _ref.contextId,
      uniqueId = _ref.uniqueId;
  return "rbd-hidden-text-" + contextId + "-" + uniqueId;
}
function useHiddenTextElement(_ref2) {
  var contextId = _ref2.contextId,
      text = _ref2.text;
  var uniqueId = useUniqueId('hidden-text', {
    separator: '-'
  });
  var id = useMemoOne.useMemo(function () {
    return getElementId({
      contextId: contextId,
      uniqueId: uniqueId
    });
  }, [uniqueId, contextId]);
  React.useEffect(function mount() {
    var el = document.createElement('div');
    el.id = id;
    el.textContent = text;
    el.style.display = 'none';
    getBodyElement().appendChild(el);
    return function unmount() {
      var body = getBodyElement();

      if (body.contains(el)) {
        body.removeChild(el);
      }
    };
  }, [id, text]);
  return id;
}

var AppContext = React__default.createContext(null);

var peerDependencies = {
	react: "^16.8.5 || ^17.0.0",
	"react-dom": "^16.8.5 || ^17.0.0"
};

var semver = /(\d+)\.(\d+)\.(\d+)/;

var getVersion = function getVersion(value) {
  var result = semver.exec(value);
  !(result != null) ?  false ? 0 : invariant(false) : void 0;
  var major = Number(result[1]);
  var minor = Number(result[2]);
  var patch = Number(result[3]);
  return {
    major: major,
    minor: minor,
    patch: patch,
    raw: value
  };
};

var isSatisfied = function isSatisfied(expected, actual) {
  if (actual.major > expected.major) {
    return true;
  }

  if (actual.major < expected.major) {
    return false;
  }

  if (actual.minor > expected.minor) {
    return true;
  }

  if (actual.minor < expected.minor) {
    return false;
  }

  return actual.patch >= expected.patch;
};

var checkReactVersion = (function (peerDepValue, actualValue) {
  var peerDep = getVersion(peerDepValue);
  var actual = getVersion(actualValue);

  if (isSatisfied(peerDep, actual)) {
    return;
  }

   false ? 0 : void 0;
});

var suffix = "\n  We expect a html5 doctype: <!doctype html>\n  This is to ensure consistent browser layout and measurement\n\n  More information: https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/guides/doctype.md\n";
var checkDoctype = (function (doc) {
  var doctype = doc.doctype;

  if (!doctype) {
     false ? 0 : void 0;
    return;
  }

  if (doctype.name.toLowerCase() !== 'html') {
     false ? 0 : void 0;
  }

  if (doctype.publicId !== '') {
     false ? 0 : void 0;
  }
});

function useDev(useHook) {
  if (false) {}
}

function useDevSetupWarning(fn, inputs) {
  useDev(function () {
    React.useEffect(function () {
      try {
        fn();
      } catch (e) {
        error("\n          A setup problem was encountered.\n\n          > " + e.message + "\n        ");
      }
    }, inputs);
  });
}

function useStartupValidation() {
  useDevSetupWarning(function () {
    checkReactVersion(peerDependencies.react, React__default.version);
    checkDoctype(document);
  }, []);
}

function usePrevious(current) {
  var ref = React.useRef(current);
  React.useEffect(function () {
    ref.current = current;
  });
  return ref;
}

function create() {
  var lock = null;

  function isClaimed() {
    return Boolean(lock);
  }

  function isActive(value) {
    return value === lock;
  }

  function claim(abandon) {
    !!lock ?  false ? 0 : invariant(false) : void 0;
    var newLock = {
      abandon: abandon
    };
    lock = newLock;
    return newLock;
  }

  function release() {
    !lock ?  false ? 0 : invariant(false) : void 0;
    lock = null;
  }

  function tryAbandon() {
    if (lock) {
      lock.abandon();
      release();
    }
  }

  return {
    isClaimed: isClaimed,
    isActive: isActive,
    claim: claim,
    release: release,
    tryAbandon: tryAbandon
  };
}

var tab = 9;
var enter = 13;
var escape = 27;
var space = 32;
var pageUp = 33;
var pageDown = 34;
var end = 35;
var home = 36;
var arrowLeft = 37;
var arrowUp = 38;
var arrowRight = 39;
var arrowDown = 40;

var _preventedKeys;
var preventedKeys = (_preventedKeys = {}, _preventedKeys[enter] = true, _preventedKeys[tab] = true, _preventedKeys);
var preventStandardKeyEvents = (function (event) {
  if (preventedKeys[event.keyCode]) {
    event.preventDefault();
  }
});

var supportedEventName = function () {
  var base = 'visibilitychange';

  if (typeof document === 'undefined') {
    return base;
  }

  var candidates = [base, "ms" + base, "webkit" + base, "moz" + base, "o" + base];
  var supported = find(candidates, function (eventName) {
    return "on" + eventName in document;
  });
  return supported || base;
}();

var primaryButton = 0;
var sloppyClickThreshold = 5;

function isSloppyClickThresholdExceeded(original, current) {
  return Math.abs(current.x - original.x) >= sloppyClickThreshold || Math.abs(current.y - original.y) >= sloppyClickThreshold;
}

var idle$1 = {
  type: 'IDLE'
};

function getCaptureBindings(_ref) {
  var cancel = _ref.cancel,
      completed = _ref.completed,
      getPhase = _ref.getPhase,
      setPhase = _ref.setPhase;
  return [{
    eventName: 'mousemove',
    fn: function fn(event) {
      var button = event.button,
          clientX = event.clientX,
          clientY = event.clientY;

      if (button !== primaryButton) {
        return;
      }

      var point = {
        x: clientX,
        y: clientY
      };
      var phase = getPhase();

      if (phase.type === 'DRAGGING') {
        event.preventDefault();
        phase.actions.move(point);
        return;
      }

      !(phase.type === 'PENDING') ?  false ? 0 : invariant(false) : void 0;
      var pending = phase.point;

      if (!isSloppyClickThresholdExceeded(pending, point)) {
        return;
      }

      event.preventDefault();
      var actions = phase.actions.fluidLift(point);
      setPhase({
        type: 'DRAGGING',
        actions: actions
      });
    }
  }, {
    eventName: 'mouseup',
    fn: function fn(event) {
      var phase = getPhase();

      if (phase.type !== 'DRAGGING') {
        cancel();
        return;
      }

      event.preventDefault();
      phase.actions.drop({
        shouldBlockNextClick: true
      });
      completed();
    }
  }, {
    eventName: 'mousedown',
    fn: function fn(event) {
      if (getPhase().type === 'DRAGGING') {
        event.preventDefault();
      }

      cancel();
    }
  }, {
    eventName: 'keydown',
    fn: function fn(event) {
      var phase = getPhase();

      if (phase.type === 'PENDING') {
        cancel();
        return;
      }

      if (event.keyCode === escape) {
        event.preventDefault();
        cancel();
        return;
      }

      preventStandardKeyEvents(event);
    }
  }, {
    eventName: 'resize',
    fn: cancel
  }, {
    eventName: 'scroll',
    options: {
      passive: true,
      capture: false
    },
    fn: function fn() {
      if (getPhase().type === 'PENDING') {
        cancel();
      }
    }
  }, {
    eventName: 'webkitmouseforcedown',
    fn: function fn(event) {
      var phase = getPhase();
      !(phase.type !== 'IDLE') ?  false ? 0 : invariant(false) : void 0;

      if (phase.actions.shouldRespectForcePress()) {
        cancel();
        return;
      }

      event.preventDefault();
    }
  }, {
    eventName: supportedEventName,
    fn: cancel
  }];
}

function useMouseSensor(api) {
  var phaseRef = React.useRef(idle$1);
  var unbindEventsRef = React.useRef(noop);
  var startCaptureBinding = useMemoOne.useMemo(function () {
    return {
      eventName: 'mousedown',
      fn: function onMouseDown(event) {
        if (event.defaultPrevented) {
          return;
        }

        if (event.button !== primaryButton) {
          return;
        }

        if (event.ctrlKey || event.metaKey || event.shiftKey || event.altKey) {
          return;
        }

        var draggableId = api.findClosestDraggableId(event);

        if (!draggableId) {
          return;
        }

        var actions = api.tryGetLock(draggableId, stop, {
          sourceEvent: event
        });

        if (!actions) {
          return;
        }

        event.preventDefault();
        var point = {
          x: event.clientX,
          y: event.clientY
        };
        unbindEventsRef.current();
        startPendingDrag(actions, point);
      }
    };
  }, [api]);
  var preventForcePressBinding = useMemoOne.useMemo(function () {
    return {
      eventName: 'webkitmouseforcewillbegin',
      fn: function fn(event) {
        if (event.defaultPrevented) {
          return;
        }

        var id = api.findClosestDraggableId(event);

        if (!id) {
          return;
        }

        var options = api.findOptionsForDraggable(id);

        if (!options) {
          return;
        }

        if (options.shouldRespectForcePress) {
          return;
        }

        if (!api.canGetLock(id)) {
          return;
        }

        event.preventDefault();
      }
    };
  }, [api]);
  var listenForCapture = useMemoOne.useCallback(function listenForCapture() {
    var options = {
      passive: false,
      capture: true
    };
    unbindEventsRef.current = bindEvents(window, [preventForcePressBinding, startCaptureBinding], options);
  }, [preventForcePressBinding, startCaptureBinding]);
  var stop = useMemoOne.useCallback(function () {
    var current = phaseRef.current;

    if (current.type === 'IDLE') {
      return;
    }

    phaseRef.current = idle$1;
    unbindEventsRef.current();
    listenForCapture();
  }, [listenForCapture]);
  var cancel = useMemoOne.useCallback(function () {
    var phase = phaseRef.current;
    stop();

    if (phase.type === 'DRAGGING') {
      phase.actions.cancel({
        shouldBlockNextClick: true
      });
    }

    if (phase.type === 'PENDING') {
      phase.actions.abort();
    }
  }, [stop]);
  var bindCapturingEvents = useMemoOne.useCallback(function bindCapturingEvents() {
    var options = {
      capture: true,
      passive: false
    };
    var bindings = getCaptureBindings({
      cancel: cancel,
      completed: stop,
      getPhase: function getPhase() {
        return phaseRef.current;
      },
      setPhase: function setPhase(phase) {
        phaseRef.current = phase;
      }
    });
    unbindEventsRef.current = bindEvents(window, bindings, options);
  }, [cancel, stop]);
  var startPendingDrag = useMemoOne.useCallback(function startPendingDrag(actions, point) {
    !(phaseRef.current.type === 'IDLE') ?  false ? 0 : invariant(false) : void 0;
    phaseRef.current = {
      type: 'PENDING',
      point: point,
      actions: actions
    };
    bindCapturingEvents();
  }, [bindCapturingEvents]);
  useIsomorphicLayoutEffect(function mount() {
    listenForCapture();
    return function unmount() {
      unbindEventsRef.current();
    };
  }, [listenForCapture]);
}

var _scrollJumpKeys;

function noop$1() {}

var scrollJumpKeys = (_scrollJumpKeys = {}, _scrollJumpKeys[pageDown] = true, _scrollJumpKeys[pageUp] = true, _scrollJumpKeys[home] = true, _scrollJumpKeys[end] = true, _scrollJumpKeys);

function getDraggingBindings(actions, stop) {
  function cancel() {
    stop();
    actions.cancel();
  }

  function drop() {
    stop();
    actions.drop();
  }

  return [{
    eventName: 'keydown',
    fn: function fn(event) {
      if (event.keyCode === escape) {
        event.preventDefault();
        cancel();
        return;
      }

      if (event.keyCode === space) {
        event.preventDefault();
        drop();
        return;
      }

      if (event.keyCode === arrowDown) {
        event.preventDefault();
        actions.moveDown();
        return;
      }

      if (event.keyCode === arrowUp) {
        event.preventDefault();
        actions.moveUp();
        return;
      }

      if (event.keyCode === arrowRight) {
        event.preventDefault();
        actions.moveRight();
        return;
      }

      if (event.keyCode === arrowLeft) {
        event.preventDefault();
        actions.moveLeft();
        return;
      }

      if (scrollJumpKeys[event.keyCode]) {
        event.preventDefault();
        return;
      }

      preventStandardKeyEvents(event);
    }
  }, {
    eventName: 'mousedown',
    fn: cancel
  }, {
    eventName: 'mouseup',
    fn: cancel
  }, {
    eventName: 'click',
    fn: cancel
  }, {
    eventName: 'touchstart',
    fn: cancel
  }, {
    eventName: 'resize',
    fn: cancel
  }, {
    eventName: 'wheel',
    fn: cancel,
    options: {
      passive: true
    }
  }, {
    eventName: supportedEventName,
    fn: cancel
  }];
}

function useKeyboardSensor(api) {
  var unbindEventsRef = React.useRef(noop$1);
  var startCaptureBinding = useMemoOne.useMemo(function () {
    return {
      eventName: 'keydown',
      fn: function onKeyDown(event) {
        if (event.defaultPrevented) {
          return;
        }

        if (event.keyCode !== space) {
          return;
        }

        var draggableId = api.findClosestDraggableId(event);

        if (!draggableId) {
          return;
        }

        var preDrag = api.tryGetLock(draggableId, stop, {
          sourceEvent: event
        });

        if (!preDrag) {
          return;
        }

        event.preventDefault();
        var isCapturing = true;
        var actions = preDrag.snapLift();
        unbindEventsRef.current();

        function stop() {
          !isCapturing ?  false ? 0 : invariant(false) : void 0;
          isCapturing = false;
          unbindEventsRef.current();
          listenForCapture();
        }

        unbindEventsRef.current = bindEvents(window, getDraggingBindings(actions, stop), {
          capture: true,
          passive: false
        });
      }
    };
  }, [api]);
  var listenForCapture = useMemoOne.useCallback(function tryStartCapture() {
    var options = {
      passive: false,
      capture: true
    };
    unbindEventsRef.current = bindEvents(window, [startCaptureBinding], options);
  }, [startCaptureBinding]);
  useIsomorphicLayoutEffect(function mount() {
    listenForCapture();
    return function unmount() {
      unbindEventsRef.current();
    };
  }, [listenForCapture]);
}

var idle$2 = {
  type: 'IDLE'
};
var timeForLongPress = 120;
var forcePressThreshold = 0.15;

function getWindowBindings(_ref) {
  var cancel = _ref.cancel,
      getPhase = _ref.getPhase;
  return [{
    eventName: 'orientationchange',
    fn: cancel
  }, {
    eventName: 'resize',
    fn: cancel
  }, {
    eventName: 'contextmenu',
    fn: function fn(event) {
      event.preventDefault();
    }
  }, {
    eventName: 'keydown',
    fn: function fn(event) {
      if (getPhase().type !== 'DRAGGING') {
        cancel();
        return;
      }

      if (event.keyCode === escape) {
        event.preventDefault();
      }

      cancel();
    }
  }, {
    eventName: supportedEventName,
    fn: cancel
  }];
}

function getHandleBindings(_ref2) {
  var cancel = _ref2.cancel,
      completed = _ref2.completed,
      getPhase = _ref2.getPhase;
  return [{
    eventName: 'touchmove',
    options: {
      capture: false
    },
    fn: function fn(event) {
      var phase = getPhase();

      if (phase.type !== 'DRAGGING') {
        cancel();
        return;
      }

      phase.hasMoved = true;
      var _event$touches$ = event.touches[0],
          clientX = _event$touches$.clientX,
          clientY = _event$touches$.clientY;
      var point = {
        x: clientX,
        y: clientY
      };
      event.preventDefault();
      phase.actions.move(point);
    }
  }, {
    eventName: 'touchend',
    fn: function fn(event) {
      var phase = getPhase();

      if (phase.type !== 'DRAGGING') {
        cancel();
        return;
      }

      event.preventDefault();
      phase.actions.drop({
        shouldBlockNextClick: true
      });
      completed();
    }
  }, {
    eventName: 'touchcancel',
    fn: function fn(event) {
      if (getPhase().type !== 'DRAGGING') {
        cancel();
        return;
      }

      event.preventDefault();
      cancel();
    }
  }, {
    eventName: 'touchforcechange',
    fn: function fn(event) {
      var phase = getPhase();
      !(phase.type !== 'IDLE') ?  false ? 0 : invariant(false) : void 0;
      var touch = event.touches[0];

      if (!touch) {
        return;
      }

      var isForcePress = touch.force >= forcePressThreshold;

      if (!isForcePress) {
        return;
      }

      var shouldRespect = phase.actions.shouldRespectForcePress();

      if (phase.type === 'PENDING') {
        if (shouldRespect) {
          cancel();
        }

        return;
      }

      if (shouldRespect) {
        if (phase.hasMoved) {
          event.preventDefault();
          return;
        }

        cancel();
        return;
      }

      event.preventDefault();
    }
  }, {
    eventName: supportedEventName,
    fn: cancel
  }];
}

function useTouchSensor(api) {
  var phaseRef = React.useRef(idle$2);
  var unbindEventsRef = React.useRef(noop);
  var getPhase = useMemoOne.useCallback(function getPhase() {
    return phaseRef.current;
  }, []);
  var setPhase = useMemoOne.useCallback(function setPhase(phase) {
    phaseRef.current = phase;
  }, []);
  var startCaptureBinding = useMemoOne.useMemo(function () {
    return {
      eventName: 'touchstart',
      fn: function onTouchStart(event) {
        if (event.defaultPrevented) {
          return;
        }

        var draggableId = api.findClosestDraggableId(event);

        if (!draggableId) {
          return;
        }

        var actions = api.tryGetLock(draggableId, stop, {
          sourceEvent: event
        });

        if (!actions) {
          return;
        }

        var touch = event.touches[0];
        var clientX = touch.clientX,
            clientY = touch.clientY;
        var point = {
          x: clientX,
          y: clientY
        };
        unbindEventsRef.current();
        startPendingDrag(actions, point);
      }
    };
  }, [api]);
  var listenForCapture = useMemoOne.useCallback(function listenForCapture() {
    var options = {
      capture: true,
      passive: false
    };
    unbindEventsRef.current = bindEvents(window, [startCaptureBinding], options);
  }, [startCaptureBinding]);
  var stop = useMemoOne.useCallback(function () {
    var current = phaseRef.current;

    if (current.type === 'IDLE') {
      return;
    }

    if (current.type === 'PENDING') {
      clearTimeout(current.longPressTimerId);
    }

    setPhase(idle$2);
    unbindEventsRef.current();
    listenForCapture();
  }, [listenForCapture, setPhase]);
  var cancel = useMemoOne.useCallback(function () {
    var phase = phaseRef.current;
    stop();

    if (phase.type === 'DRAGGING') {
      phase.actions.cancel({
        shouldBlockNextClick: true
      });
    }

    if (phase.type === 'PENDING') {
      phase.actions.abort();
    }
  }, [stop]);
  var bindCapturingEvents = useMemoOne.useCallback(function bindCapturingEvents() {
    var options = {
      capture: true,
      passive: false
    };
    var args = {
      cancel: cancel,
      completed: stop,
      getPhase: getPhase
    };
    var unbindTarget = bindEvents(window, getHandleBindings(args), options);
    var unbindWindow = bindEvents(window, getWindowBindings(args), options);

    unbindEventsRef.current = function unbindAll() {
      unbindTarget();
      unbindWindow();
    };
  }, [cancel, getPhase, stop]);
  var startDragging = useMemoOne.useCallback(function startDragging() {
    var phase = getPhase();
    !(phase.type === 'PENDING') ?  false ? 0 : invariant(false) : void 0;
    var actions = phase.actions.fluidLift(phase.point);
    setPhase({
      type: 'DRAGGING',
      actions: actions,
      hasMoved: false
    });
  }, [getPhase, setPhase]);
  var startPendingDrag = useMemoOne.useCallback(function startPendingDrag(actions, point) {
    !(getPhase().type === 'IDLE') ?  false ? 0 : invariant(false) : void 0;
    var longPressTimerId = setTimeout(startDragging, timeForLongPress);
    setPhase({
      type: 'PENDING',
      point: point,
      actions: actions,
      longPressTimerId: longPressTimerId
    });
    bindCapturingEvents();
  }, [bindCapturingEvents, getPhase, setPhase, startDragging]);
  useIsomorphicLayoutEffect(function mount() {
    listenForCapture();
    return function unmount() {
      unbindEventsRef.current();
      var phase = getPhase();

      if (phase.type === 'PENDING') {
        clearTimeout(phase.longPressTimerId);
        setPhase(idle$2);
      }
    };
  }, [getPhase, listenForCapture, setPhase]);
  useIsomorphicLayoutEffect(function webkitHack() {
    var unbind = bindEvents(window, [{
      eventName: 'touchmove',
      fn: function fn() {},
      options: {
        capture: false,
        passive: false
      }
    }]);
    return unbind;
  }, []);
}

function useValidateSensorHooks(sensorHooks) {
  useDev(function () {
    var previousRef = usePrevious(sensorHooks);
    useDevSetupWarning(function () {
      !(previousRef.current.length === sensorHooks.length) ?  false ? 0 : invariant(false) : void 0;
    });
  });
}

var interactiveTagNames = {
  input: true,
  button: true,
  textarea: true,
  select: true,
  option: true,
  optgroup: true,
  video: true,
  audio: true
};

function isAnInteractiveElement(parent, current) {
  if (current == null) {
    return false;
  }

  var hasAnInteractiveTag = Boolean(interactiveTagNames[current.tagName.toLowerCase()]);

  if (hasAnInteractiveTag) {
    return true;
  }

  var attribute = current.getAttribute('contenteditable');

  if (attribute === 'true' || attribute === '') {
    return true;
  }

  if (current === parent) {
    return false;
  }

  return isAnInteractiveElement(parent, current.parentElement);
}

function isEventInInteractiveElement(draggable, event) {
  var target = event.target;

  if (!isHtmlElement(target)) {
    return false;
  }

  return isAnInteractiveElement(draggable, target);
}

var getBorderBoxCenterPosition = (function (el) {
  return cssBoxModel.getRect(el.getBoundingClientRect()).center;
});

function isElement(el) {
  return el instanceof getWindowFromEl(el).Element;
}

var supportedMatchesName = function () {
  var base = 'matches';

  if (typeof document === 'undefined') {
    return base;
  }

  var candidates = [base, 'msMatchesSelector', 'webkitMatchesSelector'];
  var value = find(candidates, function (name) {
    return name in Element.prototype;
  });
  return value || base;
}();

function closestPonyfill(el, selector) {
  if (el == null) {
    return null;
  }

  if (el[supportedMatchesName](selector)) {
    return el;
  }

  return closestPonyfill(el.parentElement, selector);
}

function closest$1(el, selector) {
  if (el.closest) {
    return el.closest(selector);
  }

  return closestPonyfill(el, selector);
}

function getSelector(contextId) {
  return "[" + dragHandle.contextId + "=\"" + contextId + "\"]";
}

function findClosestDragHandleFromEvent(contextId, event) {
  var target = event.target;

  if (!isElement(target)) {
     false ? 0 : void 0;
    return null;
  }

  var selector = getSelector(contextId);
  var handle = closest$1(target, selector);

  if (!handle) {
    return null;
  }

  if (!isHtmlElement(handle)) {
     false ? 0 : void 0;
    return null;
  }

  return handle;
}

function tryGetClosestDraggableIdFromEvent(contextId, event) {
  var handle = findClosestDragHandleFromEvent(contextId, event);

  if (!handle) {
    return null;
  }

  return handle.getAttribute(dragHandle.draggableId);
}

function findDraggable(contextId, draggableId) {
  var selector = "[" + draggable.contextId + "=\"" + contextId + "\"]";
  var possible = toArray(document.querySelectorAll(selector));
  var draggable$1 = find(possible, function (el) {
    return el.getAttribute(draggable.id) === draggableId;
  });

  if (!draggable$1) {
    return null;
  }

  if (!isHtmlElement(draggable$1)) {
     false ? 0 : void 0;
    return null;
  }

  return draggable$1;
}

function preventDefault(event) {
  event.preventDefault();
}

function _isActive(_ref) {
  var expected = _ref.expected,
      phase = _ref.phase,
      isLockActive = _ref.isLockActive,
      shouldWarn = _ref.shouldWarn;

  if (!isLockActive()) {
    if (shouldWarn) {
       false ? 0 : void 0;
    }

    return false;
  }

  if (expected !== phase) {
    if (shouldWarn) {
       false ? 0 : void 0;
    }

    return false;
  }

  return true;
}

function canStart(_ref2) {
  var lockAPI = _ref2.lockAPI,
      store = _ref2.store,
      registry = _ref2.registry,
      draggableId = _ref2.draggableId;

  if (lockAPI.isClaimed()) {
    return false;
  }

  var entry = registry.draggable.findById(draggableId);

  if (!entry) {
     false ? 0 : void 0;
    return false;
  }

  if (!entry.options.isEnabled) {
    return false;
  }

  if (!canStartDrag(store.getState(), draggableId)) {
    return false;
  }

  return true;
}

function tryStart(_ref3) {
  var lockAPI = _ref3.lockAPI,
      contextId = _ref3.contextId,
      store = _ref3.store,
      registry = _ref3.registry,
      draggableId = _ref3.draggableId,
      forceSensorStop = _ref3.forceSensorStop,
      sourceEvent = _ref3.sourceEvent;
  var shouldStart = canStart({
    lockAPI: lockAPI,
    store: store,
    registry: registry,
    draggableId: draggableId
  });

  if (!shouldStart) {
    return null;
  }

  var entry = registry.draggable.getById(draggableId);
  var el = findDraggable(contextId, entry.descriptor.id);

  if (!el) {
     false ? 0 : void 0;
    return null;
  }

  if (sourceEvent && !entry.options.canDragInteractiveElements && isEventInInteractiveElement(el, sourceEvent)) {
    return null;
  }

  var lock = lockAPI.claim(forceSensorStop || noop);
  var phase = 'PRE_DRAG';

  function getShouldRespectForcePress() {
    return entry.options.shouldRespectForcePress;
  }

  function isLockActive() {
    return lockAPI.isActive(lock);
  }

  function tryDispatch(expected, getAction) {
    if (_isActive({
      expected: expected,
      phase: phase,
      isLockActive: isLockActive,
      shouldWarn: true
    })) {
      store.dispatch(getAction());
    }
  }

  var tryDispatchWhenDragging = tryDispatch.bind(null, 'DRAGGING');

  function lift$1(args) {
    function completed() {
      lockAPI.release();
      phase = 'COMPLETED';
    }

    if (phase !== 'PRE_DRAG') {
      completed();
      !(phase === 'PRE_DRAG') ?  false ? 0 : invariant(false) : void 0;
    }

    store.dispatch(lift(args.liftActionArgs));
    phase = 'DRAGGING';

    function finish(reason, options) {
      if (options === void 0) {
        options = {
          shouldBlockNextClick: false
        };
      }

      args.cleanup();

      if (options.shouldBlockNextClick) {
        var unbind = bindEvents(window, [{
          eventName: 'click',
          fn: preventDefault,
          options: {
            once: true,
            passive: false,
            capture: true
          }
        }]);
        setTimeout(unbind);
      }

      completed();
      store.dispatch(drop({
        reason: reason
      }));
    }

    return _extends({
      isActive: function isActive() {
        return _isActive({
          expected: 'DRAGGING',
          phase: phase,
          isLockActive: isLockActive,
          shouldWarn: false
        });
      },
      shouldRespectForcePress: getShouldRespectForcePress,
      drop: function drop(options) {
        return finish('DROP', options);
      },
      cancel: function cancel(options) {
        return finish('CANCEL', options);
      }
    }, args.actions);
  }

  function fluidLift(clientSelection) {
    var move$1 = rafSchd(function (client) {
      tryDispatchWhenDragging(function () {
        return move({
          client: client
        });
      });
    });
    var api = lift$1({
      liftActionArgs: {
        id: draggableId,
        clientSelection: clientSelection,
        movementMode: 'FLUID'
      },
      cleanup: function cleanup() {
        return move$1.cancel();
      },
      actions: {
        move: move$1
      }
    });
    return _extends({}, api, {
      move: move$1
    });
  }

  function snapLift() {
    var actions = {
      moveUp: function moveUp$1() {
        return tryDispatchWhenDragging(moveUp);
      },
      moveRight: function moveRight$1() {
        return tryDispatchWhenDragging(moveRight);
      },
      moveDown: function moveDown$1() {
        return tryDispatchWhenDragging(moveDown);
      },
      moveLeft: function moveLeft$1() {
        return tryDispatchWhenDragging(moveLeft);
      }
    };
    return lift$1({
      liftActionArgs: {
        id: draggableId,
        clientSelection: getBorderBoxCenterPosition(el),
        movementMode: 'SNAP'
      },
      cleanup: noop,
      actions: actions
    });
  }

  function abortPreDrag() {
    var shouldRelease = _isActive({
      expected: 'PRE_DRAG',
      phase: phase,
      isLockActive: isLockActive,
      shouldWarn: true
    });

    if (shouldRelease) {
      lockAPI.release();
    }
  }

  var preDrag = {
    isActive: function isActive() {
      return _isActive({
        expected: 'PRE_DRAG',
        phase: phase,
        isLockActive: isLockActive,
        shouldWarn: false
      });
    },
    shouldRespectForcePress: getShouldRespectForcePress,
    fluidLift: fluidLift,
    snapLift: snapLift,
    abort: abortPreDrag
  };
  return preDrag;
}

var defaultSensors = [useMouseSensor, useKeyboardSensor, useTouchSensor];
function useSensorMarshal(_ref4) {
  var contextId = _ref4.contextId,
      store = _ref4.store,
      registry = _ref4.registry,
      customSensors = _ref4.customSensors,
      enableDefaultSensors = _ref4.enableDefaultSensors;
  var useSensors = [].concat(enableDefaultSensors ? defaultSensors : [], customSensors || []);
  var lockAPI = React.useState(function () {
    return create();
  })[0];
  var tryAbandonLock = useMemoOne.useCallback(function tryAbandonLock(previous, current) {
    if (previous.isDragging && !current.isDragging) {
      lockAPI.tryAbandon();
    }
  }, [lockAPI]);
  useIsomorphicLayoutEffect(function listenToStore() {
    var previous = store.getState();
    var unsubscribe = store.subscribe(function () {
      var current = store.getState();
      tryAbandonLock(previous, current);
      previous = current;
    });
    return unsubscribe;
  }, [lockAPI, store, tryAbandonLock]);
  useIsomorphicLayoutEffect(function () {
    return lockAPI.tryAbandon;
  }, [lockAPI.tryAbandon]);
  var canGetLock = useMemoOne.useCallback(function (draggableId) {
    return canStart({
      lockAPI: lockAPI,
      registry: registry,
      store: store,
      draggableId: draggableId
    });
  }, [lockAPI, registry, store]);
  var tryGetLock = useMemoOne.useCallback(function (draggableId, forceStop, options) {
    return tryStart({
      lockAPI: lockAPI,
      registry: registry,
      contextId: contextId,
      store: store,
      draggableId: draggableId,
      forceSensorStop: forceStop,
      sourceEvent: options && options.sourceEvent ? options.sourceEvent : null
    });
  }, [contextId, lockAPI, registry, store]);
  var findClosestDraggableId = useMemoOne.useCallback(function (event) {
    return tryGetClosestDraggableIdFromEvent(contextId, event);
  }, [contextId]);
  var findOptionsForDraggable = useMemoOne.useCallback(function (id) {
    var entry = registry.draggable.findById(id);
    return entry ? entry.options : null;
  }, [registry.draggable]);
  var tryReleaseLock = useMemoOne.useCallback(function tryReleaseLock() {
    if (!lockAPI.isClaimed()) {
      return;
    }

    lockAPI.tryAbandon();

    if (store.getState().phase !== 'IDLE') {
      store.dispatch(flush());
    }
  }, [lockAPI, store]);
  var isLockClaimed = useMemoOne.useCallback(lockAPI.isClaimed, [lockAPI]);
  var api = useMemoOne.useMemo(function () {
    return {
      canGetLock: canGetLock,
      tryGetLock: tryGetLock,
      findClosestDraggableId: findClosestDraggableId,
      findOptionsForDraggable: findOptionsForDraggable,
      tryReleaseLock: tryReleaseLock,
      isLockClaimed: isLockClaimed
    };
  }, [canGetLock, tryGetLock, findClosestDraggableId, findOptionsForDraggable, tryReleaseLock, isLockClaimed]);
  useValidateSensorHooks(useSensors);

  for (var i = 0; i < useSensors.length; i++) {
    useSensors[i](api);
  }
}

var createResponders = function createResponders(props) {
  return {
    onBeforeCapture: props.onBeforeCapture,
    onBeforeDragStart: props.onBeforeDragStart,
    onDragStart: props.onDragStart,
    onDragEnd: props.onDragEnd,
    onDragUpdate: props.onDragUpdate
  };
};

function getStore(lazyRef) {
  !lazyRef.current ?  false ? 0 : invariant(false) : void 0;
  return lazyRef.current;
}

function App(props) {
  var contextId = props.contextId,
      setCallbacks = props.setCallbacks,
      sensors = props.sensors,
      nonce = props.nonce,
      dragHandleUsageInstructions = props.dragHandleUsageInstructions;
  var lazyStoreRef = React.useRef(null);
  useStartupValidation();
  var lastPropsRef = usePrevious(props);
  var getResponders = useMemoOne.useCallback(function () {
    return createResponders(lastPropsRef.current);
  }, [lastPropsRef]);
  var announce = useAnnouncer(contextId);
  var dragHandleUsageInstructionsId = useHiddenTextElement({
    contextId: contextId,
    text: dragHandleUsageInstructions
  });
  var styleMarshal = useStyleMarshal(contextId, nonce);
  var lazyDispatch = useMemoOne.useCallback(function (action) {
    getStore(lazyStoreRef).dispatch(action);
  }, []);
  var marshalCallbacks = useMemoOne.useMemo(function () {
    return redux.bindActionCreators({
      publishWhileDragging: publishWhileDragging,
      updateDroppableScroll: updateDroppableScroll,
      updateDroppableIsEnabled: updateDroppableIsEnabled,
      updateDroppableIsCombineEnabled: updateDroppableIsCombineEnabled,
      collectionStarting: collectionStarting
    }, lazyDispatch);
  }, [lazyDispatch]);
  var registry = useRegistry();
  var dimensionMarshal = useMemoOne.useMemo(function () {
    return createDimensionMarshal(registry, marshalCallbacks);
  }, [registry, marshalCallbacks]);
  var autoScroller = useMemoOne.useMemo(function () {
    return createAutoScroller(_extends({
      scrollWindow: scrollWindow,
      scrollDroppable: dimensionMarshal.scrollDroppable
    }, redux.bindActionCreators({
      move: move
    }, lazyDispatch)));
  }, [dimensionMarshal.scrollDroppable, lazyDispatch]);
  var focusMarshal = useFocusMarshal(contextId);
  var store = useMemoOne.useMemo(function () {
    return createStore({
      announce: announce,
      autoScroller: autoScroller,
      dimensionMarshal: dimensionMarshal,
      focusMarshal: focusMarshal,
      getResponders: getResponders,
      styleMarshal: styleMarshal
    });
  }, [announce, autoScroller, dimensionMarshal, focusMarshal, getResponders, styleMarshal]);

  if (false) {}

  lazyStoreRef.current = store;
  var tryResetStore = useMemoOne.useCallback(function () {
    var current = getStore(lazyStoreRef);
    var state = current.getState();

    if (state.phase !== 'IDLE') {
      current.dispatch(flush());
    }
  }, []);
  var isDragging = useMemoOne.useCallback(function () {
    var state = getStore(lazyStoreRef).getState();
    return state.isDragging || state.phase === 'DROP_ANIMATING';
  }, []);
  var appCallbacks = useMemoOne.useMemo(function () {
    return {
      isDragging: isDragging,
      tryAbort: tryResetStore
    };
  }, [isDragging, tryResetStore]);
  setCallbacks(appCallbacks);
  var getCanLift = useMemoOne.useCallback(function (id) {
    return canStartDrag(getStore(lazyStoreRef).getState(), id);
  }, []);
  var getIsMovementAllowed = useMemoOne.useCallback(function () {
    return isMovementAllowed(getStore(lazyStoreRef).getState());
  }, []);
  var appContext = useMemoOne.useMemo(function () {
    return {
      marshal: dimensionMarshal,
      focus: focusMarshal,
      contextId: contextId,
      canLift: getCanLift,
      isMovementAllowed: getIsMovementAllowed,
      dragHandleUsageInstructionsId: dragHandleUsageInstructionsId,
      registry: registry
    };
  }, [contextId, dimensionMarshal, dragHandleUsageInstructionsId, focusMarshal, getCanLift, getIsMovementAllowed, registry]);
  useSensorMarshal({
    contextId: contextId,
    store: store,
    registry: registry,
    customSensors: sensors,
    enableDefaultSensors: props.enableDefaultSensors !== false
  });
  React.useEffect(function () {
    return tryResetStore;
  }, [tryResetStore]);
  return React__default.createElement(AppContext.Provider, {
    value: appContext
  }, React__default.createElement(reactRedux.Provider, {
    context: StoreContext,
    store: store
  }, props.children));
}

var count$1 = 0;
function reset$1() {
  count$1 = 0;
}
function useInstanceCount() {
  return useMemoOne.useMemo(function () {
    return "" + count$1++;
  }, []);
}

function resetServerContext() {
  reset$1();
  reset();
}
function DragDropContext(props) {
  var contextId = useInstanceCount();
  var dragHandleUsageInstructions = props.dragHandleUsageInstructions || preset.dragHandleUsageInstructions;
  return React__default.createElement(ErrorBoundary, null, function (setCallbacks) {
    return React__default.createElement(App, {
      nonce: props.nonce,
      contextId: contextId,
      setCallbacks: setCallbacks,
      dragHandleUsageInstructions: dragHandleUsageInstructions,
      enableDefaultSensors: props.enableDefaultSensors,
      sensors: props.sensors,
      onBeforeCapture: props.onBeforeCapture,
      onBeforeDragStart: props.onBeforeDragStart,
      onDragStart: props.onDragStart,
      onDragUpdate: props.onDragUpdate,
      onDragEnd: props.onDragEnd
    }, props.children);
  });
}

var isEqual$1 = function isEqual(base) {
  return function (value) {
    return base === value;
  };
};

var isScroll = isEqual$1('scroll');
var isAuto = isEqual$1('auto');
var isVisible$1 = isEqual$1('visible');

var isEither = function isEither(overflow, fn) {
  return fn(overflow.overflowX) || fn(overflow.overflowY);
};

var isBoth = function isBoth(overflow, fn) {
  return fn(overflow.overflowX) && fn(overflow.overflowY);
};

var isElementScrollable = function isElementScrollable(el) {
  var style = window.getComputedStyle(el);
  var overflow = {
    overflowX: style.overflowX,
    overflowY: style.overflowY
  };
  return isEither(overflow, isScroll) || isEither(overflow, isAuto);
};

var isBodyScrollable = function isBodyScrollable() {
  if (true) {
    return false;
  }

  var body = getBodyElement();
  var html = document.documentElement;
  !html ?  false ? 0 : invariant(false) : void 0;

  if (!isElementScrollable(body)) {
    return false;
  }

  var htmlStyle = window.getComputedStyle(html);
  var htmlOverflow = {
    overflowX: htmlStyle.overflowX,
    overflowY: htmlStyle.overflowY
  };

  if (isBoth(htmlOverflow, isVisible$1)) {
    return false;
  }

   false ? 0 : void 0;
  return false;
};

var getClosestScrollable = function getClosestScrollable(el) {
  if (el == null) {
    return null;
  }

  if (el === document.body) {
    return isBodyScrollable() ? el : null;
  }

  if (el === document.documentElement) {
    return null;
  }

  if (!isElementScrollable(el)) {
    return getClosestScrollable(el.parentElement);
  }

  return el;
};

var checkForNestedScrollContainers = (function (scrollable) {
  if (!scrollable) {
    return;
  }

  var anotherScrollParent = getClosestScrollable(scrollable.parentElement);

  if (!anotherScrollParent) {
    return;
  }

   false ? 0 : void 0;
});

var getScroll$1 = (function (el) {
  return {
    x: el.scrollLeft,
    y: el.scrollTop
  };
});

var getIsFixed = function getIsFixed(el) {
  if (!el) {
    return false;
  }

  var style = window.getComputedStyle(el);

  if (style.position === 'fixed') {
    return true;
  }

  return getIsFixed(el.parentElement);
};

var getEnv = (function (start) {
  var closestScrollable = getClosestScrollable(start);
  var isFixedOnPage = getIsFixed(start);
  return {
    closestScrollable: closestScrollable,
    isFixedOnPage: isFixedOnPage
  };
});

var getDroppableDimension = (function (_ref) {
  var descriptor = _ref.descriptor,
      isEnabled = _ref.isEnabled,
      isCombineEnabled = _ref.isCombineEnabled,
      isFixedOnPage = _ref.isFixedOnPage,
      direction = _ref.direction,
      client = _ref.client,
      page = _ref.page,
      closest = _ref.closest;

  var frame = function () {
    if (!closest) {
      return null;
    }

    var scrollSize = closest.scrollSize,
        frameClient = closest.client;
    var maxScroll = getMaxScroll({
      scrollHeight: scrollSize.scrollHeight,
      scrollWidth: scrollSize.scrollWidth,
      height: frameClient.paddingBox.height,
      width: frameClient.paddingBox.width
    });
    return {
      pageMarginBox: closest.page.marginBox,
      frameClient: frameClient,
      scrollSize: scrollSize,
      shouldClipSubject: closest.shouldClipSubject,
      scroll: {
        initial: closest.scroll,
        current: closest.scroll,
        max: maxScroll,
        diff: {
          value: origin,
          displacement: origin
        }
      }
    };
  }();

  var axis = direction === 'vertical' ? vertical : horizontal;
  var subject = getSubject({
    page: page,
    withPlaceholder: null,
    axis: axis,
    frame: frame
  });
  var dimension = {
    descriptor: descriptor,
    isCombineEnabled: isCombineEnabled,
    isFixedOnPage: isFixedOnPage,
    axis: axis,
    isEnabled: isEnabled,
    client: client,
    page: page,
    frame: frame,
    subject: subject
  };
  return dimension;
});

var getClient = function getClient(targetRef, closestScrollable) {
  var base = cssBoxModel.getBox(targetRef);

  if (!closestScrollable) {
    return base;
  }

  if (targetRef !== closestScrollable) {
    return base;
  }

  var top = base.paddingBox.top - closestScrollable.scrollTop;
  var left = base.paddingBox.left - closestScrollable.scrollLeft;
  var bottom = top + closestScrollable.scrollHeight;
  var right = left + closestScrollable.scrollWidth;
  var paddingBox = {
    top: top,
    right: right,
    bottom: bottom,
    left: left
  };
  var borderBox = cssBoxModel.expand(paddingBox, base.border);
  var client = cssBoxModel.createBox({
    borderBox: borderBox,
    margin: base.margin,
    border: base.border,
    padding: base.padding
  });
  return client;
};

var getDimension = (function (_ref) {
  var ref = _ref.ref,
      descriptor = _ref.descriptor,
      env = _ref.env,
      windowScroll = _ref.windowScroll,
      direction = _ref.direction,
      isDropDisabled = _ref.isDropDisabled,
      isCombineEnabled = _ref.isCombineEnabled,
      shouldClipSubject = _ref.shouldClipSubject;
  var closestScrollable = env.closestScrollable;
  var client = getClient(ref, closestScrollable);
  var page = cssBoxModel.withScroll(client, windowScroll);

  var closest = function () {
    if (!closestScrollable) {
      return null;
    }

    var frameClient = cssBoxModel.getBox(closestScrollable);
    var scrollSize = {
      scrollHeight: closestScrollable.scrollHeight,
      scrollWidth: closestScrollable.scrollWidth
    };
    return {
      client: frameClient,
      page: cssBoxModel.withScroll(frameClient, windowScroll),
      scroll: getScroll$1(closestScrollable),
      scrollSize: scrollSize,
      shouldClipSubject: shouldClipSubject
    };
  }();

  var dimension = getDroppableDimension({
    descriptor: descriptor,
    isEnabled: !isDropDisabled,
    isCombineEnabled: isCombineEnabled,
    isFixedOnPage: env.isFixedOnPage,
    direction: direction,
    client: client,
    page: page,
    closest: closest
  });
  return dimension;
});

var immediate = {
  passive: false
};
var delayed = {
  passive: true
};
var getListenerOptions = (function (options) {
  return options.shouldPublishImmediately ? immediate : delayed;
});

function useRequiredContext(Context) {
  var result = React.useContext(Context);
  !result ?  false ? 0 : invariant(false) : void 0;
  return result;
}

var getClosestScrollableFromDrag = function getClosestScrollableFromDrag(dragging) {
  return dragging && dragging.env.closestScrollable || null;
};

function useDroppablePublisher(args) {
  var whileDraggingRef = React.useRef(null);
  var appContext = useRequiredContext(AppContext);
  var uniqueId = useUniqueId('droppable');
  var registry = appContext.registry,
      marshal = appContext.marshal;
  var previousRef = usePrevious(args);
  var descriptor = useMemoOne.useMemo(function () {
    return {
      id: args.droppableId,
      type: args.type,
      mode: args.mode
    };
  }, [args.droppableId, args.mode, args.type]);
  var publishedDescriptorRef = React.useRef(descriptor);
  var memoizedUpdateScroll = useMemoOne.useMemo(function () {
    return memoizeOne(function (x, y) {
      !whileDraggingRef.current ?  false ? 0 : invariant(false) : void 0;
      var scroll = {
        x: x,
        y: y
      };
      marshal.updateDroppableScroll(descriptor.id, scroll);
    });
  }, [descriptor.id, marshal]);
  var getClosestScroll = useMemoOne.useCallback(function () {
    var dragging = whileDraggingRef.current;

    if (!dragging || !dragging.env.closestScrollable) {
      return origin;
    }

    return getScroll$1(dragging.env.closestScrollable);
  }, []);
  var updateScroll = useMemoOne.useCallback(function () {
    var scroll = getClosestScroll();
    memoizedUpdateScroll(scroll.x, scroll.y);
  }, [getClosestScroll, memoizedUpdateScroll]);
  var scheduleScrollUpdate = useMemoOne.useMemo(function () {
    return rafSchd(updateScroll);
  }, [updateScroll]);
  var onClosestScroll = useMemoOne.useCallback(function () {
    var dragging = whileDraggingRef.current;
    var closest = getClosestScrollableFromDrag(dragging);
    !(dragging && closest) ?  false ? 0 : invariant(false) : void 0;
    var options = dragging.scrollOptions;

    if (options.shouldPublishImmediately) {
      updateScroll();
      return;
    }

    scheduleScrollUpdate();
  }, [scheduleScrollUpdate, updateScroll]);
  var getDimensionAndWatchScroll = useMemoOne.useCallback(function (windowScroll, options) {
    !!whileDraggingRef.current ?  false ? 0 : invariant(false) : void 0;
    var previous = previousRef.current;
    var ref = previous.getDroppableRef();
    !ref ?  false ? 0 : invariant(false) : void 0;
    var env = getEnv(ref);
    var dragging = {
      ref: ref,
      descriptor: descriptor,
      env: env,
      scrollOptions: options
    };
    whileDraggingRef.current = dragging;
    var dimension = getDimension({
      ref: ref,
      descriptor: descriptor,
      env: env,
      windowScroll: windowScroll,
      direction: previous.direction,
      isDropDisabled: previous.isDropDisabled,
      isCombineEnabled: previous.isCombineEnabled,
      shouldClipSubject: !previous.ignoreContainerClipping
    });
    var scrollable = env.closestScrollable;

    if (scrollable) {
      scrollable.setAttribute(scrollContainer.contextId, appContext.contextId);
      scrollable.addEventListener('scroll', onClosestScroll, getListenerOptions(dragging.scrollOptions));

      if (false) {}
    }

    return dimension;
  }, [appContext.contextId, descriptor, onClosestScroll, previousRef]);
  var getScrollWhileDragging = useMemoOne.useCallback(function () {
    var dragging = whileDraggingRef.current;
    var closest = getClosestScrollableFromDrag(dragging);
    !(dragging && closest) ?  false ? 0 : invariant(false) : void 0;
    return getScroll$1(closest);
  }, []);
  var dragStopped = useMemoOne.useCallback(function () {
    var dragging = whileDraggingRef.current;
    !dragging ?  false ? 0 : invariant(false) : void 0;
    var closest = getClosestScrollableFromDrag(dragging);
    whileDraggingRef.current = null;

    if (!closest) {
      return;
    }

    scheduleScrollUpdate.cancel();
    closest.removeAttribute(scrollContainer.contextId);
    closest.removeEventListener('scroll', onClosestScroll, getListenerOptions(dragging.scrollOptions));
  }, [onClosestScroll, scheduleScrollUpdate]);
  var scroll = useMemoOne.useCallback(function (change) {
    var dragging = whileDraggingRef.current;
    !dragging ?  false ? 0 : invariant(false) : void 0;
    var closest = getClosestScrollableFromDrag(dragging);
    !closest ?  false ? 0 : invariant(false) : void 0;
    closest.scrollTop += change.y;
    closest.scrollLeft += change.x;
  }, []);
  var callbacks = useMemoOne.useMemo(function () {
    return {
      getDimensionAndWatchScroll: getDimensionAndWatchScroll,
      getScrollWhileDragging: getScrollWhileDragging,
      dragStopped: dragStopped,
      scroll: scroll
    };
  }, [dragStopped, getDimensionAndWatchScroll, getScrollWhileDragging, scroll]);
  var entry = useMemoOne.useMemo(function () {
    return {
      uniqueId: uniqueId,
      descriptor: descriptor,
      callbacks: callbacks
    };
  }, [callbacks, descriptor, uniqueId]);
  useIsomorphicLayoutEffect(function () {
    publishedDescriptorRef.current = entry.descriptor;
    registry.droppable.register(entry);
    return function () {
      if (whileDraggingRef.current) {
         false ? 0 : void 0;
        dragStopped();
      }

      registry.droppable.unregister(entry);
    };
  }, [callbacks, descriptor, dragStopped, entry, marshal, registry.droppable]);
  useIsomorphicLayoutEffect(function () {
    if (!whileDraggingRef.current) {
      return;
    }

    marshal.updateDroppableIsEnabled(publishedDescriptorRef.current.id, !args.isDropDisabled);
  }, [args.isDropDisabled, marshal]);
  useIsomorphicLayoutEffect(function () {
    if (!whileDraggingRef.current) {
      return;
    }

    marshal.updateDroppableIsCombineEnabled(publishedDescriptorRef.current.id, args.isCombineEnabled);
  }, [args.isCombineEnabled, marshal]);
}

function noop$2() {}

var empty = {
  width: 0,
  height: 0,
  margin: noSpacing
};

var getSize = function getSize(_ref) {
  var isAnimatingOpenOnMount = _ref.isAnimatingOpenOnMount,
      placeholder = _ref.placeholder,
      animate = _ref.animate;

  if (isAnimatingOpenOnMount) {
    return empty;
  }

  if (animate === 'close') {
    return empty;
  }

  return {
    height: placeholder.client.borderBox.height,
    width: placeholder.client.borderBox.width,
    margin: placeholder.client.margin
  };
};

var getStyle = function getStyle(_ref2) {
  var isAnimatingOpenOnMount = _ref2.isAnimatingOpenOnMount,
      placeholder = _ref2.placeholder,
      animate = _ref2.animate;
  var size = getSize({
    isAnimatingOpenOnMount: isAnimatingOpenOnMount,
    placeholder: placeholder,
    animate: animate
  });
  return {
    display: placeholder.display,
    boxSizing: 'border-box',
    width: size.width,
    height: size.height,
    marginTop: size.margin.top,
    marginRight: size.margin.right,
    marginBottom: size.margin.bottom,
    marginLeft: size.margin.left,
    flexShrink: '0',
    flexGrow: '0',
    pointerEvents: 'none',
    transition: animate !== 'none' ? transitions.placeholder : null
  };
};

function Placeholder(props) {
  var animateOpenTimerRef = React.useRef(null);
  var tryClearAnimateOpenTimer = useMemoOne.useCallback(function () {
    if (!animateOpenTimerRef.current) {
      return;
    }

    clearTimeout(animateOpenTimerRef.current);
    animateOpenTimerRef.current = null;
  }, []);
  var animate = props.animate,
      onTransitionEnd = props.onTransitionEnd,
      onClose = props.onClose,
      contextId = props.contextId;

  var _useState = React.useState(props.animate === 'open'),
      isAnimatingOpenOnMount = _useState[0],
      setIsAnimatingOpenOnMount = _useState[1];

  React.useEffect(function () {
    if (!isAnimatingOpenOnMount) {
      return noop$2;
    }

    if (animate !== 'open') {
      tryClearAnimateOpenTimer();
      setIsAnimatingOpenOnMount(false);
      return noop$2;
    }

    if (animateOpenTimerRef.current) {
      return noop$2;
    }

    animateOpenTimerRef.current = setTimeout(function () {
      animateOpenTimerRef.current = null;
      setIsAnimatingOpenOnMount(false);
    });
    return tryClearAnimateOpenTimer;
  }, [animate, isAnimatingOpenOnMount, tryClearAnimateOpenTimer]);
  var onSizeChangeEnd = useMemoOne.useCallback(function (event) {
    if (event.propertyName !== 'height') {
      return;
    }

    onTransitionEnd();

    if (animate === 'close') {
      onClose();
    }
  }, [animate, onClose, onTransitionEnd]);
  var style = getStyle({
    isAnimatingOpenOnMount: isAnimatingOpenOnMount,
    animate: props.animate,
    placeholder: props.placeholder
  });
  return React__default.createElement(props.placeholder.tagName, {
    style: style,
    'data-rbd-placeholder-context-id': contextId,
    onTransitionEnd: onSizeChangeEnd,
    ref: props.innerRef
  });
}

var Placeholder$1 = React__default.memo(Placeholder);

var DroppableContext = React__default.createContext(null);

function checkIsValidInnerRef(el) {
  !(el && isHtmlElement(el)) ?  false ? 0 : invariant(false) : void 0;
}

function isBoolean(value) {
  return typeof value === 'boolean';
}

function runChecks(args, checks) {
  checks.forEach(function (check) {
    return check(args);
  });
}

var shared = [function required(_ref) {
  var props = _ref.props;
  !props.droppableId ?  false ? 0 : invariant(false) : void 0;
  !(typeof props.droppableId === 'string') ?  false ? 0 : invariant(false) : void 0;
}, function _boolean(_ref2) {
  var props = _ref2.props;
  !isBoolean(props.isDropDisabled) ?  false ? 0 : invariant(false) : void 0;
  !isBoolean(props.isCombineEnabled) ?  false ? 0 : invariant(false) : void 0;
  !isBoolean(props.ignoreContainerClipping) ?  false ? 0 : invariant(false) : void 0;
}, function ref(_ref3) {
  var getDroppableRef = _ref3.getDroppableRef;
  checkIsValidInnerRef(getDroppableRef());
}];
var standard = [function placeholder(_ref4) {
  var props = _ref4.props,
      getPlaceholderRef = _ref4.getPlaceholderRef;

  if (!props.placeholder) {
    return;
  }

  var ref = getPlaceholderRef();

  if (ref) {
    return;
  }

   false ? 0 : void 0;
}];
var virtual = [function hasClone(_ref5) {
  var props = _ref5.props;
  !props.renderClone ?  false ? 0 : invariant(false) : void 0;
}, function hasNoPlaceholder(_ref6) {
  var getPlaceholderRef = _ref6.getPlaceholderRef;
  !!getPlaceholderRef() ?  false ? 0 : invariant(false) : void 0;
}];
function useValidation(args) {
  useDevSetupWarning(function () {
    runChecks(args, shared);

    if (args.props.mode === 'standard') {
      runChecks(args, standard);
    }

    if (args.props.mode === 'virtual') {
      runChecks(args, virtual);
    }
  });
}

var AnimateInOut = function (_React$PureComponent) {
  _inheritsLoose(AnimateInOut, _React$PureComponent);

  function AnimateInOut() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$PureComponent.call.apply(_React$PureComponent, [this].concat(args)) || this;
    _this.state = {
      isVisible: Boolean(_this.props.on),
      data: _this.props.on,
      animate: _this.props.shouldAnimate && _this.props.on ? 'open' : 'none'
    };

    _this.onClose = function () {
      if (_this.state.animate !== 'close') {
        return;
      }

      _this.setState({
        isVisible: false
      });
    };

    return _this;
  }

  AnimateInOut.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {
    if (!props.shouldAnimate) {
      return {
        isVisible: Boolean(props.on),
        data: props.on,
        animate: 'none'
      };
    }

    if (props.on) {
      return {
        isVisible: true,
        data: props.on,
        animate: 'open'
      };
    }

    if (state.isVisible) {
      return {
        isVisible: true,
        data: state.data,
        animate: 'close'
      };
    }

    return {
      isVisible: false,
      animate: 'close',
      data: null
    };
  };

  var _proto = AnimateInOut.prototype;

  _proto.render = function render() {
    if (!this.state.isVisible) {
      return null;
    }

    var provided = {
      onClose: this.onClose,
      data: this.state.data,
      animate: this.state.animate
    };
    return this.props.children(provided);
  };

  return AnimateInOut;
}(React__default.PureComponent);

var zIndexOptions = {
  dragging: 5000,
  dropAnimating: 4500
};

var getDraggingTransition = function getDraggingTransition(shouldAnimateDragMovement, dropping) {
  if (dropping) {
    return transitions.drop(dropping.duration);
  }

  if (shouldAnimateDragMovement) {
    return transitions.snap;
  }

  return transitions.fluid;
};

var getDraggingOpacity = function getDraggingOpacity(isCombining, isDropAnimating) {
  if (!isCombining) {
    return null;
  }

  return isDropAnimating ? combine.opacity.drop : combine.opacity.combining;
};

var getShouldDraggingAnimate = function getShouldDraggingAnimate(dragging) {
  if (dragging.forceShouldAnimate != null) {
    return dragging.forceShouldAnimate;
  }

  return dragging.mode === 'SNAP';
};

function getDraggingStyle(dragging) {
  var dimension = dragging.dimension;
  var box = dimension.client;
  var offset = dragging.offset,
      combineWith = dragging.combineWith,
      dropping = dragging.dropping;
  var isCombining = Boolean(combineWith);
  var shouldAnimate = getShouldDraggingAnimate(dragging);
  var isDropAnimating = Boolean(dropping);
  var transform = isDropAnimating ? transforms.drop(offset, isCombining) : transforms.moveTo(offset);
  var style = {
    position: 'fixed',
    top: box.marginBox.top,
    left: box.marginBox.left,
    boxSizing: 'border-box',
    width: box.borderBox.width,
    height: box.borderBox.height,
    transition: getDraggingTransition(shouldAnimate, dropping),
    transform: transform,
    opacity: getDraggingOpacity(isCombining, isDropAnimating),
    zIndex: isDropAnimating ? zIndexOptions.dropAnimating : zIndexOptions.dragging,
    pointerEvents: 'none'
  };
  return style;
}

function getSecondaryStyle(secondary) {
  return {
    transform: transforms.moveTo(secondary.offset),
    transition: secondary.shouldAnimateDisplacement ? null : 'none'
  };
}

function getStyle$1(mapped) {
  return mapped.type === 'DRAGGING' ? getDraggingStyle(mapped) : getSecondaryStyle(mapped);
}

function getDimension$1(descriptor, el, windowScroll) {
  if (windowScroll === void 0) {
    windowScroll = origin;
  }

  var computedStyles = window.getComputedStyle(el);
  var borderBox = el.getBoundingClientRect();
  var client = cssBoxModel.calculateBox(borderBox, computedStyles);
  var page = cssBoxModel.withScroll(client, windowScroll);
  var placeholder = {
    client: client,
    tagName: el.tagName.toLowerCase(),
    display: computedStyles.display
  };
  var displaceBy = {
    x: client.marginBox.width,
    y: client.marginBox.height
  };
  var dimension = {
    descriptor: descriptor,
    placeholder: placeholder,
    displaceBy: displaceBy,
    client: client,
    page: page
  };
  return dimension;
}

function useDraggablePublisher(args) {
  var uniqueId = useUniqueId('draggable');
  var descriptor = args.descriptor,
      registry = args.registry,
      getDraggableRef = args.getDraggableRef,
      canDragInteractiveElements = args.canDragInteractiveElements,
      shouldRespectForcePress = args.shouldRespectForcePress,
      isEnabled = args.isEnabled;
  var options = useMemoOne.useMemo(function () {
    return {
      canDragInteractiveElements: canDragInteractiveElements,
      shouldRespectForcePress: shouldRespectForcePress,
      isEnabled: isEnabled
    };
  }, [canDragInteractiveElements, isEnabled, shouldRespectForcePress]);
  var getDimension = useMemoOne.useCallback(function (windowScroll) {
    var el = getDraggableRef();
    !el ?  false ? 0 : invariant(false) : void 0;
    return getDimension$1(descriptor, el, windowScroll);
  }, [descriptor, getDraggableRef]);
  var entry = useMemoOne.useMemo(function () {
    return {
      uniqueId: uniqueId,
      descriptor: descriptor,
      options: options,
      getDimension: getDimension
    };
  }, [descriptor, getDimension, options, uniqueId]);
  var publishedRef = React.useRef(entry);
  var isFirstPublishRef = React.useRef(true);
  useIsomorphicLayoutEffect(function () {
    registry.draggable.register(publishedRef.current);
    return function () {
      return registry.draggable.unregister(publishedRef.current);
    };
  }, [registry.draggable]);
  useIsomorphicLayoutEffect(function () {
    if (isFirstPublishRef.current) {
      isFirstPublishRef.current = false;
      return;
    }

    var last = publishedRef.current;
    publishedRef.current = entry;
    registry.draggable.update(entry, last);
  }, [entry, registry.draggable]);
}

function useValidation$1(props, contextId, getRef) {
  useDevSetupWarning(function () {
    function prefix(id) {
      return "Draggable[id: " + id + "]: ";
    }

    var id = props.draggableId;
    !id ?  false ? 0 : invariant(false) : void 0;
    !(typeof id === 'string') ?  false ? 0 : invariant(false) : void 0;
    !isInteger(props.index) ?  false ? 0 : invariant(false) : void 0;

    if (props.mapped.type === 'DRAGGING') {
      return;
    }

    checkIsValidInnerRef(getRef());

    if (props.isEnabled) {
      !findDragHandle(contextId, id) ?  false ? 0 : invariant(false) : void 0;
    }
  });
}
function useClonePropValidation(isClone) {
  useDev(function () {
    var initialRef = React.useRef(isClone);
    useDevSetupWarning(function () {
      !(isClone === initialRef.current) ?  false ? 0 : invariant(false) : void 0;
    }, [isClone]);
  });
}

function preventHtml5Dnd(event) {
  event.preventDefault();
}

function Draggable(props) {
  var ref = React.useRef(null);
  var setRef = useMemoOne.useCallback(function (el) {
    ref.current = el;
  }, []);
  var getRef = useMemoOne.useCallback(function () {
    return ref.current;
  }, []);

  var _useRequiredContext = useRequiredContext(AppContext),
      contextId = _useRequiredContext.contextId,
      dragHandleUsageInstructionsId = _useRequiredContext.dragHandleUsageInstructionsId,
      registry = _useRequiredContext.registry;

  var _useRequiredContext2 = useRequiredContext(DroppableContext),
      type = _useRequiredContext2.type,
      droppableId = _useRequiredContext2.droppableId;

  var descriptor = useMemoOne.useMemo(function () {
    return {
      id: props.draggableId,
      index: props.index,
      type: type,
      droppableId: droppableId
    };
  }, [props.draggableId, props.index, type, droppableId]);
  var children = props.children,
      draggableId = props.draggableId,
      isEnabled = props.isEnabled,
      shouldRespectForcePress = props.shouldRespectForcePress,
      canDragInteractiveElements = props.canDragInteractiveElements,
      isClone = props.isClone,
      mapped = props.mapped,
      dropAnimationFinishedAction = props.dropAnimationFinished;
  useValidation$1(props, contextId, getRef);
  useClonePropValidation(isClone);

  if (!isClone) {
    var forPublisher = useMemoOne.useMemo(function () {
      return {
        descriptor: descriptor,
        registry: registry,
        getDraggableRef: getRef,
        canDragInteractiveElements: canDragInteractiveElements,
        shouldRespectForcePress: shouldRespectForcePress,
        isEnabled: isEnabled
      };
    }, [descriptor, registry, getRef, canDragInteractiveElements, shouldRespectForcePress, isEnabled]);
    useDraggablePublisher(forPublisher);
  }

  var dragHandleProps = useMemoOne.useMemo(function () {
    return isEnabled ? {
      tabIndex: 0,
      role: 'button',
      'aria-describedby': dragHandleUsageInstructionsId,
      'data-rbd-drag-handle-draggable-id': draggableId,
      'data-rbd-drag-handle-context-id': contextId,
      draggable: false,
      onDragStart: preventHtml5Dnd
    } : null;
  }, [contextId, dragHandleUsageInstructionsId, draggableId, isEnabled]);
  var onMoveEnd = useMemoOne.useCallback(function (event) {
    if (mapped.type !== 'DRAGGING') {
      return;
    }

    if (!mapped.dropping) {
      return;
    }

    if (event.propertyName !== 'transform') {
      return;
    }

    dropAnimationFinishedAction();
  }, [dropAnimationFinishedAction, mapped]);
  var provided = useMemoOne.useMemo(function () {
    var style = getStyle$1(mapped);
    var onTransitionEnd = mapped.type === 'DRAGGING' && mapped.dropping ? onMoveEnd : null;
    var result = {
      innerRef: setRef,
      draggableProps: {
        'data-rbd-draggable-context-id': contextId,
        'data-rbd-draggable-id': draggableId,
        style: style,
        onTransitionEnd: onTransitionEnd
      },
      dragHandleProps: dragHandleProps
    };
    return result;
  }, [contextId, dragHandleProps, draggableId, mapped, onMoveEnd, setRef]);
  var rubric = useMemoOne.useMemo(function () {
    return {
      draggableId: descriptor.id,
      type: descriptor.type,
      source: {
        index: descriptor.index,
        droppableId: descriptor.droppableId
      }
    };
  }, [descriptor.droppableId, descriptor.id, descriptor.index, descriptor.type]);
  return children(provided, mapped.snapshot, rubric);
}

var isStrictEqual = (function (a, b) {
  return a === b;
});

var whatIsDraggedOverFromResult = (function (result) {
  var combine = result.combine,
      destination = result.destination;

  if (destination) {
    return destination.droppableId;
  }

  if (combine) {
    return combine.droppableId;
  }

  return null;
});

var getCombineWithFromResult = function getCombineWithFromResult(result) {
  return result.combine ? result.combine.draggableId : null;
};

var getCombineWithFromImpact = function getCombineWithFromImpact(impact) {
  return impact.at && impact.at.type === 'COMBINE' ? impact.at.combine.draggableId : null;
};

function getDraggableSelector() {
  var memoizedOffset = memoizeOne(function (x, y) {
    return {
      x: x,
      y: y
    };
  });
  var getMemoizedSnapshot = memoizeOne(function (mode, isClone, draggingOver, combineWith, dropping) {
    return {
      isDragging: true,
      isClone: isClone,
      isDropAnimating: Boolean(dropping),
      dropAnimation: dropping,
      mode: mode,
      draggingOver: draggingOver,
      combineWith: combineWith,
      combineTargetFor: null
    };
  });
  var getMemoizedProps = memoizeOne(function (offset, mode, dimension, isClone, draggingOver, combineWith, forceShouldAnimate) {
    return {
      mapped: {
        type: 'DRAGGING',
        dropping: null,
        draggingOver: draggingOver,
        combineWith: combineWith,
        mode: mode,
        offset: offset,
        dimension: dimension,
        forceShouldAnimate: forceShouldAnimate,
        snapshot: getMemoizedSnapshot(mode, isClone, draggingOver, combineWith, null)
      }
    };
  });

  var selector = function selector(state, ownProps) {
    if (state.isDragging) {
      if (state.critical.draggable.id !== ownProps.draggableId) {
        return null;
      }

      var offset = state.current.client.offset;
      var dimension = state.dimensions.draggables[ownProps.draggableId];
      var draggingOver = whatIsDraggedOver(state.impact);
      var combineWith = getCombineWithFromImpact(state.impact);
      var forceShouldAnimate = state.forceShouldAnimate;
      return getMemoizedProps(memoizedOffset(offset.x, offset.y), state.movementMode, dimension, ownProps.isClone, draggingOver, combineWith, forceShouldAnimate);
    }

    if (state.phase === 'DROP_ANIMATING') {
      var completed = state.completed;

      if (completed.result.draggableId !== ownProps.draggableId) {
        return null;
      }

      var isClone = ownProps.isClone;
      var _dimension = state.dimensions.draggables[ownProps.draggableId];
      var result = completed.result;
      var mode = result.mode;

      var _draggingOver = whatIsDraggedOverFromResult(result);

      var _combineWith = getCombineWithFromResult(result);

      var duration = state.dropDuration;
      var dropping = {
        duration: duration,
        curve: curves.drop,
        moveTo: state.newHomeClientOffset,
        opacity: _combineWith ? combine.opacity.drop : null,
        scale: _combineWith ? combine.scale.drop : null
      };
      return {
        mapped: {
          type: 'DRAGGING',
          offset: state.newHomeClientOffset,
          dimension: _dimension,
          dropping: dropping,
          draggingOver: _draggingOver,
          combineWith: _combineWith,
          mode: mode,
          forceShouldAnimate: null,
          snapshot: getMemoizedSnapshot(mode, isClone, _draggingOver, _combineWith, dropping)
        }
      };
    }

    return null;
  };

  return selector;
}

function getSecondarySnapshot(combineTargetFor) {
  return {
    isDragging: false,
    isDropAnimating: false,
    isClone: false,
    dropAnimation: null,
    mode: null,
    draggingOver: null,
    combineTargetFor: combineTargetFor,
    combineWith: null
  };
}

var atRest = {
  mapped: {
    type: 'SECONDARY',
    offset: origin,
    combineTargetFor: null,
    shouldAnimateDisplacement: true,
    snapshot: getSecondarySnapshot(null)
  }
};

function getSecondarySelector() {
  var memoizedOffset = memoizeOne(function (x, y) {
    return {
      x: x,
      y: y
    };
  });
  var getMemoizedSnapshot = memoizeOne(getSecondarySnapshot);
  var getMemoizedProps = memoizeOne(function (offset, combineTargetFor, shouldAnimateDisplacement) {
    if (combineTargetFor === void 0) {
      combineTargetFor = null;
    }

    return {
      mapped: {
        type: 'SECONDARY',
        offset: offset,
        combineTargetFor: combineTargetFor,
        shouldAnimateDisplacement: shouldAnimateDisplacement,
        snapshot: getMemoizedSnapshot(combineTargetFor)
      }
    };
  });

  var getFallback = function getFallback(combineTargetFor) {
    return combineTargetFor ? getMemoizedProps(origin, combineTargetFor, true) : null;
  };

  var getProps = function getProps(ownId, draggingId, impact, afterCritical) {
    var visualDisplacement = impact.displaced.visible[ownId];
    var isAfterCriticalInVirtualList = Boolean(afterCritical.inVirtualList && afterCritical.effected[ownId]);
    var combine = tryGetCombine(impact);
    var combineTargetFor = combine && combine.draggableId === ownId ? draggingId : null;

    if (!visualDisplacement) {
      if (!isAfterCriticalInVirtualList) {
        return getFallback(combineTargetFor);
      }

      if (impact.displaced.invisible[ownId]) {
        return null;
      }

      var change = negate(afterCritical.displacedBy.point);

      var _offset = memoizedOffset(change.x, change.y);

      return getMemoizedProps(_offset, combineTargetFor, true);
    }

    if (isAfterCriticalInVirtualList) {
      return getFallback(combineTargetFor);
    }

    var displaceBy = impact.displacedBy.point;
    var offset = memoizedOffset(displaceBy.x, displaceBy.y);
    return getMemoizedProps(offset, combineTargetFor, visualDisplacement.shouldAnimate);
  };

  var selector = function selector(state, ownProps) {
    if (state.isDragging) {
      if (state.critical.draggable.id === ownProps.draggableId) {
        return null;
      }

      return getProps(ownProps.draggableId, state.critical.draggable.id, state.impact, state.afterCritical);
    }

    if (state.phase === 'DROP_ANIMATING') {
      var completed = state.completed;

      if (completed.result.draggableId === ownProps.draggableId) {
        return null;
      }

      return getProps(ownProps.draggableId, completed.result.draggableId, completed.impact, completed.afterCritical);
    }

    return null;
  };

  return selector;
}

var makeMapStateToProps = function makeMapStateToProps() {
  var draggingSelector = getDraggableSelector();
  var secondarySelector = getSecondarySelector();

  var selector = function selector(state, ownProps) {
    return draggingSelector(state, ownProps) || secondarySelector(state, ownProps) || atRest;
  };

  return selector;
};
var mapDispatchToProps = {
  dropAnimationFinished: dropAnimationFinished
};
var ConnectedDraggable = reactRedux.connect(makeMapStateToProps, mapDispatchToProps, null, {
  context: StoreContext,
  pure: true,
  areStatePropsEqual: isStrictEqual
})(Draggable);

function PrivateDraggable(props) {
  var droppableContext = useRequiredContext(DroppableContext);
  var isUsingCloneFor = droppableContext.isUsingCloneFor;

  if (isUsingCloneFor === props.draggableId && !props.isClone) {
    return null;
  }

  return React__default.createElement(ConnectedDraggable, props);
}
function PublicDraggable(props) {
  var isEnabled = typeof props.isDragDisabled === 'boolean' ? !props.isDragDisabled : true;
  var canDragInteractiveElements = Boolean(props.disableInteractiveElementBlocking);
  var shouldRespectForcePress = Boolean(props.shouldRespectForcePress);
  return React__default.createElement(PrivateDraggable, _extends({}, props, {
    isClone: false,
    isEnabled: isEnabled,
    canDragInteractiveElements: canDragInteractiveElements,
    shouldRespectForcePress: shouldRespectForcePress
  }));
}

function Droppable(props) {
  var appContext = React.useContext(AppContext);
  !appContext ?  false ? 0 : invariant(false) : void 0;
  var contextId = appContext.contextId,
      isMovementAllowed = appContext.isMovementAllowed;
  var droppableRef = React.useRef(null);
  var placeholderRef = React.useRef(null);
  var children = props.children,
      droppableId = props.droppableId,
      type = props.type,
      mode = props.mode,
      direction = props.direction,
      ignoreContainerClipping = props.ignoreContainerClipping,
      isDropDisabled = props.isDropDisabled,
      isCombineEnabled = props.isCombineEnabled,
      snapshot = props.snapshot,
      useClone = props.useClone,
      updateViewportMaxScroll = props.updateViewportMaxScroll,
      getContainerForClone = props.getContainerForClone;
  var getDroppableRef = useMemoOne.useCallback(function () {
    return droppableRef.current;
  }, []);
  var setDroppableRef = useMemoOne.useCallback(function (value) {
    droppableRef.current = value;
  }, []);
  var getPlaceholderRef = useMemoOne.useCallback(function () {
    return placeholderRef.current;
  }, []);
  var setPlaceholderRef = useMemoOne.useCallback(function (value) {
    placeholderRef.current = value;
  }, []);
  useValidation({
    props: props,
    getDroppableRef: getDroppableRef,
    getPlaceholderRef: getPlaceholderRef
  });
  var onPlaceholderTransitionEnd = useMemoOne.useCallback(function () {
    if (isMovementAllowed()) {
      updateViewportMaxScroll({
        maxScroll: getMaxWindowScroll()
      });
    }
  }, [isMovementAllowed, updateViewportMaxScroll]);
  useDroppablePublisher({
    droppableId: droppableId,
    type: type,
    mode: mode,
    direction: direction,
    isDropDisabled: isDropDisabled,
    isCombineEnabled: isCombineEnabled,
    ignoreContainerClipping: ignoreContainerClipping,
    getDroppableRef: getDroppableRef
  });
  var placeholder = React__default.createElement(AnimateInOut, {
    on: props.placeholder,
    shouldAnimate: props.shouldAnimatePlaceholder
  }, function (_ref) {
    var onClose = _ref.onClose,
        data = _ref.data,
        animate = _ref.animate;
    return React__default.createElement(Placeholder$1, {
      placeholder: data,
      onClose: onClose,
      innerRef: setPlaceholderRef,
      animate: animate,
      contextId: contextId,
      onTransitionEnd: onPlaceholderTransitionEnd
    });
  });
  var provided = useMemoOne.useMemo(function () {
    return {
      innerRef: setDroppableRef,
      placeholder: placeholder,
      droppableProps: {
        'data-rbd-droppable-id': droppableId,
        'data-rbd-droppable-context-id': contextId
      }
    };
  }, [contextId, droppableId, placeholder, setDroppableRef]);
  var isUsingCloneFor = useClone ? useClone.dragging.draggableId : null;
  var droppableContext = useMemoOne.useMemo(function () {
    return {
      droppableId: droppableId,
      type: type,
      isUsingCloneFor: isUsingCloneFor
    };
  }, [droppableId, isUsingCloneFor, type]);

  function getClone() {
    if (!useClone) {
      return null;
    }

    var dragging = useClone.dragging,
        render = useClone.render;
    var node = React__default.createElement(PrivateDraggable, {
      draggableId: dragging.draggableId,
      index: dragging.source.index,
      isClone: true,
      isEnabled: true,
      shouldRespectForcePress: false,
      canDragInteractiveElements: true
    }, function (draggableProvided, draggableSnapshot) {
      return render(draggableProvided, draggableSnapshot, dragging);
    });
    return ReactDOM.createPortal(node, getContainerForClone());
  }

  return React__default.createElement(DroppableContext.Provider, {
    value: droppableContext
  }, children(provided, snapshot), getClone());
}

var isMatchingType = function isMatchingType(type, critical) {
  return type === critical.droppable.type;
};

var getDraggable = function getDraggable(critical, dimensions) {
  return dimensions.draggables[critical.draggable.id];
};

var makeMapStateToProps$1 = function makeMapStateToProps() {
  var idleWithAnimation = {
    placeholder: null,
    shouldAnimatePlaceholder: true,
    snapshot: {
      isDraggingOver: false,
      draggingOverWith: null,
      draggingFromThisWith: null,
      isUsingPlaceholder: false
    },
    useClone: null
  };

  var idleWithoutAnimation = _extends({}, idleWithAnimation, {
    shouldAnimatePlaceholder: false
  });

  var getDraggableRubric = memoizeOne(function (descriptor) {
    return {
      draggableId: descriptor.id,
      type: descriptor.type,
      source: {
        index: descriptor.index,
        droppableId: descriptor.droppableId
      }
    };
  });
  var getMapProps = memoizeOne(function (id, isEnabled, isDraggingOverForConsumer, isDraggingOverForImpact, dragging, renderClone) {
    var draggableId = dragging.descriptor.id;
    var isHome = dragging.descriptor.droppableId === id;

    if (isHome) {
      var useClone = renderClone ? {
        render: renderClone,
        dragging: getDraggableRubric(dragging.descriptor)
      } : null;
      var _snapshot = {
        isDraggingOver: isDraggingOverForConsumer,
        draggingOverWith: isDraggingOverForConsumer ? draggableId : null,
        draggingFromThisWith: draggableId,
        isUsingPlaceholder: true
      };
      return {
        placeholder: dragging.placeholder,
        shouldAnimatePlaceholder: false,
        snapshot: _snapshot,
        useClone: useClone
      };
    }

    if (!isEnabled) {
      return idleWithoutAnimation;
    }

    if (!isDraggingOverForImpact) {
      return idleWithAnimation;
    }

    var snapshot = {
      isDraggingOver: isDraggingOverForConsumer,
      draggingOverWith: draggableId,
      draggingFromThisWith: null,
      isUsingPlaceholder: true
    };
    return {
      placeholder: dragging.placeholder,
      shouldAnimatePlaceholder: true,
      snapshot: snapshot,
      useClone: null
    };
  });

  var selector = function selector(state, ownProps) {
    var id = ownProps.droppableId;
    var type = ownProps.type;
    var isEnabled = !ownProps.isDropDisabled;
    var renderClone = ownProps.renderClone;

    if (state.isDragging) {
      var critical = state.critical;

      if (!isMatchingType(type, critical)) {
        return idleWithoutAnimation;
      }

      var dragging = getDraggable(critical, state.dimensions);
      var isDraggingOver = whatIsDraggedOver(state.impact) === id;
      return getMapProps(id, isEnabled, isDraggingOver, isDraggingOver, dragging, renderClone);
    }

    if (state.phase === 'DROP_ANIMATING') {
      var completed = state.completed;

      if (!isMatchingType(type, completed.critical)) {
        return idleWithoutAnimation;
      }

      var _dragging = getDraggable(completed.critical, state.dimensions);

      return getMapProps(id, isEnabled, whatIsDraggedOverFromResult(completed.result) === id, whatIsDraggedOver(completed.impact) === id, _dragging, renderClone);
    }

    if (state.phase === 'IDLE' && state.completed && !state.shouldFlush) {
      var _completed = state.completed;

      if (!isMatchingType(type, _completed.critical)) {
        return idleWithoutAnimation;
      }

      var wasOver = whatIsDraggedOver(_completed.impact) === id;
      var wasCombining = Boolean(_completed.impact.at && _completed.impact.at.type === 'COMBINE');
      var isHome = _completed.critical.droppable.id === id;

      if (wasOver) {
        return wasCombining ? idleWithAnimation : idleWithoutAnimation;
      }

      if (isHome) {
        return idleWithAnimation;
      }

      return idleWithoutAnimation;
    }

    return idleWithoutAnimation;
  };

  return selector;
};
var mapDispatchToProps$1 = {
  updateViewportMaxScroll: updateViewportMaxScroll
};

function getBody() {
  !document.body ?  false ? 0 : invariant(false) : void 0;
  return document.body;
}

var defaultProps = {
  mode: 'standard',
  type: 'DEFAULT',
  direction: 'vertical',
  isDropDisabled: false,
  isCombineEnabled: false,
  ignoreContainerClipping: false,
  renderClone: null,
  getContainerForClone: getBody
};
var ConnectedDroppable = reactRedux.connect(makeMapStateToProps$1, mapDispatchToProps$1, null, {
  context: StoreContext,
  pure: true,
  areStatePropsEqual: isStrictEqual
})(Droppable);
ConnectedDroppable.defaultProps = defaultProps;

exports.Z5 = DragDropContext;
exports._l = PublicDraggable;
exports.bK = ConnectedDroppable;
__webpack_unused_export__ = resetServerContext;
__webpack_unused_export__ = useKeyboardSensor;
__webpack_unused_export__ = useMouseSensor;
__webpack_unused_export__ = useTouchSensor;


/***/ }),

/***/ 880615:
/***/ ((module) => {

function _extends() {
  module.exports = _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  module.exports["default"] = module.exports, module.exports.__esModule = true;
  return _extends.apply(this, arguments);
}

module.exports = _extends;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ 617357:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var setPrototypeOf = __webpack_require__(986760);

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  setPrototypeOf(subClass, superClass);
}

module.exports = _inheritsLoose;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ 986760:
/***/ ((module) => {

function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  module.exports["default"] = module.exports, module.exports.__esModule = true;
  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ 335120:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(632278)["default"]);

exports.__esModule = true;
exports["default"] = exports.ReactReduxContext = void 0;

var _react = _interopRequireDefault(__webpack_require__(667294));

var ReactReduxContext = /*#__PURE__*/_react["default"].createContext(null);

exports.ReactReduxContext = ReactReduxContext;

if (false) {}

var _default = ReactReduxContext;
exports["default"] = _default;

/***/ }),

/***/ 957456:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(632278)["default"]);

var _interopRequireWildcard = (__webpack_require__(136889)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _react = _interopRequireWildcard(__webpack_require__(667294));

var _propTypes = _interopRequireDefault(__webpack_require__(45697));

var _Context = __webpack_require__(335120);

var _Subscription = __webpack_require__(907510);

var _useIsomorphicLayoutEffect = __webpack_require__(634253);

function Provider(_ref) {
  var store = _ref.store,
      context = _ref.context,
      children = _ref.children;
  var contextValue = (0, _react.useMemo)(function () {
    var subscription = (0, _Subscription.createSubscription)(store);
    subscription.onStateChange = subscription.notifyNestedSubs;
    return {
      store: store,
      subscription: subscription
    };
  }, [store]);
  var previousState = (0, _react.useMemo)(function () {
    return store.getState();
  }, [store]);
  (0, _useIsomorphicLayoutEffect.useIsomorphicLayoutEffect)(function () {
    var subscription = contextValue.subscription;
    subscription.trySubscribe();

    if (previousState !== store.getState()) {
      subscription.notifyNestedSubs();
    }

    return function () {
      subscription.tryUnsubscribe();
      subscription.onStateChange = null;
    };
  }, [contextValue, previousState]);
  var Context = context || _Context.ReactReduxContext;
  return /*#__PURE__*/_react["default"].createElement(Context.Provider, {
    value: contextValue
  }, children);
}

if (false) {}

var _default = Provider;
exports["default"] = _default;

/***/ }),

/***/ 256702:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(632278)["default"]);

var _interopRequireWildcard = (__webpack_require__(136889)["default"]);

exports.__esModule = true;
exports["default"] = connectAdvanced;

var _extends2 = _interopRequireDefault(__webpack_require__(665659));

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(__webpack_require__(821351));

var _hoistNonReactStatics = _interopRequireDefault(__webpack_require__(108679));

var _react = _interopRequireWildcard(__webpack_require__(667294));

var _reactIs = __webpack_require__(372973);

var _Subscription = __webpack_require__(907510);

var _useIsomorphicLayoutEffect = __webpack_require__(634253);

var _Context = __webpack_require__(335120);

var _excluded = ["getDisplayName", "methodName", "renderCountProp", "shouldHandleStateChanges", "storeKey", "withRef", "forwardRef", "context"],
    _excluded2 = ["reactReduxForwardedRef"];
// Define some constant arrays just to avoid re-creating these
var EMPTY_ARRAY = [];
var NO_SUBSCRIPTION_ARRAY = [null, null];

var stringifyComponent = function stringifyComponent(Comp) {
  try {
    return JSON.stringify(Comp);
  } catch (err) {
    return String(Comp);
  }
};

function storeStateUpdatesReducer(state, action) {
  var updateCount = state[1];
  return [action.payload, updateCount + 1];
}

function useIsomorphicLayoutEffectWithArgs(effectFunc, effectArgs, dependencies) {
  (0, _useIsomorphicLayoutEffect.useIsomorphicLayoutEffect)(function () {
    return effectFunc.apply(void 0, effectArgs);
  }, dependencies);
}

function captureWrapperProps(lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, actualChildProps, childPropsFromStoreUpdate, notifyNestedSubs) {
  // We want to capture the wrapper props and child props we used for later comparisons
  lastWrapperProps.current = wrapperProps;
  lastChildProps.current = actualChildProps;
  renderIsScheduled.current = false; // If the render was from a store update, clear out that reference and cascade the subscriber update

  if (childPropsFromStoreUpdate.current) {
    childPropsFromStoreUpdate.current = null;
    notifyNestedSubs();
  }
}

function subscribeUpdates(shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, childPropsFromStoreUpdate, notifyNestedSubs, forceComponentUpdateDispatch) {
  // If we're not subscribed to the store, nothing to do here
  if (!shouldHandleStateChanges) return; // Capture values for checking if and when this component unmounts

  var didUnsubscribe = false;
  var lastThrownError = null; // We'll run this callback every time a store subscription update propagates to this component

  var checkForUpdates = function checkForUpdates() {
    if (didUnsubscribe) {
      // Don't run stale listeners.
      // Redux doesn't guarantee unsubscriptions happen until next dispatch.
      return;
    }

    var latestStoreState = store.getState();
    var newChildProps, error;

    try {
      // Actually run the selector with the most recent store state and wrapper props
      // to determine what the child props should be
      newChildProps = childPropsSelector(latestStoreState, lastWrapperProps.current);
    } catch (e) {
      error = e;
      lastThrownError = e;
    }

    if (!error) {
      lastThrownError = null;
    } // If the child props haven't changed, nothing to do here - cascade the subscription update


    if (newChildProps === lastChildProps.current) {
      if (!renderIsScheduled.current) {
        notifyNestedSubs();
      }
    } else {
      // Save references to the new child props.  Note that we track the "child props from store update"
      // as a ref instead of a useState/useReducer because we need a way to determine if that value has
      // been processed.  If this went into useState/useReducer, we couldn't clear out the value without
      // forcing another re-render, which we don't want.
      lastChildProps.current = newChildProps;
      childPropsFromStoreUpdate.current = newChildProps;
      renderIsScheduled.current = true; // If the child props _did_ change (or we caught an error), this wrapper component needs to re-render

      forceComponentUpdateDispatch({
        type: 'STORE_UPDATED',
        payload: {
          error: error
        }
      });
    }
  }; // Actually subscribe to the nearest connected ancestor (or store)


  subscription.onStateChange = checkForUpdates;
  subscription.trySubscribe(); // Pull data from the store after first render in case the store has
  // changed since we began.

  checkForUpdates();

  var unsubscribeWrapper = function unsubscribeWrapper() {
    didUnsubscribe = true;
    subscription.tryUnsubscribe();
    subscription.onStateChange = null;

    if (lastThrownError) {
      // It's possible that we caught an error due to a bad mapState function, but the
      // parent re-rendered without this component and we're about to unmount.
      // This shouldn't happen as long as we do top-down subscriptions correctly, but
      // if we ever do those wrong, this throw will surface the error in our tests.
      // In that case, throw the error from here so it doesn't get lost.
      throw lastThrownError;
    }
  };

  return unsubscribeWrapper;
}

var initStateUpdates = function initStateUpdates() {
  return [null, 0];
};

function connectAdvanced(
/*
  selectorFactory is a func that is responsible for returning the selector function used to
  compute new props from state, props, and dispatch. For example:
     export default connectAdvanced((dispatch, options) => (state, props) => ({
      thing: state.things[props.thingId],
      saveThing: fields => dispatch(actionCreators.saveThing(props.thingId, fields)),
    }))(YourComponent)
   Access to dispatch is provided to the factory so selectorFactories can bind actionCreators
  outside of their selector as an optimization. Options passed to connectAdvanced are passed to
  the selectorFactory, along with displayName and WrappedComponent, as the second argument.
   Note that selectorFactory is responsible for all caching/memoization of inbound and outbound
  props. Do not use connectAdvanced directly without memoizing results between calls to your
  selector, otherwise the Connect component will re-render on every state or props change.
*/
selectorFactory, // options object:
_ref) {
  if (_ref === void 0) {
    _ref = {};
  }

  var _ref2 = _ref,
      _ref2$getDisplayName = _ref2.getDisplayName,
      getDisplayName = _ref2$getDisplayName === void 0 ? function (name) {
    return "ConnectAdvanced(" + name + ")";
  } : _ref2$getDisplayName,
      _ref2$methodName = _ref2.methodName,
      methodName = _ref2$methodName === void 0 ? 'connectAdvanced' : _ref2$methodName,
      _ref2$renderCountProp = _ref2.renderCountProp,
      renderCountProp = _ref2$renderCountProp === void 0 ? undefined : _ref2$renderCountProp,
      _ref2$shouldHandleSta = _ref2.shouldHandleStateChanges,
      shouldHandleStateChanges = _ref2$shouldHandleSta === void 0 ? true : _ref2$shouldHandleSta,
      _ref2$storeKey = _ref2.storeKey,
      storeKey = _ref2$storeKey === void 0 ? 'store' : _ref2$storeKey,
      _ref2$withRef = _ref2.withRef,
      withRef = _ref2$withRef === void 0 ? false : _ref2$withRef,
      _ref2$forwardRef = _ref2.forwardRef,
      forwardRef = _ref2$forwardRef === void 0 ? false : _ref2$forwardRef,
      _ref2$context = _ref2.context,
      context = _ref2$context === void 0 ? _Context.ReactReduxContext : _ref2$context,
      connectOptions = (0, _objectWithoutPropertiesLoose2["default"])(_ref2, _excluded);

  if (false) { var customStoreWarningMessage; }

  var Context = context;
  return function wrapWithConnect(WrappedComponent) {
    if (false) {}

    var wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || 'Component';
    var displayName = getDisplayName(wrappedComponentName);
    var selectorFactoryOptions = (0, _extends2["default"])({}, connectOptions, {
      getDisplayName: getDisplayName,
      methodName: methodName,
      renderCountProp: renderCountProp,
      shouldHandleStateChanges: shouldHandleStateChanges,
      storeKey: storeKey,
      displayName: displayName,
      wrappedComponentName: wrappedComponentName,
      WrappedComponent: WrappedComponent
    });
    var pure = connectOptions.pure;

    function createChildSelector(store) {
      return selectorFactory(store.dispatch, selectorFactoryOptions);
    } // If we aren't running in "pure" mode, we don't want to memoize values.
    // To avoid conditionally calling hooks, we fall back to a tiny wrapper
    // that just executes the given callback immediately.


    var usePureOnlyMemo = pure ? _react.useMemo : function (callback) {
      return callback();
    };

    function ConnectFunction(props) {
      var _useMemo = (0, _react.useMemo)(function () {
        // Distinguish between actual "data" props that were passed to the wrapper component,
        // and values needed to control behavior (forwarded refs, alternate context instances).
        // To maintain the wrapperProps object reference, memoize this destructuring.
        var reactReduxForwardedRef = props.reactReduxForwardedRef,
            wrapperProps = (0, _objectWithoutPropertiesLoose2["default"])(props, _excluded2);
        return [props.context, reactReduxForwardedRef, wrapperProps];
      }, [props]),
          propsContext = _useMemo[0],
          reactReduxForwardedRef = _useMemo[1],
          wrapperProps = _useMemo[2];

      var ContextToUse = (0, _react.useMemo)(function () {
        // Users may optionally pass in a custom context instance to use instead of our ReactReduxContext.
        // Memoize the check that determines which context instance we should use.
        return propsContext && propsContext.Consumer && (0, _reactIs.isContextConsumer)( /*#__PURE__*/_react["default"].createElement(propsContext.Consumer, null)) ? propsContext : Context;
      }, [propsContext, Context]); // Retrieve the store and ancestor subscription via context, if available

      var contextValue = (0, _react.useContext)(ContextToUse); // The store _must_ exist as either a prop or in context.
      // We'll check to see if it _looks_ like a Redux store first.
      // This allows us to pass through a `store` prop that is just a plain value.

      var didStoreComeFromProps = Boolean(props.store) && Boolean(props.store.getState) && Boolean(props.store.dispatch);
      var didStoreComeFromContext = Boolean(contextValue) && Boolean(contextValue.store);

      if (false) {} // Based on the previous check, one of these must be true


      var store = didStoreComeFromProps ? props.store : contextValue.store;
      var childPropsSelector = (0, _react.useMemo)(function () {
        // The child props selector needs the store reference as an input.
        // Re-create this selector whenever the store changes.
        return createChildSelector(store);
      }, [store]);

      var _useMemo2 = (0, _react.useMemo)(function () {
        if (!shouldHandleStateChanges) return NO_SUBSCRIPTION_ARRAY; // This Subscription's source should match where store came from: props vs. context. A component
        // connected to the store via props shouldn't use subscription from context, or vice versa.

        // This Subscription's source should match where store came from: props vs. context. A component
        // connected to the store via props shouldn't use subscription from context, or vice versa.
        var subscription = (0, _Subscription.createSubscription)(store, didStoreComeFromProps ? null : contextValue.subscription); // `notifyNestedSubs` is duplicated to handle the case where the component is unmounted in
        // the middle of the notification loop, where `subscription` will then be null. This can
        // probably be avoided if Subscription's listeners logic is changed to not call listeners
        // that have been unsubscribed in the  middle of the notification loop.

        // `notifyNestedSubs` is duplicated to handle the case where the component is unmounted in
        // the middle of the notification loop, where `subscription` will then be null. This can
        // probably be avoided if Subscription's listeners logic is changed to not call listeners
        // that have been unsubscribed in the  middle of the notification loop.
        var notifyNestedSubs = subscription.notifyNestedSubs.bind(subscription);
        return [subscription, notifyNestedSubs];
      }, [store, didStoreComeFromProps, contextValue]),
          subscription = _useMemo2[0],
          notifyNestedSubs = _useMemo2[1]; // Determine what {store, subscription} value should be put into nested context, if necessary,
      // and memoize that value to avoid unnecessary context updates.


      var overriddenContextValue = (0, _react.useMemo)(function () {
        if (didStoreComeFromProps) {
          // This component is directly subscribed to a store from props.
          // We don't want descendants reading from this store - pass down whatever
          // the existing context value is from the nearest connected ancestor.
          return contextValue;
        } // Otherwise, put this component's subscription instance into context, so that
        // connected descendants won't update until after this component is done


        return (0, _extends2["default"])({}, contextValue, {
          subscription: subscription
        });
      }, [didStoreComeFromProps, contextValue, subscription]); // We need to force this wrapper component to re-render whenever a Redux store update
      // causes a change to the calculated child component props (or we caught an error in mapState)

      var _useReducer = (0, _react.useReducer)(storeStateUpdatesReducer, EMPTY_ARRAY, initStateUpdates),
          _useReducer$ = _useReducer[0],
          previousStateUpdateResult = _useReducer$[0],
          forceComponentUpdateDispatch = _useReducer[1]; // Propagate any mapState/mapDispatch errors upwards


      if (previousStateUpdateResult && previousStateUpdateResult.error) {
        throw previousStateUpdateResult.error;
      } // Set up refs to coordinate values between the subscription effect and the render logic


      var lastChildProps = (0, _react.useRef)();
      var lastWrapperProps = (0, _react.useRef)(wrapperProps);
      var childPropsFromStoreUpdate = (0, _react.useRef)();
      var renderIsScheduled = (0, _react.useRef)(false);
      var actualChildProps = usePureOnlyMemo(function () {
        // Tricky logic here:
        // - This render may have been triggered by a Redux store update that produced new child props
        // - However, we may have gotten new wrapper props after that
        // If we have new child props, and the same wrapper props, we know we should use the new child props as-is.
        // But, if we have new wrapper props, those might change the child props, so we have to recalculate things.
        // So, we'll use the child props from store update only if the wrapper props are the same as last time.
        if (childPropsFromStoreUpdate.current && wrapperProps === lastWrapperProps.current) {
          return childPropsFromStoreUpdate.current;
        } // TODO We're reading the store directly in render() here. Bad idea?
        // This will likely cause Bad Things (TM) to happen in Concurrent Mode.
        // Note that we do this because on renders _not_ caused by store updates, we need the latest store state
        // to determine what the child props should be.


        return childPropsSelector(store.getState(), wrapperProps);
      }, [store, previousStateUpdateResult, wrapperProps]); // We need this to execute synchronously every time we re-render. However, React warns
      // about useLayoutEffect in SSR, so we try to detect environment and fall back to
      // just useEffect instead to avoid the warning, since neither will run anyway.

      useIsomorphicLayoutEffectWithArgs(captureWrapperProps, [lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, actualChildProps, childPropsFromStoreUpdate, notifyNestedSubs]); // Our re-subscribe logic only runs when the store/subscription setup changes

      useIsomorphicLayoutEffectWithArgs(subscribeUpdates, [shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, childPropsFromStoreUpdate, notifyNestedSubs, forceComponentUpdateDispatch], [store, subscription, childPropsSelector]); // Now that all that's done, we can finally try to actually render the child component.
      // We memoize the elements for the rendered child component as an optimization.

      var renderedWrappedComponent = (0, _react.useMemo)(function () {
        return /*#__PURE__*/_react["default"].createElement(WrappedComponent, (0, _extends2["default"])({}, actualChildProps, {
          ref: reactReduxForwardedRef
        }));
      }, [reactReduxForwardedRef, WrappedComponent, actualChildProps]); // If React sees the exact same element reference as last time, it bails out of re-rendering
      // that child, same as if it was wrapped in React.memo() or returned false from shouldComponentUpdate.

      var renderedChild = (0, _react.useMemo)(function () {
        if (shouldHandleStateChanges) {
          // If this component is subscribed to store updates, we need to pass its own
          // subscription instance down to our descendants. That means rendering the same
          // Context instance, and putting a different value into the context.
          return /*#__PURE__*/_react["default"].createElement(ContextToUse.Provider, {
            value: overriddenContextValue
          }, renderedWrappedComponent);
        }

        return renderedWrappedComponent;
      }, [ContextToUse, renderedWrappedComponent, overriddenContextValue]);
      return renderedChild;
    } // If we're in "pure" mode, ensure our wrapper component only re-renders when incoming props have changed.


    var Connect = pure ? _react["default"].memo(ConnectFunction) : ConnectFunction;
    Connect.WrappedComponent = WrappedComponent;
    Connect.displayName = ConnectFunction.displayName = displayName;

    if (forwardRef) {
      var forwarded = _react["default"].forwardRef(function forwardConnectRef(props, ref) {
        return /*#__PURE__*/_react["default"].createElement(Connect, (0, _extends2["default"])({}, props, {
          reactReduxForwardedRef: ref
        }));
      });

      forwarded.displayName = displayName;
      forwarded.WrappedComponent = WrappedComponent;
      return (0, _hoistNonReactStatics["default"])(forwarded, WrappedComponent);
    }

    return (0, _hoistNonReactStatics["default"])(Connect, WrappedComponent);
  };
}

/***/ }),

/***/ 469478:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(632278)["default"]);

exports.__esModule = true;
exports.createConnect = createConnect;
exports["default"] = void 0;

var _extends2 = _interopRequireDefault(__webpack_require__(665659));

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(__webpack_require__(821351));

var _connectAdvanced = _interopRequireDefault(__webpack_require__(256702));

var _shallowEqual = _interopRequireDefault(__webpack_require__(68761));

var _mapDispatchToProps = _interopRequireDefault(__webpack_require__(322333));

var _mapStateToProps = _interopRequireDefault(__webpack_require__(896188));

var _mergeProps = _interopRequireDefault(__webpack_require__(519442));

var _selectorFactory = _interopRequireDefault(__webpack_require__(556726));

var _excluded = ["pure", "areStatesEqual", "areOwnPropsEqual", "areStatePropsEqual", "areMergedPropsEqual"];

/*
  connect is a facade over connectAdvanced. It turns its args into a compatible
  selectorFactory, which has the signature:

    (dispatch, options) => (nextState, nextOwnProps) => nextFinalProps
  
  connect passes its args to connectAdvanced as options, which will in turn pass them to
  selectorFactory each time a Connect component instance is instantiated or hot reloaded.

  selectorFactory returns a final props selector from its mapStateToProps,
  mapStateToPropsFactories, mapDispatchToProps, mapDispatchToPropsFactories, mergeProps,
  mergePropsFactories, and pure args.

  The resulting final props selector is called by the Connect component instance whenever
  it receives new props or store state.
 */
function match(arg, factories, name) {
  for (var i = factories.length - 1; i >= 0; i--) {
    var result = factories[i](arg);
    if (result) return result;
  }

  return function (dispatch, options) {
    throw new Error("Invalid value of type " + typeof arg + " for " + name + " argument when connecting component " + options.wrappedComponentName + ".");
  };
}

function strictEqual(a, b) {
  return a === b;
} // createConnect with default args builds the 'official' connect behavior. Calling it with
// different options opens up some testing and extensibility scenarios


function createConnect(_temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      _ref$connectHOC = _ref.connectHOC,
      connectHOC = _ref$connectHOC === void 0 ? _connectAdvanced["default"] : _ref$connectHOC,
      _ref$mapStateToPropsF = _ref.mapStateToPropsFactories,
      mapStateToPropsFactories = _ref$mapStateToPropsF === void 0 ? _mapStateToProps["default"] : _ref$mapStateToPropsF,
      _ref$mapDispatchToPro = _ref.mapDispatchToPropsFactories,
      mapDispatchToPropsFactories = _ref$mapDispatchToPro === void 0 ? _mapDispatchToProps["default"] : _ref$mapDispatchToPro,
      _ref$mergePropsFactor = _ref.mergePropsFactories,
      mergePropsFactories = _ref$mergePropsFactor === void 0 ? _mergeProps["default"] : _ref$mergePropsFactor,
      _ref$selectorFactory = _ref.selectorFactory,
      selectorFactory = _ref$selectorFactory === void 0 ? _selectorFactory["default"] : _ref$selectorFactory;

  return function connect(mapStateToProps, mapDispatchToProps, mergeProps, _ref2) {
    if (_ref2 === void 0) {
      _ref2 = {};
    }

    var _ref3 = _ref2,
        _ref3$pure = _ref3.pure,
        pure = _ref3$pure === void 0 ? true : _ref3$pure,
        _ref3$areStatesEqual = _ref3.areStatesEqual,
        areStatesEqual = _ref3$areStatesEqual === void 0 ? strictEqual : _ref3$areStatesEqual,
        _ref3$areOwnPropsEqua = _ref3.areOwnPropsEqual,
        areOwnPropsEqual = _ref3$areOwnPropsEqua === void 0 ? _shallowEqual["default"] : _ref3$areOwnPropsEqua,
        _ref3$areStatePropsEq = _ref3.areStatePropsEqual,
        areStatePropsEqual = _ref3$areStatePropsEq === void 0 ? _shallowEqual["default"] : _ref3$areStatePropsEq,
        _ref3$areMergedPropsE = _ref3.areMergedPropsEqual,
        areMergedPropsEqual = _ref3$areMergedPropsE === void 0 ? _shallowEqual["default"] : _ref3$areMergedPropsE,
        extraOptions = (0, _objectWithoutPropertiesLoose2["default"])(_ref3, _excluded);
    var initMapStateToProps = match(mapStateToProps, mapStateToPropsFactories, 'mapStateToProps');
    var initMapDispatchToProps = match(mapDispatchToProps, mapDispatchToPropsFactories, 'mapDispatchToProps');
    var initMergeProps = match(mergeProps, mergePropsFactories, 'mergeProps');
    return connectHOC(selectorFactory, (0, _extends2["default"])({
      // used in error messages
      methodName: 'connect',
      // used to compute Connect's displayName from the wrapped component's displayName.
      getDisplayName: function getDisplayName(name) {
        return "Connect(" + name + ")";
      },
      // if mapStateToProps is falsy, the Connect component doesn't subscribe to store state changes
      shouldHandleStateChanges: Boolean(mapStateToProps),
      // passed through to selectorFactory
      initMapStateToProps: initMapStateToProps,
      initMapDispatchToProps: initMapDispatchToProps,
      initMergeProps: initMergeProps,
      pure: pure,
      areStatesEqual: areStatesEqual,
      areOwnPropsEqual: areOwnPropsEqual,
      areStatePropsEqual: areStatePropsEqual,
      areMergedPropsEqual: areMergedPropsEqual
    }, extraOptions));
  };
}

var _default = /*#__PURE__*/createConnect();

exports["default"] = _default;

/***/ }),

/***/ 322333:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(632278)["default"]);

exports.__esModule = true;
exports["default"] = void 0;
exports.whenMapDispatchToPropsIsFunction = whenMapDispatchToPropsIsFunction;
exports.whenMapDispatchToPropsIsMissing = whenMapDispatchToPropsIsMissing;
exports.whenMapDispatchToPropsIsObject = whenMapDispatchToPropsIsObject;

var _bindActionCreators = _interopRequireDefault(__webpack_require__(484502));

var _wrapMapToProps = __webpack_require__(959228);

function whenMapDispatchToPropsIsFunction(mapDispatchToProps) {
  return typeof mapDispatchToProps === 'function' ? (0, _wrapMapToProps.wrapMapToPropsFunc)(mapDispatchToProps, 'mapDispatchToProps') : undefined;
}

function whenMapDispatchToPropsIsMissing(mapDispatchToProps) {
  return !mapDispatchToProps ? (0, _wrapMapToProps.wrapMapToPropsConstant)(function (dispatch) {
    return {
      dispatch: dispatch
    };
  }) : undefined;
}

function whenMapDispatchToPropsIsObject(mapDispatchToProps) {
  return mapDispatchToProps && typeof mapDispatchToProps === 'object' ? (0, _wrapMapToProps.wrapMapToPropsConstant)(function (dispatch) {
    return (0, _bindActionCreators["default"])(mapDispatchToProps, dispatch);
  }) : undefined;
}

var _default = [whenMapDispatchToPropsIsFunction, whenMapDispatchToPropsIsMissing, whenMapDispatchToPropsIsObject];
exports["default"] = _default;

/***/ }),

/***/ 896188:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;
exports.whenMapStateToPropsIsFunction = whenMapStateToPropsIsFunction;
exports.whenMapStateToPropsIsMissing = whenMapStateToPropsIsMissing;

var _wrapMapToProps = __webpack_require__(959228);

function whenMapStateToPropsIsFunction(mapStateToProps) {
  return typeof mapStateToProps === 'function' ? (0, _wrapMapToProps.wrapMapToPropsFunc)(mapStateToProps, 'mapStateToProps') : undefined;
}

function whenMapStateToPropsIsMissing(mapStateToProps) {
  return !mapStateToProps ? (0, _wrapMapToProps.wrapMapToPropsConstant)(function () {
    return {};
  }) : undefined;
}

var _default = [whenMapStateToPropsIsFunction, whenMapStateToPropsIsMissing];
exports["default"] = _default;

/***/ }),

/***/ 519442:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(632278)["default"]);

exports.__esModule = true;
exports["default"] = void 0;
exports.defaultMergeProps = defaultMergeProps;
exports.whenMergePropsIsFunction = whenMergePropsIsFunction;
exports.whenMergePropsIsOmitted = whenMergePropsIsOmitted;
exports.wrapMergePropsFunc = wrapMergePropsFunc;

var _extends2 = _interopRequireDefault(__webpack_require__(665659));

var _verifyPlainObject = _interopRequireDefault(__webpack_require__(151758));

function defaultMergeProps(stateProps, dispatchProps, ownProps) {
  return (0, _extends2["default"])({}, ownProps, stateProps, dispatchProps);
}

function wrapMergePropsFunc(mergeProps) {
  return function initMergePropsProxy(dispatch, _ref) {
    var displayName = _ref.displayName,
        pure = _ref.pure,
        areMergedPropsEqual = _ref.areMergedPropsEqual;
    var hasRunOnce = false;
    var mergedProps;
    return function mergePropsProxy(stateProps, dispatchProps, ownProps) {
      var nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);

      if (hasRunOnce) {
        if (!pure || !areMergedPropsEqual(nextMergedProps, mergedProps)) mergedProps = nextMergedProps;
      } else {
        hasRunOnce = true;
        mergedProps = nextMergedProps;
        if (false) {}
      }

      return mergedProps;
    };
  };
}

function whenMergePropsIsFunction(mergeProps) {
  return typeof mergeProps === 'function' ? wrapMergePropsFunc(mergeProps) : undefined;
}

function whenMergePropsIsOmitted(mergeProps) {
  return !mergeProps ? function () {
    return defaultMergeProps;
  } : undefined;
}

var _default = [whenMergePropsIsFunction, whenMergePropsIsOmitted];
exports["default"] = _default;

/***/ }),

/***/ 556726:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(632278)["default"]);

exports.__esModule = true;
exports["default"] = finalPropsSelectorFactory;
exports.impureFinalPropsSelectorFactory = impureFinalPropsSelectorFactory;
exports.pureFinalPropsSelectorFactory = pureFinalPropsSelectorFactory;

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(__webpack_require__(821351));

var _verifySubselectors = _interopRequireDefault(__webpack_require__(781830));

var _excluded = ["initMapStateToProps", "initMapDispatchToProps", "initMergeProps"];

function impureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch) {
  return function impureFinalPropsSelector(state, ownProps) {
    return mergeProps(mapStateToProps(state, ownProps), mapDispatchToProps(dispatch, ownProps), ownProps);
  };
}

function pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, _ref) {
  var areStatesEqual = _ref.areStatesEqual,
      areOwnPropsEqual = _ref.areOwnPropsEqual,
      areStatePropsEqual = _ref.areStatePropsEqual;
  var hasRunAtLeastOnce = false;
  var state;
  var ownProps;
  var stateProps;
  var dispatchProps;
  var mergedProps;

  function handleFirstCall(firstState, firstOwnProps) {
    state = firstState;
    ownProps = firstOwnProps;
    stateProps = mapStateToProps(state, ownProps);
    dispatchProps = mapDispatchToProps(dispatch, ownProps);
    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    hasRunAtLeastOnce = true;
    return mergedProps;
  }

  function handleNewPropsAndNewState() {
    stateProps = mapStateToProps(state, ownProps);
    if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);
    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }

  function handleNewProps() {
    if (mapStateToProps.dependsOnOwnProps) stateProps = mapStateToProps(state, ownProps);
    if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);
    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }

  function handleNewState() {
    var nextStateProps = mapStateToProps(state, ownProps);
    var statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);
    stateProps = nextStateProps;
    if (statePropsChanged) mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }

  function handleSubsequentCalls(nextState, nextOwnProps) {
    var propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);
    var stateChanged = !areStatesEqual(nextState, state);
    state = nextState;
    ownProps = nextOwnProps;
    if (propsChanged && stateChanged) return handleNewPropsAndNewState();
    if (propsChanged) return handleNewProps();
    if (stateChanged) return handleNewState();
    return mergedProps;
  }

  return function pureFinalPropsSelector(nextState, nextOwnProps) {
    return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);
  };
} // TODO: Add more comments
// If pure is true, the selector returned by selectorFactory will memoize its results,
// allowing connectAdvanced's shouldComponentUpdate to return false if final
// props have not changed. If false, the selector will always return a new
// object and shouldComponentUpdate will always return true.


function finalPropsSelectorFactory(dispatch, _ref2) {
  var initMapStateToProps = _ref2.initMapStateToProps,
      initMapDispatchToProps = _ref2.initMapDispatchToProps,
      initMergeProps = _ref2.initMergeProps,
      options = (0, _objectWithoutPropertiesLoose2["default"])(_ref2, _excluded);
  var mapStateToProps = initMapStateToProps(dispatch, options);
  var mapDispatchToProps = initMapDispatchToProps(dispatch, options);
  var mergeProps = initMergeProps(dispatch, options);

  if (false) {}

  var selectorFactory = options.pure ? pureFinalPropsSelectorFactory : impureFinalPropsSelectorFactory;
  return selectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options);
}

/***/ }),

/***/ 781830:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(632278)["default"]);

exports.__esModule = true;
exports["default"] = verifySubselectors;

var _warning = _interopRequireDefault(__webpack_require__(393099));

function verify(selector, methodName, displayName) {
  if (!selector) {
    throw new Error("Unexpected value for " + methodName + " in " + displayName + ".");
  } else if (methodName === 'mapStateToProps' || methodName === 'mapDispatchToProps') {
    if (!Object.prototype.hasOwnProperty.call(selector, 'dependsOnOwnProps')) {
      (0, _warning["default"])("The selector for " + methodName + " of " + displayName + " did not specify a value for dependsOnOwnProps.");
    }
  }
}

function verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps, displayName) {
  verify(mapStateToProps, 'mapStateToProps', displayName);
  verify(mapDispatchToProps, 'mapDispatchToProps', displayName);
  verify(mergeProps, 'mergeProps', displayName);
}

/***/ }),

/***/ 959228:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(632278)["default"]);

exports.__esModule = true;
exports.getDependsOnOwnProps = getDependsOnOwnProps;
exports.wrapMapToPropsConstant = wrapMapToPropsConstant;
exports.wrapMapToPropsFunc = wrapMapToPropsFunc;

var _verifyPlainObject = _interopRequireDefault(__webpack_require__(151758));

function wrapMapToPropsConstant(getConstant) {
  return function initConstantSelector(dispatch, options) {
    var constant = getConstant(dispatch, options);

    function constantSelector() {
      return constant;
    }

    constantSelector.dependsOnOwnProps = false;
    return constantSelector;
  };
} // dependsOnOwnProps is used by createMapToPropsProxy to determine whether to pass props as args
// to the mapToProps function being wrapped. It is also used by makePurePropsSelector to determine
// whether mapToProps needs to be invoked when props have changed.
//
// A length of one signals that mapToProps does not depend on props from the parent component.
// A length of zero is assumed to mean mapToProps is getting args via arguments or ...args and
// therefore not reporting its length accurately..


function getDependsOnOwnProps(mapToProps) {
  return mapToProps.dependsOnOwnProps !== null && mapToProps.dependsOnOwnProps !== undefined ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;
} // Used by whenMapStateToPropsIsFunction and whenMapDispatchToPropsIsFunction,
// this function wraps mapToProps in a proxy function which does several things:
//
//  * Detects whether the mapToProps function being called depends on props, which
//    is used by selectorFactory to decide if it should reinvoke on props changes.
//
//  * On first call, handles mapToProps if returns another function, and treats that
//    new function as the true mapToProps for subsequent calls.
//
//  * On first call, verifies the first result is a plain object, in order to warn
//    the developer that their mapToProps function is not returning a valid result.
//


function wrapMapToPropsFunc(mapToProps, methodName) {
  return function initProxySelector(dispatch, _ref) {
    var displayName = _ref.displayName;

    var proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {
      return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch);
    }; // allow detectFactoryAndVerify to get ownProps


    proxy.dependsOnOwnProps = true;

    proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {
      proxy.mapToProps = mapToProps;
      proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);
      var props = proxy(stateOrDispatch, ownProps);

      if (typeof props === 'function') {
        proxy.mapToProps = props;
        proxy.dependsOnOwnProps = getDependsOnOwnProps(props);
        props = proxy(stateOrDispatch, ownProps);
      }

      if (false) {}
      return props;
    };

    return proxy;
  };
}

/***/ }),

/***/ 819124:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(632278)["default"]);

exports.__esModule = true;

var _Provider = _interopRequireDefault(__webpack_require__(957456));

exports.Provider = _Provider["default"];

var _connectAdvanced = _interopRequireDefault(__webpack_require__(256702));

exports.connectAdvanced = _connectAdvanced["default"];

var _Context = __webpack_require__(335120);

exports.ReactReduxContext = _Context.ReactReduxContext;

var _connect = _interopRequireDefault(__webpack_require__(469478));

exports.connect = _connect["default"];

var _useDispatch = __webpack_require__(885158);

exports.useDispatch = _useDispatch.useDispatch;
exports.createDispatchHook = _useDispatch.createDispatchHook;

var _useSelector = __webpack_require__(681033);

exports.useSelector = _useSelector.useSelector;
exports.createSelectorHook = _useSelector.createSelectorHook;

var _useStore = __webpack_require__(569269);

exports.useStore = _useStore.useStore;
exports.createStoreHook = _useStore.createStoreHook;

var _shallowEqual = _interopRequireDefault(__webpack_require__(68761));

exports.shallowEqual = _shallowEqual["default"];

/***/ }),

/***/ 885158:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports.createDispatchHook = createDispatchHook;
exports.useDispatch = void 0;

var _Context = __webpack_require__(335120);

var _useStore = __webpack_require__(569269);

/**
 * Hook factory, which creates a `useDispatch` hook bound to a given context.
 *
 * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.
 * @returns {Function} A `useDispatch` hook bound to the specified context.
 */
function createDispatchHook(context) {
  if (context === void 0) {
    context = _Context.ReactReduxContext;
  }

  var useStore = context === _Context.ReactReduxContext ? _useStore.useStore : (0, _useStore.createStoreHook)(context);
  return function useDispatch() {
    var store = useStore();
    return store.dispatch;
  };
}
/**
 * A hook to access the redux `dispatch` function.
 *
 * @returns {any|function} redux store's `dispatch` function
 *
 * @example
 *
 * import React, { useCallback } from 'react'
 * import { useDispatch } from 'react-redux'
 *
 * export const CounterComponent = ({ value }) => {
 *   const dispatch = useDispatch()
 *   const increaseCounter = useCallback(() => dispatch({ type: 'increase-counter' }), [])
 *   return (
 *     <div>
 *       <span>{value}</span>
 *       <button onClick={increaseCounter}>Increase counter</button>
 *     </div>
 *   )
 * }
 */


var useDispatch = /*#__PURE__*/createDispatchHook();
exports.useDispatch = useDispatch;

/***/ }),

/***/ 209723:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports.useReduxContext = useReduxContext;

var _react = __webpack_require__(667294);

var _Context = __webpack_require__(335120);

/**
 * A hook to access the value of the `ReactReduxContext`. This is a low-level
 * hook that you should usually not need to call directly.
 *
 * @returns {any} the value of the `ReactReduxContext`
 *
 * @example
 *
 * import React from 'react'
 * import { useReduxContext } from 'react-redux'
 *
 * export const CounterComponent = ({ value }) => {
 *   const { store } = useReduxContext()
 *   return <div>{store.getState()}</div>
 * }
 */
function useReduxContext() {
  var contextValue = (0, _react.useContext)(_Context.ReactReduxContext);

  if (false) {}

  return contextValue;
}

/***/ }),

/***/ 681033:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports.createSelectorHook = createSelectorHook;
exports.useSelector = void 0;

var _react = __webpack_require__(667294);

var _useReduxContext2 = __webpack_require__(209723);

var _Subscription = __webpack_require__(907510);

var _useIsomorphicLayoutEffect = __webpack_require__(634253);

var _Context = __webpack_require__(335120);

var refEquality = function refEquality(a, b) {
  return a === b;
};

function useSelectorWithStoreAndSubscription(selector, equalityFn, store, contextSub) {
  var _useReducer = (0, _react.useReducer)(function (s) {
    return s + 1;
  }, 0),
      forceRender = _useReducer[1];

  var subscription = (0, _react.useMemo)(function () {
    return (0, _Subscription.createSubscription)(store, contextSub);
  }, [store, contextSub]);
  var latestSubscriptionCallbackError = (0, _react.useRef)();
  var latestSelector = (0, _react.useRef)();
  var latestStoreState = (0, _react.useRef)();
  var latestSelectedState = (0, _react.useRef)();
  var storeState = store.getState();
  var selectedState;

  try {
    if (selector !== latestSelector.current || storeState !== latestStoreState.current || latestSubscriptionCallbackError.current) {
      var newSelectedState = selector(storeState); // ensure latest selected state is reused so that a custom equality function can result in identical references

      if (latestSelectedState.current === undefined || !equalityFn(newSelectedState, latestSelectedState.current)) {
        selectedState = newSelectedState;
      } else {
        selectedState = latestSelectedState.current;
      }
    } else {
      selectedState = latestSelectedState.current;
    }
  } catch (err) {
    if (latestSubscriptionCallbackError.current) {
      err.message += "\nThe error may be correlated with this previous error:\n" + latestSubscriptionCallbackError.current.stack + "\n\n";
    }

    throw err;
  }

  (0, _useIsomorphicLayoutEffect.useIsomorphicLayoutEffect)(function () {
    latestSelector.current = selector;
    latestStoreState.current = storeState;
    latestSelectedState.current = selectedState;
    latestSubscriptionCallbackError.current = undefined;
  });
  (0, _useIsomorphicLayoutEffect.useIsomorphicLayoutEffect)(function () {
    function checkForUpdates() {
      try {
        var newStoreState = store.getState(); // Avoid calling selector multiple times if the store's state has not changed

        if (newStoreState === latestStoreState.current) {
          return;
        }

        var _newSelectedState = latestSelector.current(newStoreState);

        if (equalityFn(_newSelectedState, latestSelectedState.current)) {
          return;
        }

        latestSelectedState.current = _newSelectedState;
        latestStoreState.current = newStoreState;
      } catch (err) {
        // we ignore all errors here, since when the component
        // is re-rendered, the selectors are called again, and
        // will throw again, if neither props nor store state
        // changed
        latestSubscriptionCallbackError.current = err;
      }

      forceRender();
    }

    subscription.onStateChange = checkForUpdates;
    subscription.trySubscribe();
    checkForUpdates();
    return function () {
      return subscription.tryUnsubscribe();
    };
  }, [store, subscription]);
  return selectedState;
}
/**
 * Hook factory, which creates a `useSelector` hook bound to a given context.
 *
 * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.
 * @returns {Function} A `useSelector` hook bound to the specified context.
 */


function createSelectorHook(context) {
  if (context === void 0) {
    context = _Context.ReactReduxContext;
  }

  var useReduxContext = context === _Context.ReactReduxContext ? _useReduxContext2.useReduxContext : function () {
    return (0, _react.useContext)(context);
  };
  return function useSelector(selector, equalityFn) {
    if (equalityFn === void 0) {
      equalityFn = refEquality;
    }

    if (false) {}

    var _useReduxContext = useReduxContext(),
        store = _useReduxContext.store,
        contextSub = _useReduxContext.subscription;

    var selectedState = useSelectorWithStoreAndSubscription(selector, equalityFn, store, contextSub);
    (0, _react.useDebugValue)(selectedState);
    return selectedState;
  };
}
/**
 * A hook to access the redux store's state. This hook takes a selector function
 * as an argument. The selector is called with the store state.
 *
 * This hook takes an optional equality comparison function as the second parameter
 * that allows you to customize the way the selected state is compared to determine
 * whether the component needs to be re-rendered.
 *
 * @param {Function} selector the selector function
 * @param {Function=} equalityFn the function that will be used to determine equality
 *
 * @returns {any} the selected state
 *
 * @example
 *
 * import React from 'react'
 * import { useSelector } from 'react-redux'
 *
 * export const CounterComponent = () => {
 *   const counter = useSelector(state => state.counter)
 *   return <div>{counter}</div>
 * }
 */


var useSelector = /*#__PURE__*/createSelectorHook();
exports.useSelector = useSelector;

/***/ }),

/***/ 569269:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports.createStoreHook = createStoreHook;
exports.useStore = void 0;

var _react = __webpack_require__(667294);

var _Context = __webpack_require__(335120);

var _useReduxContext2 = __webpack_require__(209723);

/**
 * Hook factory, which creates a `useStore` hook bound to a given context.
 *
 * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.
 * @returns {Function} A `useStore` hook bound to the specified context.
 */
function createStoreHook(context) {
  if (context === void 0) {
    context = _Context.ReactReduxContext;
  }

  var useReduxContext = context === _Context.ReactReduxContext ? _useReduxContext2.useReduxContext : function () {
    return (0, _react.useContext)(context);
  };
  return function useStore() {
    var _useReduxContext = useReduxContext(),
        store = _useReduxContext.store;

    return store;
  };
}
/**
 * A hook to access the redux store.
 *
 * @returns {any} the redux store
 *
 * @example
 *
 * import React from 'react'
 * import { useStore } from 'react-redux'
 *
 * export const ExampleComponent = () => {
 *   const store = useStore()
 *   return <div>{store.getState()}</div>
 * }
 */


var useStore = /*#__PURE__*/createStoreHook();
exports.useStore = useStore;

/***/ }),

/***/ 837424:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
var _exportNames = {
  batch: true
};

var _exports = __webpack_require__(819124);

Object.keys(_exports).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _exports[key]) return;
  exports[key] = _exports[key];
});

var _reactBatchedUpdates = __webpack_require__(992581);

exports.batch = _reactBatchedUpdates.unstable_batchedUpdates;

var _batch = __webpack_require__(667852);

// Enable batched updates in our subscriptions for use
// with standard React renderers (ReactDOM, React Native)
(0, _batch.setBatch)(_reactBatchedUpdates.unstable_batchedUpdates);

/***/ }),

/***/ 907510:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports.createSubscription = createSubscription;

var _batch = __webpack_require__(667852);

// encapsulates the subscription logic for connecting a component to the redux store, as
// well as nesting subscriptions of descendant components, so that we can ensure the
// ancestor components re-render before descendants
function createListenerCollection() {
  var batch = (0, _batch.getBatch)();
  var first = null;
  var last = null;
  return {
    clear: function clear() {
      first = null;
      last = null;
    },
    notify: function notify() {
      batch(function () {
        var listener = first;

        while (listener) {
          listener.callback();
          listener = listener.next;
        }
      });
    },
    get: function get() {
      var listeners = [];
      var listener = first;

      while (listener) {
        listeners.push(listener);
        listener = listener.next;
      }

      return listeners;
    },
    subscribe: function subscribe(callback) {
      var isSubscribed = true;
      var listener = last = {
        callback: callback,
        next: null,
        prev: last
      };

      if (listener.prev) {
        listener.prev.next = listener;
      } else {
        first = listener;
      }

      return function unsubscribe() {
        if (!isSubscribed || first === null) return;
        isSubscribed = false;

        if (listener.next) {
          listener.next.prev = listener.prev;
        } else {
          last = listener.prev;
        }

        if (listener.prev) {
          listener.prev.next = listener.next;
        } else {
          first = listener.next;
        }
      };
    }
  };
}

var nullListeners = {
  notify: function notify() {},
  get: function get() {
    return [];
  }
};

function createSubscription(store, parentSub) {
  var unsubscribe;
  var listeners = nullListeners;

  function addNestedSub(listener) {
    trySubscribe();
    return listeners.subscribe(listener);
  }

  function notifyNestedSubs() {
    listeners.notify();
  }

  function handleChangeWrapper() {
    if (subscription.onStateChange) {
      subscription.onStateChange();
    }
  }

  function isSubscribed() {
    return Boolean(unsubscribe);
  }

  function trySubscribe() {
    if (!unsubscribe) {
      unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store.subscribe(handleChangeWrapper);
      listeners = createListenerCollection();
    }
  }

  function tryUnsubscribe() {
    if (unsubscribe) {
      unsubscribe();
      unsubscribe = undefined;
      listeners.clear();
      listeners = nullListeners;
    }
  }

  var subscription = {
    addNestedSub: addNestedSub,
    notifyNestedSubs: notifyNestedSubs,
    handleChangeWrapper: handleChangeWrapper,
    isSubscribed: isSubscribed,
    trySubscribe: trySubscribe,
    tryUnsubscribe: tryUnsubscribe,
    getListeners: function getListeners() {
      return listeners;
    }
  };
  return subscription;
}

/***/ }),

/***/ 667852:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.__esModule = true;
exports.setBatch = exports.getBatch = void 0;

// Default to a dummy "batch" implementation that just runs the callback
function defaultNoopBatch(callback) {
  callback();
}

var batch = defaultNoopBatch; // Allow injecting another batching function later

var setBatch = function setBatch(newBatch) {
  return batch = newBatch;
}; // Supply a getter just to skip dealing with ESM bindings


exports.setBatch = setBatch;

var getBatch = function getBatch() {
  return batch;
};

exports.getBatch = getBatch;

/***/ }),

/***/ 484502:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.__esModule = true;
exports["default"] = bindActionCreators;

function bindActionCreators(actionCreators, dispatch) {
  var boundActionCreators = {};

  var _loop = function _loop(key) {
    var actionCreator = actionCreators[key];

    if (typeof actionCreator === 'function') {
      boundActionCreators[key] = function () {
        return dispatch(actionCreator.apply(void 0, arguments));
      };
    }
  };

  for (var key in actionCreators) {
    _loop(key);
  }

  return boundActionCreators;
}

/***/ }),

/***/ 901442:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.__esModule = true;
exports["default"] = isPlainObject;

/**
 * @param {any} obj The object to inspect.
 * @returns {boolean} True if the argument appears to be a plain object.
 */
function isPlainObject(obj) {
  if (typeof obj !== 'object' || obj === null) return false;
  var proto = Object.getPrototypeOf(obj);
  if (proto === null) return true;
  var baseProto = proto;

  while (Object.getPrototypeOf(baseProto) !== null) {
    baseProto = Object.getPrototypeOf(baseProto);
  }

  return proto === baseProto;
}

/***/ }),

/***/ 992581:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports.unstable_batchedUpdates = void 0;

var _reactDom = __webpack_require__(973935);

exports.unstable_batchedUpdates = _reactDom.unstable_batchedUpdates;

/***/ }),

/***/ 68761:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.__esModule = true;
exports["default"] = shallowEqual;

function is(x, y) {
  if (x === y) {
    return x !== 0 || y !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}

function shallowEqual(objA, objB) {
  if (is(objA, objB)) return true;

  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);
  if (keysA.length !== keysB.length) return false;

  for (var i = 0; i < keysA.length; i++) {
    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }

  return true;
}

/***/ }),

/***/ 634253:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports.useIsomorphicLayoutEffect = void 0;

var _react = __webpack_require__(667294);

// React currently throws a warning when using useLayoutEffect on the server.
// To get around it, we can conditionally useEffect on the server (no-op) and
// useLayoutEffect in the browser. We need useLayoutEffect to ensure the store
// subscription callback always has the selector from the latest render commit
// available, otherwise a store update may happen between render and the effect,
// which may cause missed updates; we also must ensure the store subscription
// is created synchronously, otherwise a store update may occur before the
// subscription is created and an inconsistent state may be observed
var useIsomorphicLayoutEffect = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined' ? _react.useLayoutEffect : _react.useEffect;
exports.useIsomorphicLayoutEffect = useIsomorphicLayoutEffect;

/***/ }),

/***/ 151758:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(632278)["default"]);

exports.__esModule = true;
exports["default"] = verifyPlainObject;

var _isPlainObject = _interopRequireDefault(__webpack_require__(901442));

var _warning = _interopRequireDefault(__webpack_require__(393099));

function verifyPlainObject(value, displayName, methodName) {
  if (!(0, _isPlainObject["default"])(value)) {
    (0, _warning["default"])(methodName + "() in " + displayName + " must return a plain object. Instead received " + value + ".");
  }
}

/***/ }),

/***/ 393099:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.__esModule = true;
exports["default"] = warning;

/**
 * Prints a warning in the console if it exists.
 *
 * @param {String} message The warning message.
 * @returns {void}
 */
function warning(message) {
  /* eslint-disable no-console */
  if (typeof console !== 'undefined' && typeof console.error === 'function') {
    console.error(message);
  }
  /* eslint-enable no-console */


  try {
    // This error was thrown as a convenience so that if you enable
    // "break on all exceptions" in your console,
    // it would pause the execution at this line.
    throw new Error(message);
    /* eslint-disable no-empty */
  } catch (e) {}
  /* eslint-enable no-empty */

}

/***/ }),

/***/ 665659:
/***/ ((module) => {

function _extends() {
  module.exports = _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  module.exports["default"] = module.exports, module.exports.__esModule = true;
  return _extends.apply(this, arguments);
}

module.exports = _extends;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ 632278:
/***/ ((module) => {

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

module.exports = _interopRequireDefault;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ 136889:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _typeof = (__webpack_require__(58945)["default"]);

function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function") return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}

function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache(nodeInterop);

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

module.exports = _interopRequireWildcard;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ 821351:
/***/ ((module) => {

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

module.exports = _objectWithoutPropertiesLoose;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ 58945:
/***/ ((module) => {

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };

    module.exports["default"] = module.exports, module.exports.__esModule = true;
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };

    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }

  return _typeof(obj);
}

module.exports = _typeof;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ 88359:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/** @license React v17.0.2
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b=60103,c=60106,d=60107,e=60108,f=60114,g=60109,h=60110,k=60112,l=60113,m=60120,n=60115,p=60116,q=60121,r=60122,u=60117,v=60129,w=60131;
if("function"===typeof Symbol&&Symbol.for){var x=Symbol.for;b=x("react.element");c=x("react.portal");d=x("react.fragment");e=x("react.strict_mode");f=x("react.profiler");g=x("react.provider");h=x("react.context");k=x("react.forward_ref");l=x("react.suspense");m=x("react.suspense_list");n=x("react.memo");p=x("react.lazy");q=x("react.block");r=x("react.server.block");u=x("react.fundamental");v=x("react.debug_trace_mode");w=x("react.legacy_hidden")}
function y(a){if("object"===typeof a&&null!==a){var t=a.$$typeof;switch(t){case b:switch(a=a.type,a){case d:case f:case e:case l:case m:return a;default:switch(a=a&&a.$$typeof,a){case h:case k:case p:case n:case g:return a;default:return t}}case c:return t}}}var z=g,A=b,B=k,C=d,D=p,E=n,F=c,G=f,H=e,I=l;exports.ContextConsumer=h;exports.ContextProvider=z;exports.Element=A;exports.ForwardRef=B;exports.Fragment=C;exports.Lazy=D;exports.Memo=E;exports.Portal=F;exports.Profiler=G;exports.StrictMode=H;
exports.Suspense=I;exports.isAsyncMode=function(){return!1};exports.isConcurrentMode=function(){return!1};exports.isContextConsumer=function(a){return y(a)===h};exports.isContextProvider=function(a){return y(a)===g};exports.isElement=function(a){return"object"===typeof a&&null!==a&&a.$$typeof===b};exports.isForwardRef=function(a){return y(a)===k};exports.isFragment=function(a){return y(a)===d};exports.isLazy=function(a){return y(a)===p};exports.isMemo=function(a){return y(a)===n};
exports.isPortal=function(a){return y(a)===c};exports.isProfiler=function(a){return y(a)===f};exports.isStrictMode=function(a){return y(a)===e};exports.isSuspense=function(a){return y(a)===l};exports.isValidElementType=function(a){return"string"===typeof a||"function"===typeof a||a===d||a===f||a===v||a===e||a===l||a===m||a===w||"object"===typeof a&&null!==a&&(a.$$typeof===p||a.$$typeof===n||a.$$typeof===g||a.$$typeof===h||a.$$typeof===k||a.$$typeof===u||a.$$typeof===q||a[0]===r)?!0:!1};
exports.typeOf=y;


/***/ }),

/***/ 372973:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (true) {
  module.exports = __webpack_require__(88359);
} else {}


/***/ }),

/***/ 535281:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var _objectSpread = __webpack_require__(778161);

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var _objectSpread__default = /*#__PURE__*/_interopDefaultLegacy(_objectSpread);

/**
 * Adapted from React: https://github.com/facebook/react/blob/master/packages/shared/formatProdErrorMessage.js
 *
 * Do not require this module directly! Use normal throw error calls. These messages will be replaced with error codes
 * during build.
 * @param {number} code
 */
function formatProdErrorMessage(code) {
  return "Minified Redux error #" + code + "; visit https://redux.js.org/Errors?code=" + code + " for the full message or " + 'use the non-minified dev environment for full errors. ';
}

// Inlined version of the `symbol-observable` polyfill
var $$observable = (function () {
  return typeof Symbol === 'function' && Symbol.observable || '@@observable';
})();

/**
 * These are private action types reserved by Redux.
 * For any unknown actions, you must return the current state.
 * If the current state is undefined, you must return the initial state.
 * Do not reference these action types directly in your code.
 */
var randomString = function randomString() {
  return Math.random().toString(36).substring(7).split('').join('.');
};

var ActionTypes = {
  INIT: "@@redux/INIT" + randomString(),
  REPLACE: "@@redux/REPLACE" + randomString(),
  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
    return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
  }
};

/**
 * @param {any} obj The object to inspect.
 * @returns {boolean} True if the argument appears to be a plain object.
 */
function isPlainObject(obj) {
  if (typeof obj !== 'object' || obj === null) return false;
  var proto = obj;

  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }

  return Object.getPrototypeOf(obj) === proto;
}

// Inlined / shortened version of `kindOf` from https://github.com/jonschlinkert/kind-of
function miniKindOf(val) {
  if (val === void 0) return 'undefined';
  if (val === null) return 'null';
  var type = typeof val;

  switch (type) {
    case 'boolean':
    case 'string':
    case 'number':
    case 'symbol':
    case 'function':
      {
        return type;
      }
  }

  if (Array.isArray(val)) return 'array';
  if (isDate(val)) return 'date';
  if (isError(val)) return 'error';
  var constructorName = ctorName(val);

  switch (constructorName) {
    case 'Symbol':
    case 'Promise':
    case 'WeakMap':
    case 'WeakSet':
    case 'Map':
    case 'Set':
      return constructorName;
  } // other


  return type.slice(8, -1).toLowerCase().replace(/\s/g, '');
}

function ctorName(val) {
  return typeof val.constructor === 'function' ? val.constructor.name : null;
}

function isError(val) {
  return val instanceof Error || typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number';
}

function isDate(val) {
  if (val instanceof Date) return true;
  return typeof val.toDateString === 'function' && typeof val.getDate === 'function' && typeof val.setDate === 'function';
}

function kindOf(val) {
  var typeOfVal = typeof val;

  if (false) {}

  return typeOfVal;
}

/**
 * Creates a Redux store that holds the state tree.
 * The only way to change the data in the store is to call `dispatch()` on it.
 *
 * There should only be a single store in your app. To specify how different
 * parts of the state tree respond to actions, you may combine several reducers
 * into a single reducer function by using `combineReducers`.
 *
 * @param {Function} reducer A function that returns the next state tree, given
 * the current state tree and the action to handle.
 *
 * @param {any} [preloadedState] The initial state. You may optionally specify it
 * to hydrate the state from the server in universal apps, or to restore a
 * previously serialized user session.
 * If you use `combineReducers` to produce the root reducer function, this must be
 * an object with the same shape as `combineReducers` keys.
 *
 * @param {Function} [enhancer] The store enhancer. You may optionally specify it
 * to enhance the store with third-party capabilities such as middleware,
 * time travel, persistence, etc. The only store enhancer that ships with Redux
 * is `applyMiddleware()`.
 *
 * @returns {Store} A Redux store that lets you read the state, dispatch actions
 * and subscribe to changes.
 */

function createStore(reducer, preloadedState, enhancer) {
  var _ref2;

  if (typeof preloadedState === 'function' && typeof enhancer === 'function' || typeof enhancer === 'function' && typeof arguments[3] === 'function') {
    throw new Error( true ? formatProdErrorMessage(0) : 0);
  }

  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
    enhancer = preloadedState;
    preloadedState = undefined;
  }

  if (typeof enhancer !== 'undefined') {
    if (typeof enhancer !== 'function') {
      throw new Error( true ? formatProdErrorMessage(1) : 0);
    }

    return enhancer(createStore)(reducer, preloadedState);
  }

  if (typeof reducer !== 'function') {
    throw new Error( true ? formatProdErrorMessage(2) : 0);
  }

  var currentReducer = reducer;
  var currentState = preloadedState;
  var currentListeners = [];
  var nextListeners = currentListeners;
  var isDispatching = false;
  /**
   * This makes a shallow copy of currentListeners so we can use
   * nextListeners as a temporary list while dispatching.
   *
   * This prevents any bugs around consumers calling
   * subscribe/unsubscribe in the middle of a dispatch.
   */

  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }
  /**
   * Reads the state tree managed by the store.
   *
   * @returns {any} The current state tree of your application.
   */


  function getState() {
    if (isDispatching) {
      throw new Error( true ? formatProdErrorMessage(3) : 0);
    }

    return currentState;
  }
  /**
   * Adds a change listener. It will be called any time an action is dispatched,
   * and some part of the state tree may potentially have changed. You may then
   * call `getState()` to read the current state tree inside the callback.
   *
   * You may call `dispatch()` from a change listener, with the following
   * caveats:
   *
   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
   * If you subscribe or unsubscribe while the listeners are being invoked, this
   * will not have any effect on the `dispatch()` that is currently in progress.
   * However, the next `dispatch()` call, whether nested or not, will use a more
   * recent snapshot of the subscription list.
   *
   * 2. The listener should not expect to see all state changes, as the state
   * might have been updated multiple times during a nested `dispatch()` before
   * the listener is called. It is, however, guaranteed that all subscribers
   * registered before the `dispatch()` started will be called with the latest
   * state by the time it exits.
   *
   * @param {Function} listener A callback to be invoked on every dispatch.
   * @returns {Function} A function to remove this change listener.
   */


  function subscribe(listener) {
    if (typeof listener !== 'function') {
      throw new Error( true ? formatProdErrorMessage(4) : 0);
    }

    if (isDispatching) {
      throw new Error( true ? formatProdErrorMessage(5) : 0);
    }

    var isSubscribed = true;
    ensureCanMutateNextListeners();
    nextListeners.push(listener);
    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }

      if (isDispatching) {
        throw new Error( true ? formatProdErrorMessage(6) : 0);
      }

      isSubscribed = false;
      ensureCanMutateNextListeners();
      var index = nextListeners.indexOf(listener);
      nextListeners.splice(index, 1);
      currentListeners = null;
    };
  }
  /**
   * Dispatches an action. It is the only way to trigger a state change.
   *
   * The `reducer` function, used to create the store, will be called with the
   * current state tree and the given `action`. Its return value will
   * be considered the **next** state of the tree, and the change listeners
   * will be notified.
   *
   * The base implementation only supports plain object actions. If you want to
   * dispatch a Promise, an Observable, a thunk, or something else, you need to
   * wrap your store creating function into the corresponding middleware. For
   * example, see the documentation for the `redux-thunk` package. Even the
   * middleware will eventually dispatch plain object actions using this method.
   *
   * @param {Object} action A plain object representing “what changed”. It is
   * a good idea to keep actions serializable so you can record and replay user
   * sessions, or use the time travelling `redux-devtools`. An action must have
   * a `type` property which may not be `undefined`. It is a good idea to use
   * string constants for action types.
   *
   * @returns {Object} For convenience, the same action object you dispatched.
   *
   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
   * return something else (for example, a Promise you can await).
   */


  function dispatch(action) {
    if (!isPlainObject(action)) {
      throw new Error( true ? formatProdErrorMessage(7) : 0);
    }

    if (typeof action.type === 'undefined') {
      throw new Error( true ? formatProdErrorMessage(8) : 0);
    }

    if (isDispatching) {
      throw new Error( true ? formatProdErrorMessage(9) : 0);
    }

    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }

    var listeners = currentListeners = nextListeners;

    for (var i = 0; i < listeners.length; i++) {
      var listener = listeners[i];
      listener();
    }

    return action;
  }
  /**
   * Replaces the reducer currently used by the store to calculate the state.
   *
   * You might need this if your app implements code splitting and you want to
   * load some of the reducers dynamically. You might also need this if you
   * implement a hot reloading mechanism for Redux.
   *
   * @param {Function} nextReducer The reducer for the store to use instead.
   * @returns {void}
   */


  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== 'function') {
      throw new Error( true ? formatProdErrorMessage(10) : 0);
    }

    currentReducer = nextReducer; // This action has a similiar effect to ActionTypes.INIT.
    // Any reducers that existed in both the new and old rootReducer
    // will receive the previous state. This effectively populates
    // the new state tree with any relevant data from the old one.

    dispatch({
      type: ActionTypes.REPLACE
    });
  }
  /**
   * Interoperability point for observable/reactive libraries.
   * @returns {observable} A minimal observable of state changes.
   * For more information, see the observable proposal:
   * https://github.com/tc39/proposal-observable
   */


  function observable() {
    var _ref;

    var outerSubscribe = subscribe;
    return _ref = {
      /**
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe: function subscribe(observer) {
        if (typeof observer !== 'object' || observer === null) {
          throw new Error( true ? formatProdErrorMessage(11) : 0);
        }

        function observeState() {
          if (observer.next) {
            observer.next(getState());
          }
        }

        observeState();
        var unsubscribe = outerSubscribe(observeState);
        return {
          unsubscribe: unsubscribe
        };
      }
    }, _ref[$$observable] = function () {
      return this;
    }, _ref;
  } // When a store is created, an "INIT" action is dispatched so that every
  // reducer returns their initial state. This effectively populates
  // the initial state tree.


  dispatch({
    type: ActionTypes.INIT
  });
  return _ref2 = {
    dispatch: dispatch,
    subscribe: subscribe,
    getState: getState,
    replaceReducer: replaceReducer
  }, _ref2[$$observable] = observable, _ref2;
}

/**
 * Prints a warning in the console if it exists.
 *
 * @param {String} message The warning message.
 * @returns {void}
 */
function warning(message) {
  /* eslint-disable no-console */
  if (typeof console !== 'undefined' && typeof console.error === 'function') {
    console.error(message);
  }
  /* eslint-enable no-console */


  try {
    // This error was thrown as a convenience so that if you enable
    // "break on all exceptions" in your console,
    // it would pause the execution at this line.
    throw new Error(message);
  } catch (e) {} // eslint-disable-line no-empty

}

function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
  var reducerKeys = Object.keys(reducers);
  var argumentName = action && action.type === ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';

  if (reducerKeys.length === 0) {
    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
  }

  if (!isPlainObject(inputState)) {
    return "The " + argumentName + " has unexpected type of \"" + kindOf(inputState) + "\". Expected argument to be an object with the following " + ("keys: \"" + reducerKeys.join('", "') + "\"");
  }

  var unexpectedKeys = Object.keys(inputState).filter(function (key) {
    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];
  });
  unexpectedKeys.forEach(function (key) {
    unexpectedKeyCache[key] = true;
  });
  if (action && action.type === ActionTypes.REPLACE) return;

  if (unexpectedKeys.length > 0) {
    return "Unexpected " + (unexpectedKeys.length > 1 ? 'keys' : 'key') + " " + ("\"" + unexpectedKeys.join('", "') + "\" found in " + argumentName + ". ") + "Expected to find one of the known reducer keys instead: " + ("\"" + reducerKeys.join('", "') + "\". Unexpected keys will be ignored.");
  }
}

function assertReducerShape(reducers) {
  Object.keys(reducers).forEach(function (key) {
    var reducer = reducers[key];
    var initialState = reducer(undefined, {
      type: ActionTypes.INIT
    });

    if (typeof initialState === 'undefined') {
      throw new Error( true ? formatProdErrorMessage(12) : 0);
    }

    if (typeof reducer(undefined, {
      type: ActionTypes.PROBE_UNKNOWN_ACTION()
    }) === 'undefined') {
      throw new Error( true ? formatProdErrorMessage(13) : 0);
    }
  });
}
/**
 * Turns an object whose values are different reducer functions, into a single
 * reducer function. It will call every child reducer, and gather their results
 * into a single state object, whose keys correspond to the keys of the passed
 * reducer functions.
 *
 * @param {Object} reducers An object whose values correspond to different
 * reducer functions that need to be combined into one. One handy way to obtain
 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
 * undefined for any action. Instead, they should return their initial state
 * if the state passed to them was undefined, and the current state for any
 * unrecognized action.
 *
 * @returns {Function} A reducer function that invokes every reducer inside the
 * passed object, and builds a state object with the same shape.
 */


function combineReducers(reducers) {
  var reducerKeys = Object.keys(reducers);
  var finalReducers = {};

  for (var i = 0; i < reducerKeys.length; i++) {
    var key = reducerKeys[i];

    if (false) {}

    if (typeof reducers[key] === 'function') {
      finalReducers[key] = reducers[key];
    }
  }

  var finalReducerKeys = Object.keys(finalReducers); // This is used to make sure we don't warn about the same
  // keys multiple times.

  var unexpectedKeyCache;

  if (false) {}

  var shapeAssertionError;

  try {
    assertReducerShape(finalReducers);
  } catch (e) {
    shapeAssertionError = e;
  }

  return function combination(state, action) {
    if (state === void 0) {
      state = {};
    }

    if (shapeAssertionError) {
      throw shapeAssertionError;
    }

    if (false) { var warningMessage; }

    var hasChanged = false;
    var nextState = {};

    for (var _i = 0; _i < finalReducerKeys.length; _i++) {
      var _key = finalReducerKeys[_i];
      var reducer = finalReducers[_key];
      var previousStateForKey = state[_key];
      var nextStateForKey = reducer(previousStateForKey, action);

      if (typeof nextStateForKey === 'undefined') {
        var actionType = action && action.type;
        throw new Error( true ? formatProdErrorMessage(14) : 0);
      }

      nextState[_key] = nextStateForKey;
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    }

    hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
    return hasChanged ? nextState : state;
  };
}

function bindActionCreator(actionCreator, dispatch) {
  return function () {
    return dispatch(actionCreator.apply(this, arguments));
  };
}
/**
 * Turns an object whose values are action creators, into an object with the
 * same keys, but with every function wrapped into a `dispatch` call so they
 * may be invoked directly. This is just a convenience method, as you can call
 * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
 *
 * For convenience, you can also pass an action creator as the first argument,
 * and get a dispatch wrapped function in return.
 *
 * @param {Function|Object} actionCreators An object whose values are action
 * creator functions. One handy way to obtain it is to use ES6 `import * as`
 * syntax. You may also pass a single function.
 *
 * @param {Function} dispatch The `dispatch` function available on your Redux
 * store.
 *
 * @returns {Function|Object} The object mimicking the original object, but with
 * every action creator wrapped into the `dispatch` call. If you passed a
 * function as `actionCreators`, the return value will also be a single
 * function.
 */


function bindActionCreators(actionCreators, dispatch) {
  if (typeof actionCreators === 'function') {
    return bindActionCreator(actionCreators, dispatch);
  }

  if (typeof actionCreators !== 'object' || actionCreators === null) {
    throw new Error( true ? formatProdErrorMessage(16) : 0);
  }

  var boundActionCreators = {};

  for (var key in actionCreators) {
    var actionCreator = actionCreators[key];

    if (typeof actionCreator === 'function') {
      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
    }
  }

  return boundActionCreators;
}

/**
 * Composes single-argument functions from right to left. The rightmost
 * function can take multiple arguments as it provides the signature for
 * the resulting composite function.
 *
 * @param {...Function} funcs The functions to compose.
 * @returns {Function} A function obtained by composing the argument functions
 * from right to left. For example, compose(f, g, h) is identical to doing
 * (...args) => f(g(h(...args))).
 */
function compose() {
  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }

  if (funcs.length === 0) {
    return function (arg) {
      return arg;
    };
  }

  if (funcs.length === 1) {
    return funcs[0];
  }

  return funcs.reduce(function (a, b) {
    return function () {
      return a(b.apply(void 0, arguments));
    };
  });
}

/**
 * Creates a store enhancer that applies middleware to the dispatch method
 * of the Redux store. This is handy for a variety of tasks, such as expressing
 * asynchronous actions in a concise manner, or logging every action payload.
 *
 * See `redux-thunk` package as an example of the Redux middleware.
 *
 * Because middleware is potentially asynchronous, this should be the first
 * store enhancer in the composition chain.
 *
 * Note that each middleware will be given the `dispatch` and `getState` functions
 * as named arguments.
 *
 * @param {...Function} middlewares The middleware chain to be applied.
 * @returns {Function} A store enhancer applying the middleware.
 */

function applyMiddleware() {
  for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {
    middlewares[_key] = arguments[_key];
  }

  return function (createStore) {
    return function () {
      var store = createStore.apply(void 0, arguments);

      var _dispatch = function dispatch() {
        throw new Error( true ? formatProdErrorMessage(15) : 0);
      };

      var middlewareAPI = {
        getState: store.getState,
        dispatch: function dispatch() {
          return _dispatch.apply(void 0, arguments);
        }
      };
      var chain = middlewares.map(function (middleware) {
        return middleware(middlewareAPI);
      });
      _dispatch = compose.apply(void 0, chain)(store.dispatch);
      return _objectSpread__default['default'](_objectSpread__default['default']({}, store), {}, {
        dispatch: _dispatch
      });
    };
  };
}

/*
 * This is a dummy function to check if the function name has been altered by minification.
 * If the function has been minified and NODE_ENV !== 'production', warn the user.
 */

function isCrushed() {}

if (false) {}

exports.__DO_NOT_USE__ActionTypes = ActionTypes;
exports.applyMiddleware = applyMiddleware;
exports.bindActionCreators = bindActionCreators;
exports.combineReducers = combineReducers;
exports.compose = compose;
exports.createStore = createStore;


/***/ }),

/***/ 409792:
/***/ ((module) => {

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ 778161:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var defineProperty = __webpack_require__(409792);

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);

    if (enumerableOnly) {
      symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }

    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

module.exports = _objectSpread2;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ 426018:
/***/ ((module) => {

"use strict";


var isProduction = "production" === 'production';
var prefix = 'Invariant failed';
function invariant(condition, message) {
    if (condition) {
        return;
    }
    if (isProduction) {
        throw new Error(prefix);
    }
    var provided = typeof message === 'function' ? message() : message;
    var value = provided ? prefix + ": " + provided : prefix;
    throw new Error(value);
}

module.exports = invariant;


/***/ }),

/***/ 335185:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var react = __webpack_require__(667294);

function areInputsEqual(newInputs, lastInputs) {
  if (newInputs.length !== lastInputs.length) {
    return false;
  }

  for (var i = 0; i < newInputs.length; i++) {
    if (newInputs[i] !== lastInputs[i]) {
      return false;
    }
  }

  return true;
}

function useMemoOne(getResult, inputs) {
  var initial = react.useState(function () {
    return {
      inputs: inputs,
      result: getResult()
    };
  })[0];
  var isFirstRun = react.useRef(true);
  var committed = react.useRef(initial);
  var useCache = isFirstRun.current || Boolean(inputs && committed.current.inputs && areInputsEqual(inputs, committed.current.inputs));
  var cache = useCache ? committed.current : {
    inputs: inputs,
    result: getResult()
  };
  react.useEffect(function () {
    isFirstRun.current = false;
    committed.current = cache;
  }, [cache]);
  return cache.result;
}
function useCallbackOne(callback, inputs) {
  return useMemoOne(function () {
    return callback;
  }, inputs);
}
var useMemo = useMemoOne;
var useCallback = useCallbackOne;

exports.useCallback = useCallback;
exports.useCallbackOne = useCallbackOne;
exports.useMemo = useMemo;
exports.useMemoOne = useMemoOne;


/***/ }),

/***/ 469016:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 472501:
/***/ ((module, exports, __webpack_require__) => {

const { Argument } = __webpack_require__(180226);
const { Command } = __webpack_require__(7112);
const { CommanderError, InvalidArgumentError } = __webpack_require__(563829);
const { Help } = __webpack_require__(598831);
const { Option } = __webpack_require__(980814);

// @ts-check

/**
 * Expose the root command.
 */

exports = module.exports = new Command();
exports.program = exports; // More explicit access to global command.
// Implicit export of createArgument, createCommand, and createOption.

/**
 * Expose classes
 */

exports.Argument = Argument;
exports.Command = Command;
exports.CommanderError = CommanderError;
exports.Help = Help;
exports.InvalidArgumentError = InvalidArgumentError;
exports.InvalidOptionArgumentError = InvalidArgumentError; // Deprecated
exports.Option = Option;


/***/ }),

/***/ 180226:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

const { InvalidArgumentError } = __webpack_require__(563829);

// @ts-check

class Argument {
  /**
   * Initialize a new command argument with the given name and description.
   * The default is that the argument is required, and you can explicitly
   * indicate this with <> around the name. Put [] around the name for an optional argument.
   *
   * @param {string} name
   * @param {string} [description]
   */

  constructor(name, description) {
    this.description = description || '';
    this.variadic = false;
    this.parseArg = undefined;
    this.defaultValue = undefined;
    this.defaultValueDescription = undefined;
    this.argChoices = undefined;

    switch (name[0]) {
      case '<': // e.g. <required>
        this.required = true;
        this._name = name.slice(1, -1);
        break;
      case '[': // e.g. [optional]
        this.required = false;
        this._name = name.slice(1, -1);
        break;
      default:
        this.required = true;
        this._name = name;
        break;
    }

    if (this._name.length > 3 && this._name.slice(-3) === '...') {
      this.variadic = true;
      this._name = this._name.slice(0, -3);
    }
  }

  /**
   * Return argument name.
   *
   * @return {string}
   */

  name() {
    return this._name;
  };

  /**
   * @api private
   */

  _concatValue(value, previous) {
    if (previous === this.defaultValue || !Array.isArray(previous)) {
      return [value];
    }

    return previous.concat(value);
  }

  /**
   * Set the default value, and optionally supply the description to be displayed in the help.
   *
   * @param {any} value
   * @param {string} [description]
   * @return {Argument}
   */

  default(value, description) {
    this.defaultValue = value;
    this.defaultValueDescription = description;
    return this;
  };

  /**
   * Set the custom handler for processing CLI command arguments into argument values.
   *
   * @param {Function} [fn]
   * @return {Argument}
   */

  argParser(fn) {
    this.parseArg = fn;
    return this;
  };

  /**
   * Only allow option value to be one of choices.
   *
   * @param {string[]} values
   * @return {Argument}
   */

  choices(values) {
    this.argChoices = values;
    this.parseArg = (arg, previous) => {
      if (!values.includes(arg)) {
        throw new InvalidArgumentError(`Allowed choices are ${values.join(', ')}.`);
      }
      if (this.variadic) {
        return this._concatValue(arg, previous);
      }
      return arg;
    };
    return this;
  };

  /**
   * Make option-argument required.
   */
  argRequired() {
    this.required = true;
    return this;
  }

  /**
   * Make option-argument optional.
   */
  argOptional() {
    this.required = false;
    return this;
  }
}

/**
 * Takes an argument and returns its human readable equivalent for help usage.
 *
 * @param {Argument} arg
 * @return {string}
 * @api private
 */

function humanReadableArgName(arg) {
  const nameOutput = arg.name() + (arg.variadic === true ? '...' : '');

  return arg.required
    ? '<' + nameOutput + '>'
    : '[' + nameOutput + ']';
}

exports.Argument = Argument;
exports.humanReadableArgName = humanReadableArgName;


/***/ }),

/***/ 7112:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* provided dependency */ var process = __webpack_require__(734155);
/* provided dependency */ var Buffer = __webpack_require__(348764)["Buffer"];
const EventEmitter = (__webpack_require__(717187).EventEmitter);
// const childProcess = require('child_process');
const path = __webpack_require__(326470);
const fs = __webpack_require__(469016);

const { Argument, humanReadableArgName } = __webpack_require__(180226);
const { CommanderError } = __webpack_require__(563829);
const { Help } = __webpack_require__(598831);
const { Option, splitOptionFlags } = __webpack_require__(980814);
const { suggestSimilar } = __webpack_require__(226152);

// @ts-check

class Command extends EventEmitter {
  /**
   * Initialize a new `Command`.
   *
   * @param {string} [name]
   */

  constructor(name) {
    super();
    /** @type {Command[]} */
    this.commands = [];
    /** @type {Option[]} */
    this.options = [];
    this.parent = null;
    this._allowUnknownOption = false;
    this._allowExcessArguments = true;
    /** @type {Argument[]} */
    this._args = [];
    /** @type {string[]} */
    this.args = []; // cli args with options removed
    this.rawArgs = [];
    this.processedArgs = []; // like .args but after custom processing and collecting variadic
    this._scriptPath = null;
    this._name = name || '';
    this._optionValues = {};
    this._optionValueSources = {}; // default < config < env < cli
    this._storeOptionsAsProperties = false;
    this._actionHandler = null;
    this._executableHandler = false;
    this._executableFile = null; // custom name for executable
    this._defaultCommandName = null;
    this._exitCallback = null;
    this._aliases = [];
    this._combineFlagAndOptionalValue = true;
    this._description = '';
    this._argsDescription = undefined; // legacy
    this._enablePositionalOptions = false;
    this._passThroughOptions = false;
    this._lifeCycleHooks = {}; // a hash of arrays
    /** @type {boolean | string} */
    this._showHelpAfterError = false;
    this._showSuggestionAfterError = false;

    // see .configureOutput() for docs
    this._outputConfiguration = {
      writeOut: (str) => process.stdout.write(str),
      writeErr: (str) => process.stderr.write(str),
      getOutHelpWidth: () => process.stdout.isTTY ? process.stdout.columns : undefined,
      getErrHelpWidth: () => process.stderr.isTTY ? process.stderr.columns : undefined,
      outputError: (str, write) => write(str)
    };

    this._hidden = false;
    this._hasHelpOption = true;
    this._helpFlags = '-h, --help';
    this._helpDescription = 'display help for command';
    this._helpShortFlag = '-h';
    this._helpLongFlag = '--help';
    this._addImplicitHelpCommand = undefined; // Deliberately undefined, not decided whether true or false
    this._helpCommandName = 'help';
    this._helpCommandnameAndArgs = 'help [command]';
    this._helpCommandDescription = 'display help for command';
    this._helpConfiguration = {};
  }

  /**
   * Copy settings that are useful to have in common across root command and subcommands.
   *
   * (Used internally when adding a command using `.command()` so subcommands inherit parent settings.)
   *
   * @param {Command} sourceCommand
   * @return {Command} returns `this` for executable command
   */
  copyInheritedSettings(sourceCommand) {
    this._outputConfiguration = sourceCommand._outputConfiguration;
    this._hasHelpOption = sourceCommand._hasHelpOption;
    this._helpFlags = sourceCommand._helpFlags;
    this._helpDescription = sourceCommand._helpDescription;
    this._helpShortFlag = sourceCommand._helpShortFlag;
    this._helpLongFlag = sourceCommand._helpLongFlag;
    this._helpCommandName = sourceCommand._helpCommandName;
    this._helpCommandnameAndArgs = sourceCommand._helpCommandnameAndArgs;
    this._helpCommandDescription = sourceCommand._helpCommandDescription;
    this._helpConfiguration = sourceCommand._helpConfiguration;
    this._exitCallback = sourceCommand._exitCallback;
    this._storeOptionsAsProperties = sourceCommand._storeOptionsAsProperties;
    this._combineFlagAndOptionalValue = sourceCommand._combineFlagAndOptionalValue;
    this._allowExcessArguments = sourceCommand._allowExcessArguments;
    this._enablePositionalOptions = sourceCommand._enablePositionalOptions;
    this._showHelpAfterError = sourceCommand._showHelpAfterError;
    this._showSuggestionAfterError = sourceCommand._showSuggestionAfterError;

    return this;
  }

  /**
   * Define a command.
   *
   * There are two styles of command: pay attention to where to put the description.
   *
   * @example
   * // Command implemented using action handler (description is supplied separately to `.command`)
   * program
   *   .command('clone <source> [destination]')
   *   .description('clone a repository into a newly created directory')
   *   .action((source, destination) => {
   *     console.log('clone command called');
   *   });
   *
   * // Command implemented using separate executable file (description is second parameter to `.command`)
   * program
   *   .command('start <service>', 'start named service')
   *   .command('stop [service]', 'stop named service, or all if no name supplied');
   *
   * @param {string} nameAndArgs - command name and arguments, args are `<required>` or `[optional]` and last may also be `variadic...`
   * @param {Object|string} [actionOptsOrExecDesc] - configuration options (for action), or description (for executable)
   * @param {Object} [execOpts] - configuration options (for executable)
   * @return {Command} returns new command for action handler, or `this` for executable command
   */

  command(nameAndArgs, actionOptsOrExecDesc, execOpts) {
    let desc = actionOptsOrExecDesc;
    let opts = execOpts;
    if (typeof desc === 'object' && desc !== null) {
      opts = desc;
      desc = null;
    }
    opts = opts || {};
    const [, name, args] = nameAndArgs.match(/([^ ]+) *(.*)/);

    const cmd = this.createCommand(name);
    if (desc) {
      cmd.description(desc);
      cmd._executableHandler = true;
    }
    if (opts.isDefault) this._defaultCommandName = cmd._name;
    cmd._hidden = !!(opts.noHelp || opts.hidden); // noHelp is deprecated old name for hidden
    cmd._executableFile = opts.executableFile || null; // Custom name for executable file, set missing to null to match constructor
    if (args) cmd.arguments(args);
    this.commands.push(cmd);
    cmd.parent = this;
    cmd.copyInheritedSettings(this);

    if (desc) return this;
    return cmd;
  };

  /**
   * Factory routine to create a new unattached command.
   *
   * See .command() for creating an attached subcommand, which uses this routine to
   * create the command. You can override createCommand to customise subcommands.
   *
   * @param {string} [name]
   * @return {Command} new command
   */

  createCommand(name) {
    return new Command(name);
  };

  /**
   * You can customise the help with a subclass of Help by overriding createHelp,
   * or by overriding Help properties using configureHelp().
   *
   * @return {Help}
   */

  createHelp() {
    return Object.assign(new Help(), this.configureHelp());
  };

  /**
   * You can customise the help by overriding Help properties using configureHelp(),
   * or with a subclass of Help by overriding createHelp().
   *
   * @param {Object} [configuration] - configuration options
   * @return {Command|Object} `this` command for chaining, or stored configuration
   */

  configureHelp(configuration) {
    if (configuration === undefined) return this._helpConfiguration;

    this._helpConfiguration = configuration;
    return this;
  }

  /**
   * The default output goes to stdout and stderr. You can customise this for special
   * applications. You can also customise the display of errors by overriding outputError.
   *
   * The configuration properties are all functions:
   *
   *     // functions to change where being written, stdout and stderr
   *     writeOut(str)
   *     writeErr(str)
   *     // matching functions to specify width for wrapping help
   *     getOutHelpWidth()
   *     getErrHelpWidth()
   *     // functions based on what is being written out
   *     outputError(str, write) // used for displaying errors, and not used for displaying help
   *
   * @param {Object} [configuration] - configuration options
   * @return {Command|Object} `this` command for chaining, or stored configuration
   */

  configureOutput(configuration) {
    if (configuration === undefined) return this._outputConfiguration;

    Object.assign(this._outputConfiguration, configuration);
    return this;
  }

  /**
   * Display the help or a custom message after an error occurs.
   *
   * @param {boolean|string} [displayHelp]
   * @return {Command} `this` command for chaining
   */
  showHelpAfterError(displayHelp = true) {
    if (typeof displayHelp !== 'string') displayHelp = !!displayHelp;
    this._showHelpAfterError = displayHelp;
    return this;
  }

  /**
   * Display suggestion of similar commands for unknown commands, or options for unknown options.
   *
   * @param {boolean} [displaySuggestion]
   * @return {Command} `this` command for chaining
   */
  showSuggestionAfterError(displaySuggestion = true) {
    this._showSuggestionAfterError = !!displaySuggestion;
    return this;
  }

  /**
   * Add a prepared subcommand.
   *
   * See .command() for creating an attached subcommand which inherits settings from its parent.
   *
   * @param {Command} cmd - new subcommand
   * @param {Object} [opts] - configuration options
   * @return {Command} `this` command for chaining
   */

  addCommand(cmd, opts) {
    if (!cmd._name) throw new Error('Command passed to .addCommand() must have a name');

    // To keep things simple, block automatic name generation for deeply nested executables.
    // Fail fast and detect when adding rather than later when parsing.
    function checkExplicitNames(commandArray) {
      commandArray.forEach((cmd) => {
        if (cmd._executableHandler && !cmd._executableFile) {
          throw new Error(`Must specify executableFile for deeply nested executable: ${cmd.name()}`);
        }
        checkExplicitNames(cmd.commands);
      });
    }
    checkExplicitNames(cmd.commands);

    opts = opts || {};
    if (opts.isDefault) this._defaultCommandName = cmd._name;
    if (opts.noHelp || opts.hidden) cmd._hidden = true; // modifying passed command due to existing implementation

    this.commands.push(cmd);
    cmd.parent = this;
    return this;
  };

  /**
   * Factory routine to create a new unattached argument.
   *
   * See .argument() for creating an attached argument, which uses this routine to
   * create the argument. You can override createArgument to return a custom argument.
   *
   * @param {string} name
   * @param {string} [description]
   * @return {Argument} new argument
   */

  createArgument(name, description) {
    return new Argument(name, description);
  };

  /**
   * Define argument syntax for command.
   *
   * The default is that the argument is required, and you can explicitly
   * indicate this with <> around the name. Put [] around the name for an optional argument.
   *
   * @example
   * program.argument('<input-file>');
   * program.argument('[output-file]');
   *
   * @param {string} name
   * @param {string} [description]
   * @param {Function|*} [fn] - custom argument processing function
   * @param {*} [defaultValue]
   * @return {Command} `this` command for chaining
   */
  argument(name, description, fn, defaultValue) {
    const argument = this.createArgument(name, description);
    if (typeof fn === 'function') {
      argument.default(defaultValue).argParser(fn);
    } else {
      argument.default(fn);
    }
    this.addArgument(argument);
    return this;
  }

  /**
   * Define argument syntax for command, adding multiple at once (without descriptions).
   *
   * See also .argument().
   *
   * @example
   * program.arguments('<cmd> [env]');
   *
   * @param {string} names
   * @return {Command} `this` command for chaining
   */

  arguments(names) {
    names.split(/ +/).forEach((detail) => {
      this.argument(detail);
    });
    return this;
  };

  /**
   * Define argument syntax for command, adding a prepared argument.
   *
   * @param {Argument} argument
   * @return {Command} `this` command for chaining
   */
  addArgument(argument) {
    const previousArgument = this._args.slice(-1)[0];
    if (previousArgument && previousArgument.variadic) {
      throw new Error(`only the last argument can be variadic '${previousArgument.name()}'`);
    }
    if (argument.required && argument.defaultValue !== undefined && argument.parseArg === undefined) {
      throw new Error(`a default value for a required argument is never used: '${argument.name()}'`);
    }
    this._args.push(argument);
    return this;
  }

  /**
   * Override default decision whether to add implicit help command.
   *
   *    addHelpCommand() // force on
   *    addHelpCommand(false); // force off
   *    addHelpCommand('help [cmd]', 'display help for [cmd]'); // force on with custom details
   *
   * @return {Command} `this` command for chaining
   */

  addHelpCommand(enableOrNameAndArgs, description) {
    if (enableOrNameAndArgs === false) {
      this._addImplicitHelpCommand = false;
    } else {
      this._addImplicitHelpCommand = true;
      if (typeof enableOrNameAndArgs === 'string') {
        this._helpCommandName = enableOrNameAndArgs.split(' ')[0];
        this._helpCommandnameAndArgs = enableOrNameAndArgs;
      }
      this._helpCommandDescription = description || this._helpCommandDescription;
    }
    return this;
  };

  /**
   * @return {boolean}
   * @api private
   */

  _hasImplicitHelpCommand() {
    if (this._addImplicitHelpCommand === undefined) {
      return this.commands.length && !this._actionHandler && !this._findCommand('help');
    }
    return this._addImplicitHelpCommand;
  };

  /**
   * Add hook for life cycle event.
   *
   * @param {string} event
   * @param {Function} listener
   * @return {Command} `this` command for chaining
   */

  hook(event, listener) {
    const allowedValues = ['preAction', 'postAction'];
    if (!allowedValues.includes(event)) {
      throw new Error(`Unexpected value for event passed to hook : '${event}'.
Expecting one of '${allowedValues.join("', '")}'`);
    }
    if (this._lifeCycleHooks[event]) {
      this._lifeCycleHooks[event].push(listener);
    } else {
      this._lifeCycleHooks[event] = [listener];
    }
    return this;
  }

  /**
   * Register callback to use as replacement for calling process.exit.
   *
   * @param {Function} [fn] optional callback which will be passed a CommanderError, defaults to throwing
   * @return {Command} `this` command for chaining
   */

  exitOverride(fn) {
    if (fn) {
      this._exitCallback = fn;
    } else {
      this._exitCallback = (err) => {
        if (err.code !== 'commander.executeSubCommandAsync') {
          throw err;
        } else {
          // Async callback from spawn events, not useful to throw.
        }
      };
    }
    return this;
  };

  /**
   * Call process.exit, and _exitCallback if defined.
   *
   * @param {number} exitCode exit code for using with process.exit
   * @param {string} code an id string representing the error
   * @param {string} message human-readable description of the error
   * @return never
   * @api private
   */

  _exit(exitCode, code, message) {
    if (this._exitCallback) {
      this._exitCallback(new CommanderError(exitCode, code, message));
      // Expecting this line is not reached.
    }
    process.exit(exitCode);
  };

  /**
   * Register callback `fn` for the command.
   *
   * @example
   * program
   *   .command('serve')
   *   .description('start service')
   *   .action(function() {
   *      // do work here
   *   });
   *
   * @param {Function} fn
   * @return {Command} `this` command for chaining
   */

  action(fn) {
    const listener = (args) => {
      // The .action callback takes an extra parameter which is the command or options.
      const expectedArgsCount = this._args.length;
      const actionArgs = args.slice(0, expectedArgsCount);
      if (this._storeOptionsAsProperties) {
        actionArgs[expectedArgsCount] = this; // backwards compatible "options"
      } else {
        actionArgs[expectedArgsCount] = this.opts();
      }
      actionArgs.push(this);

      return fn.apply(this, actionArgs);
    };
    this._actionHandler = listener;
    return this;
  };

  /**
   * Factory routine to create a new unattached option.
   *
   * See .option() for creating an attached option, which uses this routine to
   * create the option. You can override createOption to return a custom option.
   *
   * @param {string} flags
   * @param {string} [description]
   * @return {Option} new option
   */

  createOption(flags, description) {
    return new Option(flags, description);
  };

  /**
   * Add an option.
   *
   * @param {Option} option
   * @return {Command} `this` command for chaining
   */
  addOption(option) {
    const oname = option.name();
    const name = option.attributeName();

    let defaultValue = option.defaultValue;

    // preassign default value for --no-*, [optional], <required>, or plain flag if boolean value
    if (option.negate || option.optional || option.required || typeof defaultValue === 'boolean') {
      // when --no-foo we make sure default is true, unless a --foo option is already defined
      if (option.negate) {
        const positiveLongFlag = option.long.replace(/^--no-/, '--');
        defaultValue = this._findOption(positiveLongFlag) ? this.getOptionValue(name) : true;
      }
      // preassign only if we have a default
      if (defaultValue !== undefined) {
        this.setOptionValueWithSource(name, defaultValue, 'default');
      }
    }

    // register the option
    this.options.push(option);

    // handler for cli and env supplied values
    const handleOptionValue = (val, invalidValueMessage, valueSource) => {
      // Note: using closure to access lots of lexical scoped variables.
      const oldValue = this.getOptionValue(name);

      // custom processing
      if (val !== null && option.parseArg) {
        try {
          val = option.parseArg(val, oldValue === undefined ? defaultValue : oldValue);
        } catch (err) {
          if (err.code === 'commander.invalidArgument') {
            const message = `${invalidValueMessage} ${err.message}`;
            // this._displayError(err.exitCode, err.code, message);
            throw new Error(message);
          }
          throw err;
        }
      } else if (val !== null && option.variadic) {
        val = option._concatValue(val, oldValue);
      }

      // unassigned or boolean value
      if (typeof oldValue === 'boolean' || typeof oldValue === 'undefined') {
        // if no value, negate false, and we have a default, then use it!
        if (val == null) {
          this.setOptionValueWithSource(name, option.negate ? false : defaultValue || true, valueSource);
        } else {
          this.setOptionValueWithSource(name, val, valueSource);
        }
      } else if (val !== null) {
        // reassign
        this.setOptionValueWithSource(name, option.negate ? false : val, valueSource);
      }
    };

    this.on('option:' + oname, (val) => {
      const invalidValueMessage = `error: option '${option.flags}' argument '${val}' is invalid.`;
      handleOptionValue(val, invalidValueMessage, 'cli');
    });

    if (option.envVar) {
      this.on('optionEnv:' + oname, (val) => {
        const invalidValueMessage = `error: option '${option.flags}' value '${val}' from env '${option.envVar}' is invalid.`;
        handleOptionValue(val, invalidValueMessage, 'env');
      });
    }

    return this;
  }

  /**
   * Internal implementation shared by .option() and .requiredOption()
   *
   * @api private
   */
  _optionEx(config, flags, description, fn, defaultValue) {
    const option = this.createOption(flags, description);
    option.makeOptionMandatory(!!config.mandatory);
    if (typeof fn === 'function') {
      option.default(defaultValue).argParser(fn);
    } else if (fn instanceof RegExp) {
      // deprecated
      const regex = fn;
      fn = (val, def) => {
        const m = regex.exec(val);
        return m ? m[0] : def;
      };
      option.default(defaultValue).argParser(fn);
    } else {
      option.default(fn);
    }

    return this.addOption(option);
  }

  /**
   * Define option with `flags`, `description` and optional
   * coercion `fn`.
   *
   * The `flags` string contains the short and/or long flags,
   * separated by comma, a pipe or space. The following are all valid
   * all will output this way when `--help` is used.
   *
   *     "-p, --pepper"
   *     "-p|--pepper"
   *     "-p --pepper"
   *
   * @example
   * // simple boolean defaulting to undefined
   * program.option('-p, --pepper', 'add pepper');
   *
   * program.pepper
   * // => undefined
   *
   * --pepper
   * program.pepper
   * // => true
   *
   * // simple boolean defaulting to true (unless non-negated option is also defined)
   * program.option('-C, --no-cheese', 'remove cheese');
   *
   * program.cheese
   * // => true
   *
   * --no-cheese
   * program.cheese
   * // => false
   *
   * // required argument
   * program.option('-C, --chdir <path>', 'change the working directory');
   *
   * --chdir /tmp
   * program.chdir
   * // => "/tmp"
   *
   * // optional argument
   * program.option('-c, --cheese [type]', 'add cheese [marble]');
   *
   * @param {string} flags
   * @param {string} [description]
   * @param {Function|*} [fn] - custom option processing function or default value
   * @param {*} [defaultValue]
   * @return {Command} `this` command for chaining
   */

  option(flags, description, fn, defaultValue) {
    return this._optionEx({}, flags, description, fn, defaultValue);
  };

  /**
  * Add a required option which must have a value after parsing. This usually means
  * the option must be specified on the command line. (Otherwise the same as .option().)
  *
  * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space.
  *
  * @param {string} flags
  * @param {string} [description]
  * @param {Function|*} [fn] - custom option processing function or default value
  * @param {*} [defaultValue]
  * @return {Command} `this` command for chaining
  */

  requiredOption(flags, description, fn, defaultValue) {
    return this._optionEx({ mandatory: true }, flags, description, fn, defaultValue);
  };

  /**
   * Alter parsing of short flags with optional values.
   *
   * @example
   * // for `.option('-f,--flag [value]'):
   * program.combineFlagAndOptionalValue(true);  // `-f80` is treated like `--flag=80`, this is the default behaviour
   * program.combineFlagAndOptionalValue(false) // `-fb` is treated like `-f -b`
   *
   * @param {Boolean} [combine=true] - if `true` or omitted, an optional value can be specified directly after the flag.
   */
  combineFlagAndOptionalValue(combine = true) {
    this._combineFlagAndOptionalValue = !!combine;
    return this;
  };

  /**
   * Allow unknown options on the command line.
   *
   * @param {Boolean} [allowUnknown=true] - if `true` or omitted, no error will be thrown
   * for unknown options.
   */
  allowUnknownOption(allowUnknown = true) {
    this._allowUnknownOption = !!allowUnknown;
    return this;
  };

  /**
   * Allow excess command-arguments on the command line. Pass false to make excess arguments an error.
   *
   * @param {Boolean} [allowExcess=true] - if `true` or omitted, no error will be thrown
   * for excess arguments.
   */
  allowExcessArguments(allowExcess = true) {
    this._allowExcessArguments = !!allowExcess;
    return this;
  };

  /**
   * Enable positional options. Positional means global options are specified before subcommands which lets
   * subcommands reuse the same option names, and also enables subcommands to turn on passThroughOptions.
   * The default behaviour is non-positional and global options may appear anywhere on the command line.
   *
   * @param {Boolean} [positional=true]
   */
  enablePositionalOptions(positional = true) {
    this._enablePositionalOptions = !!positional;
    return this;
  };

  /**
   * Pass through options that come after command-arguments rather than treat them as command-options,
   * so actual command-options come before command-arguments. Turning this on for a subcommand requires
   * positional options to have been enabled on the program (parent commands).
   * The default behaviour is non-positional and options may appear before or after command-arguments.
   *
   * @param {Boolean} [passThrough=true]
   * for unknown options.
   */
  passThroughOptions(passThrough = true) {
    this._passThroughOptions = !!passThrough;
    if (!!this.parent && passThrough && !this.parent._enablePositionalOptions) {
      throw new Error('passThroughOptions can not be used without turning on enablePositionalOptions for parent command(s)');
    }
    return this;
  };

  /**
    * Whether to store option values as properties on command object,
    * or store separately (specify false). In both cases the option values can be accessed using .opts().
    *
    * @param {boolean} [storeAsProperties=true]
    * @return {Command} `this` command for chaining
    */

  storeOptionsAsProperties(storeAsProperties = true) {
    this._storeOptionsAsProperties = !!storeAsProperties;
    if (this.options.length) {
      throw new Error('call .storeOptionsAsProperties() before adding options');
    }
    return this;
  };

  /**
   * Retrieve option value.
   *
   * @param {string} key
   * @return {Object} value
   */

  getOptionValue(key) {
    if (this._storeOptionsAsProperties) {
      return this[key];
    }
    return this._optionValues[key];
  };

  /**
   * Store option value.
   *
   * @param {string} key
   * @param {Object} value
   * @return {Command} `this` command for chaining
   */

  setOptionValue(key, value) {
    if (this._storeOptionsAsProperties) {
      this[key] = value;
    } else {
      this._optionValues[key] = value;
    }
    return this;
  };

  /**
   * Store option value and where the value came from.
    *
    * @param {string} key
    * @param {Object} value
    * @param {string} source - expected values are default/config/env/cli
    * @return {Command} `this` command for chaining
    */

  setOptionValueWithSource(key, value, source) {
    this.setOptionValue(key, value);
    this._optionValueSources[key] = source;
    return this;
  }

  /**
    * Get source of option value.
    * Expected values are default | config | env | cli
    *
    * @param {string} key
    * @return {string}
    */

  getOptionValueSource(key) {
    return this._optionValueSources[key];
  };

  /**
   * Get user arguments implied or explicit arguments.
   * Side-effects: set _scriptPath if args included application, and use that to set implicit command name.
   *
   * @api private
   */

  _prepareUserArgs(argv, parseOptions) {
    if (argv !== undefined && !Array.isArray(argv)) {
      throw new Error('first parameter to parse must be array or undefined');
    }
    parseOptions = parseOptions || {};

    // Default to using process.argv
    if (argv === undefined) {
      argv = process.argv;
      // @ts-ignore: unknown property
      if (process.versions && process.versions.electron) {
        parseOptions.from = 'electron';
      }
    }
    this.rawArgs = argv.slice();

    // make it a little easier for callers by supporting various argv conventions
    let userArgs;
    switch (parseOptions.from) {
      case undefined:
      case 'node':
        this._scriptPath = argv[1];
        userArgs = argv.slice(2);
        break;
      case 'electron':
        // @ts-ignore: unknown property
        if (process.defaultApp) {
          this._scriptPath = argv[1];
          userArgs = argv.slice(2);
        } else {
          userArgs = argv.slice(1);
        }
        break;
      case 'user':
        userArgs = argv.slice(0);
        break;
      default:
        throw new Error(`unexpected parse option { from: '${parseOptions.from}' }`);
    }
    if (!this._scriptPath && __webpack_require__.c[__webpack_require__.s]) {
      this._scriptPath = __webpack_require__.c[__webpack_require__.s].filename;
    }

    // Guess name, used in usage in help.
    this._name = this._name || (this._scriptPath && path.basename(this._scriptPath, path.extname(this._scriptPath)));

    return userArgs;
  }

  /**
   * Parse `argv`, setting options and invoking commands when defined.
   *
   * The default expectation is that the arguments are from node and have the application as argv[0]
   * and the script being run in argv[1], with user parameters after that.
   *
   * @example
   * program.parse(process.argv);
   * program.parse(); // implicitly use process.argv and auto-detect node vs electron conventions
   * program.parse(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
   *
   * @param {string[]} [argv] - optional, defaults to process.argv
   * @param {Object} [parseOptions] - optionally specify style of options with from: node/user/electron
   * @param {string} [parseOptions.from] - where the args are from: 'node', 'user', 'electron'
   * @return {Command} `this` command for chaining
   */

  parse(argv, parseOptions) {
    const userArgs = this._prepareUserArgs(argv, parseOptions);
    this._parseCommand([], userArgs);

    return this;
  };

  /**
   * Parse `argv`, setting options and invoking commands when defined.
   *
   * Use parseAsync instead of parse if any of your action handlers are async. Returns a Promise.
   *
   * The default expectation is that the arguments are from node and have the application as argv[0]
   * and the script being run in argv[1], with user parameters after that.
   *
   * @example
   * await program.parseAsync(process.argv);
   * await program.parseAsync(); // implicitly use process.argv and auto-detect node vs electron conventions
   * await program.parseAsync(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
   *
   * @param {string[]} [argv]
   * @param {Object} [parseOptions]
   * @param {string} parseOptions.from - where the args are from: 'node', 'user', 'electron'
   * @return {Promise}
   */

  async parseAsync(argv, parseOptions) {
    const userArgs = this._prepareUserArgs(argv, parseOptions);
    await this._parseCommand([], userArgs);

    return this;
  };

  _executeSubCommand(subcommand, args) {

  }

  /**
   * Execute a sub-command executable.
   *
   * @api private
   * @deprecated use _executeSubCommand
   */

  _executeSubCommand_v1(subcommand, args) {
    args = args.slice();
    let launchWithNode = false; // Use node for source targets so do not need to get permissions correct, and on Windows.
    const sourceExt = ['.js', '.ts', '.tsx', '.mjs', '.cjs'];

    // Not checking for help first. Unlikely to have mandatory and executable, and can't robustly test for help flags in external command.
    this._checkForMissingMandatoryOptions();

    // Want the entry script as the reference for command name and directory for searching for other files.
    let scriptPath = this._scriptPath;
    // Fallback in case not set, due to how Command created or called.
    if (!scriptPath && __webpack_require__.c[__webpack_require__.s]) {
      scriptPath = __webpack_require__.c[__webpack_require__.s].filename;
    }

    let baseDir;
    try {
      const resolvedLink = fs.realpathSync(scriptPath);
      baseDir = path.dirname(resolvedLink);
    } catch (e) {
      baseDir = '.'; // dummy, probably not going to find executable!
    }

    // name of the subcommand, like `pm-install`
    let bin = path.basename(scriptPath, path.extname(scriptPath)) + '-' + subcommand._name;
    if (subcommand._executableFile) {
      bin = subcommand._executableFile;
    }

    const localBin = path.join(baseDir, bin);
    if (fs.existsSync(localBin)) {
      // prefer local `./<bin>` to bin in the $PATH
      bin = localBin;
    } else {
      // Look for source files.
      sourceExt.forEach((ext) => {
        if (fs.existsSync(`${localBin}${ext}`)) {
          bin = `${localBin}${ext}`;
        }
      });
    }
    launchWithNode = sourceExt.includes(path.extname(bin));

    let proc;
    if (process.platform !== 'win32') {
      if (launchWithNode) {
        args.unshift(bin);
        // add executable arguments to spawn
        args = incrementNodeInspectorPort(process.execArgv).concat(args);

        proc = childProcess.spawn(process.argv[0], args, { stdio: 'inherit' });
      } else {
        proc = childProcess.spawn(bin, args, { stdio: 'inherit' });
      }
    } else {
      args.unshift(bin);
      // add executable arguments to spawn
      args = incrementNodeInspectorPort(process.execArgv).concat(args);
      proc = childProcess.spawn(process.execPath, args, { stdio: 'inherit' });
    }

    const signals = ['SIGUSR1', 'SIGUSR2', 'SIGTERM', 'SIGINT', 'SIGHUP'];
    signals.forEach((signal) => {
      // @ts-ignore
      process.on(signal, () => {
        if (proc.killed === false && proc.exitCode === null) {
          proc.kill(signal);
        }
      });
    });

    // By default terminate process when spawned process terminates.
    // Suppressing the exit if exitCallback defined is a bit messy and of limited use, but does allow process to stay running!
    const exitCallback = this._exitCallback;
    if (!exitCallback) {
      proc.on('close', process.exit.bind(process));
    } else {
      proc.on('close', () => {
        exitCallback(new CommanderError(process.exitCode || 0, 'commander.executeSubCommandAsync', '(close)'));
      });
    }
    proc.on('error', (err) => {
      // @ts-ignore
      if (err.code === 'ENOENT') {
        const executableMissing = `'${bin}' does not exist
 - if '${subcommand._name}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead
 - if the default executable name is not suitable, use the executableFile option to supply a custom name`;
        throw new Error(executableMissing);
      // @ts-ignore
      } else if (err.code === 'EACCES') {
        throw new Error(`'${bin}' not executable`);
      }
      if (!exitCallback) {
        process.exit(1);
      } else {
        const wrappedError = new CommanderError(1, 'commander.executeSubCommandAsync', '(error)');
        wrappedError.nestedError = err;
        exitCallback(wrappedError);
      }
    });

    // Store the reference to the child process
    this.runningCommand = proc;
  };

  /**
   * @api private
   */

  _dispatchSubcommand(commandName, operands, unknown) {
    const subCommand = this._findCommand(commandName);
    if (!subCommand) this.help({ error: true });

    if (subCommand._executableHandler) {
      this._executeSubCommand(subCommand, operands.concat(unknown));
    } else {
      return subCommand._parseCommand(operands, unknown);
    }
  };

  /**
   * Check this.args against expected this._args.
   *
   * @api private
   */

  _checkNumberOfArguments() {
    // too few
    this._args.forEach((arg, i) => {
      if (arg.required && this.args[i] == null) {
        this.missingArgument(arg.name());
      }
    });
    // too many
    if (this._args.length > 0 && this._args[this._args.length - 1].variadic) {
      return;
    }
    if (this.args.length > this._args.length) {
      this._excessArguments(this.args);
    }
  };

  /**
   * Process this.args using this._args and save as this.processedArgs!
   *
   * @api private
   */

  _processArguments() {
    const myParseArg = (argument, value, previous) => {
      // Extra processing for nice error message on parsing failure.
      let parsedValue = value;
      if (value !== null && argument.parseArg) {
        try {
          parsedValue = argument.parseArg(value, previous);
        } catch (err) {
          if (err.code === 'commander.invalidArgument') {
            const message = `error: command-argument value '${value}' is invalid for argument '${argument.name()}'. ${err.message}`;
            // this._displayError(err.exitCode, err.code, message);
            throw new Error(message);
          }
          throw err;
        }
      }
      return parsedValue;
    };

    this._checkNumberOfArguments();

    const processedArgs = [];
    this._args.forEach((declaredArg, index) => {
      let value = declaredArg.defaultValue;
      if (declaredArg.variadic) {
        // Collect together remaining arguments for passing together as an array.
        if (index < this.args.length) {
          value = this.args.slice(index);
          if (declaredArg.parseArg) {
            value = value.reduce((processed, v) => {
              return myParseArg(declaredArg, v, processed);
            }, declaredArg.defaultValue);
          }
        } else if (value === undefined) {
          value = [];
        }
      } else if (index < this.args.length) {
        value = this.args[index];
        if (declaredArg.parseArg) {
          value = myParseArg(declaredArg, value, declaredArg.defaultValue);
        }
      }
      processedArgs[index] = value;
    });
    this.processedArgs = processedArgs;
  }

  /**
   * Once we have a promise we chain, but call synchronously until then.
   *
   * @param {Promise|undefined} promise
   * @param {Function} fn
   * @return {Promise|undefined}
   * @api private
   */

  _chainOrCall(promise, fn) {
    // thenable
    if (promise && promise.then && typeof promise.then === 'function') {
      // already have a promise, chain callback
      return promise.then(() => fn());
    }
    // callback might return a promise
    return fn();
  }

  /**
   *
   * @param {Promise|undefined} promise
   * @param {string} event
   * @return {Promise|undefined}
   * @api private
   */

  _chainOrCallHooks(promise, event) {
    let result = promise;
    const hooks = [];
    getCommandAndParents(this)
      .reverse()
      .filter(cmd => cmd._lifeCycleHooks[event] !== undefined)
      .forEach(hookedCommand => {
        hookedCommand._lifeCycleHooks[event].forEach((callback) => {
          hooks.push({ hookedCommand, callback });
        });
      });
    if (event === 'postAction') {
      hooks.reverse();
    }

    hooks.forEach((hookDetail) => {
      result = this._chainOrCall(result, () => {
        return hookDetail.callback(hookDetail.hookedCommand, this);
      });
    });
    return result;
  }

  /**
   * Process arguments in context of this command.
   * Returns action result, in case it is a promise.
   *
   * @api private
   */

  _parseCommand(operands, unknown) {
    const parsed = this.parseOptions(unknown);
    this._parseOptionsEnv(); // after cli, so parseArg not called on both cli and env
    operands = operands.concat(parsed.operands);
    unknown = parsed.unknown;
    this.args = operands.concat(unknown);

    if (operands && this._findCommand(operands[0])) {
      return this._dispatchSubcommand(operands[0], operands.slice(1), unknown);
    }
    if (this._hasImplicitHelpCommand() && operands[0] === this._helpCommandName) {
      if (operands.length === 1) {
        this.help();
      }
      return this._dispatchSubcommand(operands[1], [], [this._helpLongFlag]);
    }
    if (this._defaultCommandName) {
      outputHelpIfRequested(this, unknown); // Run the help for default command from parent rather than passing to default command
      return this._dispatchSubcommand(this._defaultCommandName, operands, unknown);
    }
    if (this.commands.length && this.args.length === 0 && !this._actionHandler && !this._defaultCommandName) {
      // probably missing subcommand and no handler, user needs help (and exit)
      this.help({ error: true });
    }

    outputHelpIfRequested(this, parsed.unknown);
    this._checkForMissingMandatoryOptions();

    // We do not always call this check to avoid masking a "better" error, like unknown command.
    const checkForUnknownOptions = () => {
      if (parsed.unknown.length > 0) {
        this.unknownOption(parsed.unknown[0]);
      }
    };

    const commandEvent = `command:${this.name()}`;
    if (this._actionHandler) {
      checkForUnknownOptions();
      this._processArguments();

      let actionResult;
      actionResult = this._chainOrCallHooks(actionResult, 'preAction');
      actionResult = this._chainOrCall(actionResult, () => this._actionHandler(this.processedArgs));
      if (this.parent) this.parent.emit(commandEvent, operands, unknown); // legacy
      actionResult = this._chainOrCallHooks(actionResult, 'postAction');
      return actionResult;
    }
    if (this.parent && this.parent.listenerCount(commandEvent)) {
      checkForUnknownOptions();
      this._processArguments();
      this.parent.emit(commandEvent, operands, unknown); // legacy
    } else if (operands.length) {
      if (this._findCommand('*')) { // legacy default command
        return this._dispatchSubcommand('*', operands, unknown);
      }
      if (this.listenerCount('command:*')) {
        // skip option check, emit event for possible misspelling suggestion
        this.emit('command:*', operands, unknown);
      } else if (this.commands.length) {
        this.unknownCommand();
      } else {
        checkForUnknownOptions();
        this._processArguments();
      }
    } else if (this.commands.length) {
      checkForUnknownOptions();
      // This command has subcommands and nothing hooked up at this level, so display help (and exit).
      this.help({ error: true });
    } else {
      checkForUnknownOptions();
      this._processArguments();
      // fall through for caller to handle after calling .parse()
    }
  };

  /**
   * Find matching command.
   *
   * @api private
   */
  _findCommand(name) {
    if (!name) return undefined;
    return this.commands.find(cmd => cmd._name === name || cmd._aliases.includes(name));
  };

  /**
   * Return an option matching `arg` if any.
   *
   * @param {string} arg
   * @return {Option}
   * @api private
   */

  _findOption(arg) {
    return this.options.find(option => option.is(arg));
  };

  /**
   * Display an error message if a mandatory option does not have a value.
   * Lazy calling after checking for help flags from leaf subcommand.
   *
   * @api private
   */

  _checkForMissingMandatoryOptions() {
    // Walk up hierarchy so can call in subcommand after checking for displaying help.
    for (let cmd = this; cmd; cmd = cmd.parent) {
      cmd.options.forEach((anOption) => {
        if (anOption.mandatory && (cmd.getOptionValue(anOption.attributeName()) === undefined)) {
          cmd.missingMandatoryOptionValue(anOption);
        }
      });
    }
  };

  /**
   * Parse options from `argv` removing known options,
   * and return argv split into operands and unknown arguments.
   *
   * Examples:
   *
   *     argv => operands, unknown
   *     --known kkk op => [op], []
   *     op --known kkk => [op], []
   *     sub --unknown uuu op => [sub], [--unknown uuu op]
   *     sub -- --unknown uuu op => [sub --unknown uuu op], []
   *
   * @param {String[]} argv
   * @return {{operands: String[], unknown: String[]}}
   */

  parseOptions(argv) {
    const operands = []; // operands, not options or values
    const unknown = []; // first unknown option and remaining unknown args
    let dest = operands;
    const args = argv.slice();

    function maybeOption(arg) {
      return arg.length > 1 && arg[0] === '-';
    }

    // parse options
    let activeVariadicOption = null;
    while (args.length) {
      const arg = args.shift();

      // literal
      if (arg === '--') {
        if (dest === unknown) dest.push(arg);
        dest.push(...args);
        break;
      }

      if (activeVariadicOption && !maybeOption(arg)) {
        this.emit(`option:${activeVariadicOption.name()}`, arg);
        continue;
      }
      activeVariadicOption = null;

      if (maybeOption(arg)) {
        const option = this._findOption(arg);
        // recognised option, call listener to assign value with possible custom processing
        if (option) {
          if (option.required) {
            const value = args.shift();
            if (value === undefined) this.optionMissingArgument(option);
            this.emit(`option:${option.name()}`, value);
          } else if (option.optional) {
            let value = null;
            // historical behaviour is optional value is following arg unless an option
            if (args.length > 0 && !maybeOption(args[0])) {
              value = args.shift();
            }
            this.emit(`option:${option.name()}`, value);
          } else { // boolean flag
            this.emit(`option:${option.name()}`);
          }
          activeVariadicOption = option.variadic ? option : null;
          continue;
        }
      }

      // Look for combo options following single dash, eat first one if known.
      if (arg.length > 2 && arg[0] === '-' && arg[1] !== '-') {
        const option = this._findOption(`-${arg[1]}`);
        if (option) {
          if (option.required || (option.optional && this._combineFlagAndOptionalValue)) {
            // option with value following in same argument
            this.emit(`option:${option.name()}`, arg.slice(2));
          } else {
            // boolean option, emit and put back remainder of arg for further processing
            this.emit(`option:${option.name()}`);
            args.unshift(`-${arg.slice(2)}`);
          }
          continue;
        }
      }

      // Look for known long flag with value, like --foo=bar
      if (/^--[^=]+=/.test(arg)) {
        const index = arg.indexOf('=');
        const option = this._findOption(arg.slice(0, index));
        if (option && (option.required || option.optional)) {
          this.emit(`option:${option.name()}`, arg.slice(index + 1));
          continue;
        }
      }

      // Not a recognised option by this command.
      // Might be a command-argument, or subcommand option, or unknown option, or help command or option.

      // An unknown option means further arguments also classified as unknown so can be reprocessed by subcommands.
      if (maybeOption(arg)) {
        dest = unknown;
      }

      // If using positionalOptions, stop processing our options at subcommand.
      if ((this._enablePositionalOptions || this._passThroughOptions) && operands.length === 0 && unknown.length === 0) {
        if (this._findCommand(arg)) {
          operands.push(arg);
          if (args.length > 0) unknown.push(...args);
          break;
        } else if (arg === this._helpCommandName && this._hasImplicitHelpCommand()) {
          operands.push(arg);
          if (args.length > 0) operands.push(...args);
          break;
        } else if (this._defaultCommandName) {
          unknown.push(arg);
          if (args.length > 0) unknown.push(...args);
          break;
        }
      }

      // If using passThroughOptions, stop processing options at first command-argument.
      if (this._passThroughOptions) {
        dest.push(arg);
        if (args.length > 0) dest.push(...args);
        break;
      }

      // add arg
      dest.push(arg);
    }

    return { operands, unknown };
  };

  /**
   * Return an object containing options as key-value pairs
   *
   * @return {Object}
   */
  opts() {
    if (this._storeOptionsAsProperties) {
      // Preserve original behaviour so backwards compatible when still using properties
      const result = {};
      const len = this.options.length;

      for (let i = 0; i < len; i++) {
        const key = this.options[i].attributeName();
        result[key] = key === this._versionOptionName ? this._version : this[key];
      }
      return result;
    }

    return this._optionValues;
  };

  /**
   * Internal bottleneck for handling of parsing errors.
   *
   * @api private
   */
  _displayError(exitCode, code, message) {
    this._outputConfiguration.outputError(`${message}\n`, this._outputConfiguration.writeErr);
    if (typeof this._showHelpAfterError === 'string') {
      this._outputConfiguration.writeErr(`${this._showHelpAfterError}\n`);
    } else if (this._showHelpAfterError) {
      this._outputConfiguration.writeErr('\n');
      this.outputHelp({ error: true });
    }
    this._exit(exitCode, code, message);
  }

  /**
   * Apply any option related environment variables, if option does
   * not have a value from cli or client code.
   *
   * @api private
   */
  _parseOptionsEnv() {
    this.options.forEach((option) => {
      if (option.envVar && option.envVar in process.env) {
        const optionKey = option.attributeName();
        // Priority check. Do not overwrite cli or options from unknown source (client-code).
        if (this.getOptionValue(optionKey) === undefined || ['default', 'config', 'env'].includes(this.getOptionValueSource(optionKey))) {
          if (option.required || option.optional) { // option can take a value
            // keep very simple, optional always takes value
            this.emit(`optionEnv:${option.name()}`, process.env[option.envVar]);
          } else { // boolean
            // keep very simple, only care that envVar defined and not the value
            this.emit(`optionEnv:${option.name()}`);
          }
        }
      }
    });
  }

  /**
   * Argument `name` is missing.
   *
   * @param {string} name
   * @api private
   */

  missingArgument(name) {
    const message = `error: missing required argument '${name}'`;
    // this._displayError(1, 'commander.missingArgument', message);
    throw new Error(message);
  };

  /**
   * `Option` is missing an argument.
   *
   * @param {Option} option
   * @api private
   */

  optionMissingArgument(option) {
    const message = `error: option '${option.flags}' argument missing`;
    // this._displayError(1, 'commander.optionMissingArgument', message);
    throw new Error(message);
  };

  /**
   * `Option` does not have a value, and is a mandatory option.
   *
   * @param {Option} option
   * @api private
   */

  missingMandatoryOptionValue(option) {
    const message = `error: required option '${option.flags}' not specified`;
    // this._displayError(1, 'commander.missingMandatoryOptionValue', message);
    throw new Error(message);
  };

  /**
   * Unknown option `flag`.
   *
   * @param {string} flag
   * @api private
   */

  unknownOption(flag) {
    if (this._allowUnknownOption) return;
    let suggestion = '';

    if (flag.startsWith('--') && this._showSuggestionAfterError) {
      // Looping to pick up the global options too
      let candidateFlags = [];
      let command = this;
      do {
        const moreFlags = command.createHelp().visibleOptions(command)
          .filter(option => option.long)
          .map(option => option.long);
        candidateFlags = candidateFlags.concat(moreFlags);
        command = command.parent;
      } while (command && !command._enablePositionalOptions);
      suggestion = suggestSimilar(flag, candidateFlags);
    }

    const message = `error: unknown option '${flag}'${suggestion}`;
    // this._displayError(1, 'commander.unknownOption', message);
    throw new Error(message);
  };

  /**
   * Excess arguments, more than expected.
   *
   * @param {string[]} receivedArgs
   * @api private
   */

  _excessArguments(receivedArgs) {
    if (this._allowExcessArguments) return;

    const expected = this._args.length;
    const s = (expected === 1) ? '' : 's';
    const forSubcommand = this.parent ? ` for '${this.name()}'` : '';
    const message = `error: too many arguments${forSubcommand}. Expected ${expected} argument${s} but got ${receivedArgs.length}.`;
    // this._displayError(1, 'commander.excessArguments', message);
    throw new Error(message);
  };

  /**
   * Unknown command.
   *
   * @api private
   */

  unknownCommand() {
    const unknownName = this.args[0];
    let suggestion = '';

    if (this._showSuggestionAfterError) {
      const candidateNames = [];
      this.createHelp().visibleCommands(this).forEach((command) => {
        candidateNames.push(command.name());
        // just visible alias
        if (command.alias()) candidateNames.push(command.alias());
      });
      suggestion = suggestSimilar(unknownName, candidateNames);
    }

    const message = `error: unknown command '${unknownName}'${suggestion}`;
    // this._displayError(1, 'commander.unknownCommand', message);
    throw new Error(message);
  };

  /**
   * Set the program version to `str`.
   *
   * This method auto-registers the "-V, --version" flag
   * which will print the version number when passed.
   *
   * You can optionally supply the  flags and description to override the defaults.
   *
   * @param {string} str
   * @param {string} [flags]
   * @param {string} [description]
   * @return {this | string} `this` command for chaining, or version string if no arguments
   */

  version(str, flags, description) {
    if (str === undefined) return this._version;
    this._version = str;
    flags = flags || '-V, --version';
    description = description || 'output the version number';
    const versionOption = this.createOption(flags, description);
    this._versionOptionName = versionOption.attributeName();
    this.options.push(versionOption);
    this.on('option:' + versionOption.name(), () => {
      this._outputConfiguration.writeOut(`${str}\n`);
      this._exit(0, 'commander.version', str);
    });
    return this;
  };

  /**
   * Set the description to `str`.
   *
   * @param {string} [str]
   * @param {Object} [argsDescription]
   * @return {string|Command}
   */
  description(str, argsDescription) {
    if (str === undefined && argsDescription === undefined) return this._description;
    this._description = str;
    if (argsDescription) {
      this._argsDescription = argsDescription;
    }
    return this;
  };

  /**
   * Set an alias for the command.
   *
   * You may call more than once to add multiple aliases. Only the first alias is shown in the auto-generated help.
   *
   * @param {string} [alias]
   * @return {string|Command}
   */

  alias(alias) {
    if (alias === undefined) return this._aliases[0]; // just return first, for backwards compatibility

    /** @type {Command} */
    let command = this;
    if (this.commands.length !== 0 && this.commands[this.commands.length - 1]._executableHandler) {
      // assume adding alias for last added executable subcommand, rather than this
      command = this.commands[this.commands.length - 1];
    }

    if (alias === command._name) throw new Error('Command alias can\'t be the same as its name');

    command._aliases.push(alias);
    return this;
  };

  /**
   * Set aliases for the command.
   *
   * Only the first alias is shown in the auto-generated help.
   *
   * @param {string[]} [aliases]
   * @return {string[]|Command}
   */

  aliases(aliases) {
    // Getter for the array of aliases is the main reason for having aliases() in addition to alias().
    if (aliases === undefined) return this._aliases;

    aliases.forEach((alias) => this.alias(alias));
    return this;
  };

  /**
   * Set / get the command usage `str`.
   *
   * @param {string} [str]
   * @return {String|Command}
   */

  usage(str) {
    if (str === undefined) {
      if (this._usage) return this._usage;

      const args = this._args.map((arg) => {
        return humanReadableArgName(arg);
      });
      return [].concat(
        (this.options.length || this._hasHelpOption ? '[options]' : []),
        (this.commands.length ? '[command]' : []),
        (this._args.length ? args : [])
      ).join(' ');
    }

    this._usage = str;
    return this;
  };

  /**
   * Get or set the name of the command
   *
   * @param {string} [str]
   * @return {string|Command}
   */

  name(str) {
    if (str === undefined) return this._name;
    this._name = str;
    return this;
  };

  /**
   * Return program help documentation.
   *
   * @param {{ error: boolean }} [contextOptions] - pass {error:true} to wrap for stderr instead of stdout
   * @return {string}
   */

  helpInformation(contextOptions) {
    const helper = this.createHelp();
    if (helper.helpWidth === undefined) {
      helper.helpWidth = (contextOptions && contextOptions.error) ? this._outputConfiguration.getErrHelpWidth() : this._outputConfiguration.getOutHelpWidth();
    }
    return helper.formatHelp(this, helper);
  };

  /**
   * @api private
   */

  _getHelpContext(contextOptions) {
    contextOptions = contextOptions || {};
    const context = { error: !!contextOptions.error };
    let write;
    if (context.error) {
      write = (arg) => this._outputConfiguration.writeErr(arg);
    } else {
      write = (arg) => this._outputConfiguration.writeOut(arg);
    }
    context.write = contextOptions.write || write;
    context.command = this;
    return context;
  }

  /**
   * Output help information for this command.
   *
   * Outputs built-in help, and custom text added using `.addHelpText()`.
   *
   * @param {{ error: boolean } | Function} [contextOptions] - pass {error:true} to write to stderr instead of stdout
   */

  outputHelp(contextOptions) {
    let deprecatedCallback;
    if (typeof contextOptions === 'function') {
      deprecatedCallback = contextOptions;
      contextOptions = undefined;
    }
    const context = this._getHelpContext(contextOptions);

    getCommandAndParents(this).reverse().forEach(command => command.emit('beforeAllHelp', context));
    this.emit('beforeHelp', context);

    let helpInformation = this.helpInformation(context);
    if (deprecatedCallback) {
      helpInformation = deprecatedCallback(helpInformation);
      if (typeof helpInformation !== 'string' && !Buffer.isBuffer(helpInformation)) {
        throw new Error('outputHelp callback must return a string or a Buffer');
      }
    }
    context.write(helpInformation);

    this.emit(this._helpLongFlag); // deprecated
    this.emit('afterHelp', context);
    getCommandAndParents(this).forEach(command => command.emit('afterAllHelp', context));
  };

  /**
   * You can pass in flags and a description to override the help
   * flags and help description for your command. Pass in false to
   * disable the built-in help option.
   *
   * @param {string | boolean} [flags]
   * @param {string} [description]
   * @return {Command} `this` command for chaining
   */

  helpOption(flags, description) {
    if (typeof flags === 'boolean') {
      this._hasHelpOption = flags;
      return this;
    }
    this._helpFlags = flags || this._helpFlags;
    this._helpDescription = description || this._helpDescription;

    const helpFlags = splitOptionFlags(this._helpFlags);
    this._helpShortFlag = helpFlags.shortFlag;
    this._helpLongFlag = helpFlags.longFlag;

    return this;
  };

  /**
   * Output help information and exit.
   *
   * Outputs built-in help, and custom text added using `.addHelpText()`.
   *
   * @param {{ error: boolean }} [contextOptions] - pass {error:true} to write to stderr instead of stdout
   */

  help(contextOptions) {
    this.outputHelp(contextOptions);
    let exitCode = process.exitCode || 0;
    if (exitCode === 0 && contextOptions && typeof contextOptions !== 'function' && contextOptions.error) {
      exitCode = 1;
    }
    // message: do not have all displayed text available so only passing placeholder.
    this._exit(exitCode, 'commander.help', '(outputHelp)');
  };

  /**
   * Add additional text to be displayed with the built-in help.
   *
   * Position is 'before' or 'after' to affect just this command,
   * and 'beforeAll' or 'afterAll' to affect this command and all its subcommands.
   *
   * @param {string} position - before or after built-in help
   * @param {string | Function} text - string to add, or a function returning a string
   * @return {Command} `this` command for chaining
   */
  addHelpText(position, text) {
    const allowedValues = ['beforeAll', 'before', 'after', 'afterAll'];
    if (!allowedValues.includes(position)) {
      throw new Error(`Unexpected value for position to addHelpText.
Expecting one of '${allowedValues.join("', '")}'`);
    }
    const helpEvent = `${position}Help`;
    this.on(helpEvent, (context) => {
      let helpStr;
      if (typeof text === 'function') {
        helpStr = text({ error: context.error, command: context.command });
      } else {
        helpStr = text;
      }
      // Ignore falsy value when nothing to output.
      if (helpStr) {
        context.write(`${helpStr}\n`);
      }
    });
    return this;
  }
};

/**
 * Output help information if help flags specified
 *
 * @param {Command} cmd - command to output help for
 * @param {Array} args - array of options to search for help flags
 * @api private
 */

function outputHelpIfRequested(cmd, args) {
  const helpOption = cmd._hasHelpOption && args.find(arg => arg === cmd._helpLongFlag || arg === cmd._helpShortFlag);
  if (helpOption) {
    cmd.outputHelp();
    // (Do not have all displayed text available so only passing placeholder.)
    cmd._exit(0, 'commander.helpDisplayed', '(outputHelp)');
  }
}

/**
 * Scan arguments and increment port number for inspect calls (to avoid conflicts when spawning new command).
 *
 * @param {string[]} args - array of arguments from node.execArgv
 * @returns {string[]}
 * @api private
 */

function incrementNodeInspectorPort(args) {
  // Testing for these options:
  //  --inspect[=[host:]port]
  //  --inspect-brk[=[host:]port]
  //  --inspect-port=[host:]port
  return args.map((arg) => {
    if (!arg.startsWith('--inspect')) {
      return arg;
    }
    let debugOption;
    let debugHost = '127.0.0.1';
    let debugPort = '9229';
    let match;
    if ((match = arg.match(/^(--inspect(-brk)?)$/)) !== null) {
      // e.g. --inspect
      debugOption = match[1];
    } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null) {
      debugOption = match[1];
      if (/^\d+$/.test(match[3])) {
        // e.g. --inspect=1234
        debugPort = match[3];
      } else {
        // e.g. --inspect=localhost
        debugHost = match[3];
      }
    } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/)) !== null) {
      // e.g. --inspect=localhost:1234
      debugOption = match[1];
      debugHost = match[3];
      debugPort = match[4];
    }

    if (debugOption && debugPort !== '0') {
      return `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}`;
    }
    return arg;
  });
}

/**
 * @param {Command} startCommand
 * @returns {Command[]}
 * @api private
 */

function getCommandAndParents(startCommand) {
  const result = [];
  for (let command = startCommand; command; command = command.parent) {
    result.push(command);
  }
  return result;
}

exports.Command = Command;


/***/ }),

/***/ 563829:
/***/ ((__unused_webpack_module, exports) => {

// @ts-check

/**
 * CommanderError class
 * @class
 */
class CommanderError extends Error {
  /**
   * Constructs the CommanderError class
   * @param {number} exitCode suggested exit code which could be used with process.exit
   * @param {string} code an id string representing the error
   * @param {string} message human-readable description of the error
   * @constructor
   */
  constructor(exitCode, code, message) {
    super(message);
    // properly capture stack trace in Node.js
    Error.captureStackTrace(this, this.constructor);
    this.name = this.constructor.name;
    this.code = code;
    this.exitCode = exitCode;
    this.nestedError = undefined;
  }
}

/**
 * InvalidArgumentError class
 * @class
 */
class InvalidArgumentError extends CommanderError {
  /**
   * Constructs the InvalidArgumentError class
   * @param {string} [message] explanation of why argument is invalid
   * @constructor
   */
  constructor(message) {
    super(1, 'commander.invalidArgument', message);
    // properly capture stack trace in Node.js
    Error.captureStackTrace(this, this.constructor);
    this.name = this.constructor.name;
  }
}

exports.CommanderError = CommanderError;
exports.InvalidArgumentError = InvalidArgumentError;


/***/ }),

/***/ 598831:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

const { humanReadableArgName } = __webpack_require__(180226);

/**
 * TypeScript import types for JSDoc, used by Visual Studio Code IntelliSense and `npm run typescript-checkJS`
 * https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#import-types
 * @typedef { import("./argument.js").Argument } Argument
 * @typedef { import("./command.js").Command } Command
 * @typedef { import("./option.js").Option } Option
 */

// @ts-check

// Although this is a class, methods are static in style to allow override using subclass or just functions.
class Help {
  constructor() {
    this.helpWidth = undefined;
    this.sortSubcommands = false;
    this.sortOptions = false;
  }

  /**
   * Get an array of the visible subcommands. Includes a placeholder for the implicit help command, if there is one.
   *
   * @param {Command} cmd
   * @returns {Command[]}
   */

  visibleCommands(cmd) {
    const visibleCommands = cmd.commands.filter(cmd => !cmd._hidden);
    if (cmd._hasImplicitHelpCommand()) {
      // Create a command matching the implicit help command.
      const [, helpName, helpArgs] = cmd._helpCommandnameAndArgs.match(/([^ ]+) *(.*)/);
      const helpCommand = cmd.createCommand(helpName)
        .helpOption(false);
      helpCommand.description(cmd._helpCommandDescription);
      if (helpArgs) helpCommand.arguments(helpArgs);
      visibleCommands.push(helpCommand);
    }
    if (this.sortSubcommands) {
      visibleCommands.sort((a, b) => {
        // @ts-ignore: overloaded return type
        return a.name().localeCompare(b.name());
      });
    }
    return visibleCommands;
  }

  /**
   * Get an array of the visible options. Includes a placeholder for the implicit help option, if there is one.
   *
   * @param {Command} cmd
   * @returns {Option[]}
   */

  visibleOptions(cmd) {
    const visibleOptions = cmd.options.filter((option) => !option.hidden);
    // Implicit help
    const showShortHelpFlag = cmd._hasHelpOption && cmd._helpShortFlag && !cmd._findOption(cmd._helpShortFlag);
    const showLongHelpFlag = cmd._hasHelpOption && !cmd._findOption(cmd._helpLongFlag);
    if (showShortHelpFlag || showLongHelpFlag) {
      let helpOption;
      if (!showShortHelpFlag) {
        helpOption = cmd.createOption(cmd._helpLongFlag, cmd._helpDescription);
      } else if (!showLongHelpFlag) {
        helpOption = cmd.createOption(cmd._helpShortFlag, cmd._helpDescription);
      } else {
        helpOption = cmd.createOption(cmd._helpFlags, cmd._helpDescription);
      }
      visibleOptions.push(helpOption);
    }
    if (this.sortOptions) {
      const getSortKey = (option) => {
        // WYSIWYG for order displayed in help with short before long, no special handling for negated.
        return option.short ? option.short.replace(/^-/, '') : option.long.replace(/^--/, '');
      };
      visibleOptions.sort((a, b) => {
        return getSortKey(a).localeCompare(getSortKey(b));
      });
    }
    return visibleOptions;
  }

  /**
   * Get an array of the arguments if any have a description.
   *
   * @param {Command} cmd
   * @returns {Argument[]}
   */

  visibleArguments(cmd) {
    // Side effect! Apply the legacy descriptions before the arguments are displayed.
    if (cmd._argsDescription) {
      cmd._args.forEach(argument => {
        argument.description = argument.description || cmd._argsDescription[argument.name()] || '';
      });
    }

    // If there are any arguments with a description then return all the arguments.
    if (cmd._args.find(argument => argument.description)) {
      return cmd._args;
    };
    return [];
  }

  /**
   * Get the command term to show in the list of subcommands.
   *
   * @param {Command} cmd
   * @returns {string}
   */

  subcommandTerm(cmd) {
    // Legacy. Ignores custom usage string, and nested commands.
    const args = cmd._args.map(arg => humanReadableArgName(arg)).join(' ');
    return cmd._name +
      (cmd._aliases[0] ? '|' + cmd._aliases[0] : '') +
      (cmd.options.length ? ' [options]' : '') + // simplistic check for non-help option
      (args ? ' ' + args : '');
  }

  /**
   * Get the option term to show in the list of options.
   *
   * @param {Option} option
   * @returns {string}
   */

  optionTerm(option) {
    return option.flags;
  }

  /**
   * Get the argument term to show in the list of arguments.
   *
   * @param {Argument} argument
   * @returns {string}
   */

  argumentTerm(argument) {
    return argument.name();
  }

  /**
   * Get the longest command term length.
   *
   * @param {Command} cmd
   * @param {Help} helper
   * @returns {number}
   */

  longestSubcommandTermLength(cmd, helper) {
    return helper.visibleCommands(cmd).reduce((max, command) => {
      return Math.max(max, helper.subcommandTerm(command).length);
    }, 0);
  };

  /**
   * Get the longest option term length.
   *
   * @param {Command} cmd
   * @param {Help} helper
   * @returns {number}
   */

  longestOptionTermLength(cmd, helper) {
    return helper.visibleOptions(cmd).reduce((max, option) => {
      return Math.max(max, helper.optionTerm(option).length);
    }, 0);
  };

  /**
   * Get the longest argument term length.
   *
   * @param {Command} cmd
   * @param {Help} helper
   * @returns {number}
   */

  longestArgumentTermLength(cmd, helper) {
    return helper.visibleArguments(cmd).reduce((max, argument) => {
      return Math.max(max, helper.argumentTerm(argument).length);
    }, 0);
  };

  /**
   * Get the command usage to be displayed at the top of the built-in help.
   *
   * @param {Command} cmd
   * @returns {string}
   */

  commandUsage(cmd) {
    // Usage
    let cmdName = cmd._name;
    if (cmd._aliases[0]) {
      cmdName = cmdName + '|' + cmd._aliases[0];
    }
    let parentCmdNames = '';
    for (let parentCmd = cmd.parent; parentCmd; parentCmd = parentCmd.parent) {
      parentCmdNames = parentCmd.name() + ' ' + parentCmdNames;
    }
    return parentCmdNames + cmdName + ' ' + cmd.usage();
  }

  /**
   * Get the description for the command.
   *
   * @param {Command} cmd
   * @returns {string}
   */

  commandDescription(cmd) {
    // @ts-ignore: overloaded return type
    return cmd.description();
  }

  /**
   * Get the command description to show in the list of subcommands.
   *
   * @param {Command} cmd
   * @returns {string}
   */

  subcommandDescription(cmd) {
    // @ts-ignore: overloaded return type
    return cmd.description();
  }

  /**
   * Get the option description to show in the list of options.
   *
   * @param {Option} option
   * @return {string}
   */

  optionDescription(option) {
    const extraInfo = [];
    // Some of these do not make sense for negated boolean and suppress for backwards compatibility.

    if (option.argChoices && !option.negate) {
      extraInfo.push(
        // use stringify to match the display of the default value
        `choices: ${option.argChoices.map((choice) => JSON.stringify(choice)).join(', ')}`);
    }
    if (option.defaultValue !== undefined && !option.negate) {
      extraInfo.push(`default: ${option.defaultValueDescription || JSON.stringify(option.defaultValue)}`);
    }
    if (option.envVar !== undefined) {
      extraInfo.push(`env: ${option.envVar}`);
    }
    if (extraInfo.length > 0) {
      return `${option.description} (${extraInfo.join(', ')})`;
    }

    return option.description;
  };

  /**
   * Get the argument description to show in the list of arguments.
   *
   * @param {Argument} argument
   * @return {string}
   */

  argumentDescription(argument) {
    const extraInfo = [];
    if (argument.argChoices) {
      extraInfo.push(
        // use stringify to match the display of the default value
        `choices: ${argument.argChoices.map((choice) => JSON.stringify(choice)).join(', ')}`);
    }
    if (argument.defaultValue !== undefined) {
      extraInfo.push(`default: ${argument.defaultValueDescription || JSON.stringify(argument.defaultValue)}`);
    }
    if (extraInfo.length > 0) {
      const extraDescripton = `(${extraInfo.join(', ')})`;
      if (argument.description) {
        return `${argument.description} ${extraDescripton}`;
      }
      return extraDescripton;
    }
    return argument.description;
  }

  /**
   * Generate the built-in help text.
   *
   * @param {Command} cmd
   * @param {Help} helper
   * @returns {string}
   */

  formatHelp(cmd, helper) {
    const termWidth = helper.padWidth(cmd, helper);
    const helpWidth = helper.helpWidth || 80;
    const itemIndentWidth = 2;
    const itemSeparatorWidth = 2; // between term and description
    function formatItem(term, description) {
      if (description) {
        const fullText = `${term.padEnd(termWidth + itemSeparatorWidth)}${description}`;
        return helper.wrap(fullText, helpWidth - itemIndentWidth, termWidth + itemSeparatorWidth);
      }
      return term;
    };
    function formatList(textArray) {
      return textArray.join('\n').replace(/^/gm, ' '.repeat(itemIndentWidth));
    }

    // Usage
    let output = [`Usage: ${helper.commandUsage(cmd)}`, ''];

    // Description
    const commandDescription = helper.commandDescription(cmd);
    if (commandDescription.length > 0) {
      output = output.concat([commandDescription, '']);
    }

    // Arguments
    const argumentList = helper.visibleArguments(cmd).map((argument) => {
      return formatItem(helper.argumentTerm(argument), helper.argumentDescription(argument));
    });
    if (argumentList.length > 0) {
      output = output.concat(['Arguments:', formatList(argumentList), '']);
    }

    // Options
    const optionList = helper.visibleOptions(cmd).map((option) => {
      return formatItem(helper.optionTerm(option), helper.optionDescription(option));
    });
    if (optionList.length > 0) {
      output = output.concat(['Options:', formatList(optionList), '']);
    }

    // Commands
    const commandList = helper.visibleCommands(cmd).map((cmd) => {
      return formatItem(helper.subcommandTerm(cmd), helper.subcommandDescription(cmd));
    });
    if (commandList.length > 0) {
      output = output.concat(['Commands:', formatList(commandList), '']);
    }

    return output.join('\n');
  }

  /**
   * Calculate the pad width from the maximum term length.
   *
   * @param {Command} cmd
   * @param {Help} helper
   * @returns {number}
   */

  padWidth(cmd, helper) {
    return Math.max(
      helper.longestOptionTermLength(cmd, helper),
      helper.longestSubcommandTermLength(cmd, helper),
      helper.longestArgumentTermLength(cmd, helper)
    );
  };

  /**
   * Wrap the given string to width characters per line, with lines after the first indented.
   * Do not wrap if insufficient room for wrapping (minColumnWidth), or string is manually formatted.
   *
   * @param {string} str
   * @param {number} width
   * @param {number} indent
   * @param {number} [minColumnWidth=40]
   * @return {string}
   *
   */

  wrap(str, width, indent, minColumnWidth = 40) {
    // Detect manually wrapped and indented strings by searching for line breaks
    // followed by multiple spaces/tabs.
    if (str.match(/[\n]\s+/)) return str;
    // Do not wrap if not enough room for a wrapped column of text (as could end up with a word per line).
    const columnWidth = width - indent;
    if (columnWidth < minColumnWidth) return str;

    const leadingStr = str.substr(0, indent);
    const columnText = str.substr(indent);

    const indentString = ' '.repeat(indent);
    const regex = new RegExp('.{1,' + (columnWidth - 1) + '}([\\s\u200B]|$)|[^\\s\u200B]+?([\\s\u200B]|$)', 'g');
    const lines = columnText.match(regex) || [];
    return leadingStr + lines.map((line, i) => {
      if (line.slice(-1) === '\n') {
        line = line.slice(0, line.length - 1);
      }
      return ((i > 0) ? indentString : '') + line.trimRight();
    }).join('\n');
  }
}

exports.Help = Help;


/***/ }),

/***/ 980814:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

const { InvalidArgumentError } = __webpack_require__(563829);

// @ts-check

class Option {
  /**
   * Initialize a new `Option` with the given `flags` and `description`.
   *
   * @param {string} flags
   * @param {string} [description]
   */

  constructor(flags, description) {
    this.flags = flags;
    this.description = description || '';

    this.required = flags.includes('<'); // A value must be supplied when the option is specified.
    this.optional = flags.includes('['); // A value is optional when the option is specified.
    // variadic test ignores <value,...> et al which might be used to describe custom splitting of single argument
    this.variadic = /\w\.\.\.[>\]]$/.test(flags); // The option can take multiple values.
    this.mandatory = false; // The option must have a value after parsing, which usually means it must be specified on command line.
    const optionFlags = splitOptionFlags(flags);
    this.short = optionFlags.shortFlag;
    this.long = optionFlags.longFlag;
    this.negate = false;
    if (this.long) {
      this.negate = this.long.startsWith('--no-');
    }
    this.defaultValue = undefined;
    this.defaultValueDescription = undefined;
    this.envVar = undefined;
    this.parseArg = undefined;
    this.hidden = false;
    this.argChoices = undefined;
  }

  /**
   * Set the default value, and optionally supply the description to be displayed in the help.
   *
   * @param {any} value
   * @param {string} [description]
   * @return {Option}
   */

  default(value, description) {
    this.defaultValue = value;
    this.defaultValueDescription = description;
    return this;
  };

  /**
   * Set environment variable to check for option value.
   * Priority order of option values is default < env < cli
   *
   * @param {string} name
   * @return {Option}
   */

  env(name) {
    this.envVar = name;
    return this;
  };

  /**
   * Set the custom handler for processing CLI option arguments into option values.
   *
   * @param {Function} [fn]
   * @return {Option}
   */

  argParser(fn) {
    this.parseArg = fn;
    return this;
  };

  /**
   * Whether the option is mandatory and must have a value after parsing.
   *
   * @param {boolean} [mandatory=true]
   * @return {Option}
   */

  makeOptionMandatory(mandatory = true) {
    this.mandatory = !!mandatory;
    return this;
  };

  /**
   * Hide option in help.
   *
   * @param {boolean} [hide=true]
   * @return {Option}
   */

  hideHelp(hide = true) {
    this.hidden = !!hide;
    return this;
  };

  /**
   * @api private
   */

  _concatValue(value, previous) {
    if (previous === this.defaultValue || !Array.isArray(previous)) {
      return [value];
    }

    return previous.concat(value);
  }

  /**
   * Only allow option value to be one of choices.
   *
   * @param {string[]} values
   * @return {Option}
   */

  choices(values) {
    this.argChoices = values;
    this.parseArg = (arg, previous) => {
      if (!values.includes(arg)) {
        throw new InvalidArgumentError(`Allowed choices are ${values.join(', ')}.`);
      }
      if (this.variadic) {
        return this._concatValue(arg, previous);
      }
      return arg;
    };
    return this;
  };

  /**
   * Return option name.
   *
   * @return {string}
   */

  name() {
    if (this.long) {
      return this.long.replace(/^--/, '');
    }
    return this.short.replace(/^-/, '');
  };

  /**
   * Return option name, in a camelcase format that can be used
   * as a object attribute key.
   *
   * @return {string}
   * @api private
   */

  attributeName() {
    return camelcase(this.name().replace(/^no-/, ''));
  };

  /**
   * Check if `arg` matches the short or long flag.
   *
   * @param {string} arg
   * @return {boolean}
   * @api private
   */

  is(arg) {
    return this.short === arg || this.long === arg;
  };
}

/**
 * Convert string from kebab-case to camelCase.
 *
 * @param {string} str
 * @return {string}
 * @api private
 */

function camelcase(str) {
  return str.split('-').reduce((str, word) => {
    return str + word[0].toUpperCase() + word.slice(1);
  });
}

/**
 * Split the short and long flag out of something like '-m,--mixed <value>'
 *
 * @api private
 */

function splitOptionFlags(flags) {
  let shortFlag;
  let longFlag;
  // Use original very loose parsing to maintain backwards compatibility for now,
  // which allowed for example unintended `-sw, --short-word` [sic].
  const flagParts = flags.split(/[ |,]+/);
  if (flagParts.length > 1 && !/^[[<]/.test(flagParts[1])) shortFlag = flagParts.shift();
  longFlag = flagParts.shift();
  // Add support for lone short flag without significantly changing parsing!
  if (!shortFlag && /^-[^-]$/.test(longFlag)) {
    shortFlag = longFlag;
    longFlag = undefined;
  }
  return { shortFlag, longFlag };
}

exports.Option = Option;
exports.splitOptionFlags = splitOptionFlags;


/***/ }),

/***/ 226152:
/***/ ((__unused_webpack_module, exports) => {

const maxDistance = 3;

function editDistance(a, b) {
  // https://en.wikipedia.org/wiki/Damerau–Levenshtein_distance
  // Calculating optimal string alignment distance, no substring is edited more than once.
  // (Simple implementation.)

  // Quick early exit, return worst case.
  if (Math.abs(a.length - b.length) > maxDistance) return Math.max(a.length, b.length);

  // distance between prefix substrings of a and b
  const d = [];

  // pure deletions turn a into empty string
  for (let i = 0; i <= a.length; i++) {
    d[i] = [i];
  }
  // pure insertions turn empty string into b
  for (let j = 0; j <= b.length; j++) {
    d[0][j] = j;
  }

  // fill matrix
  for (let j = 1; j <= b.length; j++) {
    for (let i = 1; i <= a.length; i++) {
      let cost = 1;
      if (a[i - 1] === b[j - 1]) {
        cost = 0;
      } else {
        cost = 1;
      }
      d[i][j] = Math.min(
        d[i - 1][j] + 1, // deletion
        d[i][j - 1] + 1, // insertion
        d[i - 1][j - 1] + cost // substitution
      );
      // transposition
      if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
        d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + 1);
      }
    }
  }

  return d[a.length][b.length];
}

/**
 * Find close matches, restricted to same number of edits.
 *
 * @param {string} word
 * @param {string[]} candidates
 * @returns {string}
 */

function suggestSimilar(word, candidates) {
  if (!candidates || candidates.length === 0) return '';
  // remove possible duplicates
  candidates = Array.from(new Set(candidates));

  const searchingOptions = word.startsWith('--');
  if (searchingOptions) {
    word = word.slice(2);
    candidates = candidates.map(candidate => candidate.slice(2));
  }

  let similar = [];
  let bestDistance = maxDistance;
  const minSimilarity = 0.4;
  candidates.forEach((candidate) => {
    if (candidate.length <= 1) return; // no one character guesses

    const distance = editDistance(word, candidate);
    const length = Math.max(word.length, candidate.length);
    const similarity = (length - distance) / length;
    if (similarity > minSimilarity) {
      if (distance < bestDistance) {
        // better edit distance, throw away previous worse matches
        bestDistance = distance;
        similar = [candidate];
      } else if (distance === bestDistance) {
        similar.push(candidate);
      }
    }
  });

  similar.sort((a, b) => a.localeCompare(b));
  if (searchingOptions) {
    similar = similar.map(candidate => `--${candidate}`);
  }

  if (similar.length > 1) {
    return `\n(Did you mean one of ${similar.join(', ')}?)`;
  }
  if (similar.length === 1) {
    return `\n(Did you mean ${similar[0]}?)`;
  }
  return '';
}

exports.suggestSimilar = suggestSimilar;


/***/ })

}]);
//# sourceMappingURL=4308.js.map